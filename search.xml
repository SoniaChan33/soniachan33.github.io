<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS</title>
    <url>/2021/06/15/CSS/</url>
    <content><![CDATA[cascading style sheets
样式
行内样式（优先级最高）、内部样式、外部样式(最常用的)

&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!--        【书写方式2:内部样式】        --&gt;        &lt;style type=&quot;text/css&quot;&gt;            h1&#123;                color: pink;                font-family: &quot;宋体&quot;;            &#125;        &lt;/style&gt;        &lt;!--        【书写方式3:外部样式】        --&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/样式.css&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--        【书写方式1：行内样式】        --&gt;        &lt;h1 style=&quot;color: deeppink;font-family: &#x27;宋体&#x27;;&quot;&gt;This is a h1 title&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;

选择器
1.基本选择器
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            /*            * [1]基本选择器：元素选择器            */            h1&#123;                color: red;                font-family: &quot;楷体&quot;;            &#125;            i&#123;                color: blue;                font-family: &quot;黑体&quot;;            &#125;            /*            * [2]基本选择器：类选择器            */            .mycls&#123;                color: green;                font-family: &quot;宋体&quot;;            &#125;            /*            * [3]基本选择器：唯一选择器            */            #myid&#123;                color: yellow;                font-family: &quot;微软雅黑&quot;;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;我是&lt;i&gt;一个&lt;/i&gt;标题&lt;/h1&gt;        &lt;h1&gt;我是一个标题&lt;/h1&gt;        &lt;h1 class=&quot;mycls&quot;&gt;我是一个标题&lt;/h1&gt;        &lt;h1&gt;我是一个标题&lt;/h1&gt;        &lt;h2 class=&quot;mycls&quot;&gt;我是h2标题&lt;/h2&gt;        &lt;h2&gt;我是h2标题&lt;/h2&gt;        &lt;h2 id=&quot;myid&quot;&gt;我是h2标题&lt;/h2&gt;    &lt;/body&gt;&lt;/html&gt;
效果
2.关系选择器
div和span标签

div属于块级元素–》换行
span属于行内元素–》没有换行效果：里面的内容占多大，span包裹的区域就多大

&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            /*            我们可以通俗的理解，把div理解为一个“塑料袋”            div属于块级元素--》换行            span属于行内元素--》没有换行效果            span:里面的内容占多大，span包裹的区域就多大*/            div&#123;                border: 1px red solid;            &#125;            span&#123;                border: 1px greenyellow solid;             &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;马士兵马士兵&lt;br /&gt;马士兵马士兵&lt;/div&gt;        &lt;div&gt;马士兵&lt;/div&gt;        &lt;span&gt;马士兵马士兵&lt;/span&gt;        &lt;span&gt;马士兵&lt;/span&gt;        &lt;span&gt;马士兵&lt;/span&gt;    &lt;/body&gt;&lt;/html&gt;
效果：

选择器
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            /*关系选择器:            * 后代选择器：只要是这个元素的后代，样式都会发生变化            * div下面的所有h1标签样式都会改变            */            /*div h1&#123;            color: red;            &#125;*/            /*关系选择器：子代选择器            只改变子标签的样式*/            div&gt;h1&#123;                color: royalblue;            &#125;            span&gt;h1&#123;                color: yellow;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;            &lt;h1&gt;这是标题&lt;/h1&gt;            &lt;h1&gt;这是标题&lt;/h1&gt;            &lt;h1&gt;这是标题&lt;/h1&gt;            &lt;h1&gt;这是标题&lt;/h1&gt;            &lt;h1&gt;这是标题&lt;/h1&gt;            &lt;span&gt;                &lt;h1&gt;这是标题&lt;/h1&gt;                &lt;h1&gt;这是标题&lt;/h1&gt;                &lt;h1&gt;这是标题&lt;/h1&gt;                &lt;h1&gt;这是标题&lt;/h1&gt;                &lt;h1&gt;这是标题&lt;/h1&gt;            &lt;/span&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
效果：

3.属性选择器
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            /*属性选择器*/            input[type=&quot;password&quot;]&#123;                background-color: red;            &#125;            input[type=&quot;text&quot;][value=&quot;zhaoss1&quot;]&#123;                background-color: yellow;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form&gt;            用户名：&lt;input type=&quot;text&quot; value=&quot;zhaoss1&quot; /&gt;            用户名2：&lt;input type=&quot;text&quot; value=&quot;zhaoss2&quot; /&gt;            密码：&lt;input type=&quot;password&quot; value=&quot;123123&quot; /&gt;            &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;
4.伪类选择器
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            .mycls:hover&#123;                color: red;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1 class=&quot;mycls&quot;&gt;我是标题&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;
一般伪类选择器都应用在超链接上
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            /*设置静止状态*/            a:link&#123;                color: yellow;            &#125;            /*设置鼠标悬浮状态*/            a:hover&#123;                color: red;            &#125;            /*设置触发状态*/            a:active&#123;                color: blue;            &#125;            /*设置完成状态*/            a:visited&#123;                color: green;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=&quot;index.html&quot;&gt;超链接&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;
例子：百度导航条
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            ul&#123;                list-style-type: none;/*将无序列表前面的图标取消*/            &#125;            li&#123;                float:left;/*向左浮动*/                margin-left: 20px;/*设置间隔20px*/            &#125;            a&#123;                text-decoration: none;/*去掉下划线*/                font-size: 13px;/*字号*/                color: black;/*字体颜色*/            &#125;            a:hover&#123;                color: #0000FF;            &#125;            div&#123;                /*定位：*/                position: absolute;/*绝对定位*/                right:200px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;            &lt;ul&gt;                &lt;li&gt;                    &lt;a href=&quot;aaaa&quot;&gt;新闻&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;aaaa&quot;&gt;hao123&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;aaaa&quot;&gt;地图&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;aaaa&quot;&gt;视频&lt;/a&gt;                &lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
效果：


浮动效果
文字环绕图片
​		浮动设计的初衷为了解决文字环绕图片问题，浮动后一定不会将文字挡住，这是设计初衷，不能违背的。

原理
​		CSS 的 Float（浮动）使元素脱离文档流，按照指定的方向（左或右发生移动），直到它的外边缘碰到包含框或另一个浮动框的边框为止。文档流是文档中可显示对象在排列时所占用的位置/空间，而脱离文档流就是在页面中不占位置了。
语法

实例展示
设置一个大的div，里面放三个小的div
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--外层div--&gt;        &lt;div style=&quot;background-color: pink;&quot;&gt;            &lt;div style=&quot;width: 100px;height: 100px;background-color: chartreuse;&quot;&gt;11&lt;/div&gt;            &lt;div style=&quot;width: 200px;height: 200px;background-color: coral;&quot;&gt;22&lt;/div&gt;            &lt;div style=&quot;width: 300px;height: 300px;background-color: yellow&quot;&gt;33&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
没有任何浮动

给绿div设置浮动
&lt;div style=&quot;width: 100px;height: 100px;background-color: chartreuse;&quot;&gt;11&lt;/div&gt;

给橘色小块设置浮动
&lt;div style=&quot;width: 200px;height: 200px;background-color: coral;&quot;&gt;22&lt;/div&gt;

给黄色小块设置浮动
&lt;div style=&quot;width: 300px;height: 300px;background-color: yellow;float: left;&quot;&gt;33&lt;/div&gt;

因为所有的小div都浮到上面，大div里没有东西填充，所以就消失了。
这样如果有其他的div块，就会变位置

消除浮动影响


给浮动的父节点加入一个属性overflow:hidden




给父节点加一个高度，让粉色div“撑起来”




被影响的元素紫色div：给它加入一个属性clear:both;




定位
静态定位(static)
就是默认的定位
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--静态定位:默认效果 效果就是元素出现在本来应该出现的位置 一般就省略不写--&gt;        &lt;img src=&quot;img/1.jpg&quot; style=&quot;position: static;&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;
相对定位(relative)
相对元素自身所在的原来的位置进行定位,可以设置left,color,bottom,top这四个属性
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--相对定位        相对元素自身所在的原来的位置进行定位        可以设置left,color,bottom,top这四个属性        --&gt;        &lt;div style=&quot;width: 500px; height: 500px; background-color: pink;&quot;&gt;            &lt;div style=&quot;width: 100px; height: 100px; background-color: green;&quot;&gt;&lt;/div&gt;            &lt;div style=&quot;width: 100px; height: 100px; background-color: red; position: relative; bottom: 10px;&quot; &gt;&lt;/div&gt;            &lt;div style=&quot;width: 100px; height: 100px; background-color: blue;&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
z-index属性：
设置堆叠顺序，设置元素谁在上谁在下。注意：z-index属性要设置在定位的元素上,
应用场合：
（1）元素在小范围移动的时候
（2）结合绝对定位使用
绝对定位(absolute)

设置子块div为绝对定位

&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            #outer&#123;                width: 500px;                height: 500px;                background-color: pink;                margin-left:300px;            &#125;            #div01&#123;                width: 100px;                height: 100px;                background-color: cornflowerblue;                position: absolute;/*设置一个绝对定位*/                left: 30px;                top: 50px;            &#125;            #div02&#123;                width: 100px;                height: 100px;                background-color: coral;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;outer&quot;&gt;            &lt;div id=&quot;div01&quot;&gt;111&lt;/div&gt;            &lt;div id=&quot;div02&quot;&gt;222&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
效果

蓝色div相对body产生的位移，相对body进行位置的改变，然后蓝色div发生位移以后，原位置得到了释放。橙色div移动上去了！

实际开发中，我们往往让蓝色div在粉色div中发生位移效果
配合定位来使用：

&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            #outer&#123;                /*父块设置一个相对定位*/                width: 500px;                height: 500px;                background-color: pink;                margin-left:300px;                position: relative;            &#125;            #div01&#123;                width: 100px;                height: 100px;                background-color: cornflowerblue;                position: absolute;                left: 30px;                top: 50px;            &#125;            #div02&#123;                width: 100px;                height: 100px;                background-color: coral;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;outer&quot;&gt;            &lt;div id=&quot;div01&quot;&gt;111&lt;/div&gt;            &lt;div id=&quot;div02&quot;&gt;222&lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
效果

总结：
当给一个元素设置了绝对定位的时候，它相对谁变化呢？它会向上一层一层的找父级节点是否有定位，如果直到找到body了也没有定位，那么就相对body进行变化，如果父级节点有定位（绝对定位，相对定位，固定定位），但是一般我们会配合使用父级为相对定位，当前元素为绝对定位，这样这个元素就会相对父级位置产生变化。无论是上面的哪一种，都会释放原来的位置，然后其他元素会占用那个位置。
开发中建议使用：父级节点relative定位，子级节点使用绝对定位。
固定定位(fixed)
应用场合：在页面过长的时候，将某个元素固定在浏览器的某个位置上，当拉动滚动条的时候，这个元素位置不动。
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            #mydiv&#123;                width: 50px;                height: 400px;                background-color: cadetblue;                /*固定定位*/                position: fixed;                right: 0px;                top: 300px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;mydiv&quot;&gt;&lt;/div&gt;        &lt;p&gt;你好&lt;/p&gt;        ...(省略很多行)        &lt;p&gt;你好&lt;/p&gt;            &lt;/body&gt;&lt;/html&gt;
效果

盒子模型
​		页面上也有很多元素，元素之间的布局/设计 依靠 盒子模型：
​		所有HTML元素可以看作盒子，在CSS中，&quot;box model&quot;这一术语是用来设计和布局时使用。
​		CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。
​		盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。
​		下面的图片说明了盒子模型(Box Model)：


感受盒子模型
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;!--代码感受盒子的具体含义--&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            /*将所有元素的样式：外边距，边框，内边距全部设置为0*/            /*没有单独设置盒子模型样式的就遵照总的设置*/            *&#123;                margin:0px;                padding: 0px;                border: 0px;            &#125;            #outer&#123;                /*修改了内边距padding需要更改原来的长和宽 */                width:450px;                height: 450px;                background-color: pink;                margin-left: 50px;                margin-top: 50px;                padding-left: 50px;                padding-top: 50px;            &#125;            #mydiv&#123;                width: 60px;                height: 60px;                background-color: yellowgreen;                padding-left: 40px;                padding-top: 40px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;outer&quot;&gt;            &lt;div id=&quot;mydiv&quot;&gt;111&lt;/div&gt;        &lt;/div&gt;                &lt;div style=&quot;background-color: blue;width: 100px; height: 100px;&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
注意修改了内边距以后需要修改原本的长和宽
效果

H+C练习
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            #bigdiv&#123;                width: 65px;                border: solid #D70000 ;                background-color:#FBEECF ;                /*设置div里中文字的效果*/                font-size: 17px;                font-family: &quot;微软雅黑&quot;;                color: #D70000;                /*设置固定定位*/                position: fixed;                right: 0px;				                top: 50px;                /*背景图大小的设置*/            &#125;            #mydiv&#123;                height: 60px;                /*先写背景图，再写背景色*/                background: url(img/小喇叭.png) no-repeat 8px 12px;                padding-top: 60px;/*盒子模型的页内边距*/                padding-right: 2px;                text-align: center;/*设置水平居中*/            &#125;            #mydiv2&#123;                height: 60px;                /*先写背景图，再写背景色*/                background: url(img/联系客服.png) no-repeat 3px 8px;                padding-top: 70px;/*盒子模型的页内边距*/                text-align: center;/*设置水平居中*/            &#125;            #mydiv3&#123;                height: 60px;                /*先写背景图，再写背景色*/                background: url(img/二维码.png) no-repeat 3px 8px;                padding-top: 70px;/*盒子模型的页内边距*/                text-align: center;/*设置水平居中*/            &#125;            #mydiv4&#123;                /*先写背景图，再写背景色*/                background: url(img/呵护.png) no-repeat 3px 8px;                padding-top: 60px;/*盒子模型的页内边距*/                text-align: center;/*设置水平居中*/            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;bigdiv&quot; &gt;            &lt;div id=&quot;mydiv&quot;&gt;                最新&lt;br /&gt;发布            &lt;/div&gt;            &lt;hr width=&quot;50px&quot; align=&quot;center&quot; color=&quot;black&quot;  /&gt;            &lt;div id=&quot;mydiv2&quot;&gt;                联系&lt;br /&gt;客服            &lt;/div&gt;            &lt;hr width=&quot;50px&quot; align=&quot;center&quot; color=&quot;black&quot;  /&gt;            &lt;div id=&quot;mydiv3&quot;&gt;                APP&lt;br /&gt;下载            &lt;/div&gt;            &lt;hr width=&quot;50px&quot; align=&quot;center&quot; color=&quot;black&quot;  /&gt;            &lt;div id=&quot;mydiv4&quot;&gt;                旅游&lt;br /&gt;出行&lt;br /&gt;温馨&lt;br /&gt;提示            &lt;/div&gt;        &lt;/div&gt;        &lt;p&gt;hello&lt;/p&gt;		...省略很多个hello        &lt;p&gt;hello&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;
效果：

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2021/06/13/HTML/</url>
    <content><![CDATA[超文本标记语言
head 标签
head标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表。文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。

下面这些标签可用在 head 部分：
&lt;title&gt;、&lt;meta&gt;、&lt;link&gt;、&lt;style&gt;、 &lt;script&gt;、 &lt;base&gt;。
&lt;html&gt;	&lt;head&gt;		&lt;!--			页面注释			可以放入&lt;title&gt;、&lt;meta&gt;、&lt;style&gt;、&lt;script&gt;、&lt;base&gt;		--&gt;		&lt;!--页面标题--&gt;		&lt;title&gt;百度一下，你就知道&lt;/title&gt;		&lt;!--设置页面的编码，防止乱码现象				利用meta标签				charset=&quot;UTF-8&quot;		--&gt;		&lt;meta charset=&quot;utf-8&quot;&gt;		&lt;!--页面刷新效果--&gt;		&lt;!--&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;http://www.baidu.com&quot;  /&gt;--&gt;		&lt;!--页面作者--&gt;		&lt;meta name = &quot;author&quot; content=&quot;chs;1374347231@qq.com&quot;  /&gt;		&lt;!--页面描述--&gt;		&lt;meta name =&quot;description&quot; content=&quot;陈慧珊简介&quot; /&gt;		&lt;!--link 标签引入外部资源--&gt;		&lt;link rel = &quot;shortcut icon&quot; href=&quot;https://www.baidu.com/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;			&lt;/head&gt;	&lt;body&gt;	&lt;!--	body标签中：放入页面展示的内容		--&gt;		hello 这里是第一个html！！！	&lt;/body&gt;&lt;/html&gt;&lt;html&gt;	&lt;head&gt;		&lt;!--			页面注释			可以放入&lt;title&gt;、&lt;meta&gt;、&lt;style&gt;、&lt;script&gt;、&lt;base&gt;		--&gt;		&lt;!--页面标题--&gt;		&lt;title&gt;百度一下，你就知道&lt;/title&gt;		&lt;!--设置页面的编码，防止乱码现象				利用meta标签				charset=&quot;UTF-8&quot;		--&gt;		&lt;meta charset=&quot;utf-8&quot;&gt;		&lt;!--页面刷新效果--&gt;		&lt;!--&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;http://www.baidu.com&quot;  /&gt;--&gt;		&lt;!--页面作者--&gt;		&lt;meta name = &quot;author&quot; content=&quot;chs;1374347231@qq.com&quot;  /&gt;		&lt;!--页面描述--&gt;		&lt;meta name =&quot;description&quot; content=&quot;陈慧珊简介&quot; /&gt;		&lt;!--link 标签引入外部资源--&gt;		&lt;link rel = &quot;shortcut icon&quot; href=&quot;https://www.baidu.com/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt;	&lt;/head&gt;	&lt;body&gt;	&lt;!--	body标签中：放入页面展示的内容		--&gt;		hello 这里是第一个html！！！	&lt;/body&gt;&lt;/html&gt;
运行效果：

body 标签
body 元素是定义文档的主体。body 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。）body是用在网页中的一种HTML标签，标签是用在网页中的一种HTML标签，表示网页的主体部分，也就是用户可以看到的内容，可以包含文本、图片、音频、视频等各种内容。
文本标签

    	 

实体名称
&lt;!DOCTYPE html&gt;&lt;html&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot;&gt;		&lt;title&gt;&lt;/title&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;!--			h1-h6字号逐渐变小，每个标题独占一行，自带换行效果			h7之后属于无效标签，但是浏览器也不会报错，而是以普通文本的形式展现		--&gt;		&lt;h1&gt;媒体：为人父母，要不要“持证上岗”&lt;/h1&gt;		&lt;h2&gt;媒体：为人父母，要不要“持证上岗 ”&lt;/h2&gt;		&lt;h3&gt;媒体：为人父母，要不要“持证上岗”&lt;/h3&gt;		&lt;!--横线标签			width：设置宽度					300px 固定宽度					30% 页面宽度的百分比， 会随着页面宽度的变化而变化			align: 设置位置 left,center,right 默认不写的话就是center居中效果		--&gt;		&lt;hr width=&quot;300px&quot; align=&quot;center&quot; /&gt;		&lt;hr width=&quot;30%&quot; align=&quot;center&quot; /&gt;		&lt;!--			段落标签			段落效果：段落中文字自动换行，段落和段落之间有空行		--&gt;		&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;26日，“建议父母持合格&amp;lt;父母证&amp;gt;上岗&amp;copy;”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。5月26日，“建议父母持合格父母证上岗”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。5月26日，“建议父母持合格父母证上岗”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。&lt;/p&gt;		&lt;p&gt;&amp;emsp;26日，“建议父母持合格&amp;lt;父母证&amp;gt;上岗&amp;copy;”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。5月26日，“建议父母持合格父母证上岗”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。5月26日，“建议父母持合格父母证上岗”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。&lt;/p&gt;		&lt;p&gt;26日，“建议父母持合格&amp;lt;父母证&amp;gt;上岗&amp;copy;”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。5月26日，“建议父母持合格父母证上岗”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。5月26日，“建议父母持合格父母证上岗”冲上微博热搜，迅速引发热议。在正在召开的全国两会上，全国政协委员许洪玲建议在社区举办家长课堂，建立“家长教育指导工作室”。针对准备入小学的家长开展相关课程教育，颁发“合格父母”上岗证随学生档案入学。&lt;/p&gt;	    	    &lt;!--加粗倾斜下划线--&gt;	    &lt;b&gt;加粗&lt;/b&gt;	    &lt;i&gt;倾斜&lt;/i&gt;	    &lt;u&gt;下划线&lt;/u&gt;	    &lt;i&gt;&lt;u&gt;&lt;b&gt;加粗倾斜下划线&lt;/b&gt;&lt;/u&gt;&lt;/i&gt;	    &lt;!--一箭穿心--&gt;	    &lt;del&gt;谭颖&lt;/del&gt;	    &lt;!--预编译标签：在页面上显示原样效果--&gt;	    &lt;pre&gt;	    public static void main(string[] args)&#123;	    	stopThinkingAboutHer();	    &#125;	    &lt;/pre&gt;    	    &lt;!--换行--&gt;	    		    		    &lt;!--字体标签--&gt;	    &lt;font color=&quot;aqua&quot; size= &quot;7&quot; face=&quot;黑体&quot;&gt;&lt;p&gt; &lt;/p&gt;&lt;/font&gt;	&lt;/body&gt;	&lt;/html&gt;
运行效果：

多媒体标签
&lt;!DOCTYPE html&gt;&lt;html&gt;        &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;                &lt;!--图片                        src:引入图片的位置                                引入本地资源                                引入网络资源                        width:设置宽度                        height:设置高度                        注意:一般高度和宽度只设置一个即可，另一个会按照比例自动适应                        title:鼠标悬浮在图片上的时候的提示语，默认情况下（没有设置alt属性） 图片如果加载失败那么提示语也是title的内容                        alt:图片加载失败的提示语                --&gt;                &lt;img src=&quot;img/ss6.jpg&quot; width=&quot;300px&quot; title=&quot;这是一个美女小姐姐&quot; alt=&quot;图片加载失败&quot;/&gt;                &lt;img src=&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1833909874,761626004&amp;fm=26&amp;gp=0.jpg&quot; /&gt;                &lt;!--音频--&gt;                &lt;embed src=&quot;music/我要你.mp3&quot;&gt;&lt;/embed&gt;                &lt;br /&gt;                &lt;!--视频--&gt;                &lt;embed src=&quot;video/周杰伦 - 说好的幸福呢.mp4&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt;&lt;/embed&gt;                &lt;embed src=&quot;//player.video.iqiyi.com/38913f9ed7358c0933e82a03d9b26ec1/0/0/v_19rv8qeokk.swf-albumId=9194699400-tvId=9194699400-isPurchase=0-cnId=undefined&quot; allowFullScreen=&quot;true&quot; quality=&quot;high&quot; width=&quot;480&quot; height=&quot;350&quot; align=&quot;middle&quot; allowScriptAccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/embed&gt;        &lt;/body&gt;&lt;/html&gt;
超链接标签
&lt;!DOCTYPE html&gt;&lt;html&gt;        &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;                &lt;!--超链接标签：作用：实现页面的跳转功能                        href:控制跳转的目标位置                        target:_self 在自身页面打开 （默认效果也是在自身页面打开）    _blank 在空白页面打开                --&gt;                 &lt;a href=&quot;文本标签.html&quot;&gt;这是一个超链接01&lt;/a&gt;&lt;!--跳转到本地资源--&gt;                &lt;a href=&quot;&quot;&gt;这是一个超链接02&lt;/a&gt; &lt;!--跳转到自身页面--&gt;                &lt;a href=&quot;abc&quot;&gt;这是一个超链接03&lt;/a&gt;&lt;!--跳转的目标找不到，提示找不到资源--&gt;                &lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_self&quot;&gt;这是一个超链接04&lt;/a&gt;&lt;!--跳转到网络资源--&gt;                &lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;这是一个超链接05&lt;/a&gt;&lt;!--跳转到网络资源--&gt;                                &lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;img/ss.jpg&quot; /&gt;&lt;/a&gt;        &lt;/body&gt;&lt;/html&gt;
列表标签
&lt;!DOCTYPE html&gt;&lt;html&gt;        &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;                &lt;!--无序列表:                        type:可以设置列表前图标的样式   type=&quot;square&quot;                        如果想要更换图标样式，需要借助css技术： style=&quot;list-style:url(img/act.jpg) ;&quot;                --&gt;                &lt;h1&gt;起床以后需要做的事&lt;/h1&gt;                &lt;ul type=&quot;square&quot;&gt;                        &lt;li&gt;睁眼&lt;/li&gt;                        &lt;li&gt;穿衣服&lt;/li&gt;                        &lt;li&gt;上厕所&lt;/li&gt;                        &lt;li&gt;吃早饭&lt;/li&gt;                        &lt;li&gt;洗漱&lt;/li&gt;                        &lt;li&gt;出门&lt;/li&gt;                &lt;/ul&gt;                &lt;!--有序列表:                        type:可以设置列表的标号：1,a,A,i,I                        start:设置起始标号                --&gt;                &lt;h1&gt;学习java的顺序&lt;/h1&gt;                &lt;ol type=&quot;A&quot; start=&quot;3&quot;&gt;                        &lt;li&gt;JAVASE&lt;/li&gt;                        &lt;li&gt;ORACLE&lt;/li&gt;                        &lt;li&gt;MYSQL&lt;/li&gt;                        &lt;li&gt;HTML&lt;/li&gt;                        &lt;li&gt;CSS&lt;/li&gt;                        &lt;li&gt;JS&lt;/li&gt;                &lt;/ol&gt;        &lt;/body&gt;&lt;/html&gt;
表格标签
&lt;!DOCTYPE html&gt;&lt;html&gt;        &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;                &lt;!--表格：4行4列                        table:表格                        tr:行                        td:单元格                        th:特殊单元格：表头效果：加粗，居中                        默认情况下表格是没有边框的，通过属性来增加表框：                        border:设置边框大小                        cellspacing：设置单元格和边框之间的空隙                        align=&quot;center&quot;  设置居中                        background 设置背景图片 background=&quot;img/ss.jpg&quot;                        bgcolor :设置背景颜色                        rowspan:行合并                        colspan：列合并                --&gt;                &lt;table border=&quot;1px&quot; cellspacing=&quot;0px&quot; width=&quot;400px&quot; height=&quot;300px&quot; bgcolor=&quot;darkseagreen&quot; &gt;                        &lt;tr bgcolor=&quot;bisque&quot;&gt;                                &lt;th&gt;学号&lt;/th&gt;                                &lt;th&gt;姓名&lt;/th&gt;                                &lt;th&gt;年纪&lt;/th&gt;                                &lt;th&gt;成绩&lt;/th&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                                &lt;td align=&quot;center&quot;&gt;1001&lt;/td&gt;                                &lt;td&gt;丽丽&lt;/td&gt;                                &lt;td&gt;19&lt;/td&gt;                                &lt;td rowspan=&quot;3&quot;&gt;90.5&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                                &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;2006&lt;/td&gt;                                &lt;td&gt;30&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                                &lt;td&gt;3007&lt;/td&gt;                                &lt;td&gt;小明&lt;/td&gt;                                &lt;td&gt;18&lt;/td&gt;                        &lt;/tr&gt;                &lt;/table&gt;        &lt;/body&gt;&lt;/html&gt;
结果：

框架
内嵌框架
内嵌框架是用于在网页中嵌入一个网页并让它在网页中显示.
添加内嵌框架的语法:
&lt;iframe src=&quot; URL &quot;&gt;&lt;/iframe&gt; &lt;!--URL --- 指定独立网页的路径--&gt;
实例一：展示商品


首页
&lt;!DOCTYPE html&gt;&lt;html&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot;&gt;		&lt;title&gt;首页&lt;/title&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;iframe src=&quot;音乐导航.html&quot; height=&quot;700px&quot; width=&quot;30%&quot;&gt;&lt;/iframe&gt;		&lt;iframe src=&quot;展示页面.html&quot; name =&quot;iframe_my&quot; height=&quot;700px&quot; width=&quot;67%&quot;  src=&quot;img/肆无忌惮.png&quot;&gt;&lt;/iframe&gt;	&lt;/body&gt;&lt;/html&gt;


目录页
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;音乐导航&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;ul&gt;            &lt;li&gt;                &lt;a href=&quot;img/肆无忌惮.png&quot; target=&quot;iframe_my&quot;&gt;肆无忌惮 ---薛之谦&lt;/a&gt;            &lt;/li&gt;            &lt;li&gt;                &lt;a href=&quot;img/梦伴.png&quot; target=&quot;iframe_my&quot;&gt;梦伴 ---李悦君&lt;/a&gt;            &lt;/li&gt;            &lt;li&gt;                &lt;a href=&quot;img/stay.png&quot; target=&quot;iframe_my&quot;&gt;stay ---The kid LAROL/Justin Bieber&lt;/a&gt;            &lt;/li&gt;            &lt;li&gt;                &lt;a href=&quot;img/Blue&amp;Grey.png&quot; target=&quot;iframe_my&quot;&gt;Blue&amp;Grey ---BTS&lt;/a&gt;            &lt;/li&gt;			        &lt;/ul&gt;    &lt;/body&gt;&lt;/html&gt;


展示页
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        这是展示列表    &lt;/body&gt;&lt;/html&gt;
效果：



实例二：邮箱
登录首页
&lt;!DOCTYPE html&gt;&lt;html&gt;	&lt;head&gt;		&lt;meta charset=&quot;utf-8&quot; /&gt;		&lt;title&gt;&lt;/title&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;font color=&quot;cornflowerblue&quot; size= &quot;3&quot; face=&quot;黑体&quot; &gt;			&lt;p align=&quot;center&quot;&gt;				用户名&lt;input type=&quot;text&quot; /&gt;&lt;br /&gt;				密&amp;emsp;码&lt;input type=&quot;password&quot; /&gt;&lt;br /&gt;				&lt;a href=&quot;邮箱首页.html&quot;&gt;登录&lt;/a&gt;			&lt;/p&gt;		&lt;/font&gt;	&lt;/body&gt;&lt;/html&gt;
效果：

邮箱页
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--邮箱上侧的页面--&gt;        &lt;iframe src=&quot;邮箱上侧.html&quot; width=&quot;100%&quot; height=&quot;100px&quot; align=&quot;middle&quot;&gt;&lt;/iframe&gt;        &lt;!--邮箱左侧页面--&gt;        &lt;iframe src=&quot;邮箱左侧.html&quot; width=&quot;20%&quot; height=&quot;500px&quot; align=&quot;left&quot;&gt;&lt;/iframe&gt;        &lt;!--邮箱右侧页面--&gt;        &lt;iframe src=&quot;邮箱右侧.html&quot; name=&quot;if1&quot; width=&quot;78%&quot; height=&quot;500px&quot; align=&quot;right&quot;&gt;&lt;/iframe&gt;    &lt;/body&gt;&lt;/html&gt;
上侧
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;font color=&quot;blueviolet&quot; face=&quot;黑体&quot;&gt;            &lt;h1&gt;                欢迎来到TeaSea33的邮箱！！！            &lt;/h1&gt;        &lt;/font&gt;    &lt;/body&gt;&lt;/html&gt;
左侧
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;font color=&quot;cornflowerblue&quot; size= &quot;5&quot; face=&quot;黑体&quot;&gt;            &lt;ul&gt;                &lt;li&gt;                    &lt;a href=&quot;img/写信.png&quot; target=&quot;if1&quot;&gt;                        写信                    &lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;img/收信箱.png&quot; target=&quot;if1&quot;&gt;                        收信箱                    &lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a href=&quot;img/垃圾箱.png&quot; target=&quot;if1&quot;&gt;                        垃圾箱                    &lt;/a&gt;                &lt;/li&gt;            &lt;/ul&gt;        &lt;/font&gt;    &lt;/body&gt;&lt;/html&gt;
右侧
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        展示页面    &lt;/body&gt;&lt;/html&gt;
效果

框架集合
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;!--框架集合：和body是并列的概念，不要将框架集合放入body中--&gt;    &lt;frameset rows=&quot;20%,*,30%&quot;&gt;        &lt;frame /&gt;        &lt;frameset cols=&quot;30%,40%,*&quot;&gt;            &lt;frame /&gt;            &lt;frame src=&quot;index.html&quot;/&gt;            &lt;frame /&gt;        &lt;/frameset&gt;        &lt;frameset cols=&quot;50%,*&quot;&gt;            &lt;frame /&gt;            &lt;frame /&gt;        &lt;/frameset&gt;    &lt;/frameset&gt;&lt;/html&gt;
将上面的页面改为
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;frameset rows=&quot;20%,*&quot;&gt;        &lt;frame src=&quot;邮箱上侧.html&quot; width=&quot;100%&quot; height=&quot;100px&quot; align=&quot;middle&quot;/&gt;        &lt;frameset cols=&quot;30%,*&quot;&gt;            &lt;frame src=&quot;邮箱左侧.html&quot; width=&quot;20%&quot; height=&quot;500px&quot; align=&quot;left&quot;/&gt;            &lt;frame src=&quot;邮箱右侧.html&quot; name=&quot;if1&quot; width=&quot;78%&quot; height=&quot;500px&quot; align=&quot;right&quot;/&gt;        &lt;/frameset&gt;    &lt;/frameset&gt;&lt;/html&gt;
Form表单
​		表单在 Web 网页中用来给访问者填写信息，从而能采集客户端信息，使网页具有交互的功能。一般是将表单设计在一个Html 文档中，当用户填写完信息后做**提交(submit)**操作，于是表单的内容就从客户端的浏览器传送到服务器上，经过服务器上程序处理后，再将用户所需信息传送回客户端的浏览器上，这样网页就具有了交互性。这里我们只讲怎样使用Html 标志来设计表单。
​		所有的用户输入内容的地方都用表单来写，如登录注册、搜索框。
​		一个表单一般应该包含用户填写信息的输入框,提交按钮等，这些输入框,按钮叫做控件,表单很像容器,它能够容纳各种各样的控件。
&lt;form action＝&quot;url&quot; method=get|post name=&quot;myform&quot; &gt;&lt;/form&gt;-name：表单提交时的名称-action：提交到的地址-method：提交方式，有get和post两种，默认为get
&lt;!DOCTYPE html&gt;&lt;html&gt;	&lt;head&gt;		&lt;meta charset=&quot;UTF-8&quot;&gt;		&lt;title&gt;&lt;/title&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;!--定义form表单			【1】action属性			地址栏信息：			http://127.0.0.1:8020/Form表单/aaa?username=admin&amp;pwd=chcsiu			？之前是提交的资源的目的地址				http:信息交互遵照http协议				127.0.0.1:代表本机的IP地址				8020:端口号---HBuilder内置服务器的端口号				Form表单:指的是你项目的名字				PS:浏览器的地址栏不支持中文，都会转为编码传送，如果在地址栏看到中文，只是当前浏览器给的一个友好展示			？之后是提交的具体数据				username=admin&amp;pwd=chcsiu				我们写的文本框和密码框都要加入一个属性：name				然后name属性和具体录入的信息会拼成一个键值对的形式				多个键值对之间，用&amp;符号进行拼接				PS:只有form表单中的内容才会被收集并提交			【2】 method属性 （默认情况下值为get）			get 提交的数据可见 不安全 提交数据长度有限制 效率高			post 提交的数据不可见 安全 提交的数据 效率低		--&gt;		&lt;form action=&quot;aaa&quot; method=&quot;post&quot;&gt;			用户名 ：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br /&gt;			密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;br /&gt;			&lt;!--提交按钮--&gt;			&lt;input type=&quot;submit&quot; /&gt;		&lt;/form&gt;		用户名2：&lt;input  type=&quot;text&quot; /&gt;	&lt;/body&gt;&lt;/html&gt;
效果：
 
实例：模仿百度搜索
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;百度一下你就知道&lt;/title&gt;        &lt;link rel=&quot;icon&quot; sizes=&quot;any&quot; mask href=&quot;//www.baidu.com/img/baidu_85beaf5496f291521eb75ba38eacbd87.svg&quot;&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--百度的连接		https://www.baidu.com/s	(找到action)		?		...&amp;wd=java&amp;... (找到文本框名)		--&gt;        &lt;form action=&quot;https://www.baidu.com/s&quot; method=&quot;get&quot;&gt;            &lt;!--文本框--&gt;            &lt;input type=&quot;text&quot; name=&quot;wd&quot; /&gt;            &lt;!--提交按钮--&gt;            &lt;input type=&quot;submit&quot; value=&quot;百度一下&quot; /&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;
表单元素
1. 文本框
&lt;!--文本框	input标签使用很广泛，通过type属性的不同性，来表现不通过的形态，表单元素必须有一个属性：name有了name才可以提交书数据，才可以采集数据，然后提交的时候以键值对的形式拼到一起。value:就是文本框中的具体内容;键值对：name=value的形式placeholder--默认提示语readonly--只读：无法更改写法：readonly=&quot;true&quot;；readonly；readonly=&quot;readonly&quot;disabled--禁用：不能提交--&gt;&lt;input type=&quot;text&quot; name=&quot;uname&quot; placeholder=&quot;请输入身份证信息&quot;/&gt;&lt;br /&gt;&lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;123&quot; readonly=&quot;true&quot;&gt;&lt;br /&gt;&lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;123&quot; readonly/&gt;&lt;br /&gt;
效果：

2. 密码框
&lt;!--密码框--&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;br /&gt;
效果：

3. 按钮
普通按钮
&lt;!--普通按钮：没有什么效果就是可以点击，js可以加入事件--&gt;&lt;input type=&quot;button&quot; value=&quot;普通&quot; /&gt;
效果：

单选按钮
&lt;!--单选按钮注意：一组当选按钮，必须通过name属性来控制，让它们在一个分组中，然后在一个分组里只能选择一个正常状态下，提交数据为:gender=on,后台不能区分你提交的数据--&gt;性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; checked/&gt;男&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;2&quot;/&gt;女&lt;br /&gt;
效果：

多选按钮
&lt;!--多选按钮必须通过name属性来控制，让它们在一个分组中，然后在一个分组里可以选择多个不同的选项的value值要控制为不同，这样后台接收就可以区分了多个选项提交的时候，键值对用&amp;符号进行拼接：例如下：favlan=1&amp;favlan=3--&gt;&lt;input type=&quot;checkbox&quot; name=&quot;favlan&quot; value=&quot;1&quot;/&gt;java&lt;input type=&quot;checkbox&quot; name=&quot;favlan&quot; value=&quot;2&quot;/&gt;python&lt;input type=&quot;checkbox&quot; name=&quot;favlan&quot; value=&quot;&quot;/&gt;php&lt;input type=&quot;checkbox&quot; name=&quot;favlan&quot;value=&quot;&quot;/&gt;c#
效果：

图片按钮
&lt;!--特殊按钮：图片按钮 点击是可以提交的--&gt;&lt;input type=&quot;image&quot; src=&quot;img/1.jpg&quot; width=&quot;100px&quot; /&gt;
重置按钮
&lt;!--特殊按钮：重置按钮：将页面恢复到初始状态--&gt;&lt;input type=&quot;reset&quot; /&gt;
提交按钮
&lt;!--特殊按钮：提交按钮：具备提交功能--&gt;&lt;input type=&quot;submit&quot; /&gt;
4.下拉列表
select
&lt;!--下拉列表	selected 默认选中	multiple 多选--&gt;你喜欢的城市&lt;select name=&quot;city&quot; multiple=&quot;multiple&quot;&gt;    &lt;option value=&quot;0&quot;&gt;---请选择---&lt;/option&gt;    &lt;option value=&quot;1&quot;&gt;成都市&lt;/option&gt;    &lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;北京市&lt;/option&gt;     &lt;option value=&quot;3&quot;&gt;重庆市&lt;/option&gt;    &lt;option value=&quot;4&quot;&gt;广州市&lt;/option&gt;&lt;/select&gt;
效果：

5.多行文本框
&lt;!--多行文本框利用css样式来控制大小不可变：style=&quot;resize: none;&quot;--&gt;自我介绍：&lt;textarea style=&quot;resize: none;&quot; rows=&quot;10&quot; cols=&quot;30&quot;&gt;请在这里填写信息。。&lt;/textarea&gt;&lt;br /&gt;
效果：

6.文件
&lt;!--文件--&gt;&lt;input type=&quot;file&quot; name=&quot;文件&quot; /&gt;&lt;br /&gt;
效果：


7.隐藏域
&lt;!--隐藏域--&gt;&lt;input type=&quot;hidden &quot; name=&quot;uname&quot; value=&quot;12324&quot; /&gt;
效果：

8.label标签
&lt;!--label标签一般会在想要获得焦点的标签上加入一个id属性，然后label中的for属性跟id配合使用。点击用户名 光标就会到用户名对应的文本框里面--&gt;&lt;label for=&quot;uname&quot;&gt;用户名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;uername&quot; id=&quot;uname&quot;/&gt;            
HTML5新增
增加校验
html5的类型可以增加校验&lt;!--email--&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; /&gt;&lt;!--url--&gt;&lt;input type=&quot;url&quot; /&gt;&lt;!--color--&gt;&lt;input type=&quot;color&quot; /&gt;&lt;!--number:min:最小值max:最大值step:步长value:默认值：一定在步长的范围中，否则不能提交--&gt;&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;10&quot; step=&quot;3&quot; value=&quot;4&quot;/&gt;&lt;!--range--&gt;1&lt;input type=&quot;range&quot; min=&quot;1&quot; max=&quot;10&quot; name=&quot;range&quot; step=&quot;3&quot;/&gt;10&lt;!--date--&gt;&lt;input type=&quot;date&quot; /&gt;&lt;!--month--&gt;&lt;input type=&quot;month&quot; /&gt;&lt;!--week--&gt;&lt;input type=&quot;week&quot; /&gt;
新增属性
&lt;!--HTML5新增属性：multiple：多选placehoder:默认提示autofocus:自动获取焦点required:必填项--&gt;&lt;input type=&quot;text&quot; multiple=&quot;multiple&quot;/&gt;&lt;input type=&quot;text&quot; placeholder=&quot;11111&quot; /&gt;&lt;input type=&quot;text&quot; autofocus:&quot;autofocus&quot; /&gt;&lt;input type=&quot;text&quot; required=&quot;required&quot; /&gt;&lt;!--提交按钮--&gt;&lt;input type=&quot;submit&quot; /&gt;
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub搭建个人博客</title>
    <url>/2022/05/06/Hexo-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/</url>
    <content><![CDATA[安装hexo
1.前提准备：


安装git
brew install git

验证
git --version 


安装node.js
brew install node


2.安装
npm install -g hexo-cli
3.创建博客文件夹并初始化
hexo initnpm install
4.本地启动
hexo ghexo s
访问本地链接：http://localhost:4000/
显示如下页面，表示安装成功

安装next主题
hexo官网主题：https://hexo.io/themes/
这里以next为例
1.在创建文件夹下安装主题
git clone https://github.com/theme-next/hexo-theme-next themes/next
2.修改文件夹下的_config.yml文件

修改theme为next
# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next
再次访问页面：

表示next主题安装成功
部署到github仓库
1.创建仓库
仓库名严格按xxx.github.io来（xxx为github用户名 且 小写！

2.配置SSH
如果已经配置过就跳过。
生成SSH key
ssh-keygen -t rsa -C 你的邮箱
这个邮箱是github绑定的邮箱
然后登陆github，在Settings里面的SSH and GPG keys里面添加new SSH key

验证是否成功
ssh -T git@github.com

3.部署到github
安装git部署插件
npm install hexo-deployer-git --save
打开_config.yml文件，地步修改部署配置
# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:youname/youname.github.io.git  branch: master
保存后终端执行
hexo cleanhexo ghexo d
在浏览器输入xxx.github.io就可以看到自己的一个博客了
常用的hexo命令
npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/06/07/JDBC/</url>
    <content><![CDATA[引入
1. 概念
JDBC（Java DataBase Connectivity,  Java数据库连接) ,是一种用于执行SQL语句的Java API，为多种关系数据库提供统一访问,它由一组用Java语言编写的类和接口组成

2. 依赖
导入依赖
src下创建一个文件夹命名lib，然后把依赖包复制到里面，右键create library

移除依赖
setting ——&gt;project structure

3. 实例
1：加载一个Driver驱动
//1.加载驱动 DriverDriver driver = new com.mysql.cj.jdbc.Driver();
2：创建数据库连接（Connection）


url
格式——协议**://ip:端口/资源路径?参数名=参数值&amp;参数名=参数值&amp;…**

协议         jdbc:mysql
IP          127.0.0.1/localhost
端口号       3306

数据库名字   mydb
参数  useSSL(是否使用SSL)、useUnicode(是否使用unicod)、characterEncoding(使用unicode类型)、serverTimezone(时区)





user


password


//3.获得链接/** 传入三个参数：url，user，password* */String url = &quot;jdbc:mysql://127.0.0.1:3306/mytestdb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/ShangHai&quot;;String user = &quot;root&quot;;String password = &quot;root&quot;;Connection connection = DriverManager.getConnection(url,user,password);
3：创建SQL命令发送器Statement
//4.获得语句对象statementStatement statement = connection.createStatement();
4：通过Statement发送SQL命令并得到结果
statement.executeUpdate 在sql操作insert、delete、update时使用
//5.执行SQL语句，返回结果String sql = &quot;insert into dept values(50,&#x27;教学部&#x27;,&#x27;BeiJing&#x27;)&quot;;int row = statement.executeUpdate(sql); //insert delete updateSystem.out.println(&quot;影响行数为&quot;+ row);
5：关闭数据库资源ResultSet  Statement  Connection
//6.释放资源statement.close();connection.close();
结果

4. 常见的异常分析
MySQL8中数据库连接的四个参数有两个发生了变化
String driver = “com.mysql.cj.jdbc.Driver”;
String url = “jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai”;
或者String url = “…serverTimezone=GMT%2B8”;

错误1：Exception in thread “main” java.lang.ClassNotFoundException: com.mysql.jdbc2.Driver

原因：没有添加jar包或者com.mysql.jdbc2.Driver路径错误

错误2：Exception in thread “main” java.sql.SQLException:No suitable driver found for jbdc:mysql://127.0.0.1:3306/stumgr

原因：url错误

错误3：Exception in thread “main” java.sql.SQLException:

Access denied for user ‘root’@‘localhost’ (using password: YES)
原因：用户名或者密码错误

错误4：Exception in thread “main” com.mysql.jdbc.exceptions


.jdbc4.MySQLIntegrityConstraintViolationException:Duplicate entry ‘90’ for key ‘PRIMARY’
原因：主键冲突


错误5：Public Key Retrieval is not allowed
如果用户使用 sha256_password 认证，密码在传输过程中必须使用 TLS 协议保护，但是如果 RSA 公钥不可用，可以使用服务器提供的公钥；可以在连接中通过 ServerRSAPublicKeyFile 指定服务器的 RSA 公钥，或者AllowPublicKeyRetrieval=True参数以允许客户端从服务器获取公钥；但是需要注意的是 AllowPublicKeyRetrieval=True可能会导致恶意的代理通过中间人攻击(MITM)获取到明文密码，所以默认是关闭的，必须显式开启
在jdbc连接添加上参数allowPublicKeyRetrieval=true即可，注意参数间用&amp;


加参数allowPublicKeyRetrieval=true
1. 驱动的加载


在查看Driver的源代码时我们发现,该类内部有一个静态代码块,在代码块中就是在实例化一个驱动并在驱动中心注册.静态代码块会在类进入内存时执行,也就是说,我们只要让该类字节码进入内存,就会自动完成注册,不需要我们手动去new




可以通过反射来加载驱动
//可以通过反射来加载驱动Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
因为Driver类里面的静态代码块已经注册了驱动，就不用再单独注册驱动了


查看jar包发现,jar包中已经默认配置了驱动类的加载，其实不需要手动加载，程序运行的时候也会自动加载jar包里的类



2. 添加异常处理

将需要catch的异常部分 用快捷键ctrl+alt+T选择

把最后处理放在finally里面，分别加上try catch
public class TestJDBC2 &#123;    private static String driver=&quot;com.mysql.cj.jdbc.Driver&quot;;//    private static String url = &quot;jdbc:mysql://127.0.0.1:3306/mytestdb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;//    private static String user= &quot;root&quot;;    private static String password = &quot;root&quot;;    public static void main(String[] args) &#123;        Connection connection = null;        Statement statement = null;        try &#123;            Class.forName(driver);            connection = DriverManager.getConnection(url,user,password);            statement = connection.createStatement();            String sql = &quot;insert into dept values(50,&#x27;教学部&#x27;,&#x27;BeiJing&#x27;)&quot;;            int row = statement.executeUpdate(sql);            System.out.println(&quot;影响行数为&quot;+ row);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(null != statement)&#123; //statement如果创建失败就不需要关了                try &#123;                    statement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null != connection)&#123;// 同上                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;
3. JDBC完成CURD
删除和修改操作
和上面实例一样，只需要改sql语句
String sql = &quot;delete from emp where deptno = 20 &quot;;
String sql = &quot;update dept set dname = &#x27;总部&#x27;,loc=&#x27;BeiJing&#x27; where deptno = 30 &quot;;
查询操作

使用的方法是executeQuery()，返回的是一个结果集即表格被抽象成的对象 resultSet

String sql = &quot;select * from emp&quot;;ResultSet resultSet = statement.executeQuery(sql); 


循环获得每一列的数据：
resultset.next()：返回当前游标所指的行数据是否为空，如果为不为空，返回true，游标向下移动；为空则返回false，游标不移动


while (resultSet.next())&#123;//判断游标是否为空    int empno = resultSet.getInt(&quot;empno&quot;);    String ename = resultSet.getString(&quot;ename&quot;);    String job = resultSet.getString(&quot;job&quot;);    int MGR = resultSet.getInt(&quot;MGR&quot;);    Date date = resultSet.getDate(&quot;hiredate&quot;);    double sal = resultSet.getDouble(&quot;SAL&quot;);    double comm = resultSet.getDouble(&quot;comm&quot;);    int deptno = resultSet.getInt(&quot;deptno&quot;);    System.out.println(empno+&quot; &quot;+ename+&quot; &quot;+job+&quot; &quot;+MGR+&quot; &quot;+&quot; &quot;+date+&quot; &quot;+sal+&quot; &quot;+comm+&quot; &quot;+deptno);&#125;
ps: 获得的date对象不是util包的，而是sql包的对象


关闭resultSet：
虽然 Statement 关闭、重新执行或用于从多结果序列中获取下一个结果时，ResultSet将被自动关闭，但是一个好的编程习惯很重要嘛，该关的还是要关。


if(null != resultSet)&#123;              try &#123;                  resultSet.close();              &#125; catch (SQLException e) &#123;                  e.printStackTrace();              &#125;          &#125;
完整代码
package com.chs.test01;import java.sql.*;import static java.lang.Class.forName;/** * @author: ChanHuiShan * @date: 2021-07-05 - 07 - 05 - 16:28 * @description: com.chs.test01 * @version: 1.0 */public class TestJDBC4 &#123;    private static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    private  static String url =&quot;jdbc:mysql://127.0.0.1:3306/mytestdb?&quot; +            &quot;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;&quot; +            &quot;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;    private static String user = &quot;root&quot;;    private static String password = &quot;root&quot;;    public static void main(String[] args) &#123;        testQuery();    &#125;    public static void testQuery()&#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try &#123;            //1.加载驱动            forName(driver);            //2.建立连接            connection = DriverManager.getConnection(url,user,password);            //3.通过连接搭建statement            statement = connection.createStatement();            //4.操作sql            String sql = &quot;select * from emp&quot;;            resultSet = statement.executeQuery(sql);            while (resultSet.next())&#123;                int empno = resultSet.getInt(&quot;empno&quot;);                String ename = resultSet.getString(&quot;ename&quot;);                String job = resultSet.getString(&quot;job&quot;);                int MGR = resultSet.getInt(&quot;MGR&quot;);                Date date = resultSet.getDate(&quot;hiredate&quot;);                double sal = resultSet.getDouble(&quot;SAL&quot;);                double comm = resultSet.getDouble(&quot;comm&quot;);                int deptno = resultSet.getInt(&quot;deptno&quot;);                System.out.println(empno+&quot; &quot;+ename+&quot; &quot;+job+&quot; &quot;+MGR+&quot; &quot;+&quot; &quot;+date+&quot; &quot;+sal+&quot; &quot;+comm+&quot; &quot;+deptno);            &#125;        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125;finally&#123;            //关闭resultSet            if(null != resultSet)&#123;                try &#123;                    resultSet.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null != statement)&#123;                try &#123;                    statement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null != connection)&#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;
结果：

创建实体类封装结果集
​	该实体类是和数据表格名称和字段是一一对应的类，该类主要用处是存储重数据库中查询出来的数据，除此之外该类无其他功能。
Emp.java
要求：

类名和表名保持一致
属性个数和表的列数保持一致
属性的数据类型和列的数据类型保持一致
属性名和表格列名保持一致
所有的属性都是私有的 （出于安全考虑）
实体类的属性推荐写成包装类 （例如int类型不能赋值为null）
日期类型建议使用java.util.Date(因为是父类,比较方便使用多态）
所有的属性都要有get和set方法
必须具备空参构造器
实体类需要实现序列化接口（mybatis 分布式）
实体类中其他构造方法可选
添加toString方法

package com.chs.entity;import com.sun.scenario.effect.impl.prism.PrRenderInfo;import java.io.Serializable;import java.util.Date;//是java.sql.Date的父类/** * @author: ChanHuiShan * @date: 2021-07-05 - 07 - 05 - 19:07 * @description: com.chs.entity * @version: 1.0 */public class Emp implements Serializable &#123;//实现序列化接口    private Integer empno;    private String ename;    private String job;    private Integer mgr;    private Date hiredate;    private Double sal;    private Double comm;    private Integer deptno;    //可以有其他构造方法    public Emp(Integer empno, String ename, String job, Integer mgr, Date hiredate, Double sal, Double comm, Integer deptno) &#123;        this.empno = empno;        this.ename = ename;        this.job = job;        this.mgr = mgr;        this.hiredate = hiredate;        this.sal = sal;        this.comm = comm;        this.deptno = deptno;    &#125;    //必须有空参构造器    public Emp() &#123;    &#125;    //set和get方法省略    //toSting省略&#125;
TestJDBC.java
修改—返回的是Emp的List集合对象：
public static List&lt;Emp&gt; testQuery()&#123;&#125;
main（）方法里面遍历输出：
public static void main(String[] args) &#123;    //获得方法里返回的集合    List&lt;Emp&gt; emps = testQuery();    //遍历集合    for(Emp emp:emps)&#123;        System.out.println(emp);    &#125;&#125;
完整代码
/** * @author: ChanHuiShan * @date: 2021-07-05 - 07 - 05 - 16:28 * @description: com.chs.test01 * @version: 1.0 */public class TestJDBC4 &#123;    private static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    private  static String url =&quot;jdbc:mysql://127.0.0.1:3306/mytestdb?&quot; +            &quot;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;&quot; +            &quot;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;    private static String user = &quot;root&quot;;    private static String password = &quot;root&quot;;    public static void main(String[] args) &#123;        //获得方法里返回的集合        List&lt;Emp&gt; emps = testQuery();        //遍历集合        for(Emp emp:emps)&#123;            System.out.println(emp);        &#125;    &#125;    public static List&lt;Emp&gt; testQuery()&#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        List&lt;Emp&gt; list = null;//emp对象的集合初始化        try &#123;            forName(driver);            connection = DriverManager.getConnection(url,user,password);            statement = connection.createStatement();            String sql = &quot;select * from emp&quot;;            resultSet = statement.executeQuery(sql);            list= new ArrayList&lt;&gt;();            while (resultSet.next())&#123;                int empno = resultSet.getInt(&quot;empno&quot;);                String ename = resultSet.getString(&quot;ename&quot;);                String job = resultSet.getString(&quot;job&quot;);                int MGR = resultSet.getInt(&quot;MGR&quot;);                Date date = resultSet.getDate(&quot;hiredate&quot;);                double sal = resultSet.getDouble(&quot;SAL&quot;);                double comm = resultSet.getDouble(&quot;comm&quot;);                int deptno = resultSet.getInt(&quot;deptno&quot;);                Emp emp = new Emp(empno, ename, job, MGR, date, sal, comm, deptno);//构造每一行数据对象                list.add(emp);//将每一行都放入集合中            &#125;        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125;finally&#123;            if(null != resultSet)&#123;                try &#123;                    resultSet.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null != statement)&#123;                try &#123;                    statement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null != connection)&#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return list;//返回集合    &#125;&#125;
4. 预编译PreparedStatement
使用预编译语句来预防SQL注入攻击
​		SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。
模拟登录
在前台输入用户名和密码，后台判断信息是否正确，并给出前台反馈信息，前台输出反馈信息。
具体实现步骤：


创建数据库表



创建实体类



测试类：
/** * @author: ChanHuiShan * @date: 2021-07-06 - 07 - 06 - 14:13 * @description: com.chs.test02 * @version: 1.0 */public class TestInjection &#123;    private static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    private  static String url =&quot;jdbc:mysql://127.0.0.1:3306/mytestdb?&quot; +            &quot;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;&quot; +            &quot;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;    private static String user = &quot;root&quot;;    private static String password = &quot;root&quot;;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入用户名：&quot;);        String username = sc.next();        System.out.println(&quot;请输入密码：&quot;);        String pwd = sc.next();        Account account = getAccount(username, pwd);        System.out.println(null!=account?(&quot;登录成功&quot;+&quot;用户信息&quot;+account):&quot;登录失败&quot;);    &#125;    public static Account getAccount(String username,String pwd)&#123;        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        Account account = null;        try &#123;            //1.加载驱动            forName(driver);            //2.建立连接            connection = DriverManager.getConnection(url,user,password);            //3.通过连接搭建statement            statement = connection.createStatement();            //4.操作sql            String sql = &quot;select * from account where username = &#x27;&quot;+username+&quot;&#x27;and password = &#x27;&quot;+pwd+&quot;&#x27;&quot;;            resultSet = statement.executeQuery(sql);            while (resultSet.next())&#123;                int aid = resultSet.getInt(&quot;aid&quot;);                String usernamea = resultSet.getString(&quot;username&quot;);                String pwda = resultSet.getString(&quot;password&quot;);                Double balance = resultSet.getDouble(&quot;balance&quot;);                account = new Account(aid,usernamea,pwda,balance);            &#125;        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125;finally&#123;            if(null != resultSet)&#123;                try &#123;                    resultSet.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null != statement)&#123;                try &#123;                    statement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null != connection)&#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            return account;        &#125;    &#125;&#125;
结果：



注入攻击
构建特殊的输入:
例如输入密码
asdf&#x27;or&#x27;a&#x27;=&#x27;a
整个sql语句就会变为
select * from account where username = &#x27;asdf&#x27; and password = &#x27;asdf&#x27;or&#x27;a&#x27;=&#x27;a&#x27;;
导致含义改变。
通过预编译语句来预防

使用PreparedStatement语句对象防止注入攻击

PreparedStatement 可以使用 ? 作为参数的占位符,即使是字符串和日期类型,也不使用单独再添加 ’ ’
connection.createStatement();获得的是普通语句对象 Statement
ction.prepareStatement(sql);可以获得一个预编译语句对象PreparedStatement
如果SQL语句中有?作为参数占位符号,那么要在执行CURD之前先设置参数
***(问号的编号,数据) 方法设置参数



String sql=&quot;select * from account where username = ? and password = ?&quot;;preparedStatement = connection.prepareStatement(sql);//这里已经传入SQL语句//设置参数preparedStatement.setString(1,username );preparedStatement.setString(2,pwd );//执行CURDresultSet = preparedStatement.executeQuery();// 这里不需要再传入SQL语句，传了会报错，亲身经历man
效果：

原理：
说白了就是把值当中的所有单引号给转义了!这就达到了防止sql注入的目的，说白了mysql驱动的PreparedStatement实现类的setString();方法内部做了单引号的转义，而Statement不能防止sql注入，就是因为它没有把单引号做转义，而是简单粗暴的直接拼接字符串，所以达不到防止sql注入的目的。
预编译的原理
预编译的开启
值得注意的是,我们的Connector/J 5.0.5及之后useServerPrepStmts默认false,就是默认没有开启预编译,之前默认为true, cachePrepStmts 一直默认为false,需要我们手动设置才可以启用预编译,在开启预编译的同时要同时开启预编译缓存才能带来些许的性能提升.
&quot;jdbc:mysql://localhost:3306/mydb?*****&amp;useServerPrepStmts=true&amp;cachePrepStmts=true&quot;; 
优点


安全性高,可以避免SQL注入


简单不繁琐,不用进行字符串拼接


性能高，用在执行多个相同数据库DML操作时,可以减少sql语句的编译次数


预编译实现CURD
TestPreparedStatement.java
/** * @author: ChanHuiShan * @date: 2021-07-06 - 07 - 06 - 19:31 * @description: com.chs.test03 * @version: 1.0 */public class TestPreparedStatement &#123;    private static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    private static String url = &quot;jdbc:mysql://127.0.0.1:3306/mytestdb?&quot; +            &quot;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;&quot; +            &quot;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;    private static String user = &quot;root&quot;;    private static String password = &quot;root&quot;;    public static void main(String[] args) &#123;        testAdd(); //向emp表中增加一条数据        testUpdate();//根据工号修改员工表中的数据        testDelete();//根据工号删除员工表中的数据        testQuery();//查询名字中包含A的员工信息    &#125;    public static void testAdd() &#123;        //向emp表中增加一条数据        Connection connection = null;        PreparedStatement preparedStatement = null;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;insert into emp values(DEFAULT,?,?,?,?,?,?,?)&quot;;            preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象            //设置参数            preparedStatement.setString(1, &quot;Mark&quot;);            preparedStatement.setString(2, &quot;MANAGER&quot;);            preparedStatement.setInt(3, 7839);            preparedStatement.setDate(4, new Date(System.currentTimeMillis()));            preparedStatement.setDouble(5, 3000.12);            preparedStatement.setDouble(6, 0.0);            preparedStatement.setDouble(7, 30);            //执行CURD            int rows = preparedStatement.executeUpdate();            System.out.println(&quot;影响行数&quot; + rows);        &#125;         catch()&#123;&#125;finally&#123;&#125;        &#125;    &#125;    public static void testUpdate() &#123;        //根据工号修改员工表中的数据        Connection connection = null;        PreparedStatement preparedStatement = null;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;update emp set ename =?,job= ? where empno = ?&quot;;            preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象            //设置参数            preparedStatement.setString(1, &quot;John&quot;);            preparedStatement.setString(2, &quot;ANALYST&quot;);            preparedStatement.setInt(3, 7777);            //执行CURD            int rows = preparedStatement.executeUpdate();            System.out.println(&quot;影响行数&quot; + rows);        &#125;catch()&#123;&#125;finally&#123;&#125;//这部分都省略，同下        &#125;    &#125;    public static void testDelete() &#123;        //根据工号删除员工表中的数据        Connection connection = null;        PreparedStatement preparedStatement = null;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;delete from emp where empno = ?&quot;;            preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象            //设置参数            preparedStatement.setInt(1, 7777);            //执行CURD            int rows = preparedStatement.executeUpdate();            System.out.println(&quot;影响行数&quot; + rows);        &#125; catch()&#123;&#125;finally&#123;&#125;        &#125;    &#125;    public static void testQuery() &#123;        //查询名字中包含A的员工信息        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        List&lt;Emp&gt; list = null;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;select * from emp where ename like ?&quot;;            preparedStatement = connection.prepareStatement(sql);            preparedStatement.setString(1,&quot;%A%&quot;);            resultSet = preparedStatement.executeQuery();            list= new ArrayList&lt;&gt;();            while (resultSet.next()) &#123;                int empno = resultSet.getInt(&quot;empno&quot;);                String ename = resultSet.getString(&quot;ename&quot;);                String job = resultSet.getString(&quot;job&quot;);                int MGR = resultSet.getInt(&quot;MGR&quot;);                Date date = resultSet.getDate(&quot;hiredate&quot;);                double sal = resultSet.getDouble(&quot;SAL&quot;);                double comm = resultSet.getDouble(&quot;comm&quot;);                int deptno = resultSet.getInt(&quot;deptno&quot;);                Emp emp = new Emp(empno, ename, job, MGR, date, sal, comm, deptno);                list.add(emp);            &#125;        &#125; catch () &#123;&#125; finally &#123;&#125;        for(Emp e:list)&#123;            System.out.println(e);        &#125;    &#125;&#125;
5. 批处理
概念
​		当我们有多条sql语句需要发送到数据库执行的时候，有两种发送方式，一种是执行一条发送一条sql语句给数据库,另一个种是发送一个sql集合给数据库，也就是发送一个批sql到数据库。普通的执行过程是：每处理一条数据，就访问一次数据库；而批处理是：累积到一定数量，再一次性提交到数据库，减少了与数据库的交互次数，所以效率会大大提高,很显然两者的数据库执行效率是不同的，我们发送批处理sql的时候数据库执行效率要高
Statement和preparedStatement的批处理区别

statement语句对象实现批处理有如下问题

缺点：采用硬编码效率低，安全性较差。
原理：硬编码，每次执行时相似SQL都会进行编译


PreparedStatement+批处理

优点：语句只编译一次，减少编译次数。提高了安全性（阻止了SQL注入）
原理：相似SQL只编译一次，减少编译次数



批处理开启
&quot;&amp;rewriteBatchedStatements=true&quot;
实例
向部门表中增加多条数据
利用循环添加，并每1000为一批，放入之后清除
String sql = &quot;insert into dept values(default ,?,?)&quot;;preparedStatement = connection.prepareStatement(sql);for (int i = 0; i &lt; 10036 i++) &#123;    preparedStatement.setString(1,&quot;name&quot;);    preparedStatement.setString(2,&quot;location&quot;);    //放进一批里    preparedStatement.addBatch();    if(i%1000==0)&#123;        //每1000为一批，放入后清除        preparedStatement.executeBatch();        preparedStatement.clearBatch();    &#125;&#125;//没有整除完的部分preparedStatement.executeBatch();preparedStatement.addBatch();
6.JDBC控制事务
主要是在学习如何让多个数据库操作成为一个整体，实现要么全部执行成功，要么全部都不执行
在JDBC中，事务操作是自动提交，一条对数据库的DML代表一项事务操作
转账的操作：
/** * @author: ChanHuiShan * @date: 2021-07-08 - 07 - 08 - 16:02 * @description: com.chs.test05 * @version: 1.0 */public class TestTransaction &#123;    private static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    private static String url = &quot;jdbc:mysql://127.0.0.1:3306/mytestdb?&quot; +            &quot;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;&quot; +    &quot;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&amp;useServerPrepStmts=true&amp;cachePrepStmts=true&amp;rewriteBatchedStatements=true&quot;;    private static String user = &quot;root&quot;;    private static String password = &quot;root&quot;;    public static void main(String[] args) &#123;        testTransaction();    &#125;    //定义一个方法，向部门表增加多条数据    public static void testTransaction()&#123;        Connection connection = null;        PreparedStatement preparedStatement = null;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;update account set balance = balance-? where aid =?&quot;;            preparedStatement = connection.prepareStatement(sql);            //转出            preparedStatement.setDouble(1,100);            preparedStatement.setInt(2,1);            //执行            preparedStatement.executeUpdate();            //转入            preparedStatement.setDouble(1,-100);            preparedStatement.setInt(2,2);            //执行            preparedStatement.executeUpdate();        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != connection) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;
为了保证多个sql语句一起执行，使用事务。
在JDBC中，事务操作是自动提交。一条对数据库的DML(insert、update、delete)代表一项事务操作,操作成功后，系统将自动调用commit()提交，否则自动调用rollback()回滚。
设置事务手动提交
try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            //设置事务手动提交            String sql = &quot;update account set balance = balance-? where aid =?&quot;;            preparedStatement = connection.prepareStatement(sql);            //转出            preparedStatement.setDouble(1,100);            preparedStatement.setInt(2,1);            preparedStatement.executeUpdate();   		   //出现异常            int i =1/0;            //转入            preparedStatement.setDouble(1,-100);            preparedStatement.setInt(2,2);            preparedStatement.executeUpdate();        &#125; catch (Exception e) &#123;            //回滚操作            if(null!=connection)&#123;                try &#123;                    connection.rollback();                &#125; catch (SQLException ex) &#123;                    ex.printStackTrace();                &#125;            &#125;        &#125; finally &#123;            //提交操作            if(null!=connection)&#123;                try &#123;                    connection.commit();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != connection) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;
设置回滚点
作用是保证回滚点之前的数据更改生效，回滚点以后的数据更改操作就会无效。
并且回滚点的操作值可以进行更改和设置。

在增加数据操作里面，每一千设置一个回滚点：

connection = DriverManager.getConnection(url, user, password);connection.setAutoCommit(false);//设置手动提交String sql = &quot;insert into dept values(default ,?,?)&quot;;preparedStatement = connection.prepareStatement(sql);for (int i = 0; i &lt; 10036; i++) &#123;    preparedStatement.setString(1,&quot;name&quot;);    preparedStatement.setString(2,&quot;location&quot;);    preparedStatement.addBatch();    if(i%1000==0)&#123;        preparedStatement.executeBatch();        preparedStatement.clearBatch();        //每一千条设置回滚点        Savepoint savepoint = connection.setSavepoint();        savepoints.addLast(savepoint);    &#125;    //期间出现异常    if(i==10001)&#123;        int x =1/0;    &#125;&#125;preparedStatement.executeBatch();preparedStatement.addBatch();

出现异常是10000以后，在最后一个回滚点回滚，剩下36则不保留

catch (Exception e) &#123;    if (null != connection) &#123;        try &#123;            //获得回滚点集合最后一个点            Savepoint sp = savepoints.getLast();            if(null != sp)&#123;                connection.rollback(sp);&#125;//回滚        &#125; catch (SQLException ex) &#123;            ex.printStackTrace();        &#125;    &#125;    e.printStackTrace();&#125; 

设置特定的回滚点

//获得特定的回滚点Savepoint sp = savepoints.get(4);
7. DAO模式
项目结构


实体类：和数据库表格一一对应的类,单独放入一个包中,包名往往是 pojo/entity/bean,要操作的每个表格都应该有对应的实体类


emp &gt; class Emp
dept &gt; class Dept
account &gt; class Account




DAO层：定义了对数据要执行那些操作的接口和实现类,包名往往是 dao/mapper,要操作的每个表格都应该有对应的接口和实现类


emp &gt; interface EmpDao &gt;EmpDaoImpl
dept &gt; interface DeptDao&gt; DeptDaoImpl




Mybatis/Spring-JDBCTemplate 中,对DAO层代码进行了封装,代码编写方式会有其他变化


项目截图

接口类（DAO层）
Emp.java
/** * @author: ChanHuiShan * @date: 2021-07-09 - 07 - 09 - 15:26 * @description: com.chs.dao * @version: 1.0 */public interface EmpDao &#123;    /**     * 向数据库Emp表中增加一条数据的方法     * @param emp 要增加的数据封装成的Emp类的对象     * @return 增加成功返回大于0的整数，增加失败返回0     */    int addEmp(Emp emp);    /**     * 根据员工编号来删除员工信息的方法     * @param empno 要删除的员工的编号     * @return 删除成功返回大于0的整数，删除失败返回0     */    int deleteByEmpno(int empno);    /**     * 查询所有员工的信息     * @return 所有员工的信息集合     */    List&lt;Emp&gt; findAll();    /**     * 根据工号修改员工信息     * @param emp 传入修改的信息     * @return 修改成功返回大于0的整数，删除失败返回0     */    int updateEmp(Emp emp);&#125;
Dept.java
/** * @author: ChanHuiShan * @date: 2021-07-09 - 07 - 09 - 15:26 * @description: com.chs.dao * @version: 1.0 */public interface DeptDao &#123;    /**     * 查询所有部门信息     * @return 所有部门信息的集合     */    List&lt;Dept&gt; findAll();    /**     * 添加部门信息     * @param dept 需要添加的部门信息     * @return 增加成功返回大于0的整数，增加失败返回0     */    int addDept(Dept dept);&#125;
实现类（未被抽取的）
EmpDaoImpl.java
/** * @author: ChanHuiShan * @date: 2021-07-09 - 07 - 09 - 15:28 * @description: com.chs.dao.impl * @version: 1.0 */public class EmpDaoImpl implements EmpDao &#123;    private static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    private static String url = &quot;jdbc:mysql://127.0.0.1:3306/mytestdb?&quot; +            &quot;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;&quot; +            &quot;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;    private static String user = &quot;root&quot;;    private static String password = &quot;root&quot;;    @Override    public int addEmp(Emp emp) &#123;        //向emp表中增加一条数据        Connection connection = null;        PreparedStatement preparedStatement = null;        int rows= 0;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;insert into emp values(DEFAULT,?,?,?,?,?,?,?)&quot;;            preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象            //设置参数            preparedStatement.setObject(1, emp.getEname());            preparedStatement.setObject(2, emp.getJob());            preparedStatement.setObject(3, emp.getMgr());            preparedStatement.setObject(4, emp.getHiredate());            preparedStatement.setObject(5, emp.getSal());            preparedStatement.setObject(6, emp.getComm());            preparedStatement.setObject(7, emp.getDeptno());            //执行CURD            rows = preparedStatement.executeUpdate();        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;//释放资源            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != connection) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return rows;    &#125;    @Override    public int deleteByEmpno(int empno) &#123;        //根据工号删除员工表中的数据        Connection connection = null;        PreparedStatement preparedStatement = null;        int rows= 0;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;delete from emp where empno = ?&quot;;            preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象            //设置参数            preparedStatement.setObject(1, empno);            //执行CURD            rows = preparedStatement.executeUpdate();            //设置参数然后今次那        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;//释放资源            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != connection) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return rows;    &#125;    @Override    public List&lt;Emp&gt; findAll() &#123;        //查询名字中包含A的员工信息        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        List&lt;Emp&gt; list = null;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;select * from emp &quot;;            preparedStatement = connection.prepareStatement(sql);            resultSet = preparedStatement.executeQuery();            list= new ArrayList&lt;&gt;();            while (resultSet.next()) &#123;                int empno = resultSet.getInt(&quot;empno&quot;);                String ename = resultSet.getString(&quot;ename&quot;);                String job = resultSet.getString(&quot;job&quot;);                int MGR = resultSet.getInt(&quot;MGR&quot;);                Date date = resultSet.getDate(&quot;hiredate&quot;);                double sal = resultSet.getDouble(&quot;SAL&quot;);                double comm = resultSet.getDouble(&quot;comm&quot;);                int deptno = resultSet.getInt(&quot;deptno&quot;);                Emp emp = new Emp(empno, ename, job, MGR, date, sal, comm, deptno);                list.add(emp);            &#125;        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (null != resultSet) &#123;                try &#123;                    resultSet.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != connection) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return list;    &#125;    @Override    public int updateEmp(Emp emp) &#123;        //向emp表中增加一条数据        Connection connection = null;        PreparedStatement preparedStatement = null;        int rows= 0;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;update emp set ename = ?,job = ?,mgr = ?,hiredate=?,sal=?,comm=? ,deptno = ? where empno = ?&quot;;            preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象            //设置参数            preparedStatement.setObject(1, emp.getEname());            preparedStatement.setObject(2, emp.getJob());            preparedStatement.setObject(3, emp.getMgr());            preparedStatement.setObject(4, emp.getHiredate());            preparedStatement.setObject(5, emp.getSal());            preparedStatement.setObject(6, emp.getComm());            preparedStatement.setObject(7, emp.getDeptno());            preparedStatement.setObject(8,emp.getEmpno());            //执行CURD            rows = preparedStatement.executeUpdate();        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;//释放资源            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != connection) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return rows;    &#125;&#125;
这些操作都很多相似的地方，可以被抽取成为一个总的类，所以可以啊看待
DeptDaoImpl.java
/** * @author: ChanHuiShan * @date: 2021-07-09 - 07 - 09 - 15:29 * @description: com.chs.dao.impl * @version: 1.0 */public class DeptDaoImpl implements DeptDao &#123;    private static String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    private static String url = &quot;jdbc:mysql://127.0.0.1:3306/mytestdb?&quot; +            &quot;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;&quot; +            &quot;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;;    private static String user = &quot;root&quot;;    private static String password = &quot;root&quot;;    @Override    public List&lt;Dept&gt; findAll() &#123;        //查询名字中包含A的员工信息        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        List&lt;Dept&gt; list = null;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;select * from dept &quot;;            preparedStatement = connection.prepareStatement(sql);            resultSet = preparedStatement.executeQuery();            list= new ArrayList&lt;&gt;();            while (resultSet.next()) &#123;                int deptno = resultSet.getInt(&quot;deptno&quot;);                String dname = resultSet.getString(&quot;dname&quot;);                String loc = resultSet.getString(&quot;loc&quot;);                Dept dept = new Dept(deptno,dname,loc);                list.add(dept);            &#125;        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (null != resultSet) &#123;                try &#123;                    resultSet.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != connection) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return list;    &#125;    @Override    public int addDept(Dept dept) &#123;        //向emp表中增加一条数据        Connection connection = null;        PreparedStatement preparedStatement = null;        int rows= 0;        try &#123;            forName(driver);            connection = DriverManager.getConnection(url, user, password);            String sql = &quot;insert into dept values(?,?,?)&quot;;            preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象            //设置参数            preparedStatement.setObject(1,dept.getDeptno());            preparedStatement.setObject(2,dept.getDname());            preparedStatement.setObject(3,dept.getLoc());            //执行CURD            rows = preparedStatement.executeUpdate();        &#125; catch (ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;//释放资源            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != connection) &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return rows;    &#125;&#125;
员工管理系统
EmpManageSystem.java
/** * @author: ChanHuiShan * @date: 2021-07-09 - 07 - 09 - 20:11 * @description: com.chs.view * @version: 1.0 */public class EmpManageSystem &#123;    private static Scanner sc = new Scanner(System.in);    private static EmpDao empDao = new EmpDaoImpl();    private static DeptDao deptDao= new DeptDaoImpl();    private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    public static void main(String[] args) &#123;        while (true)&#123;//控制台循环打印            showMenu();            System.out.println(&quot;请用户录入选项&quot;);            int i = sc.nextInt();            switch (i)&#123;                case 1:                    case1();                    break;                case 2:                    case2();                    break;                case 3:                    case3();                    break;                case 4:                    case4();                    break;                case 5:                    case5();                    break;                case 6:                    case6();                    break;                default:                    System.out.println(&quot;请输入1-7的数字！！！&quot;);                    break;            &#125;        &#125;    &#125;    public static void showMenu()&#123;        System.out.println(&quot;----------------------------&quot;);        System.out.println(&quot;1.查看所有员工的信息&quot;);        System.out.println(&quot;2.查看所有部门信息&quot;);        System.out.println(&quot;3.根据工号删除员工信息&quot;);        System.out.println(&quot;4.根据工号修改员工信息&quot;);        System.out.println(&quot;5.增加员工信息&quot;);        System.out.println(&quot;6.增加部门信息&quot;);        System.out.println(&quot;----------------------------&quot;);    &#125;    public static void case1()&#123;        //查看所有员工的信息        List&lt;Emp&gt; list = empDao.findAll();        /*for (Emp e: list)&#123;            System.out.println(e);        &#125;*/        list.forEach(System.out::println);    &#125;    public static void case2()&#123;        //查看所有部门的信息        List&lt;Dept&gt; list = deptDao.findAll();        list.forEach(System.out::println);    &#125;    public static void case3()&#123;        //根据工号来删除员工信息        System.out.println(&quot;请输入要删除员工的工号：&quot;);        int i = sc.nextInt();        int i1 = empDao.deleteByEmpno(i);        if (i1!=0)&#123;            System.out.println(&quot;删除成功！&quot;);        &#125;else        &#123;            System.out.println(&quot;删除失败！&quot;);        &#125;    &#125;    public static void case4()&#123;        //根据员工工号修改员工信息        System.out.println(&quot;*请输入员工的编号&quot;);        int empno = sc.nextInt();        System.out.println(&quot;*请输入员工的姓名&quot;);        String ename = sc.next();        System.out.println(&quot;*请输入员工的工作&quot;);        String job = sc.next();        System.out.println(&quot;*请输入员工的上级编号&quot;);        int mgr = sc.nextInt();        System.out.println(&quot;*请输入员工的聘用日期（格式为yyyy-mm-dd）&quot;);        Date hiredate = null;//把参数从try代码块里拿出来初始化，因为创建对象的时候会访问不到这个值        try &#123;            hiredate = simpleDateFormat.parse(sc.next());        &#125; catch (ParseException e) &#123;            System.out.println(&quot;请按照格式输入!!!&quot;);            e.printStackTrace();        &#125;        System.out.println(&quot;*请输入员工的薪资&quot;);        double sal = sc.nextDouble();        System.out.println(&quot;*请输入员工的奖金&quot;);        double comm = sc.nextDouble();        System.out.println(&quot;*请输入员工的部门编号&quot;);        int deptno = sc.nextInt();        Emp emp = new Emp(empno,ename,job,mgr,hiredate,sal,comm,deptno);        empDao.updateEmp(emp);    &#125;    public static void case5()&#123;        //添加员工信息        System.out.println(&quot;*请输入员工的姓名&quot;);        String ename = sc.next();        System.out.println(&quot;*请输入员工的工作&quot;);        String job = sc.next();        System.out.println(&quot;*请输入员工的上级编号&quot;);        int mgr = sc.nextInt();        System.out.println(&quot;*请输入员工的聘用日期（格式为yyyy-mm-dd）&quot;);        Date hiredate = null;//把参数从try代码块里拿出来初始化，因为创建对象的时候会访问不到这个值        try &#123;            hiredate = simpleDateFormat.parse(sc.next());        &#125; catch (ParseException e) &#123;            System.out.println(&quot;请按照格式输入!!!&quot;);            e.printStackTrace();        &#125;        System.out.println(&quot;*请输入员工的薪资&quot;);        double sal = sc.nextDouble();        System.out.println(&quot;*请输入员工的奖金&quot;);        double comm = sc.nextDouble();        System.out.println(&quot;*请输入员工的部门编号&quot;);        int deptno = sc.nextInt();        Emp emp = new Emp(null,ename,job,mgr,hiredate,sal,comm,deptno);        int i = empDao.addEmp(emp);        if (i&gt;0)&#123;            System.out.println(&quot;添加成功&quot;);        &#125;else&#123;            System.out.println(&quot;添加失败！！！&quot;);        &#125;    &#125;    public static void case6()&#123;        //添加部门信息        System.out.println(&quot;请输入部门号&quot;);        int deptno = sc.nextInt();        System.out.println(&quot;*请输入部门名称&quot;);        String dname = sc.next();        System.out.println(&quot;*请输入部门地址&quot;);        String loc = sc.next();        Dept dept = new Dept(deptno, dname, loc);        int i = deptDao.addDept(dept);        if (i&gt;0)&#123;            System.out.println(&quot;添加成功&quot;);        &#125;else&#123;            System.out.println(&quot;添加失败！！！&quot;);        &#125;    &#125;&#125;
BaseDao抽取
由上面实现类的代码可以看到增删改查方法的代码都很相似，其实可以把相似的部分抽取出来称为一个BaseDao的类
增删改的抽取–baseUpdate
/**     * 增删改方法的抽取     * @param sql 传入的sql语句对象     * @param args 传入的可变参数     * @return 修改成功返回大于0的数，返回失败返回0     */public static int baseUpdate(String sql,Object ... args)&#123;    Connection connection = null;    PreparedStatement preparedStatement = null;    int rows= 0;    try &#123;        forName(driver);        connection = DriverManager.getConnection(url, user, password);        preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象        //设置参数        for (int i = 0; i &lt; args.length; i++) &#123;            preparedStatement.setObject(i+1,args[i]);        &#125;        //执行CURD        rows = preparedStatement.executeUpdate();    &#125; catch (ClassNotFoundException | SQLException e) &#123;        e.printStackTrace();    &#125; finally &#123;//释放资源        if (null != preparedStatement) &#123;            try &#123;                preparedStatement.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (null != connection) &#123;            try &#123;                connection.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    return rows;&#125;
查询的抽取–baseQuery
通过反射获取传入字节码的对象属性
关于反射是否破坏封装类（面试）：https://www.cnblogs.com/wk-missQ1/p/13304329.html
/**     * 查询操作的抽取     * @param clazz 传入字节码以便通过反射获得对象的属性，     *              因为不知道具体会传入什么对象里面是什么属性。     * @param sql 传入的sql语句对象     * @param args 一些可变的参数     * @return 返回一个查询结果集合     */public static List baseQuery(Class clazz,String sql,Object ... args)&#123;    Connection connection = null;    PreparedStatement preparedStatement = null;    ResultSet resultSet = null;    List list = null;    try &#123;        forName(driver);        connection = DriverManager.getConnection(url, user, password);        preparedStatement = connection.prepareStatement(sql);        list= new ArrayList&lt;&gt;();        //设置参数 -- 这里要注意呀        for (int i = 0; i &lt; args.length; i++) &#123;            preparedStatement.setObject(i+1,args[i]);        &#125;        //执行CURD        resultSet = preparedStatement.executeQuery();        //通过字节码获取对象的属性        Field[] fields = clazz.getDeclaredFields();        //获取访问封装类属性的权限--设置为true可以访问        for (Field field : fields) &#123;            field.setAccessible(true);        &#125;        while (resultSet.next()) &#123;            //通过反射创建对象            Object obj = clazz.newInstance();//默认通过反射调用对象的空参构造方法            for (Field field : fields) &#123;                String name = field.getName();//先将属性名字获得                Object data = resultSet.getObject(name);//通过属性名从结果集中获得                field.set(data,obj);//将数据放入对象中            &#125;            list.add(obj);//将对象加入到链表集合里        &#125;    &#125; catch (ClassNotFoundException | SQLException e) &#123;        e.printStackTrace();    &#125; catch (IllegalAccessException e) &#123;        e.printStackTrace();    &#125; catch (InstantiationException e) &#123;        e.printStackTrace();    &#125; finally &#123;        if (null != resultSet) &#123;            try &#123;                resultSet.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (null != preparedStatement) &#123;            try &#123;                preparedStatement.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (null != connection) &#123;            try &#123;                connection.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    return list;&#125;//设置参数for (int i = 0; i &lt; args.length; i++) &#123;    preparedStatement.setObject(i+1,args[i]);&#125;//执行CURDresultSet = preparedStatement.executeQuery();//通过字节码获取对象的属性Field[] fields = clazz.getDeclaredFields();//获取访问封装类属性的权限--设置为true可以访问for (Field field : fields) &#123;    field.setAccessible(true);&#125;while (resultSet.next()) &#123;    //通过反射创建对象    Object obj = clazz.newInstance();//默认通过反射调用对象的空参构造方法    for (Field field : fields) &#123;        String name = field.getName();//先将属性名字获得        Object data = resultSet.getObject(name);//通过属性名从结果集中获得        field.set(data,obj);//将数据放入对象中    &#125;    list.add(obj);//将对象放入list表中&#125;
这样一来，两个实现类中间的增删改操作就可以被简化
实现类简化结果
DeptDaoImpl.java
public class DeptDaoImpl extends BaseDao implements DeptDao &#123;//注意继承BaseDao    @Override    public List&lt;Dept&gt; findAll() &#123;            String sql = &quot;select * from dept &quot;;            return baseQuery(Dept.class,sql);    &#125;    @Override    public int addDept(Dept dept) &#123;            String sql = &quot;insert into dept values(?,?,?)&quot;;            return baseUpdate(sql,dept.getDeptno(),dept.getDname(),                    dept.getLoc());    &#125;&#125;
EmpDaoImpl.java
public class EmpDaoImpl extends BaseDao implements EmpDao &#123;    @Override    public int addEmp(Emp emp) &#123;            String sql = &quot;insert into emp values(DEFAULT,?,?,?,?,?,?,?)&quot;;            return baseUpdate(sql,emp.getEname(),emp.getJob(),emp.getMgr(),                    emp.getHiredate(),emp.getSal(),emp.getComm(),emp.getDeptno());    &#125;    @Override    public int deleteByEmpno(int empno) &#123;            String sql = &quot;delete from emp where empno = ?&quot;;            return baseUpdate(sql,empno);    &#125;    @Override    public List&lt;Emp&gt; findAll() &#123;            String sql = &quot;select * from emp &quot;;            return baseQuery(Emp.class,sql);    &#125;    @Override    public int updateEmp(Emp emp) &#123;        String sql = &quot;update emp set ename = ?,job = ?,mgr = ?,hiredate=?,sal=?,comm=? ,deptno = ? where empno = ?&quot;;        return baseUpdate(sql,emp.getEname(),emp.getJob(),emp.getMgr(),                emp.getHiredate(),emp.getSal(),emp.getComm(),emp.getDeptno(),emp.getEmpno());    &#125;&#125;
错误总结：
java.lang.IllegalArgumentException：传入参数传错了

field.set(obj,data);//将数据放入对象中,不要传反了
连接池


传统的连接：
​	首先调用Class.forName()方法加载数据库驱动，然后调用DriverManager.getConnection()方法建立连接.


缺点：
​	Connection对象在每次执行DML和DQL的过程中都要创建一次,DML和DQL执行完毕后,connection对象都会被销毁. connection对象是可以反复使用的,没有必要每次都创建新的.该对象的创建和销毁都是比较消耗系统资源的,如何实现connection对象的反复使用呢?使用连接池技术实现.




使用连接池：


预先准备一些链接对象,放入连接池中,当多个线程并发执行时,可以避免短时间内一次性大量创建链接对象,减少计算机单位时间内的运算压力,提高程序的响应速度


实现链接对象的反复使用,可以大大减少链接对象的创建次数,减少资源的消耗




MyConnectionPool.java


创建一个连接对象
//准备一个池子装连接对象private static LinkedList&lt;Connection&gt; pool;


静态代码块

加载驱动
初始化pool
创建5个链接对象

//使用静态代码块加载驱动，创建连接static&#123;    //加载驱动    try &#123;        Class.forName(driver);    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;    //初始化pool    pool = new LinkedList&lt;&gt;();    //创建五个链接对象    for (int i = 0; i &lt; initSize; i++) &#123;        Connection connection = initConnection();        if(null != connection)&#123;            pool.add(connection);            System.out.println(&quot;初始化连接：&quot;+connection.hashCode()+&quot;放入连接池&quot;);        &#125;    &#125;&#125;


私有的初始化一个链接对象的方法
/**     * 私有的初始化一个链接对象的方法     * @return 初始化的连接对象     */private static Connection initConnection()&#123;    try &#123;        return DriverManager.getConnection(url,user,password);    &#125; catch (SQLException e) &#123;        e.printStackTrace();    &#125;    return null;&#125;


公有的向外界提供链接对象

如果池子里有对象

remove（）


如果池子没了：创建新的对象
最后返回对象

/**     * 公有的向外界提供链接对象的方法     * @return     */public static Connection getConnection()&#123;    Connection connection = null;    if (pool.size()&gt;0)&#123;//如果连接池里面有元素        connection = pool.remove();//移出集合中的第一个元素        System.out.println(&quot;连接池中还有链接，获得链接：&quot;+connection.hashCode());    &#125;else&#123;        connection = initConnection();        System.out.println(&quot;连接池为空，创建新链接：&quot;+connection);    &#125;    return connection;&#125;


公有的向链接对象归还链接对象的方法

若链接没有被关闭

调整事务状态，设置为手动提交
容量小于最大容量

池子最后加上connection


容量达到最大容量

关闭连接，打印池子满了，关闭连接




若已经被关闭，打印：无需关闭，不用归还

/**     * 公有的向链接对象归还链接对象的方法     * @param connection     */public static void returnConnection(Connection connection)&#123;    if (null != connection)&#123;        try &#123;            if (!connection.isClosed())                if (pool.size()&lt; maxSize)&#123;                    connection.setAutoCommit(true);//调整事务状态                    pool.addLast(connection);//归还链接对象给池子                    System.out.println(&quot;连接池未满，归还链接对象：&quot;+connection.hashCode());                &#125;else&#123;                    connection.close();                    System.out.println(&quot;连接池已满，关闭连接池&quot;);                &#125;            &#125;else&#123;                System.out.println(&quot;连接已经关闭无需归还&quot;);//连接被关了下次是没法用的            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;else&#123;        System.out.println(&quot;传入的连接为null，无需归还&quot;);


测试


创建多个连接：
Connection connection1 = MyConnectionPool.getConnection();...Connection connection11 = MyConnectionPool.getConnection();
结果：前面小于initSize的部分个从连接池里取，后面超过的部分直接初始化。



归还连接


传入null值
MyConnectionPool.returnConnection(null);
结果：



传入已关闭的连接
connection1.close();MyConnectionPool.returnConnection(connection1);
结果：



传入超过maxSize的连接
MyConnectionPool.returnConnection(connection11);//maxSize=10---11&gt;10





BaseDao改进


原来的参数可以删除



加载驱动和连接部分改进



连接最后归还



BaseDao.java
public abstract class BaseDao &#123;    //原来的参数全部删除    /**     * 增删改方法的抽取     * @param sql 传入的sql语句对象     * @param args 传入的可变参数     * @return 修改成功返回大于0的数，返回失败返回0     */    public static int baseUpdate(String sql,Object ... args)&#123;        Connection connection = null;        PreparedStatement preparedStatement = null;        int rows= 0;        try &#123;            connection = MyConnectionPool.getConnection();//从连接池里获得连接            preparedStatement = connection.prepareStatement(sql);//这个时候就要传入语句对象            //设置参数            for (int i = 0; i &lt; args.length; i++) &#123;                preparedStatement.setObject(i+1,args[i]);            &#125;            //执行CURD            rows = preparedStatement.executeUpdate();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;//释放资源            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            MyConnectionPool.returnConnection(connection);//归还到连接池里        &#125;        return rows;    &#125;    /**     * 查询操作的抽取     * @param clazz 传入字节码以便通过反射获得对象的属性，     *              因为不知道具体会传入什么对象里面是什么属性。     * @param sql 传入的sql语句对象     * @param args 一些可变的参数     * @return 返回一个查询结果集合     */    public static List baseQuery(Class clazz,String sql,Object ... args)&#123;        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        List list = null;        try &#123;            connection = MyConnectionPool.getConnection();            preparedStatement = connection.prepareStatement(sql);            list= new ArrayList&lt;&gt;();            //设置参数            for (int i = 0; i &lt; args.length; i++) &#123;                preparedStatement.setObject(i+1,args[i]);            &#125;            //执行CURD            resultSet = preparedStatement.executeQuery();            //通过字节码获取对象的属性            Field[] fields = clazz.getDeclaredFields();            //获取访问封装类属性的权限--设置为true可以访问            for (Field field : fields) &#123;               field.setAccessible(true);            &#125;            while (resultSet.next()) &#123;                //通过反射创建对象                Object obj = clazz.newInstance();//默认通过反射调用对象的空参构造方法                for (Field field : fields) &#123;                    String name = field.getName();//先将属性名字获得                    Object data = resultSet.getObject(name);//通过属性名从结果集中获得                    field.set(obj,data);//将数据放入对象中                &#125;                list.add(obj);//将对象加入到链表集合里            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (null != resultSet) &#123;                try &#123;                    resultSet.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (null != preparedStatement) &#123;                try &#123;                    preparedStatement.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            MyConnectionPool.returnConnection(connection);        &#125;        return list;    &#125;&#125;
配置文件优化连接池

注意格式：空格不能随便加

PropertiesUtil工具类

创建工具类

定义构造方法

传进配置文件的路径
通过字节码获取文件路径
加载IO流


定义一个获得参数的方法



public class PropertiesUtil &#123;    private Properties properties;//定义配置文件参数    /**     * 定义配置文件构造器     * @param path 传入配置文件路径     */    public PropertiesUtil(String path)&#123;        properties = new Properties();        //通过字节码获取IO流        InputStream resourceAsStream = this.getClass().getResourceAsStream(path);        try &#123;            //加载IO流            properties.load(resourceAsStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 返回配置文件参数值的方法     * @param key 参数名     * @return 参数的字符串     */    public String getProperties(String key)&#123;        return properties.getProperty(key);    &#125;&#125;
连接池优化


删除参数值



在静态代码块里配置参数
//创建配置文件对象PropertiesUtil propertiesUtil = new PropertiesUtil(&quot;/jdbc.properties&quot;);driver = propertiesUtil.getProperties(&quot;driver&quot;);url = propertiesUtil.getProperties(&quot;url&quot;);user = propertiesUtil.getProperties(&quot;user&quot;);password = propertiesUtil.getProperties(&quot;password&quot;);initSize = Integer.parseInt(propertiesUtil.getProperties(&quot;initSize&quot;));maxSize = Integer.parseInt(propertiesUtil.getProperties(&quot;maxSize&quot;));


错误总结
连接池的定义好像出现了某种问题
Exception in thread “main” java.lang.NoClassDefFoundError: Could not initialize class com.chs.dao.MyConnectionPool
发现是构造器中没有用到本身的参数，而是重新定义了一个参数：

8. log4j日志


什么是日志log
​		异常信息  登录成功失败的信息  其他重要操作的信息，日志可以记录程序的运行状态,运行信息,用户的一些常用操作.日志可以帮助我们分析程序的运行状态,帮我们分析用户的操作习惯,进而对程序进行改


如何记录日志


方式1：System.out.println(…)    e.printStackTrace();
缺点：不是保存到文件，不能长久存储


方式2：IO流 将System.out.println(…)  e.printStackTrace();写入文件
缺点：操作繁琐,IO流操作容易阻塞线程,日志没有等级,日志的格式不能很好的定制,要想实行编程复杂


方式3：使用现成的日志框架，比如log4j
优点：1长久保存 2有等级3格式可以很好的定制 4代码编写简单




log4j日志的级别
FATAL：  指出现非常严重的错误事件，这些错误可能导致应用程序异常中止
ERROR： 指虽有错误，但仍允许应用程序继续运行
WARN：  指运行环境潜藏着危害
INFO：    指报告信息，这些信息在粗粒度级别上突出显示应用程序的进程
DEBUG： 指细粒度信息事件，对于应用程序的调试是最有用的



使用log4j记录日志


加入jar包   log4j-1.2.8.jar



加入属性文件 src 下 log4j.properties

log4j.rootLogger=error,logfile## 方式一：打印到控制台log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayout## 方式二：打印到logfile文件log4j.appender.logfile=org.apache.log4j.FileAppenderlog4j.appender.logfile.File=d:/msb.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd   HH:mm:ss&#125; %l %F %p %m%n




通过属性文件理解log4j的主要API
Appender 日志目的地 :ConsoleAppender  FileAppender
Layout 日志格式化器 ：SimpleLayout  PatternLayout




以连接池为例：


添加日志对象



初始化日志



将sout语句和错误打印改为日志输出：

错误大多使用fatal级别



sout提示语句一般使用info级别


运行结果：



补充
%p：输出日志信息的优先级，即DEBUG，INFO，WARN，ERROR，FATAL。%d：输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，如：%d&#123;yyyy/MM/dd HH:mm:ss,SSS&#125;。%r：输出自应用程序启动到输出该log信息耗费的毫秒数。%t：输出产生该日志事件的线程名。%l：输出日志事件的发生位置，相当于%c.%M(%F:%L)的组合，包括类全名、方法、文件名以及在代码中的行数。例如test.TestLog4j.main(TestLog4j.java:10)。%c：输出日志信息所属的类目，通常就是所在类的全名。%M：输出产生日志信息的方法名。%F：输出日志消息产生时所在的文件名称。%L:：输出代码中的行号。%m:：输出代码中指定的具体日志信息。%n：输出一个回车换行符，Windows平台为&quot;rn&quot;，Unix平台为&quot;n&quot;。%x：输出和当前线程相关联的NDC(嵌套诊断环境)，尤其用到像java servlets这样的多客户多线程的应用中。%%：输出一个&quot;%&quot;字符。
9. 三大范式
第一范式（1NF）
要求数据库表的每一列都是不可分割的原子数据项。
举例说明：

在上面的表中，“家庭信息”和“学校信息”列均不满足原子性的要求，故不满足第一范式，调整如下：

可见，调整后的每一列都是不可再分的，因此满足第一范式（1NF）；
第二范式（2NF）
在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）
第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。
举例说明：

在上图所示的情况中，同一个订单中可能包含不同的产品，因此主键必须是“订单号”和“产品号”联合组成，
但可以发现，产品数量、产品折扣、产品价格与“订单号”和“产品号”都相关，但是订单金额和订单时间仅与“订单号”相关，与“产品号”无关，
这样就不满足第二范式的要求，调整如下，需分成两个表：
 
第三范式（3NF）
在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）
第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。
举例说明：

上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，
而不是主键“学号”，所以需做如下调整：
 
这样以来，就满足了第三范式的要求。
ps:如果把上表中的班主任姓名改成班主任教工号可能更确切，更符合实际情况，不过只要能理解就行。
总结


优点：结构合理、冗余较小、尽量避免插入删除修改异常


缺点：性能降低、多表查询比单表查询速度慢。


范式是指导数据设计的规范化理论，可以保证数据库设计质量

第一范式：字段不能再分
第二范式：不存在局部依赖
第三范式：不含传递依赖（间接依赖）



在实际设计中，要整体遵循范式理论，但某些特定的情况下不能死板遵循，这样会降低数据库的效率，一般单表查询效率会比多表查询高，特定表的的设计可以违反第三范式，增加冗余提高性能

例如：经常购物车条目的中除了条目编号，商品编号，商品数量外，可以增加经常使用的商品名称，商品价格等






]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>Java</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery</title>
    <url>/2021/06/18/JQuery/</url>
    <content><![CDATA[引入
为什么使用jQuery？
使用原生JavaScript编码存在问题
1选择器功能弱
2 DOM操作繁琐之极
3浏览器兼容性不好
4动画功能弱

优点
1强大的选择器
2出色的DOM封装
3出色的浏览器兼容性
4强大的动画功能
5体积小，压缩后只有100KB左右
6可靠的事件处理机制
7使用隐式迭代简化编程
8丰富的插件支持
定义
目前最流行的JavaScript函数库之一，对JavaScript进行了封装。并不是一门新语言。将常用的、复杂的操作进行函数化封装，直接调用，大大降低了使用JavaScript的难度，改变了使用JavaScript的习惯。jQuery能做的JavaScript也能做，但使用jQuery能大幅提高开发效率,由美国人John Resig在2006年推出，目前最新版本是v3.5.1。宗旨：Write less，do more（写更少代码，做更多事情）。官方网址http://jquery.com/

==$()==
作用一：页面加载函数
/*jQuery(document).ready(function ()&#123;                                var domS1=document.getElementById(&quot;s1&quot;);                                console.log(domS1.innerText);                        &#125;)*/// jQuery  可以简写 $/*$(document).ready(function ()&#123;                                var domS1=document.getElementById(&quot;s1&quot;);                                console.log(domS1.innerText);                        &#125;)*/$(function()&#123;    var domS1=document.getElementById(&quot;s1&quot;);    console.log(domS1.innerText);&#125;)$(function()&#123;    console.log(&quot;第二个页面加载函数&quot;)&#125;)$(function()&#123;    console.log(&quot;第三个页面加载函数&quot;)&#125;)
作用二：选择器标志
$(selector)
选择器
基本选择器
//标签选择器 $(&quot;a&quot;)                     $(&quot;h3&quot;).addClass(&quot;myClass&quot;);                   $(&quot;p&quot;).addClass(&quot;myClass&quot;); // ID选择器 $(&quot;#id&quot;)     $(&quot;p#id&quot;)                   $(&quot;#h31&quot;).addClass(&quot;myClass&quot;);                   $(&quot;h3#h31&quot;).addClass(&quot;myClass&quot;); // 类选择器 $(&quot;.class&quot;)    $(&quot;h2.class&quot;)                   $(&quot;.red1&quot;).addClass(&quot;myClass&quot;); // 通配选择器 $(&quot;*&quot;)                   $(&quot;*&quot;).addClass(&quot;myClass&quot;); // 并集选择器$(&quot;elem1,elem2,elem3&quot;)                   $(&quot;#h31,span,div&quot;).addClass(&quot;myClass&quot;); // 后代选择器$(ul li)                     $(&quot;p span&quot;).addClass(&quot;myClass&quot;);   //  父子选择器 $(ul&gt;li)                     $(&quot;p&gt;span&quot;).addClass(&quot;myClass&quot;); //  后面第一个兄弟元素 prev + next                   $(&quot;h3+p&quot;).addClass(&quot;myClass&quot;); //  后面所有的兄弟元素 prev ~ next                 $(&quot;h3~p&quot;).addClass(&quot;myClass&quot;); 
属性选择器
//[attribute]                     $(&quot;a&quot;).addClass(&quot;myClass&quot;);                     $(&quot;a[href]&quot;).addClass(&quot;myClass&quot;); //[attribute1][attribute2]                     $(&quot;a[href][title]&quot;).addClass(&quot;myClass&quot;); //[attribute=value]                       $(&quot;a[href=&#x27;film-2.html&#x27;]&quot;).addClass(&quot;myClass&quot;); //[attribute!=value]                       $(&quot;a[href][href!=&#x27;film-2.html&#x27;]&quot;).addClass(&quot;myClass&quot;); //[attribute^=value]                       $(&quot;a[href^=&#x27;http&#x27;]&quot;).addClass(&quot;myClass&quot;); //[attribute$=value                       $(&quot;a[href$=&#x27;htm&#x27;]&quot;).addClass(&quot;myClass&quot;); //[attribute*=value]                  		 $(&quot;a[href*=&#x27;mashibing&#x27;]&quot;).addClass(&quot;myClass&quot;);
位置选择器
  //位置针对整个页面                   //:first     :last   :odd   :even                     $(&quot;p:first&quot;).addClass(&quot;myClass&quot;);                   $(&quot;p:last&quot;).addClass(&quot;myClass&quot;);                   $(&quot;p:odd&quot;).addClass(&quot;myClass&quot;);//索引从0开始 奇数的索引 1 3 5 第偶数的元素                  $(&quot;p:even&quot;).addClass(&quot;myClass&quot;); //                  //:eq(n)     :gt(n)   :lt(n)                   $(&quot;p:eq(4)&quot;).addClass(&quot;myClass&quot;);   //equals                   $(&quot;p:lt(4)&quot;).addClass(&quot;myClass&quot;);//less   than                    $(&quot;p:gt(4)&quot;).addClass(&quot;myClass&quot;);//greater   than //位置针对上级标签                   //:first-child    :last-child   :only-child                   $(&quot;p:first-child&quot;).addClass(&quot;myClass&quot;);                   $(&quot;p:last-child&quot;).addClass(&quot;myClass&quot;);                   $(&quot;p:only-child&quot;).addClass(&quot;myClass&quot;);                   //:nth-child(n)   :nth-child(odd|even) :nth-child(xn+y)                   // 索引从0开始 只有此处从1开始                  $(&quot;p:nth-child(2)&quot;).addClass(&quot;myClass&quot;);                  $(&quot;p:nth-child(odd)&quot;).addClass(&quot;myClass&quot;);                   $(&quot;p:nth-child(even)&quot;).addClass(&quot;myClass&quot;);                   $(&quot;p:nth-child(3n+1)&quot;).addClass(&quot;myClass&quot;);//n=0,1,2,3 
表单选择器


关于表单项的选择器
:text   :password  :radio  :checkbox  :hidden  :file  :submit
:input  匹配所有 input, textarea, select 和 button 元素


关于表单项状态的选择器
:selected  :checked  :enabled  :disabled  :hidden :visible


注意(&quot;input&quot;)和(&quot;input&quot;)和(&quot;input&quot;)和(“:input”)的区别
$(“input”)：标签选择器，只匹配input标签,
$(“:input”)： 匹配所有 input, textarea, select 和 button 元素


//:text   :password    :radio  :checkbox  :hidden    :file  :submit                     var arr =$(&quot;input&quot;); // 标签名选择器                                      var arr = $(&quot;input[type=hidden]&quot;);                     var arr = $(&quot;input:hidden&quot;);              //:input  匹配所有 input, textarea, select 和 button 元素                     var arr =   $(&quot;input,select,textarea,button&quot;);                     var arr = $(&quot;:input&quot;); //:selected    :checked  :enabled  :disabled                       var arr = $(&quot;:disabled&quot;);                     var arr = $(&quot;:enabled&quot;);                     var arr = $(&quot;:input:not(:disabled)&quot;);                     var arr = $(&quot;:checked&quot;);                     var arr = $(&quot;:selected&quot;);                     //:hidden :visible                           var arr = $(&quot;input:hidden&quot;)                     var   arr = $(&quot;:input:visible&quot;)                  for(var i = 0; i &lt; arr.length; i++) &#123;                      console.info(arr[i]);                  &#125;
完成DOM编程
操作属性
原生js 中的通过元素.属性名或者元素.setAttribute()方式操作元素属性,jQuery给我们封装了attr() 和removeAttr(),更加便捷的操作属性
/*         	 *attr()          	 *          	 * *///获得属性             function fun1()&#123;                  console.log($(&quot;#f1&quot;).attr(&quot;color&quot;))                  console.log($(&quot;#f1&quot;).attr(&quot;id&quot;))                  console.log($(&quot;#f1&quot;).attr(&quot;size&quot;))             &#125;//修改属性             function fun2()&#123;                 $(&quot;#f1&quot;).attr(&quot;color&quot;,&quot;green&quot;)                 $(&quot;#f1&quot;).attr(&quot;size&quot;,&quot;5&quot;)             &#125;//删除属性             function fun3()&#123;                 $(&quot;#f1&quot;).removeAttr(&quot;color&quot;)              &#125;//添加属性             function fun4()&#123;                $(&quot;#f1&quot;).attr(&quot;class&quot;,&quot;a&quot;)             &#125;
操作样式
原生js 中的通过元素.style.样式名=’样式值’的方式操作元素样式,jQuery给我们封装了css()方法,便于我们操作样式,多数情况样式选择器使用类选择器,所以jQuery针对于这一情况,给我们封装了==addClass==  ==removeClass== ==toggleClass== 三个方法
css样式
&lt;style&gt;          .a&#123;              width: 100px;              height: 100px;              background-color: pink;          &#125;            .b&#123;              border: 10px solid green;              border-radius: 20px;          &#125;&lt;/style&gt;
jQuery封装的==css()==方法
&lt;script&gt;    //修改样式    function fun1()&#123;        //获得d1的css样式        console.log($(&quot;#d1&quot;).css(&quot;width&quot;));        console.log($(&quot;#d1&quot;).css(&quot;height&quot;));        console.log($(&quot;#d1&quot;).css(&quot;background-color&quot;));        //修改d1的css样式        $(&quot;#d1&quot;).css(&quot;width&quot;,&quot;200px&quot;)        $(&quot;#d1&quot;).css(&quot;height&quot;,&quot;300px&quot;)        $(&quot;#d1&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);    &#125;    /*              * CSS 样式在实际的研发中,往往通过类选择器作用到元素上              * jQuery就专门的封装了操作class属性值的方法              * */	//添加class值    function fun2()&#123;        $(&quot;#d2&quot;).addClass(&quot;b&quot;)    &#125;    //删除class值    function fun3()&#123;        $(&quot;#d2&quot;).removeClass(&quot;b&quot;)    &#125;    //切换class值    function fun4()&#123;        $(&quot;#d2&quot;).toggleClass(&quot;b&quot;)// 原来有b 则删除,如果没有,则增加b    &#125;&lt;/script&gt;
操作文本
原生js 中的通过元素.innerText和innerHTML和.value属性操作标签内部文本和内容,jQuery给我们封装了==text(),html()和val()==三个方法
&lt;script&gt;    //获得标签内容    function fun1()&#123;        /*                          	 * innerText &gt;&gt;&gt;&gt; text();                          	 * innerHTML &gt;&gt;&gt;&gt; html();                          	 * value     &gt;&gt;&gt;&gt; val();                          	 *                           	 * */        console.log($(&quot;#d1&quot;).text())         console.log($(&quot;#d1&quot;).html())        console.log($(&quot;#i1&quot;).val())    &#125;    //修改标签内容    function fun2()&#123;        //$(&quot;#d1&quot;).text(&quot;&lt;h1&gt;牛气冲天&lt;/h1&gt;&quot;);        $(&quot;#d1&quot;).html(&quot;&lt;h1&gt;牛气冲天&lt;/h1&gt;&quot;);        $(&quot;#i1&quot;).val(&quot;你好&quot;);    &#125;    //删除标签中的内容    function fun3()&#123;        //$(&quot;#d1&quot;).html(&quot;&quot;);        $(&quot;#d1&quot;).empty();// 清空内容        $(&quot;#i1&quot;).val(&quot;&quot;);    &#125;&lt;/script&gt;
增删元素
原生js 中的对于元素的创建,增加和删除代码比较繁琐,而jQuery从元素的创建到元素的增加和删除都给我们提供了更加便捷的方法

创建元素

$(‘text’)


追加元素

append() appendTo() 添加内部标签
before() insertBefore() 向前增加标签
after() insertAfter()  向后增加标签


删除元素

empty()  清空字标签
remove() 移除当前标签



&lt;script&gt;    //append() 调用的对象是添加的区域    function fun1()&#123;        // 创建元素        var span1=$(&quot;&lt;span&gt;&lt;/span&gt;&quot;);        // 设置样式        span1.css(&quot;color&quot;,&quot;green&quot;);        span1.css(&quot;border&quot;,&quot;1px solid blue&quot;);        span1.css(&quot;background-color&quot;,&quot;lightgray&quot;)        // 设置文字        span1.text(&quot;今天天气很好&quot;);        $(&#x27;#d1&#x27;).append(span1)    &#125;        //appendTo() 调用的对象是要添加的内容    function fun2()&#123;        var h =$(&quot;&lt;h3&gt;测试文字&lt;/h3&gt;&quot;).css(&quot;color&quot;,&quot;red&quot;).css(&quot;border&quot;,&quot;1px solid green&quot;)        h.appendTo($(&#x27;#d1&#x27;))    &#125;        //before()    function fun3()&#123;        var span1=$(&#x27;&lt;span style=&quot;color: red; border: 1px solid orangered;&quot;&gt;测试文字&lt;/span&gt;&#x27;)         $(&quot;#d1&quot;).before(span1);    &#125;    function fun4()&#123;        var span1=$(&#x27;&lt;span style=&quot;color: red; border: 1px solid orangered;&quot;&gt;测试文字&lt;/span&gt;&#x27;)         span1.insertBefore($(&quot;#d1&quot;));    &#125;        //after()    function fun5()&#123;        var span1=$(&#x27;&lt;span style=&quot;color: red; border: 1px solid orangered;&quot;&gt;测试文字&lt;/span&gt;&#x27;)         $(&quot;#d1&quot;).after(span1);    &#125;    function fun6()&#123;        var span1=$(&#x27;&lt;span style=&quot;color: red; border: 1px solid orangered;&quot;&gt;测试文字&lt;/span&gt;&#x27;)         span1.insertAfter($(&quot;#d1&quot;));    &#125;        //empty()    function fun7()&#123;        $(&quot;#d1&quot;).empty()    &#125;        //remove()    function fun8()&#123;        $(&quot;#d1&quot;).remove(); // 移除当前元素本身    &#125;&lt;/script&gt;
操作事件
无非就是绑定事件,触发事件,解绑定事件.原生js中的通过DOM编程和在标签上的事件属性绑定事件,
jQuery中,我们可以使用
事件的绑定:

==bind()==
==live()==(1.8及之前可用)
==on()==(1.9之后推荐使用),==one()==

事件解绑定:==unbind()==
事件的触发:行为触发, jQuery方法触发
&lt;script&gt;    //给元素绑定事件    function fun1()&#123;        //原生JS        /*var div1=document.getElementById(&quot;d1&quot;)                div1.onmouseover=function ()&#123;                	alert(&quot;悬停&quot;)                &#125;*/        /* bind 方法绑定事件                * 在jQuery中,事件的名称= 原始名称去掉 on                * onclick       click                * onmouseover   mouseover                *                 * */        $(&quot;#d1&quot;).bind(&#x27;mouseover&#x27;,function()&#123;            $(&#x27;#d1&#x27;).css(&quot;background-color&quot;,&#x27;yellow&#x27;)        &#125;);        /*事件名作为方法*/        $(&quot;#d1&quot;).mouseleave(function()&#123;            $(&#x27;#d1&#x27;).css(&quot;background-color&quot;,&#x27;lightgreen&#x27;)        &#125;);        /*                 * one 绑定事件一次                  *                  * */        /*$(&quot;#d1&quot;).one(&#x27;mouseover&#x27;,function()&#123;                	$(&#x27;#d1&#x27;).css(&quot;background-color&quot;,&#x27;yellow&#x27;)                &#125;);                 $(&quot;#d1&quot;).one(&#x27;mouseleave&#x27;,function()&#123;                	$(&#x27;#d1&#x27;).css(&quot;background-color&quot;,&#x27;lightgreen&#x27;)                &#125;);*/    &#125;    //解除绑定    function fun2()&#123;        //$(&quot;#d1&quot;).unbind();  解除绑定的所有事件        $(&quot;#d1&quot;).unbind(&quot;mouseover&quot;) // 接触绑定的指定事件    &#125;    //触发事件    function fun3()&#123;        // 相当于发生了获得焦点事件        $(&quot;#i1&quot;).focus()    &#125;    function fun4()&#123;        console.log(&quot;获得焦点了&quot;)    &#125;&lt;/script&gt;
jQuery对象和DOM对象的转换
使用原生JS方式获得的页面结点对象我们可以简称为DOM对象,使用jQuery核心函数获得的对象我们可以简称为jQuery对象,这两种方式获得的对象即是是页面上同一个元素,那么也是不一样的,二者之间的API是不通用的.而在某些情况下,我们往往无法选择接收的对象,只能被动使用,那么这个时候我们可以让二者实现转换,以达到可以调用API实现功能的目的
使用原生JSDOM对象转换成jQuery对象方式是==$(dom对象)==
jQuery对象转换成DOM对象的方式是==jQuery对象[0]/.get(0)==，
&lt;script&gt;    $(function()&#123;        //1 原生JS获取页面元素  原生DOM对象        var div1=document.getElementById(&quot;d1&quot;);        //2 jQuery方式获取页面元素 jQuery对象        var div2=$(&quot;#d1&quot;);        /*				 * DOM对象和jQuery对象之间的方法和属性是不通用的				 *  				 * */        console.log(div1.innerText);        console.log(div2.text());        console.log(div1)        console.log(div2)        // DOM对象如何调用jQuery函数  DOM对象转换为jQuery    $(DOM)        console.log($(div1).text());        // jQuery对象如何调用DOM对象的属性和方法   jQuery转换为DOM对象  get(0)  [0]        console.log(div2.get(0).innerText)        console.log(div2[0].innerText)    &#125;)&lt;/script&gt;
迭代遍历方式
jQuery给我们封装了一个快捷遍历元素的方法,接下来我们就使用一下jQuery中新的遍历方式
&lt;script&gt;    $(function()&#123;        /*         		 * jQuery对象名往往以$开始, 以示和DOM对象区分         		 *          		 *          		 * */        var $lis =$(&quot;li&quot;);        console.log($lis)        for(var i =0;i&lt;$lis.length;i++)&#123;            console.log($lis.get(i))        &#125;        /*         		 * jQuery提供了一个each方法帮助我们遍历元素         		 * */        $lis.each(function(i,e)&#123;            /*         			 * e是一个原生DOM对象,所以用的是text()方法来提取文本         			 * */            console.log(i+&quot;&gt;&quot;+$(e).text())        &#125;);        $.each($lis,function(i,e)&#123;            /*         			 * e是一个原生DOM对象         			 * */            console.log(i+&quot;&gt;&quot;+$(e).text())        &#125;);    &#125;)&lt;/script&gt;
动画效果
显示和隐藏

==show()== :实现简单显示动画效果方法
==hide()== :实现简单隐藏动画效果方法
==toggle()== :实现切换简单显示和隐藏动画效果方法

&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            #d1&#123;                width: 200px;                height: 200px;                background-color: yellow;                display: none;            &#125;        &lt;/style&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;            function fun1()&#123;                /*$(&quot;#d1&quot;).show(2000,&#x27;swing&#x27;,function()&#123;                                        alert(&quot;动画执行结束&quot;)                                &#125;)*/                $(&quot;#d1&quot;).show(2000);            &#125;            function fun2()&#123;                $(&quot;#d1&quot;).hide(3000)            &#125;            function fun3()&#123;                $(&quot;#d1&quot;).toggle(5000);//            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;d1&quot;&gt;&lt;/div&gt;        &lt;input type=&quot;button&quot; value=&quot;show&quot; onclick=&quot;fun1()&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;hide&quot; onclick=&quot;fun2()&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;toggle&quot; onclick=&quot;fun3()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt; 
滑动动画效果

==slideDown()==:实现向下滑动效果
==slideUp()==:实现向上滑动效果
==slideToggle()==:实现滑动切换动画效果

&lt;script&gt;    function fun1()&#123;        $(&quot;#d1&quot;).slideDown(2000);    &#125;    function fun2()&#123;        $(&quot;#d1&quot;).slideUp(3000)    &#125;    function fun3()&#123;        $(&quot;#d1&quot;).slideToggle(5000);//    &#125;&lt;/script&gt;
淡入淡出动画效果

==fadeln()==: 实现淡入动画效果
==fadeOut()==:实现淡出动画效果
==fadeToggle()==:实现淡入淡出切换效果
==fadeTo()==：实现淡入指定透明度效果方法

&lt;script&gt;    //淡入动画    function fun1()&#123;        $(&quot;#d1&quot;).fadeIn(2000);    &#125;    //淡出动画    function fun2()&#123;        $(&quot;#d1&quot;).fadeOut(3000)    &#125;    //淡入淡出切换    function fun3()&#123;        $(&quot;#d1&quot;).fadeToggle(5000);    &#125;    //淡入指定透明度效果    function fun4()&#123;        $(&quot;#d1&quot;).fadeTo(5000,0.2);// 0-1     &#125;&lt;/script&gt;
实现自定义动画效果
==$(“”).animate({动画内容},执行时间,动画结束后要执行的方法)==
&lt;script&gt;    $(function()&#123;        //$(&quot;&quot;).animate(&#123;动画内容&#125;,执行时间,动画结束后要执行的方法)        $(&quot;#d1&quot;).animate(&#123;            width:&quot;100px&quot;,            height:&quot;100px&quot;,            opcity:0.5,            borderRadius:&quot;50px&quot;        &#125;,2000,function()&#123;            alert(&quot;动画执行结束了&quot;)        &#125;)    &#125;)&lt;/script&gt;

表单检验
表单验证案例
验证要求
用户名不能为空
用户名长度大于等于6
用户名中不能有数字
密码不少于5位
两次密码必须一致
邮箱格式正确 必须有@和.  例如123456789@qq.com
实现效果

代码
代码改进
总结
1.对于表单的提交，要给form标签绑定onSubmit事件，而不是给submit按钮绑定onClick事件,onsubmit绑定的方法时要有return关键字,绑定的方法要返回true/false
1.对于表单的提交，要给form标签绑定onSubmit事件，而不是给submit按钮绑定onClick事件,onsubmit绑定的方法时要有return关键字,绑定的方法要返回true/false
2.表单项内容不管输入的是字符串、数字、日期，js、jQuery、JSP接收后都是String类型
3.表单的验证和String对象有密切关系 length charAt(i) indexOf(“@”)
4.如果表单项内容为空，js收到的不是null，而是空字符串。判断条件不能写 username == null，而要写username==&quot;&quot;或username.length ==0
5.验证出错要return false，验证无错要return true，并且 onsubmit=&quot;return checkForm()
6.该示例的缺点主要在于对于邮箱如果采用传统方式进行验证，代码繁琐并且不能保证严谨性,过度依赖String的API。对于邮箱、手机号码、邮政编码等验证，可以使用正则表达式进行验证，严谨而且简单。
正则表达式
1. 什么是正则表达式
Regular Expression，在代码中常简写为regex,正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。
2. 为什么使用正则表达式

正则表达式可以是文本的校验的代码更加简洁
正则表达式可以实现更加严谨细致的校验

3. 正则表达式举例
匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}
匹配腾讯QQ号：[1-9][0-9]{4,}
匹配中国邮政编码：\d{6}
匹配身份证：\d{15}|\d{18}
匹配由数字和26个英文字母组成的字符串 ^[A-Za-z0-9]+$
匹配Email地址：\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*
匹配中文字符的正则表达式： [\u4e00-\u9fa5] [a-zA-Z]
4. JS创建正则表达式
正则表达式在JS中创建的语法为:
==var reg=/china/;==
==var reg=new RegExp(“china”);==
5. 通配符号

6. 重复符号

使用正则表达式实现数据验证
&lt;script&gt;    /*			 * 正则表达式不依赖jQuery			 * 正则表达式本身就是一个字符串 只不过该字符串用于表述一种规则			 * 			 * */    var reg =/^\w?$/    var words =&quot;a&quot;;    console.log(reg.test(words))    var regex1 = /^\d&#123;6&#125;$/;    var regex2 = /^1[3456789]\d&#123;9&#125;$/;    var regex3 = /^\w&#123;6,&#125;@[0-9A-Za-z]&#123;2,&#125;(\.[a-zA-Z]&#123;2,3&#125;)&#123;1,2&#125;$/;  &lt;/script&gt;
form表单应用正则
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;            function checkUsername()&#123;                var reg1=/^\D&#123;6,&#125;$/                var username =$(&quot;#user&quot;).val();                if(!reg1.test(username))&#123;                    $(&quot;#usertip&quot;).html(&quot;&lt;font color=&#x27;red&#x27;&gt;格式必须是至少六位的非数字&lt;/font&gt;&quot;);                    return false;                &#125;                // 提示OK                $(&quot;#usertip&quot;).html(&quot;&lt;font color=&#x27;green&#x27;&gt;OK&lt;/font&gt;&quot;)                return true;            &#125;            function checkPassword()&#123;                var reg2=/^\S&#123;5,&#125;$/                var pwd =$(&quot;#pwd&quot;).val();                if(!reg2.test(pwd))&#123;                    $(&quot;#pwdtip&quot;).html(&quot;&lt;font color=&#x27;red&#x27;&gt;至少为5位非空格&lt;/font&gt;&quot;);                    return false;                &#125;                $(&quot;#pwdtip&quot;).html(&quot;&lt;font color=&#x27;green&#x27;&gt;OK&lt;/font&gt;&quot;);                return true;            &#125;            function checkRepwd()&#123;                var p1=$(&quot;#pwd&quot;).val();                var p2=$(&quot;#repwd&quot;).val();                if(p1.length&lt; 5 || p1 != p2)&#123;                    $(&quot;#repwdtip&quot;).html(&quot;&lt;font color=&#x27;red&#x27;&gt;两次密码不一致&lt;/font&gt;&quot;);                    return false;                &#125;                $(&quot;#repwdtip&quot;).html(&quot;&lt;font color=&#x27;green&#x27;&gt;OK&lt;/font&gt;&quot;);                return true;            &#125;            function checkEmail()&#123;                var em=$(&quot;#email&quot;).val();                var regex3 = /^\w&#123;6,&#125;@[0-9A-Za-z]&#123;2,&#125;(\.[a-zA-Z]&#123;2,3&#125;)&#123;1,2&#125;$/;                 if(!regex3.test(em) )&#123;                    $(&quot;#emailtip&quot;).html(&quot;&lt;font color=&#x27;red&#x27;&gt;邮箱格式有误&lt;/font&gt;&quot;);                    return false;                &#125;                $(&quot;#emailtip&quot;).html(&quot;&lt;font color=&#x27;green&#x27;&gt;OK&lt;/font&gt;&quot;);                return true;            &#125;            function checkForm()&#123;                return checkUsername()&amp;&amp;checkPassword()&amp;&amp;checkRepwd()&amp;&amp;checkEmail();            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table id=&quot;center&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;            &lt;form action=&quot;http://www.baidu.com&quot; method=&quot;get&quot; onsubmit=&quot;return checkForm()&quot;&gt;                &lt;tr&gt;                    &lt;td&gt;您的姓名：&lt;/td&gt;                    &lt;td&gt;                        &lt;input id=&quot;user&quot; type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;/&gt;                        &lt;div id=&quot;usertip&quot; style=&quot;display: inline;&quot;&gt;&lt;/div&gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;输入密码：&lt;/td&gt;                    &lt;td&gt;                        &lt;input id=&quot;pwd&quot; name=&quot;pwd&quot; type=&quot;password&quot; onblur=&quot;checkPassword()&quot;/&gt;                        &lt;div id=&quot;pwdtip&quot; style=&quot;display: inline;&quot;&gt;&lt;/div&gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;再输入一遍密码：&lt;/td&gt;                    &lt;td&gt;                        &lt;input id=&quot;repwd&quot; type=&quot;password&quot; onblur=&quot;checkRepwd()&quot;/&gt;                        &lt;div id=&quot;repwdtip&quot; style=&quot;display: inline;&quot;&gt;&lt;/div&gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;您的Email：&lt;/td&gt;                    &lt;td&gt;                        &lt;input id=&quot;email&quot; type=&quot;text&quot; onblur=&quot;checkEmail()&quot;/&gt;                        &lt;span id=&quot;emailtip&quot;&gt;&lt;/span&gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan=&quot;2&quot;&gt;                        &lt;input type=&quot;submit&quot; value=&quot;注册&quot; class=&quot;rb1&quot; /&gt;                    &lt;/td&gt;                &lt;/tr&gt;            &lt;/form&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;
BootStrap
容器类
==.container== 类用于固定宽度并支持响应式布局的容器。
==.container-fluid== 类用于 100% 宽度，占据全部视口（viewport）的容器。
二者区别:
固定容器的响应式布局规则是当窗口大小变化时,在指定的宽度范围内使用固定的宽度,
流容器的响应式布局规则是随着窗口大小的变化一同变化,横向全部占满
固定容器的阈值如下图:

栅格系统
Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。我们也可以根据自己的需要定义列数.
网格类
Bootstrap 4 网格系统有以下 5 个类:
==.col-== 针对所有设备
==.col-sm-== 平板 - 屏幕宽度等于或大于 576px
==.col-md-== 桌面显示器 - 屏幕宽度等于或大于 768px)
==.col-lg-== 大桌面显示器 - 屏幕宽度等于或大于 992px)
==.col-xl-== 超大桌面显示器 - 屏幕宽度等于或大于 1200px)
网格系统规则
1 网格每一行需要放在设置了 .container (固定宽度) 或 .container-fluid (全屏宽度) 类的容器中，这样就可以自动设置一些外边距与内边距。
2 使用行来创建水平的列组class=row。
3 内容需要放置在列中，并且只有列可以是行的直接子节点。
4 预定义的类如 .row 和 .col-sm-4 可用于快速制作网格布局。
5 列通过填充创建列内容之间的间隙。 这个间隙是通过 .rows 类上的负边距设置第一行和最后一列的偏移。
6 网格列是通过跨越指定的 12 个列来创建。 例如，设置三个相等的列，需要使用三个.col-sm-4 来设置。
7  Bootstrap 3 和 Bootstrap 4 最大的区别在于 Bootstrap 4 现在使用 flexbox（弹性盒子） 而不是浮动。 Flexbox 的一大优势是，没有指定宽度的网格列将自动设置为等宽与等高列 。 如果您想了解有关Flexbox的更多信息，可以阅读我们的CSS Flexbox教程。

&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!--移动端优先的配置--&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;        &lt;!--bootstrap的样式库--&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; &gt;        &lt;!--jQuery--&gt;        &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;        &lt;!--popper--&gt;        &lt;script src=&quot;js/bootstrap.bundle.min.js&quot; &gt;&lt;/script&gt;        &lt;!--核心js文件--&gt;        &lt;script src=&quot;js/bootstrap.min.js&quot; &gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;container&quot;&gt;            &lt;div class=&quot;row&quot;&gt;                &lt;div class=&quot;col-sm-2&quot; style=&quot;background-color: lavender;border:1px solid #117A8B;&quot;&gt;                    One of three columns                &lt;/div&gt;                &lt;div class=&quot;col-sm-8&quot; style=&quot;background-color: lavender;border:1px solid #117A8B;&quot;&gt;                    One of three columns                &lt;/div&gt;                &lt;div class=&quot;col-sm-2&quot; style=&quot;background-color: lavender;border:1px solid #117A8B;&quot;&gt;                    One of three columns                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;row&quot;&gt;                &lt;div class=&quot;col-sm-1&quot; style=&quot;background-color: lavender;border:1px solid #117A8B;&quot;&gt;                    One of three columns                &lt;/div&gt;                &lt;div class=&quot;col-sm-4&quot; style=&quot;background-color: lavender;border:1px solid #117A8B;&quot;&gt;                    One of three columns                &lt;/div&gt;                &lt;div class=&quot;col-sm-7&quot; style=&quot;background-color: lavender;border:1px solid #117A8B;&quot;&gt;                    One of three columns                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
导航栏案例

&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!--移动端优先的配置--&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;        &lt;!--bootstrap的样式库--&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; &gt;        &lt;!--jQuery--&gt;        &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;        &lt;!--popper--&gt;        &lt;script src=&quot;js/bootstrap.bundle.min.js&quot; &gt;&lt;/script&gt;        &lt;!--核心js文件--&gt;        &lt;script src=&quot;js/bootstrap.min.js&quot; &gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;container&quot;&gt;            &lt;h2&gt;欢迎进入马士兵教育&lt;/h2&gt;            &lt;br&gt;            &lt;!-- Nav pills --&gt;            &lt;ul class=&quot;nav nav-pills&quot; role=&quot;tablist&quot;&gt;                &lt;li class=&quot;nav-item&quot;&gt;                    &lt;a class=&quot;nav-link active&quot; data-toggle=&quot;pill&quot; href=&quot;#home&quot;&gt;主页&lt;/a&gt;                &lt;/li&gt;                &lt;li class=&quot;nav-item&quot;&gt;                    &lt;a class=&quot;nav-link&quot; data-toggle=&quot;pill&quot; href=&quot;#menu1&quot;&gt;讲师介绍&lt;/a&gt;                &lt;/li&gt;                &lt;li class=&quot;nav-item&quot;&gt;                    &lt;a class=&quot;nav-link&quot; data-toggle=&quot;pill&quot; href=&quot;#menu2&quot;&gt;课程介绍&lt;/a&gt;                &lt;/li&gt;                &lt;li class=&quot;nav-item&quot;&gt;                    &lt;a class=&quot;nav-link&quot; data-toggle=&quot;pill&quot; href=&quot;#menu3&quot;&gt;优秀学员&lt;/a&gt;                &lt;/li&gt;            &lt;/ul&gt;            &lt;!-- Tab panes --&gt;            &lt;div class=&quot;tab-content&quot;&gt;                &lt;div id=&quot;home&quot; class=&quot;container tab-pane active&quot; style=&quot;border: 10px solid red;&quot;&gt;&lt;br&gt;                    &lt;h3&gt;我们公司&lt;/h3&gt;                    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;/p&gt;                &lt;/div&gt;                &lt;div id=&quot;menu1&quot; class=&quot;container tab-pane fade&quot; style=&quot;border: 10px solid green;&quot;&gt;&lt;br&gt;                    &lt;h3&gt;我们的优秀讲师&lt;/h3&gt;                    &lt;p&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.&lt;/p&gt;                &lt;/div&gt;                &lt;div id=&quot;menu2&quot; class=&quot;container tab-pane fade&quot; style=&quot;border: 10px solid yellow;&quot;&gt;&lt;br&gt;                    &lt;h3&gt;我们的课程&lt;/h3&gt;                    &lt;p&gt;Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam.&lt;/p&gt;                &lt;/div&gt;                &lt;div id=&quot;menu3&quot; class=&quot;container tab-pane fade&quot; style=&quot;border: 10px solid blueviolet;&quot;&gt;&lt;br&gt;                    &lt;h3&gt;优秀学员&lt;/h3&gt;                    &lt;p&gt;Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam.&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
轮播图案例
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!--移动端优先的配置--&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;        &lt;!--bootstrap的样式库--&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot; &gt;        &lt;!--jQuery--&gt;        &lt;script src=&quot;js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;        &lt;!--popper--&gt;        &lt;script src=&quot;js/bootstrap.bundle.min.js&quot; &gt;&lt;/script&gt;        &lt;!--核心js文件--&gt;        &lt;script src=&quot;js/bootstrap.min.js&quot; &gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;carouselExampleCaptions&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;            &lt;ol class=&quot;carousel-indicators&quot;&gt;                &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;                &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;                &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;                &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;3&quot;&gt;&lt;/li&gt;            &lt;/ol&gt;            &lt;div class=&quot;carousel-inner&quot;&gt;                &lt;div class=&quot;carousel-item active&quot;&gt;                    &lt;img src=&quot;https://static.runoob.com/images/mix/img_fjords_wide.jpg&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt;                    &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt;                        &lt;h5&gt;江河&lt;/h5&gt;                        &lt;p&gt;Nulla vitae elit libero, a pharetra augue mollis interdum.&lt;/p&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;carousel-item&quot;&gt;                    &lt;img src=&quot;https://static.runoob.com/images/mix/img_nature_wide.jpg&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt;                    &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt;                        &lt;h5&gt;山川&lt;/h5&gt;                        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;carousel-item&quot;&gt;                    &lt;img src=&quot;https://static.runoob.com/images/mix/img_mountains_wide.jpg&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt;                    &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt;                        &lt;h5&gt;公路&lt;/h5&gt;                        &lt;p&gt;Praesent commodo cursus magna, vel scelerisque nisl consectetur.&lt;/p&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;carousel-item&quot;&gt;                    &lt;img src=&quot;https://www.12306.cn/index/images/pic/banner0619.jpg&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt;                    &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt;                        &lt;h5&gt;火车&lt;/h5&gt;                        &lt;p&gt;Praesent commodo cursus magna, vel scelerisque nisl consectetur.&lt;/p&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;a class=&quot;carousel-control-prev&quot; href=&quot;#carouselExampleCaptions&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;                &lt;span class=&quot;carousel-control-prev-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;            &lt;/a&gt;            &lt;a class=&quot;carousel-control-next&quot; href=&quot;#carouselExampleCaptions&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;                &lt;span class=&quot;carousel-control-next-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;            &lt;/a&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>JS</title>
    <url>/2021/06/16/JS/</url>
    <content><![CDATA[概念
JS是运行在浏览器上的一种脚本语言

特点
1.脚本语言
脚本语言是一种简单的程序，规模小,不需要编译,运行快,是由一些ASCII字符构成，可以使用任何一种文本编辑器编写。脚本语言是指在web浏览器内有解释器解释执行的编程语言，每次运行程序的时候，解释器会把程序代码翻译成可执行的格式。一些程序语言（如C、C++、Java等）都必须经过编译，将源代码编译成二进制的可执行文件之后才能运行，而脚本语言不需要事先编译，只要有一个与其相适应的解释器就可以执行。
2.基于对象的语言
面向对象有三大特点（封装，继承，多态）缺一不可。通常&quot;基于对象&quot;是使用对象，但是无法利用现有的对象模板产生新的对象类型，也就是说&quot;基于对象&quot;没有继承的特点。没有了继承的概念也就无从谈论&quot;多态&quot;
3.事件驱动
在网页中执行了某种操作的动作，被称为&quot;事件&quot;(Event)，比如按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会引起相应的事件响应。
4.简单性
变量类型是采用弱类型，并未使用严格的数据类型。var a,b,c;  a=123;  b=“abc”; a=b;
5.安全性
JavaScript不能访问本地的硬盘，不能将数据存入到服务器上，不能对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互
6.跨平台性
JavaScript依赖于浏览器本身，与操作平台无关， 只要计算机安装了支持JavaScript的浏览器（装有JavaScript解释器），JavaScript程序就可以正确执行。
缺点
各种浏览器支持JavaScript的程度是不一样的，支持和不完全支持JavaScript的 浏览器在浏览同一个带有JavaScript脚本的网页时，效果会有一定的差距，有时甚至会显示不出来。
JS 和 java的区别
区别1：公司不同，前身不同
JavaScript是Netscape公司的产品，是为了扩展Netscape Navigator功能而开发的一种可以嵌入Web页面中的基于对象和事件驱动的解释性语言，它的前身是Live Script；Java是SUN公司推出的新一代面向对象的程序设计语言，特别适合于Internet应用程序开发； Java的前身是Oak语言。
区别2：基于对象和面向对象
JavaScript是脚本语言，是一种基于对象的语言。本身提供了非常丰富的内部对象供设计人员使用，但不支持继承和多态。Java是面向对象的，是一种真正的面向对象的语言，支持封装、继承和多态。
区别3：变量类型强弱不同
Java采用强类型变量检查，即所有变量在编译之前必须声明为某一指定类型。如: int  x=1234;JavaScript中是弱类型变量。统一采用var声明，可赋各种数据类型值。
区别4: 运行的位置不同
Java运行与服务器端的,大型编程语言, JS运行于客户端(浏览器)一种小规模脚本语言
HTML和CSS和JS这之间的关系
HTML和CSS和JS都是前端的主要技术,三者各有分工.HTML可以用于制作网页的主体结构,CSS用于给网页做美化,JS用于在网页上添加动态效果
引入方式
1.内嵌式引入
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!--内嵌式引入方式1在head标签中，用一堆script标签嵌入JS--&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            /*定义一个函数（方法）*/            function fun1()&#123;                /*弹窗提示一点信息*/                alert(&quot;你好&quot;)            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;点我呀 &quot; onclick=&quot;fun1()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;
效果

2.链接式引入
将JS代码放入外部JS文件中,通过script标签引入，提高代码复用度，降低了代码维护的难度
1 一个页面可以同时引入多个不同的JS文件
2 script标签一点用于引入外部JS文件，就不能在中间定义内嵌式代码
3 一个页面上可以用多个script标签 位置也不是非得放到head标签中
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!--链接式 引入外部JS文件        		--&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/myjs.js&quot;&gt;        &lt;/script&gt;		    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;点我呀&quot; onclick=&quot;fun1()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;
3.URL网络路径
略
数据类型和运算符
JS是弱类型的脚本语言，不明显，所有的变量对象数据类型的声明都是用var
变量的声明和赋值
变量声明时不用确定具体的数据类型，在变量赋值时，确定变量的具体数据类型。
var i;i = 10;
1. 数据类型


数值型：
number整数和浮点数统称为数值。例如85或3.1415926等。


字符串型：
String由0个,1个或多个字符组成的序列。在JavaScript中，用双引号或单引号括起来表示，如&quot;您好&quot;、‘学习JavaScript’ 等。


逻辑（布尔）型：
boolean用true或false来表示。


空（null）值：
表示没有值，用于定义空的或不存在的引用。要注意，空值不等同于空字符串&quot;&quot;或0。


未定义（undefined）值：
它也是一个保留字。表示变量虽然已经声明，但却没有赋值。


除了以上五种基本的数据类型之外，JavaScript还支持复合数据类型Object，复合数据类型包括对象和数组两种。


JS中的变量可以反复声明，后声明的变量会覆盖原来的变量
var i = 10;var i = 20;alert(i)
typeof 查看变量类型
var i = 20;alert(typeof i);
当给一个变量赋值为null时，变量的类型就是object
var i ;/*默认为null*/var i = nullalert(typeof i);/*Object*/
JS标识符的命名规则与java保持一致即可，不要用$，避免与JQuery冲突
2.运算符

    

/ 和 %
/* * 能除尽,则默认结果就是一个整数,不能除尽,结果默认就是浮点数* 除零不会出现异常,而是出现 Infinity* 和0取余数,出现NaN   not a number 不是一个数字* */    alert(10/3);    alert(10/0);    alert(10%3);    alert(10%0);
JS取余数运算对于浮点数仍然有效,如果和0取余数,结果是NaN(not a number)
+
同时也是连接运算符,看两端的变量类型,如果都是number那么就是算数中的加法 如果有字符串,那么就是连接符号,如果是布尔类型和number相加,那么会将true转化为1 将false 转化为0
/** +号中 如果一段是字符串,就变成了文字拼接* 数字和 boolean类型相加  true会转变成1  false会转变成0  再做数学运算* */    var i=1;    alert(i+1);    alert(1+&quot;1&quot;);    alert(1+true);
== (等值符)
先比较类型,如果类型一致,再比较内容,如果类型不一致,会强制转换为number再比较内容
/** == 等值符* 先比较类型,如果类型一致,则比较值是否相同* 如果类型不一致,会将数据尝试转换number 再比较内容* */    var a =1;    var b=&quot;1&quot;;    var c=true;    var d=&quot;true&quot;;    alert(a==b)// t    alert(a==c)// t    alert(a==d)// f    alert(b==c)// t    alert(b==d)// f    alert(c==d)// f
===( 等同符)
数据类型不同 直接返回false如果类型相同 才会比较内容
/** === 等同符* 如果数据类型不同,直接返回false  如果类型相同,才会继续比较内容* * */    var a =1;    var b=&quot;1&quot;;    var c=true;    var d=&quot;true&quot;;    alert(a===b)//f    alert(a===c)//f    alert(a===d)//f    alert(b===c)//f    alert(b===d)//f    alert(c===d)//f    alert(&quot;asdf&quot;===&quot;asdf&quot;)//t
流程控制
分支结构
&lt;!DOCTYPE html&gt;&lt;html&gt;        &lt;head&gt;                &lt;meta charset=&quot;UTF-8&quot;&gt;                &lt;title&gt;&lt;/title&gt;                &lt;script&gt;                        /*                         * 定义变量表示月份                         * 根据月份输出该月的季节和应季活动                         * */                        var i=10;                        if(i ==12 || i ==1 || i==2)&#123;                                alert(&quot;大约在冬季: 冬天吃火锅&quot;);                        &#125;else if(i &gt;= 3 &amp;&amp; i&lt;=5 )&#123;                                alert(&quot;春天来了: 春天吃青菜&quot;);                        &#125;else if(i &gt;= 6 &amp;&amp; i &lt;= 8)&#123;                                alert(&quot;夏天到了: 吃烧烤喝啤酒&quot;);                        &#125;else if(i &gt;= 9 &amp;&amp; i &lt;=11)&#123;                                alert(&quot;秋天到了: 贴秋膘&quot;);                        &#125;else&#123;                                alert(&quot;月份有误&quot;)                        &#125;                        switch(i)&#123;                                case 3:                                case 4:                                case 5:                                        alert(&quot;春眠不觉晓&quot;);                                        break;                                case 6:                                case 7:                                case 8:                                        alert(&quot;夏天蚊子咬&quot;);                                        break;                                case 9:                                case 10:                                case 11:                                        alert(&quot;秋天一身包&quot;);                                        break;                                case 1:                                case 2:                                case 12:                                        alert(&quot;冬天蚊子死翘翘&quot;);                                        break;                                default:                                        alert(&quot;月份有误&quot;)                        &#125;                &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;/body&gt;&lt;/html&gt;
循环结构
var i=1;      while(i&lt;=10)&#123;              alert(i)              i++;      &#125;      /*       * 考试,直到分数过线为止       * 求1-10整数和 1+10*(10/2) */      var sum=0;      var j=1;      do&#123;              sum+=j;              j++;      &#125;while(j&lt;=10);      alert(sum)      var sum2=0;      for(var z=1;z&lt;=10;z++)&#123;              sum2+=z;      &#125;      alert(sum2)
九九乘法表
for(var i =1;i&lt;=9;i++)&#123;      for(var j=1;j&lt;=i;j++)&#123;          document.write(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;)      &#125;      document.write(&quot;&lt;br/&gt;&quot;)  &#125;
效果

函数
​		类似于java中的方法,JS中也可以定义一些函数,java中的方法签名包含访问修饰符,返回值类型,方法名,参数列表,异常列表,但是JS中定义函数的语法相对简单很多,主要以function作为函数关键字,具备函数名和参数列表,但是没有访问修饰符也没有返回值类型关键字和异常列表。
三种语法


function 函数名(参数列表){js代码}
function fun1()&#123;       alert(&quot;你好&quot;);&#125;


var 函数名=function(参数列表){JS代码}
var fun2=function()&#123;       alert(&quot;你很好&quot;)&#125;


var 函数名=new Function(‘js代码’)
var fun3=new Function(&#x27;alert(&quot;你非常好&quot;);&#x27;);


调用方法
// 调用方法fun1();fun2();fun3();
函数参数和返回值
1.传入的实参可以和形参个数不同
function fun1(a,b,c)&#123;				alert(&quot;a:&quot;+a)				alert(&quot;b:&quot;+b)				alert(&quot;c:&quot;+c)&#125;fun1(10,&quot;hello js&quot;,false);// 少传参数 OKfun1(1,2);// 多传参数 OK 多出来的参数相当于没传fun1(10,&quot;hello js&quot;,false,new Date());														&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;	&lt;/body&gt;&lt;/html&gt;
2.函数如果有返回值，直接return即可
function fun2(a,b)&#123;                var c=a*b;                return c;&#125;var x =fun2(10,20);alert(x)
3.可以将方法作为参数传进去
// 方法本身作为参数(了解)function funa( i ,j)&#123;		return i+j;&#125;function funb(a)&#123;		return a(10,20);&#125;var sum =funb(funa)alert(sum)
数组
1. 创建数组
/*第一种——创建空数组*/			var arr = new Array();			arr[0]=1;			console.log(arr);/*第二种——创建定长数组*/			var arr2= new Array(5);			arr2[0]=&quot;x&quot;;			arr2[4]=true;			console.log(arr2);/*第三种——创建时直接指定元素值*/			var arr3=new Array(&#x27;aaa&#x27;,10,20.3,true);			console.log(arr3)/*第四种——相当于第三种语法的简写*/			var arr3=[&#x27;aaa&#x27;,10,20.3,true];			console.log(arr3)
2. 数组元素和长度

可以通过修改length属性来改变数组长度

var arr=[11,22,33];arr.length=5;console.log(arr)


可以通过索引改变数组长度

arr[9]=99;	console.log(arr);

3. 数组遍历

普通for循环

for(var i=0;i&lt;arr.length;i++)&#123;                                console.log(arr[i])&#125;

foreach循环遍历数组

/** JS 中foreach写法为  for( var i in 数组)* i 不是元素  是索引* */for (var i in arr)&#123;    console.log(arr[i])&#125;
4.数组常用方法


查询元素索引
  


concat()
合并两个数组
var arr2 = [3,3,6,7];var arr3 = [4,6,7,8];var arr4 = arr2.concat(arr3);console.log(arr4);

合并三个数组
var arr5 = [3,3,6,7];var arr6 = [4,6,7,8];var arr7 = [4,6,7,8];var arr8 = arr5.concat(arr6,arr7);console.log(arr8);



join():合并字符串
var fruits=[&#x27;Banana&#x27;,&#x27;Orange&#x27;,&#x27;Apple&#x27;,&#x27;Mango&#x27;]var fs = fruits.join();console.log(fs);



pop():移除最后一个元素
var fruit = fruits.pop();



push():想结尾增加元素
fruits.push(&quot;Grape&quot;);



reverse():反转数组
fruits.reverse();



shift():删除数组第一个元素
var ss = fruits.shift();console.log(fruits);console.log(ss);



unshift():向第一个位置添加元素
fruits.unshift(&quot;火龙果&quot;);



slice():截取子数组
var citrus =fruits.slice(1,3);console.log(citrus)



splice()
删除数组中的某些元素 （传入索引和删除元素的个数
var num=[1,2,3,4,5,6,7,8];num.splice(2,3);console.log(num);

如果第二个参数为0，则变为在指定索引位置增加元素
num.splice(2,0,100);console.log(num);



sort(): 排序
//按照字母升序排列var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort();console.log(fruits)//数字的排序：var numbers=[5,7,9,6,1,8,3,4,2];//a-b 升序 b-a 降序numbers.sort(function(a,b)&#123;return b-a&#125;);console.log(numbers)


JS对象
JavaS0cript 中的所有事物都是对象：字符串、数值、数组、函数…   此外，JavaScript 允许自定义对象
JS基于对象的脚本语言 ,有类和对象,但是没有封装,继承,多态,Java script 中有一些浏览器直接识别并使用的对象,常见的对象有Array（前面的数组也是一个对象）,String对象,Math对象,Number对象,Date对象等等.
常用对象
String
属性



属性
描述




constructor
对创建该对象的函数的引用


length
字符串的长度


prototype
允许您向对象添加属性和方法



方法



方法
描述




charAt()
返回在指定位置的字符。


charCodeAt()
返回在指定的位置的字符的 Unicode 编码。


concat()
连接两个或更多字符串，并返回新的字符串。


fromCharCode()
将 Unicode 编码转为字符。


indexOf()
返回某个指定的字符串值在字符串中首次出现的位置。


includes()
查找字符串中是否包含指定的子字符串。


lastIndexOf()
从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。


match()
查找找到一个或多个正则表达式的匹配。


 repeat()
复制字符串指定次数，并将它们连接在一起返回。


replace()
在字符串中查找匹配的子串，并替换与正则表达式匹配的子串。


replaceAll()
在字符串中查找匹配的子串，并替换与正则表达式匹配的所有子串。


search()
查找与正则表达式相匹配的值。


slice()
提取字符串的片断，并在新的字符串中返回被提取的部分。


split()
把字符串分割为字符串数组。


startsWith()
查看字符串是否以指定的子字符串开头。


substr()
从起始索引号提取字符串中指定数目的字符。


substring()
提取字符串中两个指定的索引号之间的字符。


toLowerCase()
把字符串转换为小写。


toUpperCase()
把字符串转换为大写。


trim()
去除字符串两边的空白


 toLocaleLowerCase()
根据本地主机的语言环境把字符串转换为小写。


 toLocaleUpperCase()
根据本地主机的语言环境把字符串转换为大写。


valueOf()
返回某个字符串对象的原始值。


 toString()
返回一个字符串。





charAt()根据索引获取字符
var str =&quot;hello js&quot;;var c =str.charAt(6);console.log(c);



concat()：拼接字符串
var a = &quot;hi&quot;var b = &quot;good&quot;var c = &quot;China&quot;var d = c.concat(a,b)



repeat():重复
var e = &#x27;absf&#x27;var f = e.repeat(3)console.log(f)



substr() substring():截取字符串

从m开始截取n个字符

var g = &quot;hello&quot;var h = g.substr(1,5);console.log(h)

从m开始从n结束:包头不包尾

var i = g.substring(1,7);console.log(i)



length 属性：获取长度
console.log(g.length)



可以将字符串内容解析成JS代码并运行
var testStr=&quot;var x=10&quot;eval(testStr)console.log(x)



Number
属性



属性
描述




constructor
返回对创建此对象的 Number 函数的引用。


MAX_VALUE
可表示的最大的数。


MIN_VALUE
可表示的最小的数。


NEGATIVE_INFINITY
负无穷大，溢出时返回该值。


NaN
非数字值。


POSITIVE_INFINITY
正无穷大，溢出时返回该值。


prototype
允许您可以向对象添加属性和方法。



console.log(Number.MAX_VALUE)//最大值console.log(Number.MIN_VALUE)//最小值console.log(Number.MAX_SAFE_INTEGER)//负无穷console.log(Number.MIN_SAFE_INTEGER)
方法



方法
描述




 isFinite 
检测指定参数是否为无穷大。


toExponential(x)
把对象的值转换为指数计数法。


toFixed(x)
把数字转换为字符串，结果的小数点后有指定位数的数字。


toPrecision(x)
把数字格式化为指定的长度。


toString()
把数字转换为字符串，使用指定的基数。


valueOf()
返回一个 Number 对象的基本数字值。





parseFloat():将字符串转换成浮点数
console.log(Number.parseFloat(&quot;10.123&quot;)+20);



parseInt():将字符串转换成整型数字
console.log(Number.parseInt(&quot;30&quot;)+20);


相关判断方法：
var i = 10%0;var j = 10/0;console.log(i)console.log(j)// is not a number 是不是NANconsole.log(Number.isNAN(i))//true//isFinite()：判断数字是不是无限console.log(Number.isFinite(j))//false//isSafeInteger()：判断数字是不是一个安全的范围的方法console.log(Number.isSafeInteger(Number.MAX_VALUE))//falseconsole.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER))//false


Math
其他详情 https://www.runoob.com/jsref/jsref-obj-math.html


常用方法和属性
console.log(Math.round(3.64))console.log(Math.floor(3.14))// 向上取整console.log(Math.ceil(3.01))// 向下取整console.log(Math.max(1,2,3,5.6))//最大值console.log(Math.min(1,2,3,5.6))//最小值console.log(Math.random())//随机数console.log(Math.sqrt(16))//开平方// 属性PIconsole.log(Math.PI)


生成给定范围内的随机数
var start =10;var end =16;var result =Math.floor(Math.random()*(end-start+1)+start);console.log(result)


Date
Date对象用于处理日期和时间

创建Date对象的四种方法

var d = new Date();var d = new Date(milliseconds);var d = new Date(dateString);var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);
属性



属性
描述




constructor
返回对创建此对象的 Date 函数的引用。


prototype
使您有能力向对象添加属性和方法。



方法



方法
描述




getDate()
从 Date 对象返回一个月中的某一天 (1 ~ 31)。


getDay()
从 Date 对象返回一周中的某一天 (0 ~ 6)。


getFullYear()
从 Date 对象以四位数字返回年份。


getHours()
返回 Date 对象的小时 (0 ~ 23)。


getMilliseconds()
返回 Date 对象的毫秒(0 ~ 999)。


getMinutes()
返回 Date 对象的分钟 (0 ~ 59)。


getMonth()
从 Date 对象返回月份 (0 ~ 11)。


getSeconds()
返回 Date 对象的秒数 (0 ~ 59)。


getTime()
返回 1970 年 1 月 1 日至今的毫秒数。


getTimezoneOffset()
返回本地时间与格林威治标准时间 (GMT) 的分钟差。


getUTCDate()
根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。


getUTCDay()
根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。


getUTCFullYear()
根据世界时从 Date 对象返回四位数的年份。


getUTCHours()
根据世界时返回 Date 对象的小时 (0 ~ 23)。


getUTCMilliseconds()
根据世界时返回 Date 对象的毫秒(0 ~ 999)。


getUTCMinutes()
根据世界时返回 Date 对象的分钟 (0 ~ 59)。


getUTCMonth()
根据世界时从 Date 对象返回月份 (0 ~ 11)。


getUTCSeconds()
根据世界时返回 Date 对象的秒钟 (0 ~ 59)。


getYear()
已废弃。 请使用 getFullYear() 方法代替。


parse()
返回1970年1月1日午夜到指定日期（字符串）的毫秒数。


setDate()
设置 Date 对象中月的某一天 (1 ~ 31)。


setFullYear()
设置 Date 对象中的年份（四位数字）。


setHours()
设置 Date 对象中的小时 (0 ~ 23)。


setMilliseconds()
设置 Date 对象中的毫秒 (0 ~ 999)。


setMinutes()
设置 Date 对象中的分钟 (0 ~ 59)。


setMonth()
设置 Date 对象中月份 (0 ~ 11)。


setSeconds()
设置 Date 对象中的秒钟 (0 ~ 59)。


setTime()
setTime() 方法以毫秒设置 Date 对象。


setUTCDate()
根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。


setUTCFullYear()
根据世界时设置 Date 对象中的年份（四位数字）。


setUTCHours()
根据世界时设置 Date 对象中的小时 (0 ~ 23)。


setUTCMilliseconds()
根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。


setUTCMinutes()
根据世界时设置 Date 对象中的分钟 (0 ~ 59)。


setUTCMonth()
根据世界时设置 Date 对象中的月份 (0 ~ 11)。


setUTCSeconds()
setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。


setYear()
已废弃。请使用 setFullYear() 方法代替。


toDateString()
把 Date 对象的日期部分转换为字符串。


toGMTString()
已废弃。请使用 toUTCString() 方法代替。


toISOString()
使用 ISO 标准返回字符串的日期格式。


toJSON()
以 JSON 数据格式返回日期字符串。


toLocaleDateString()
根据本地时间格式，把 Date 对象的日期部分转换为字符串。


toLocaleTimeString()
根据本地时间格式，把 Date 对象的时间部分转换为字符串。


toLocaleString()
根据本地时间格式，把 Date 对象转换为字符串。


toString()
把 Date 对象转换为字符串。


toTimeString()
把 Date 对象的时间部分转换为字符串。


toUTCString()
根据世界时，把 Date 对象转换为字符串。 实例： var today = new Date(); var UTCstring = today.toUTCString();


UTC()
根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。


valueOf()
返回 Date 对象的原始值。






创建Date对象：
/** 在程序中 西方的月份编号从0开始* 1 2 3 4 5 6 * 0 1 2 3 4 5* */var today = new Date()var d1 = new Date(&quot;October 13, 1975 11:13:00&quot;)var d2 = new Date(79,5,24)var d3 = new Date(79,5,24,11,33,0)console.log(d1);console.log(d2);console.log(d3);



获得Date对象属性
var d4 = new Date(2048,0,13,16,51,20,123)console.log(d4)console.log(d4.getYear())//和1900的年份差console.log(d4.getFullYear())//完整的年份console.log(d4.getMonth())console.log(d4.getDate())console.log(d4.getHours())console.log(d4.getMinutes())console.log(d4.getMilliseconds())//毫秒



判断日期大小
var d5 = new Date(2048,0,13,16,51,20,456)console.log(d4&lt;d5)



自定义日期格式
format格式化方法可以放在js文件中，不用重复复制
/*date对象的格式化方法*//*修改Date原型,添加一个format格式化的方法*/Date.prototype.format = function(fmt)&#123;    var o = &#123;        &quot;M+&quot; : this.getMonth()+1,                 //月份        &quot;d+&quot; : this.getDate(),                    //日        &quot;h+&quot; : this.getHours(),                   //小时        &quot;m+&quot; : this.getMinutes(),                 //分        &quot;s+&quot; : this.getSeconds(),                 //秒        &quot;q+&quot; : Math.floor((this.getMonth()+3)/3), //季度        &quot;S&quot;  : this.getMilliseconds()             //毫秒    &#125;;    if(/(y+)/.test(fmt))&#123;        fmt=fmt.replace(RegExp.$1, (this.getFullYear()+&quot;&quot;).substr(4 - RegExp.$1.length));    &#125;    for(var k in o)&#123;        if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(fmt))&#123;            fmt = fmt.replace(                RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length)));          &#125;           &#125;    return fmt;&#125;var fmt=d4.format(&quot;yyyy-MM-dd hh:mm:ss&quot;);console.log(fmt)



自定义对象
JS除了一些常用方法和类以外,允许我们自己定义对象,在JS中自定义对象有三种可用的语法格式,分别为:
1. 调用系统的构造函数创建对象


实例化对象
/*实例化对象*/var obj = new Object();


给对象添加属性和方法
/*给对象添加属性*/obj.name=&quot;陈慧珊&quot;obj.sex=&quot;女&quot;obj.age=20;


查看对象属性
/*给对象添加属性*/obj.name=&quot;陈慧珊&quot;obj.sex=&quot;女&quot;obj.age=20;


调用对象方法
/*给对象添加方法*/obj.miss=function(ex)&#123;    console.log(this.name+&quot;一直都放不下&quot;+ex)&#125;


查看属性，调用方法
/*查看对象属性*/console.log(obj.name)console.log(obj.sex)console.log(obj.age)/*调用方法*/obj.miss(&quot;谭颖&quot;)



2. 自定义构造方法创建对象


准备一个构造方法：
可以声明属性还可以声明方法
function Person(name,sex)&#123;				this.name=name;				this.sex=sex;				this.miss=function(ex)&#123;					console.log(this.name+&quot;一直都放不下&quot;+ex)				&#125;			&#125;


调用构造方法创建对象
var obj = new Person(&quot;陈慧珊&quot;,&quot;女&quot;)


查看对象属性调用对象方法
/*查看对象属性*/console.log(obj.name)console.log(obj.sex)/*调用方法*/obj.miss(&quot;谭颖&quot;)



3. 字面量的方式创建对象


使用JSON方式
var 对象名={属性名：属性值，属性名：属性值，…，方法名：方法声明：方法名：方法声明，……}
/*使用JSON方式*/var obj = &#123;    name:&quot;陈慧珊&quot;,    sex:&quot;女&quot;,    miss:function(ex)&#123;        console.log(this.name+&quot;一直都放不下&quot;+ex)    &#125;&#125;


查看属性 调用方法
/*查看参数 调用方法*/			console.log(obj.name)			console.log(obj.sex)			obj.miss(&quot;谭颖&quot;)



原型
构造器与原型的关系
当我们用构造方法创建一个类时,在内存会预先调用构造方法创建一个对象,这对象我们称之为原型对象,构造方法对象中有一个prototype属性指向该对象,原型对象中有一个constructor属性指向构造方法.获得一个类的原型对象可以通过类名.prototype的方式获得.

// 准备一个构造方法 function Person(pname,page)&#123;    this.pname=pname;    this.page=page;    this.eat=function(food)&#123;        console.log(this.page+&quot;岁的&quot;+this.pname+&quot;正在吃&quot;+food);    &#125;	&#125;console.log(Person)// Constructor对象  构造方法对象console.log(Person.prototype)
控制台打印Person构造器和其原型对象

当前类对象与原型的关系
当前类的每一个对象内部有一个 _ proto _的一个属性,指向他们的原型, 当我们用对象获取属性和调用方法时,如果当前对象中没有,那么会去他们所对应的原型对象中去找.

/*为Person所有对象增加属性和方法*///通过给Person的原型增加属性Person.prototype.ex=&quot;ty&quot;//通过给Person的原型增加方法Person.prototype.emotion=function(emo)&#123;    console.log(this.pname+emo+&quot;极了&quot;+this.ex)&#125;var p1 = new Person(&quot;chs&quot;,10);p1.emotion(&quot;讨厌&quot;);var p2 = new Person(&quot;陈慧珊&quot;,10);p2.emotion(&quot;恨&quot;);
原型链
一个类的原型是一个Object类的对象,也就是说,原型也有一个_proto_属性,指向Object的原型对象,那么也就是说 Person prototype中没有的属性和方法会继续向Object  prototype去找,也就是说,我们在Object原型中添加的属性和方法,我们在person1和person2中也可以使用.那么这种连续的 _proto_属性指向就形成了原型链
也就是给Object的原型对象添加的属性和方法，所有的对象都可以用

// 准备一个构造方法 function Person(pname,page)&#123;    this.pname=pname;    this.page=page;    this.eat=function(food)&#123;        console.log(this.page+&quot;岁的&quot;+this.pname+&quot;正在吃&quot;+food);    &#125;	&#125;// 给所有的对象增加属性和方法//给最终原型增加属性Object.prototype.gender=&quot;男&quot;;//给Person的原型增加一个方法Object.prototype.sleep=function()&#123;    console.log(this.page+&quot;岁的&quot;+this.gender+&quot;孩儿&quot;+this.pname+&quot;正在睡觉&quot;);&#125;var p1=new Person(&quot;张三&quot;,10);p1.eat(&quot;蛋挞&quot;)p1.sleep();var p2=new Person(&quot;李四&quot;,8);p2.eat(&quot;牛角面包&quot;)p2.sleep()console.log(p1);console.log(p2);
事件
鼠标事件



属性
描述
DOM




onclick
当用户点击某个对象时调用的事件句柄。
2


oncontextmenu
在用户点击鼠标右键打开上下文菜单时触发



ondblclick
当用户双击某个对象时调用的事件句柄。
2


onmousedown
鼠标按钮被按下。
2


onmouseenter
当鼠标指针移动到元素上时触发。
2


onmouseleave
当鼠标指针移出元素时触发
2


onmousemove
鼠标被移动。
2


onmouseover
鼠标移到某元素之上。
2


onmouseout
鼠标从某元素移开。
2


onmouseup
鼠标按键被松开。
2



&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            .d1&#123;                width: 100px;                height: 100px;                background-color: greenyellow;            &#125;        &lt;/style&gt;        &lt;script&gt;            function fun1()&#123;                console.log(&quot;双击666&quot;)            &#125;            function fun2()&#123;                console.log(&quot;鼠标按下&quot;)            &#125;            function fun3()&#123;                console.log(&quot;鼠标抬起&quot;)            &#125;            function fun4()&#123;                console.log(&quot;鼠标进入&quot;)            &#125;            function fun5()&#123;                console.log(&quot;鼠标离开&quot;)            &#125;            function fun6()&#123;                console.log(&quot;鼠标移动&quot;)            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;d1&quot;              ondblclick=&quot;fun1()&quot;              onmousedown=&quot;fun2()&quot;              onmouseup=&quot;fun3()&quot;              onmouseenter=&quot;fun4()&quot;              onmouseleave=&quot;fun5()&quot;              onmousemove=&quot;fun6()&quot;&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;

按键事件



属性
描述
DOM




onkeydown
某个键盘按键被按下。
2


onkeypress
某个键盘按键被按下并松开。
2


onkeyup
某个键盘按键被松开。
2



&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;                console.info(&quot;按钮按下&quot;)            &#125;            function fun2()&#123;                console.info(&quot;按钮抬起&quot;)            &#125;            function fun3()&#123;                console.info(&quot;按钮按下并抬起&quot;)            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;text&quot; onkeydown=&quot;fun1()&quot; onkeyup=&quot;fun2()&quot; onkeypress=&quot;fun3()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;

表单事件



属性
描述
DOM




onblur
元素失去焦点时触发
2


onchange
该事件在表单元素的内容改变时触发( , , , 和 )
2


onfocus
元素获取焦点时触发
2


onfocusin
元素即将获取焦点时触发
2


onfocusout
元素即将失去焦点时触发
2


oninput
元素获取用户输入时触发
3


onreset
表单重置时触发
2


onsearch
用户向搜索域输入文本时触发 (  &lt;input=“search”&gt;)



onselect
用户选取文本时触发 (  和 )
2


onsubmit
表单提交时触发
2



&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;console.log(&quot;获得焦点&quot;);&#125;            function fun2()&#123;console.log(&quot;失去焦点&quot;);&#125;            function fun3()&#123;console.log(&quot;正在输入&quot;);&#125;// 只要输入了,就会触发            function fun4()&#123;console.log(&quot;内容改变&quot;);&#125;// 内部信息发生变化的同时,要失去焦点            function fun5(sel)&#123;console.log(&quot;内容发生改变了&quot;+sel.value)&#125;            function fun6()&#123;                alert(&quot;发生了提交事件&quot;);                // 做了一些运算之后 动态决定表单能否提交                return false ;            &#125;            function fun7()&#123;                 console.log(&quot;发生了重置事件&quot;);                return true;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form method=&quot;get&quot;  action=&quot;https://www.baidu.com&quot; onsubmit=&quot;return fun6()&quot; onreset=&quot;return fun7()&quot;&gt;            &lt;input name=&quot;&quot;  value=&quot;&quot;  type=&quot;text&quot; onfocus=&quot;fun1()&quot; onblur=&quot;fun2()&quot; oninput=&quot;fun3()&quot; onchange=&quot;fun4()&quot;/&gt;&lt;br /&gt;            &lt;select name=&quot;city&quot; onchange=&quot;fun5(this)&quot;&gt;                &lt;option selected&gt;-请选择城市-&lt;/option&gt;                &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;天津&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;上海&lt;/option&gt;                &lt;option value=&quot;4&quot;&gt;重庆&lt;/option&gt;            &lt;/select&gt;            &lt;br /&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交数据&quot; /&gt;            &lt;input type=&quot;reset&quot;  value=&quot;重置数据&quot; /&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;
页面加载事件
==onload标签==可以让页面加载完了自动执行相应函数
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function testFun()&#123;                var in1=document.getElementById(&quot;i1&quot;);                var v1=in1.value;                console.log(v1)            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body onload=&quot;testFun()&quot;&gt;        &lt;input type=&quot;text&quot; value=&quot;测试文字&quot; id=&quot;i1&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;
BOM编程
BOM与DOM的概念和联系
Browser Object Model 浏览器对象模型


BOM有一系列对象组成，是访问、控制、修改浏览器的属性的方法


BOM没有统一的标准(每种客户端都可以自定标准)。


BOM的顶层是==window对象==


Document Object Model 文档对象模型


DOM用于XHTML、XML文档的应用程序接口(API)。


DOM提供一种结构化的文档描述方式，从而使HTML内容使用结构化的方式显示。


DOM由一系列对象组成，是访问、检索、修改XHTML文档内容与结构的标准方法。


DOM标准是由w3c制定与维护。DOM是跨平台与跨语言的。


DOM的顶层是==document对象==


​                                            &lt;下图红色框内是DOM控制，绿色框内是BOM控制&gt;

联系

也可以说DOM也是归BOM管的.
BOM编程就是把整个浏览器抽象成一个对象(window),这个对象中有很多的属性和方法,访问这些属性或者调用这些方法就可以控制浏览器作出…行为
DOM编程就是把浏览器当前页面对应的文档抽象成一个对象(document),这个对象中有很多关于操作文档的一些属性和方法,访问这些属性和方法的时候,我们就可以通过代码动态控制页面上显示的内容
BOM 是为了操作浏览器出现的 API，window 是其根对象。
DOM 是为了操作文档出现的 API，document 是其根对象。
window对象及常用方法
三种弹窗方式
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;                /*                                 * 如果是使用window对象调用的方法和访问的属性 那么window对象都可以省略不写                                 *                                  * */                window.alert(&quot;你好呀&quot;);//普通信息提示框                var con =window.confirm(&quot;确定要删除***女友吗?&quot;);// 确认框                console.log(con);                var message =window.prompt(&quot;请输入3号女友的名字&quot;,&quot;例如:小刚&quot;);// 信息输入框                console.log(message)            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;测试按钮&quot;  onclick=&quot;fun1()&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;



定时器
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            /*持续打印的控制器*/            //定义一个存储因为每次点击而生成的intervalID            var intervalIDS=new Array();            /*循环执行的定时器任务*/            function startInterval()&#123;                //定时器setInterval()&#123;执行的动作，时间&#125;                var intervalID = window.setInterval(                    function()&#123;                        var today=new Date();                        var hours = today.getHours();                        var minutes=today.getMinutes();                        var seconds=today.getSeconds();                        var str= hours+&quot;点&quot;+minutes+&quot;分&quot;+seconds+&quot;秒&quot;;                        var ta = document.getElementById(&quot;timeArea&quot;);                        ta.value=str;                    &#125;,                    1000//1s                );                intervalIDS.push(intervalID);            &#125;            /*设置循环停止*/            function endInterval()&#123;                //删除定时器任务                while(intervalIDS.length&gt;0)&#123;                    //删除数组第一个元素                    window.clearInterval(intervalIDS.shift())                &#125;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;text&quot; id=&quot;timeArea&quot; /&gt;&lt;br /&gt;        &lt;input type=&quot;button&quot; value=&quot;开始计时&quot; onclick=&quot;startInterval()&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;停止计时&quot; onclick=&quot;endInterval()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;

open和close
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;                window.open(&quot;https://www.baidu.com&quot;)            &#125;            function fun2()&#123;                window.close();            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;打开百度&quot; onclick=&quot;fun1()&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;关闭页面&quot; onclick=&quot;fun2()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;
window属性
location
location对象,是window对象的一个属性,代表浏览器上URL地址栏,使用location对象可以操作地址栏
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;                console.log(location.host);// 服务器的IP+端口号                console.log(location.hostname);// IP                 console.log(location.port);// 端口号                console.log(location.href);// 地址栏中具体的文字                location.href=&quot;https://www.baidu.com&quot;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;测试location&quot; onclick=&quot;fun1()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;
history
history对象是window对象的一个属性,代表浏览器访问历史记录,通过history的操作我们可以实现翻阅浏览器历史网页
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;                window.history.forward();            &#125;            function fun2()&#123;                history.back();            &#125;            function fun3()&#123;                history.go(2); // 正整数 向前跳转 * 页  负整数 向后跳转*页            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=&quot;a.html&quot; target=&quot;_self&quot;&gt;pageA&lt;/a&gt;        &lt;input type=&quot;button&quot; value=&quot;向前&quot; onclick=&quot;fun1()&quot;/&gt;        &lt;input type=&quot;button&quot; value=&quot;向后&quot; onclick=&quot;fun2()&quot;/&gt;        &lt;input type=&quot;button&quot; value=&quot;go&quot; onclick=&quot;fun3()&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;
screen和navigator
screen代表屏幕,navigator代表浏览器软件本身,通过这两个对象可以获得屏幕和浏览器软件的一些信息
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;                console.info(window.screen.width)                console.info(window.screen.height)                console.info(navigator.userAgent)                console.info(navigator.appName)            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body onload=&quot;fun1()&quot;&gt;    &lt;/body&gt;&lt;/html&gt;
DOM编程
引入
DOM编程就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程.
和BOM的联系
document
document对象代表整个html文档，可用来访问页面中的所有元素，是最复杂的一个dom对象，可以说是学习好dom编程的关键所在。
document对象
document对象是window对象的一个成员属性，通过window.document来访问，当然也可以直接使用document,根据HTML代码结构特点,document对象本身是一种树形结构的文档对象。
如何获取？
document对象是window对象的一个成员属性，通过window.document来访问，当然也可以直接使用document,根据HTML代码结构特点,document对象本身是一种树形结构的文档对象。


结点对象：Node
在 HTML DOM (Document Object Model) 中, 所有的都是  节点
它有三个子类


元素节点：Element 如：
&lt;a href=&quot;链接地址&quot;&gt;我的链接&lt;/a&gt;


属性节点 Attribute 如：
href=&quot;链接地址&quot;


文本节点 Text 如：
我的链接


document的操作


查询元素（获取元素,进而操作元素,或者元素的属性,文本）


操作文本


操作属性


操作元素


操作CSS样式（一个特殊的属性style）


实例
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;页面分析&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        x        &lt;div id=&quot;d1&quot; style=&quot;width: 100px;height: 100px; border: 1px solid red;&quot;&gt;            1a            &lt;span&gt;hello&lt;/span&gt;            2b            &lt;span&gt;thank you&lt;/span&gt;            3c            &lt;span&gt;thank you very much&lt;/span&gt;            4d        &lt;/div&gt;        y    &lt;/body&gt;&lt;/html&gt;
树形结构图

获取节点

id值获取
class属性值获取
标签名获取
name属性值获取

&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;                // 获得document对象                var element1 =document.getElementById(&quot;d1&quot;);                console.log(element1);                element1.innerText=&quot;这是我的div&quot;;            &#125;            function fun2(className)&#123;                var elements =document.getElementsByClassName(className);                console.log(elements)                for(var i =0;i&lt;elements.length;i++)&#123;                    console.log(elements[i])                &#125;            &#125;            function fun3()&#123;                var elements =document.getElementsByTagName(&quot;input&quot;);                console.log(elements);                for(var i =0;i&lt;elements.length;i++)&#123;                    console.log(elements[i])                &#125;            &#125;            function fun4()&#123;                var elements=document.getElementsByName(&quot;hobby&quot;);                console.log(elements);                for(var i =0;i&lt;elements.length;i++)&#123;                    console.log(elements[i])                &#125;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&#x27;d1&#x27; class=&quot;a&quot;&gt;这是第一个div&lt;/div&gt;        &lt;div id=&#x27;d2&#x27; class=&quot;a&quot;&gt;这是第二个div&lt;/div&gt;        &lt;div id=&#x27;d3&#x27; class=&quot;a&quot;&gt;这是第三个div&lt;/div&gt;        &lt;input id=&#x27;i1&#x27; class=&quot;a&quot; name=&#x27;name1&#x27;/&gt;        &lt;div id=&#x27;d4&#x27; class=&quot;b&quot; name=&#x27;name1&#x27;&gt;这是第四个div&lt;/div&gt;        &lt;div id=&#x27;d5&#x27; class=&quot;b&quot;&gt;这是第五个div&lt;/div&gt;        爱好:        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;  value=&quot;1&quot; /&gt;篮球        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;  value=&quot;2&quot; /&gt;足球        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot;  value=&quot;3&quot; /&gt;羽毛球        &lt;hr /&gt;        &lt;input type=&quot;button&quot; value=&quot;id值获取&quot; onclick=&#x27;fun1()&#x27; /&gt;        &lt;input type=&quot;button&quot; value=&quot;class属性值获取&quot; onclick=&#x27;fun2(&quot;b&quot;)&#x27; /&gt;        &lt;input type=&quot;button&quot; value=&quot;标签名获取&quot; onclick=&#x27;fun3()&#x27; /&gt;        &lt;input type=&quot;button&quot; value=&quot;name属性值获取&quot; onclick=&#x27;fun4()&#x27; /&gt;    &lt;/body&gt;&lt;/html&gt;
修改操作
修改节点属性
 &lt;body&gt;        &lt;input type=&quot;text&quot; value=&quot;你好呀&quot; id=&quot;in1&quot; /&gt;         &lt;hr /&gt;        &lt;input type=&quot;button&quot; value=&quot;变&quot; onclick=&quot;fun1()&quot;  /&gt;&lt;/body&gt;


语法一：获得  节点.属性名    修改  节点.属性名 =属性值
// 语法1     console.log(node.type);console.log(node.value);//改变属性值node.type=&quot;button&quot;;node.value=&quot;你好我也好&quot;;


语法二：getAttribute   setAttribute
// 语法2  getAttribute   setAttributeconsole.log(node.getAttribute(&quot;type&quot;));console.log(node.getAttribute(&quot;value&quot;));node.setAttribute(&quot;type&quot;,&quot;button&quot;);node.setAttribute(&quot;value&quot;,&quot;大家好&quot;);


修改节点样式
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            #div1&#123;                width: 100px;                height: 100px;                border: 1px solid red;            &#125;            .a&#123;                background-color: lightblue;                color: blue;                font-size: 40px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;div1&quot; &gt;            你好呀        &lt;/div&gt;        &lt;hr/&gt;        &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;fun1()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;


节点.style.样式名=样式值
// 节点.style.样式名=样式值var element =document.getElementById(&quot;div1&quot;);element.style.width=&quot;200px&quot;;element.style.height=&quot;200px&quot;;element.style.border=&quot;10px solid green&quot;;


css样式在更多的时候是以class选择器的形式作用到元素上
可以通过修改class属性,影响div的样式
 &lt;style&gt;.a&#123;                 background-color: lightblue;                 color: blue;                 font-size: 40px;             &#125; &lt;/style&gt;
 element.setAttribute(&quot;class&quot;,&quot;a&quot;)


修改标签文本


innerHtml 操作双标签中间的HTML


innerText  操作双标签中间的 Text


value      操作表单标签值


&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            div&#123;                border: 1px solid red;                width: 200px;                height: 200px;            &#125;        &lt;/style&gt;        &lt;script&gt;            function fun1()&#123;                var element1=document.getElementById(&quot;d1&quot;);                /*                                 * innerText  不包含HTML结构                                 * innerHTML  包含HTML结构                                 * */                console.log(&quot;innerText&gt;&gt;&gt;&quot;+element1.innerText);                console.log(&quot;innerHTML&gt;&gt;&gt;&quot;+element1.innerHTML);                var element2=document.getElementById(&quot;i1&quot;);                console.log(element2.value)            &#125;            function fun2()&#123;                var element1=document.getElementById(&quot;d1&quot;);                //element1.innerText=&quot;&lt;h1&gt;一刻也不能分割&lt;/h1&gt;&quot;                element1.innerHTML=&quot;&lt;h1&gt;一刻也不能分割&lt;/h1&gt;&quot;                var element2=document.getElementById(&quot;i1&quot;);                element2.value=&quot;无论我走到哪里&quot;;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&#x27;d1&#x27;&gt;            a            &lt;span&gt;文字&lt;/span&gt;            b        &lt;/div&gt;        &lt;input type=&quot;text&quot; value=&quot;我和我的祖国&quot; id=&#x27;i1&#x27; /&gt;        &lt;input type=&quot;button&quot; value=&quot;获取内容&quot;  onclick=&quot;fun1()&quot;/&gt;        &lt;input type=&quot;button&quot; value=&quot;修改内容&quot;  onclick=&quot;fun2()&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;
增加删除节点
删除节点需要的知识
行间距和创建标签
创建标签输入内筒以后进行进一步的创建w
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style&gt;            #d1&#123;                border: 1px solid red;                width: 80%;                height: 200px;            &#125;        &lt;/style&gt;        &lt;script&gt;            function fun1()&#123;                var div1=document.getElementById(&quot;d1&quot;);                // 通过JS创建标签                var in1=document.createElement(&quot;input&quot;);                in1.setAttribute(&quot;type&quot;,&quot;text&quot;);                in1.setAttribute(&quot;value&quot;,&quot;请输入内容&quot;);                var in2=document.createElement(&quot;input&quot;);                in2.setAttribute(&quot;type&quot;,&quot;password&quot;);                in2.setAttribute(&quot;value&quot;,&quot;123456789&quot;);                var in3=document.createElement(&quot;input&quot;);                in3.setAttribute(&quot;type&quot;,&quot;button&quot;);                in3.setAttribute(&quot;value&quot;,&quot;删除&quot;);                var br=document.createElement(&quot;br&quot;);                in3.onclick=function ()&#123;                    div1.removeChild(in1)                    div1.removeChild(in2)                    div1.removeChild(in3)                    div1.removeChild(br)                &#125;                div1.appendChild(in1);                div1.appendChild(in2);                div1.appendChild(in3);                div1.appendChild(br);            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;d1&quot;&gt;        &lt;/div&gt;        &lt;input type=&quot;button&quot; value=&quot;增加&quot; onclick=&quot;fun1()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;
案例
Do You Love Me??
&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;            function fun1()&#123;                var outerDiv =document.getElementById(&quot;outerDiv&quot;);                 // 1000                var left =Math.floor(Math.random()*1000)                // 500                var top =Math.floor(Math.random()*500)                outerDiv.style.marginTop=top+&quot;px&quot;;                outerDiv.style.marginLeft=left+&quot;px&quot;;            &#125;            function  fun2()&#123;                alert(&quot;love you too&quot;)            &#125;        &lt;/script&gt;        &lt;style&gt;            #outerDiv&#123;                width: 200px;                height: 200px;                border: 1px solid gold;                background-color: gray;                text-align: center;                margin-top: 200px;                margin-left: 200px;            &#125;            #outerDiv input&#123;                width: 50px;                height: 50px;                margin: 20px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body &gt;        &lt;div id=&quot;outerDiv&quot;&gt;            &lt;h3&gt;do you love me?&lt;/h3&gt;            &lt;input type=&quot;button&quot; value=&quot;是&quot; onclick=&quot;fun2()&quot;/&gt;            &lt;input type=&quot;button&quot; value=&quot;否&quot; onmouseover=&quot;fun1()&quot;/&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习</title>
    <url>/2021/07/21/Linux%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[常用配置
启动网络

启动网卡（仅针对单次可用）

# nmcli c up ens33

修改配置文件（永久可用）

# vim /etc/sysconfig/network-scripts/ifcfg-ens33

ONBOOT=yes
NAT模式
在VMWare中默认使用的NAT模式

Network Address Translation 网络地址转换，

为什么要求改网络类型：因为给NAT模式外界不能访问windows里面的操作系统
改成桥接模式

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/05/07/MySQL/</url>
    <content><![CDATA[引入
1.数据库基本概念
1.1 数据
所谓数据（Data）是指对客观事物进行描述并可以鉴别的符号，这些符号是可识别的、抽象的。它不仅仅指狭义上的数字，而是有多种表现形式：字母、文字、文本、图形、音频、视频等。现在计算机存储和处理的数据范围十分广泛，而描述这些数据的符号也变得越来越复杂了。
1.2 数据库
数据库（Database，DB）指的是以一定格式存放、能够实现多个用户共享、与应用程序彼此独立的数据集合。

1.3 数据库管理系统
数据库管理系统（Database Management System，DBMS）是用来定义和管理数据的软件。如何科学的组织和存储数据，如何高效的获取和维护数据，如何保证数据的安全性和完整性，这些都需要靠数据库管理系统完成。目前，比较流行的数据库管理系统有：Oracle、MySQL、SQL Server、DB2等。
1.4数据库应用程序
数据库应用程序（Database Application System，DBAS）是在数据库管理系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序，如学生管理系统、人事管理系统、图书管理系统等。
1.5 数据库管理员
数据库管理员（Database Administrator，DBA）是指对数据库管理系统进行操作的人员，其主要负责数据库的运营和维护。
1.6 最终用户
最终用户（User）指的是数据库应用程序的使用者。用户面向的是数据库应用程序（通过应用程序操作数据），并不会直接与数据库打交道。
1.7 数据库系统
数据库系统（Database System，DBS）一般是由数据库、数据库管理系统、数据库应用程序、数据库管理员和最终用户构成。其中DBMS是数据库系统的基础和核心
2. 数据库表列类型
2.1 整数类型



MySQL支持选择在该类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示


主键自增：不使用序列，通过auto_increment，要求是整数类型


支持选择在该类型关键字后面的括号内指定整数值的显示宽度



表的完整性约束
1. 非外键约束



约束条件
约束描述




PRIMARY KEY
主键约束，约束字段的值可唯一地标识对应的记录


NOT NULL
非空约束，约束字段的值不能为空


UNIQUE
唯一约束，约束字段的值是唯一的


CHECK
检查约束，限制某个字段的取值范围


DEFAULT
默认值约束，约束字段的默认值


AUTO_INCREMENT
自动增加约束，约束字段的值自动递增


FOREIGN KEY
外键约束，约束表与表之间的关系



实例一：建立一张用来存储学生信息的表
/*建立一张用来存储学生信息的表字段包含学号、姓名、性别，年龄、入学日期、班级，email等信息约束：建立一张用来存储学生信息的表字段包含学号、姓名、性别，年龄、入学日期、班级，email等信息【1】学号是主键 = 不能为空 +  唯一 ，主键的作用：可以通过主键查到唯一的一条记录【2】如果主键是整数类型，那么需要自增【3】姓名不能为空【4】Email唯一【5】性别默认值是男【6】性别只能是男女【7】年龄只能在18-50之间*/-- 创建数据库表：create table t_student(        sno int(6) primary key auto_increment, -- 主键自增        sname varchar(5) not null,         sex char(1) default &#x27;男&#x27; check(sex=&#x27;男&#x27; || sex=&#x27;女&#x27;),        age int(3) check(age&gt;=18 and age&lt;=50),        enterdate date,        classname varchar(10),        email varchar(15) unique -- 唯一);-- 查看数据：select * from t_student;



添加数据：
-- 添加数据：--  1048 - Column &#x27;sname&#x27; cannot be null 不能为null-- 3819 - Check constraint &#x27;t_student_chk_1&#x27; is violated. 违反检查约束insert into t_student values (1,&#x27;张三&#x27;,&#x27;男&#x27;,21,&#x27;2023-9-1&#x27;,&#x27;java01班&#x27;,&#x27;zs@126.com&#x27;);-- 1062 - Duplicate entry &#x27;1&#x27; for key &#x27;t_student.PRIMARY&#x27; 主键重复-- &gt; 1062 - Duplicate entry &#x27;ls@126.com&#x27; for key &#x27;t_student.email&#x27; 违反唯一约束insert into t_student values (2,&#x27;李四&#x27;,&#x27;男&#x27;,21,&#x27;2023-9-1&#x27;,&#x27;java01班&#x27;,&#x27;ls@126.com&#x27;);insert into t_student values (3,&#x27;露露&#x27;,&#x27;男&#x27;,21,&#x27;2023-9-1&#x27;,&#x27;java01班&#x27;,&#x27;ls@126.com&#x27;);-- 如果主键没有设定值，或者用null.default都可以完成主键自增的效果insert into t_student (sname,enterdate) values (&#x27;菲菲&#x27;,&#x27;2029-4-5&#x27;);insert into t_student values (null,&#x27;小明&#x27;,&#x27;男&#x27;,21,&#x27;2023-9-1&#x27;,&#x27;java01班&#x27;,&#x27;xm@126.com&#x27;);insert into t_student values (default,&#x27;小刚&#x27;,&#x27;男&#x27;,21,&#x27;2023-9-1&#x27;,&#x27;java01班&#x27;,&#x27;xg@126.com&#x27;);-- 如果sql报错，可能主键就浪费了，后续插入的主键是不连号的，我们主键也不要求连号的insert into t_student values (null,&#x27;小明&#x27;,&#x27;男&#x27;,21,&#x27;2023-9-1&#x27;,&#x27;java01班&#x27;,&#x27;oo@126.com&#x27;);
常见错误：
–》 1048 - Column ‘sname’ cannot be null 不能为null
–》 819 - Check constraint ‘t_student_chk_1’ is violated. 违反检查约束
– 》1062 - Duplicate（重复的） entry ‘1’ for key ‘t_student.PRIMARY’ 主键重复
– 》1062 - Duplicate entry ‘ls@126.com’ for key ‘t_student.email’ 违反唯一约束

使用自增的时候用null和default都是可以
如果sql报错，可能主键就浪费了，后续插入的主键是不连号的，主键也不要求连号的



- 列级约束和表级约束
(1)   表级约束：可以约束表中任意一个或多个字段。与列定义相互独立，不包含在列定义中；与定义用‘，’分隔；必须指出要约束的列的名称；
(2)   列级约束：包含在列定义中，直接跟在该列的其它定义之后 ，用空格分隔；不必指定列名；
实例二
-- 删除表：drop table t_student;-- 创建数据库表：create table t_student(        sno int(6) auto_increment,         sname varchar(5) not null,         sex char(1) default &#x27;男&#x27;,        age int(3),        enterdate date,        classname varchar(10),        email varchar(15),    -- 表级约束：        constraint pk_stu primary key (sno),  -- pk_stu 主键约束的名字        constraint ck_stu_sex check (sex = &#x27;男&#x27; || sex = &#x27;女&#x27;),        constraint ck_stu_age check (age &gt;= 18 and age &lt;= 50),        constraint uq_stu_email unique (email));-- 添加数据：insert into t_student values (1,&#x27;张三&#x27;,&#x27;男&#x27;,21,&#x27;2023-9-1&#x27;,&#x27;java01班&#x27;,&#x27;zs@126.com&#x27;);-- &gt; 3819 - Check constraint &#x27;ck_stu_sex&#x27; is violated.-- &gt; 3819 - Check constraint &#x27;ck_stu_age&#x27; is violated.-- &gt; 1062 - Duplicate entry &#x27;zs@126.com&#x27; for key &#x27;t_student.uq_stu_email&#x27;insert into t_student values (3,&#x27;李四&#x27;,&#x27;男&#x27;,21,&#x27;2023-9-1&#x27;,&#x27;java01班&#x27;,&#x27;zs@126.com&#x27;);-- 查看数据：select * from t_student;
- 创建表之后添加约束
实例三
-- 删除表：drop table t_student;-- 创建数据库表：create table t_student(        sno int(6),         sname varchar(5) not null,         sex char(1) default &#x27;男&#x27;,        age int(3),        enterdate date,        classname varchar(10),        email varchar(15));-- &gt; 1075 - Incorrect table definition; there can be only one auto column and it must be defined as a key-- 错误的解决办法：就是auto_increment去掉-- 在创建表以后添加约束：alter table t_student add constraint pk_stu primary key (sno) ; -- 主键约束alter table t_student modify sno int(6) auto_increment; -- 修改自增条件alter table t_student add constraint ck_stu_sex check (sex = &#x27;男&#x27; || sex = &#x27;女&#x27;);alter table t_student add constraint ck_stu_age check (age &gt;= 18 and age &lt;= 50);alter table t_student add constraint uq_stu_email unique (email);-- 查看表结构：desc t_student;
验证约束添加成功：

2. 外键约束

外键约束（FOREIGN KEY，缩写FK）是用来实现数据库表的参照完整性的。外键约束可以使两张表紧密的结合起来，特别是针对修改或者删除的级联操作时，会保证数据的完整性。
外键是指表中某个字段的值依赖于另一张表中某个字段的值，而被依赖的字段必须具有主键约束或者唯一约束。被依赖的表我们通常称之为父表或者主表，设置外键约束的表称为子表或者从表。
只有表级约束没有列级约束

实例四
主表（父表）：班级表  -  班级编号 - 主键
从表（子表）：学生表 - 班级编号 - 外键


创建父表—班级表：




cno(主键、自增)；cname（不为空）；room；
-- 先删除表，先删除从表再删除父表drop table t_student;drop table t_class;-- 先创建父表：班级表：create table t_class(        cno int(4) primary key auto_increment,        cname varchar(10) not null,        room char(4))




创建从表—学生表：


sno(主键、自增)；sname（不为空）；classno（取值参考t_class表中的cno字段，不要求字段名字完全重复，但是类型长度定义 尽量要求相同。);


添加外键约束：
-- 添加学生表，添加外键约束：create table t_student(        sno int(6) primary key auto_increment,         sname varchar(5) not null,         classno int(4),-- 取值参考t_class表中的cno字段，不要求字段名字完全重复，但是类型长度定义 尽量要求相同。    -- 外键约束：        constraint fk_stu_classno foreign key (classno) references t_class (cno)    );




删除外键约束
-- 删除外键约束alter table EMP	drop foreign key FK_DEPTNO




添加数据：


可以一次性添加多条记录：
 -- 可以一次性添加多条记录：insert into t_class values (null,&#x27;java001&#x27;,&#x27;r803&#x27;),(null,&#x27;java002&#x27;,&#x27;r416&#x27;),(null,&#x27;大数据001&#x27;,&#x27;r103&#x27;);insert into t_student values (null,&#x27;张三&#x27;,1),(null,&#x27;李四&#x27;,1),(null,&#x27;王五&#x27;,2),(null,&#x27;朱六&#x27;,3);


查询班级表：
-- 查看班级表和学生表：select * from t_class;select * from t_student;


添加外键的效果：

删除班级会出错

-- 尝试删除班级delete from t_class where cno = 1;



外键策略：
直接删除班级会错误，有时候必须删，可以加入外键策略
策略一：no action 不允许操作
-- 策略1：no action 不允许操作-- 通过操作sql来完成：-- 先把班级2的学生对应的班级 改为null update t_student set classno = null where classno = 2;-- 然后再删除班级2   delete from t_class where cno = 2;
结果：


策略二：使用cascade级联操作
操作主表的时候影响从表的外键


先删除外键约束
-- 策略2：cascade 级联操作：操作主表的时候影响从表的外键信息：alter table t_student drop foreign key fk_stu_classno;


重新添加外键约束（增加一个级联操作）
-- 重新添加外键约束：alter table t_student add constraint fk_stu_classno foreign key (classno) references t_class (cno) on update cascade on delete cascade;


试着更新和删除操作：
-- 试试更新：update t_class set cno = 5 where cno = 3;-- 试试删除：delete from t_class where cno = 5;
结果



策略三：set null     置空操作


先删除之前的外键约束
-- 先删除之前的外键约束：alter table t_student drop foreign key fk_stu_classno;


重新添加外键约束
-- 重新添加外键约束：alter table t_student add constraint fk_stu_classno foreign key (classno) references t_class (cno) on update set null on delete set null;


试着更新操作
-- 更新update t_class set cno = 5 whwere con = 1;
结果：




注：策略2 级联操作  和  策略2 的  删除操作  可以混着使用
alter table t_student add constraint fk_stu_classno foreign key (classno) references t_class (cno) on update cascade on delete set null ;
应用场合：
– （1）朋友圈删除，点赞。留言都删除  –  级联操作
– （2）解散班级，对应的学生 置为班级为null就可以了，-- set null
DQL查询操作*
1. 常见表的准备
部门表(dept)
create table DEPT(    DEPTNO int(2) not null,    DNAME  VARCHAR(14),    LOC    VARCHAR(13)  );  alter table DEPT   add constraint PK_DEPT primary key (DEPTNO); 
员工表（emp)
create table EMP  (    EMPNO    int(4) primary key,    ENAME    VARCHAR(10),    JOB      VARCHAR(9),    MGR      int(4),    HIREDATE DATE,    SAL      double(7,2),    COMM     double(7,2),    DEPTNO   int(2)  );  alter table EMP    add constraint FK_DEPTNO foreign key (DEPTNO)    references DEPT (DEPTNO);  
薪资登记表(salgrade)
create table SALGRADE  (    GRADE int primary key,    LOSAL double(7,2),    HISAL double(7,2)  );  
奖金表(bonus)
create table BONUS  (    ENAME VARCHAR(10),    JOB   VARCHAR(9),    SAL   double(7,2),    COMM  double(7,2)  );  
操作
-- DEPTinsert into DEPT (DEPTNO, DNAME, LOC)  values (10, &#x27;ACCOUNTING&#x27;, &#x27;NEW YORK&#x27;);  insert into DEPT (DEPTNO, DNAME, LOC)  values (20, &#x27;RESEARCH&#x27;, &#x27;DALLAS&#x27;);  insert into DEPT (DEPTNO, DNAME, LOC)  values (30, &#x27;SALES&#x27;, &#x27;CHICAGO&#x27;);  insert into DEPT (DEPTNO, DNAME, LOC)  values (40, &#x27;OPERATIONS&#x27;, &#x27;BOSTON&#x27;);  -- EMPinsert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7369, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, 7902, &#x27;1980-12-17&#x27;, 800, null, 20);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7499, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1981-02-20&#x27;, 1600, 300, 30);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7521, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1981-02-22&#x27;, 1250, 500, 30);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7566, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1981-04-02&#x27;, 2975, null, 20);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7654, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1981-09-28&#x27;, 1250, 1400, 30);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7698, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1981-05-01&#x27;, 2850, null, 30);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7782, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, 7839, &#x27;1981-06-09&#x27;, 2450, null, 10);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7788, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, 7566, &#x27;1987-04-19&#x27;, 3000, null, 20);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7839, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, null, &#x27;1981-11-17&#x27;, 5000, null, 10);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7844, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, 7698, &#x27;1981-09-08&#x27;, 1500, 0, 30);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7876, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, 7788, &#x27;1987-05-23&#x27;, 1100, null, 20);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7900, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, 7698, &#x27;1981-12-03&#x27;, 950, null, 30);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7902, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, 7566, &#x27;1981-12-03&#x27;, 3000, null, 20);  insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)  values (7934, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, 7782, &#x27;1982-01-23&#x27;, 1300, null, 10);  -- SALGRADEinsert into SALGRADE (GRADE, LOSAL, HISAL)  values (1, 700, 1200);  insert into SALGRADE (GRADE, LOSAL, HISAL)  values (2, 1201, 1400);  insert into SALGRADE (GRADE, LOSAL, HISAL)  values (3, 1401, 2000);  insert into SALGRADE (GRADE, LOSAL, HISAL)  values (4, 2001, 3000);  insert into SALGRADE (GRADE, LOSAL, HISAL)  values (5, 3001, 9999);  -- 查看表：select * from dept; -- 部门表：dept:department 部分 ，loc - location 位置select * from emp;-- 员工表：emp:employee 员工   ,mgr :manager上级领导编号，hiredate 入职日期  firedate 解雇日期 ，common：补助-- deptno 外键 参考  dept - deptno字段-- mgr 外键  参考  自身表emp - empno  产生了自关联select * from salgrade;-- losal - lowsal-- hisal - highsalselect * from bonus;
结果(表格形式)




2.  单表查询
2.1 简单的SQL查询
-- 对emp表查询：select * from emp; -- *代表所有数据-- 显示部分列：select empno,ename,sal from emp;-- 显示部分行：where子句select * from emp where sal &gt; 2000;-- 显示部分列，部分行：select empno,ename,job,mgr from emp where sal &gt; 2000;-- 起别名：select empno 员工编号,ename 姓名,sal 工资 from emp; -- as 省略，&#x27;&#x27;或者&quot;&quot;省略了-- as alias 别名select empno as 员工编号,ename as 姓名,sal as 工资 from emp;select empno as &#x27;员工编号&#x27;,ename as &quot;姓名&quot;,sal as 工资 from emp;-- &gt; 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;编号,ename as &quot;姓 名&quot;,sal as 工资 from emp&#x27; at line 1-- 错误原因：在别名中有特殊符号的时候，&#x27;&#x27;或者&quot;&quot;不可以省略不写select empno as 员工 编号,ename as &quot;姓 名&quot;,sal as 工资 from emp;-- 算术运算符：select empno,ename,sal,sal+1000 as &#x27;涨薪后&#x27;,deptno from emp where sal &lt; 2500;select empno,ename,sal,comm,sal+comm from emp;  -- ？？？后面再说-- 去重操作：select job from emp;select distinct job from emp;select job,deptno from emp;select distinct job,deptno from emp; -- 对后面的所有列组合 去重 ，而不是单独的某一列去重-- 排序：select * from emp order by sal; -- 默认情况下是按照升序排列的select * from emp order by sal asc; -- asc 升序，可以默认不写select * from emp order by sal desc; -- desc 降序select * from emp order by sal asc ,deptno desc; -- 在工资升序的情况下，deptno按照降序排列
2.2 where子句
将过滤条件放在where子句的后面，可以筛选/过滤出我们想要的符合条件的数据


加关系运算符
-- where 子句 + 关系运算符select * from emp where deptno = 10;select * from emp where deptno &gt; 10;select * from emp where deptno &gt;= 10;select * from emp where deptno &lt; 10;select * from emp where deptno &lt;= 10;select * from emp where deptno &lt;&gt; 10;select * from emp where deptno != 10;select * from emp where job = &#x27;CLERK&#x27;; select * from emp where job = &#x27;clerk&#x27;; -- 默认情况下不区分大小写 select * from emp where binary job = &#x27;clerk&#x27;; -- binary区分大小写select * from emp where hiredate &lt; &#x27;1981-12-25&#x27;;


加逻辑运算符
-- where 子句 + 逻辑运算符：and select * from emp where sal &gt; 1500 and sal &lt; 3000;  -- (1500,3000)select * from emp where sal &gt; 1500 &amp;&amp; sal &lt; 3000; select * from emp where sal &gt; 1500 and sal &lt; 3000 order by sal;select * from emp where sal between 1500 and 3000; -- [1500,3000]-- where 子句 + 逻辑运算符：orselect * from emp where deptno = 10 or deptno = 20;select * from emp where deptno = 10 || deptno = 20;select * from emp where deptno in (10,20);select * from emp where job in (&#x27;MANAGER&#x27;,&#x27;CLERK&#x27;,&#x27;ANALYST&#x27;);


加模糊查询
-- where子句 + 模糊查询：-- 查询名字中带A的员工  -- %代表任意多个字符 0,1,2，.....select * from emp where ename like &#x27;%A%&#x27; ;-- -任意一个字符select * from emp where ename like &#x27;__A%&#x27; ;


关于null的判断
-- 关于null的判断：select * from emp where comm is null;select * from emp where comm is not null;


小括号的使用：因为不同运算符的优先级别不同，加括号为了可读性
-- 小括号的使用  ：因为不同的运算符的优先级别不同，加括号为了可读性select * from emp where job = &#x27;SALESMAN&#x27; or job = &#x27;CLERK&#x27; and sal &gt;=1500; -- 先and再or  and &gt; orselect * from emp where job = &#x27;SALESMAN&#x27; or (job = &#x27;CLERK&#x27; and sal &gt;=1500); select * from emp where (job = &#x27;SALESMAN&#x27; or job = &#x27;CLERK&#x27;) and sal &gt;=1500;


2.3 函数
除了多行函数（max,min,count,sum,avg），都是单行函数
- 单行函数
1. 字符串函数



函数
描述




CONCAT(str1, str2, ···, strn)
将str1、str2···strn拼接成一个新的字符串


INSERT(str, index, n,  newstr)
将字符串str从第index位置开始的n个字符替换成字符串newstr


LENGTH(str)
获取字符串str的长度


LOWER(str)
将字符串str中的每个字符转换为小写


UPPER(str)
将字符串str中的每个字符转换为大写


LEFT(str, n)
获取字符串str最左边的n个字符


RIGHT(str, n)
获取字符串str最右边的n个字符


LPAD(str, n, pad)
使用字符串pad在str的最左边进行填充，直到长度为n个字符为止


RPAD(str, n, pad)
使用字符串pad在str的最右边进行填充，直到长度为n个字符为止


LTRIM(str)
去除字符串str左侧的空格


RTRIM(str)
去除字符串str右侧的空格


TRIM(str)
去除字符串str左右两侧的空格


REPLACE(str,oldstr,newstr)
用字符串newstr替换字符串str中所有的子字符串oldstr


REVERSE(str)
将字符串str中的字符逆序


STRCMP(str1,  str2)
比较字符串str1和str2的大小


SUBSTRING(str,index,n)
获取从字符串str的index位置开始的n个字符



-- 1.字符串函数select ename,length(ename),substring(ename,2,3) from emp;-- substring字符串截取，2:从字符下标为2开始，3：截取长度3    （下标从1开始）
显示结果：

2. 数值函数



函数
描述




ABS(num)
返回num的绝对值


CEIL(num)
返回大于num的最小整数（向上取整）


FLOOR(num)
返回小于num的最大整数（向下取整）


MOD(num1, num2)
返回num1/num2的余数（取模）


PI()
返回圆周率的值


POW(num,n)/POWER(num,  n)
返回num的n次方


RAND(num)
返回0~1之间的随机数


ROUND(num, n)
返回x四舍五入后的值，该值保留到小数点后n位


TRUNCATE(num, n)
返回num被舍去至小数点后n位的值



-- 2.数值函数select abs(-5),ceil(5.3),floor(5.9),round(3.14) from dual; -- dual实际就是一个伪表select abs(-5) 绝对值,ceil(5.3) 向上取整,floor(5.9) 向下取整,round(3.14) 四舍五入;  -- 如果没有where条件的话，from dual可以省略不写select ceil(sal) from emp;select 10/3,10%3,mod(10,3) ;
显示结果：

3. 日期与时间函数



函数
描述




CURDATE()
返回当前日期


CURTIME()
返回当前时间


NOW()
返回当前日期和时间


SYSDATE()
返回该函数执行时的日期和时间


DAYOFYEAR(date)
返回日期date为一年中的第几天


WEEK(date)/WEEKOFYEAR(date)
返回日期date为一年中的第几周


DATE_FORMAT(date,  format)
返回按字符串format格式化后的日期date


DATE_ADD(date,  INTERVAL expr unit)    /ADDDATE(date,  INTERVAL expr unit)
返回date加上一个时间间隔后的新时间值


DATE_SUB(date,  INTERVAL expr unit)    /SUBDATE(date,  INTERVAL expr unit)
返回date减去一个时间间隔后的新时间值


DATEDIFF(date1,  date2)
返回起始日期date1与结束日期date2之间的间隔天数



-- 3.日期与时间函数 select * from emp;select curdate(),curtime() ; -- curdate()年月日 curtime()时分秒select now(),sysdate(),sleep(3),now(),sysdate() from dual; -- now(),sysdate() 年月日时分秒insert into emp values (9999,&#x27;lili&#x27;,&#x27;SALASMAN&#x27;,7698,now(),1000,null,30);-- now()可以表示年月日时分秒，但是插入数据的时候还是要参照表的结构的desc emp;



4. 流程函数

-- 4.流程函数-- if相关select empno,ename,sal,if(sal&gt;=2500,&#x27;高薪&#x27;,&#x27;底薪&#x27;) as &#x27;薪资等级&#x27; from emp; -- if-else 双分支结构select empno,ename,sal,comm,sal+ifnull(comm,0) from emp; -- 如果comm是null，那么取值为0 -- 单分支select nullif(1,1),nullif(1,2) from dual; --  如果value1等于value2，则返回null，否则返回value1  -- case相关：-- case等值判断select empno,ename,job,case job  when &#x27;CLERK&#x27; then &#x27;店员&#x27; when &#x27;SALESMAN&#x27;  then &#x27;销售&#x27; when &#x27;MANAGER&#x27; then &#x27;经理&#x27; else &#x27;其他&#x27;end &#x27;岗位&#x27;,sal from emp;-- case区间判断:select empno,ename,sal,case  when sal&lt;=1000 then &#x27;A&#x27; when sal&lt;=2000 then &#x27;B&#x27; when sal&lt;=3000 then &#x27;C&#x27; else &#x27;D&#x27;end &#x27;工资等级&#x27;,deptno from emp;from emp;
5. JSON函数

6. 其他函数

 -- 6.其他函数select database(),user(),version() from dual;
- 多行函数
对一组数据进行运算，针对一组数据（多行记录）只返回一个结果，也称分组函数

-- 多行函数：select max(sal),min(sal),count(sal),sum(sal),sum(sal)/count(sal),avg(sal) from emp;select * from emp;-- 多行函数自动忽略null值select max(comm),min(comm),count(comm),sum(comm),sum(comm)/count(comm),avg(comm) from emp;-- max(),min(),count()针对所有类型   sum(),avg() 只针对数值型类型有效select max(ename),min(ename),count(ename),sum(ename),avg(ename) from emp;-- count --计数   -- 统计表的记录数：方式1：select * from emp;select count(ename) from emp;select count(*) from emp;-- 统计表的记录数：方式2select 1 from dual;select 1 from emp;select count(1) from emp;
2.4 分组与筛选
group by 分组
select * from emp;-- 统计各个部门的平均工资 select deptno,avg(sal) from emp; -- 字段和多行函数不可以同时使用select deptno,avg(sal) from emp group by deptno; -- 字段和多行函数不可以同时使用,除非这个字段属于分组select deptno,avg(sal) from emp group by deptno order by deptno desc;-- 统计各个岗位的平均工资 统计各个岗位的select job,avg(sal) from emp group by job;select job,lower(job),avg(sal) from emp group by job;
having 分组后筛选
-- 统计各个部门的平均工资 ,只显示平均工资2000以上的  - 分组以后进行二次筛选 havingselect deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;select deptno,avg(sal) 平均工资 from emp group by deptno having 平均工资 &gt; 2000;select deptno,avg(sal) 平均工资 from emp group by deptno having 平均工资 &gt; 2000 order by deptno desc;
where在分组前进行过滤的，having在分组后进行后滤。
对比实例：
-- 对比实例：统计各个岗位的平均工资,除了MANAGER-- 方法1：select job,avg(sal) from emp where job != &#x27;MANAGER&#x27; group by job;-- 方法2：select job,avg(sal) from emp group by job having job != &#x27;MANAGER&#x27; ;-- where在分组前进行过滤的，having在分组后进行后滤。
总结
[1] select语句总结
select column, group_function(column) from table [where condition] [group by  group_by_expression] [having group_condition] [order by column]; 
注意：顺序固定，不可以改变顺序
[2] select语句的执行顺序
from — where — group  by —  select — having — order  by
[3] 单表查询练习
-- 单表查询练习：-- 列出工资最小值小于2000的职位select job,min(sal)from empgroup by jobhaving min(sal) &lt; 2000;-- 列出平均工资大于1200元的部门和工作搭配组合select deptno,job,avg(sal)from empgroup by deptno,jobhaving avg(sal) &gt; 1200order by avg(sal);-- 统计[人数小于4的]部门的平均工资。 select deptno,count(ename),avg(sal) -- 这里可用 count(1)from empgroup by deptnohaving count(ename) &lt; 4;-- 统计各部门的最高工资，排除最高工资小于3000的部门。select deptno,max(sal)from empgroup by deptnohaving max(sal) &gt;= 3000;
3.  多表查询
3.1  交叉连接 cross join
select *from empcross join dept;
3.2  自然连接 natural
select * from empnatural join dept;
优点：自动匹配所有的同名列 ，同名列只显示一次，简单
缺点：查询字段的时候，没有指定字段对应的数据库表，效率低
解决——指定表名
select emp.empno,emp.enaem,emp.sal,dept.dname,dept.loc,dept.deptnofrom empnatural join dept;
缺点：表名太长
解决——起表名
select e.empno,e.ename,e.sal,d.dname,d.loc,d.deptnofrom emp enatural join dept d;
缺点：会自动匹配所有表中同名的字段。有时候我们只需要部分相同的字段
3.3 内连接 inner join
select * from emp einner join dept d using(deptno); -- 同名字段才有效
缺点：连接的表字段不同时using无法使用。
解决——使用on子句
select *from emp einner join dept d -- 使用on的时候inner可以省略on e.deptno = d.deptno;
3.4 外连接  outer  join

内连接只显示匹配的数据，例如一个部门没有员工就不会显示
外连接可以显示不匹配的数据
outer都可以省略的

左外连接
左边的那个表的信息，即使不匹配也可以查看出结果
select * from empleft outer join dept don e.deptno = d.deptno
结果

右外连接
右边的那个表的信息，即使不匹配也可以查看出结果
select *from emp eright outer join dept don e.deptno = d.deptno;
结果

全外连接
这个语法在mysql里面不支持，oracle才支持
为了代替 可以取左外连接和右外连接的并集
并集 union
select * from empleft outer join dept don e.deptno = d.deptnounion -- 并集，不去重，效率低select *from emp eright outer join dept don e.deptno = d.deptno;
结果

union all
select * from empleft outer join dept don e.deptno = d.deptnounion  all -- 不去重的并集， 效率高select *from emp eright outer join dept don e.deptno = d.deptno;
结果

3.5 三表查询
案例：查询员工的编号、姓名、薪水、部门编号、部门名称、薪水等级
select * from emp;select * from dept;select * from salgrade；select *from emp eright outer join dept don e.deptno = d.deptno;-- 可以看做就是上面的结果是一张表，然后再和第三张表进行连接inner join salgrade son e.sal between salgrade
结果

3.6 自连接查询
相当于把本身表复制一份，本质与前面的连接没有区别
-- 查询员工的编号、姓名、上级编号,上级的姓名select * from emp;select e1.empno 员工编号,e1.ename 员工姓名,e1.mgr 领导编号,e2.ename 员工领导姓名from emp e1inner join emp e2on e1.mgr = e2.empno;-- 左外连接：select e1.empno 员工编号,e1.ename 员工姓名,e1.mgr 领导编号,e2.ename 员工领导姓名from emp e1left outer join emp e2on e1.mgr = e2.empno;
结果

补充：92语法的多表查询
-- 查询员工的编号，员工姓名，薪水，员工部门编号，部门名称：select e.empno,e.ename,e.sal,e.deptno,d.dnamefrom emp e,dept d-- 相当于99语法中的cross join ,出现笛卡尔积，没有意义select e.empno,e.ename,e.sal,e.deptno,d.dnamefrom emp e,dept dwhere e.deptno = d.deptno;-- 相当于99语法中的natural join -- 查询员工的编号，员工姓名，薪水，员工部门编号，部门名称，查询出工资大于2000的员工select e.empno,e.ename,e.sal,e.deptno,d.dnamefrom emp e,dept dwhere e.deptno = d.deptno and e.sal &gt; 2000;-- 查询员工的名字，岗位，上级编号，上级名称（自连接）：select e1.ename,e1.job,e1.mgr ,e2.ename from emp e1,emp e2where e1.mgr = e2.empno;-- 查询员工的编号、姓名、薪水、部门编号、部门名称、薪水等级select e.empno,e.ename,e.sal,e.deptno,d.dname,s.grade from emp e,dept d,salgrade swhere e.deptno = d.deptno and e.sal &gt;= s.losal and e.sal &lt;= s.hisal;-- 总结：-- 1.92语法麻烦 -- 2.92语法中 表的连接条件 和  筛选条件  是放在一起的没有分开-- 3.99语法中提供了更多的查询连接类型：cross,natural,inner,outer 
4. 不相关子查询
引入
要查询所有比“CLARK”工资高的员工的信息
需要两个命令而且第二个命令依托于第一个命令，会相互影响
-- 命令一：查询clark的工资select sal from emp where ename = clark; -- 2450-- 命令二：查询所有比其工资高的员工信息select * from emp where sal &gt; 2450;
子查询可以通过一个命令解决问题 !
4.1  单行子查询
-- 将上面两个命令合并-- 查询工资高于平均工资的雇员的名字和工资select ename,salfrom empwhere sal &gt; (select sal from emp where sal &gt; avg(sal)); -- 查询和CLARK同一部门且比他工资低的雇员的名字和工资select ename,salfrom empwhere deptno = (select deptno from emp where ename=&#x27;CLARK&#x27;) 	  and 	  sal &lt; (select sal from emp where ename=&#x27;CLARK&#x27; );-- 查询职务和SCOTT相同，比SCOTT雇佣时间早的雇员信息select * from empwhere job = (select job from emp where ename=&#x27;SCOTT&#x27;)	  and	  hiredate &lt; (select hiredate from emp where ename=&#x27;SCOTT&#x27;);	  
4.2  多行子查询
子查询查出来的记录为多条：
实例一

查询部门20中职务同部门10的雇员一样的雇员信息。

-- 查询雇员信息select * from emp;-- 查询部门20中的雇员信息select * from emp where deptno = 20;-- CLERK,MANAGER,ANALYST-- 部门10的雇员的职务：select job from emp where deptno = 10; -- MANAGER,PRESIDENT,CLERK
如果使用单行子查询，就会报错  -&gt;Subquery returns more than 1 row
select * from emp where deptno = 20 and job in (select job from emp where deptno = 10)-- &gt; Subquery returns more than 1 row
多行子查询可以解决
select * from emp where deptno = 20 and job = any(select job from emp where deptno = 10) -- any
实例二


查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资
-- 查询雇员的编号、名字和工资select empno,ename,sal from emp-- “SALESMAN”的工资：select sal from emp where job = &#x27;SALESMAN&#x27;-- 查询工资比所有的“SALESMAN”都高的雇员的编号、名字和工资。-- 多行子查询：select empno,ename,sal from emp where sal &gt; all(select sal from emp where job = &#x27;SALESMAN&#x27;);
-- 单行子查询：select empno,ename,sal from emp where sal &gt; (select max(sal) from emp where job = &#x27;SALESMAN&#x27;);


实例三

查询工资低于任意一个“CLERK”的工资的雇员信息。

-- 查询雇员信息select * from emp;-- 查询工资低于任意一个“CLERK”的工资的雇员信息select * from empwhere sal &lt; any(select sal from emp where job = &#x27;CLERK&#x27;)and job != &#x27;CLERK&#x27;
-- 单行子查询：select * from empwhere sal &lt; (select max(sal) from emp where job = &#x27;CLERK&#x27;)and job != &#x27;CLERK&#x27;
5. 相关子查询
引入


不相关的子查询引入：
不相关的子查询：子查询可以独立运行，先运行子查询，再运行外查询。
相关子查询：子查询不可以独立运行，并且先运行外查询，再运行子查询


不相关的子查询优缺点：
好处：简单   功能强大（一些使用不相关子查询不能实现或者实现繁琐的子查询，可以使用相关子查询实现）
缺点：稍难理解


实例


查询各个部门最高工资的员工

不相关子查询

select * from emp where deptno = 10 and sal = (select max(sal) from emp where deptnp = 10)unionselect * from emp where deptno = 20 and sal = (select max(sal) from emp where deptno = 20)unionselect * from emp where deptno = 30 and sal = (select max(sal) from emp where deptno = 30);
太复杂了:unamused:

相关子查询

select * from emp e where sal = (select max(sal) from emp where deptno = e.deptno)
简单多啦:happy:


查询工高于所在岗位的平均工资的那些员工

不相关子查询

select * from emp where job = &#x27;&#x27; and sal &gt;= (select avg(sal) from emp where job = &#x27;&#x27;)union ....

相关子查询

select * from emp e where sal &gt;= (select avg(sal) from emp where job = e.job);


数据库对象
1. 事务
**事务（Transaction）**是用来维护数据库完整性的，它能够保证一系列的MySQL操作要么全部执行，要么全不执行。
eg1.
转账操作：A账户要转账给B账户，那么A账户上减少的钱数和B账户上增加的钱数必须一致，也就是说A账户的转出操作和B账户的转入操作要么全部执行，要么全不执行；如果其中一个操作出现异常而没有执行的话，就会导致账户A和账户B的转入转出金额不一致的情况，为而事实上这种情况是不允许发生的，所以为了防止这种情况的发生，需要使用事务处理。
eg2.
在淘宝购物下订单的时候，商家库存要减少，订单增加记录，付款我的账号少100元…操作要么全部执行，要么全不执行
概念
事务（Transaction）指的是一个操作序列，该操作序列中的多个操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，由DBMS（数据库管理系统）中的事务管理子系统负责事务的处理。
目前常用的存储引擎有InnoDB（MySQL5.5以后默认的存储引擎）和MyISAM（MySQL5.5之前默认的存储引擎），其中InnoDB支持事务处理机制，而MyISAM不支持。
特性

事务处理可以确保除非事务性序列内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的序列，可以简化错误恢复并使应用程序更加可靠。
但并不是所有的操作序列都可以称为事务，这是因为一个操作序列要成为事务，必须满足事务的原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性简称为ACID特性。

原子性
原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，事务是应用中不可再分的最小的逻辑执行体。
使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，而原子性消除了系统只处理部分操作的可能性。
一致性
一致性是指事务执行的结果必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，数据库处于一致性状态。一致性是通过原子性来保证的。
例如：在转账时，只有保证转出和转入的金额一致才能构成事务。也就是说事务发生前和发生后，数据的总额依然匹配。
隔离性
隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。
例如：在转账时，只有当A账户中的转出和B账户中转入操作都执行成功后才能看到A账户中的金额减少以及B账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。
持久性
持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。

实例：使用事务保证转账安全
-- 创建账户表：id\uname\balancecreate table account(        id int primary key auto_increment,        uname varchar(10) not null,        balance double);-- 查看账户表：select * from account;-- 在表中插入数据：insert into account values (null,&#x27;丽丽&#x27;,2000),(null,&#x27;小刚&#x27;,2000);-- 丽丽给小刚 转200元：update account set balance = balance - 200 where id = 1;update account set balance = balance + 200 where id = 2;-- 默认一个DML语句是一个事务，所以上面的操作执行了2个事务。update account set balance = balance - 200 where id = 1;update account set balance = balance2 + 200 where id = 2;
必须让上面的两个操作控制在一个事务中
-- 手动开启事务：start transaction;-- 操作：update account set balance = balance - 200 where id = 1;update account set balance = balance + 200 where id = 2;-- 手动回滚：刚才执行的操作全部取消：rollback;-- 手动提交：commit;
在回滚和提交之前，数据库中的数据都是操作的缓存中的数据，而不是数据库的真实数据
事务并发问题
脏读（Dirty read）
当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

不可重复读 （Unrepeatableread）
指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

幻读 （Phantom read）
幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
 
不可重复度和幻读区别：
不可重复读的重点是修改，幻读的重点在于新增或者删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 。
例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。
例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读
事务隔离级别
​	事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。
​	从低到高依次为READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ以及SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。
                        
-- 查看默认的事务隔离级别  MySQL默认的是repeatable read  select @@transaction_isolation;  -- 设置事务的隔离级别   （设置当前会话的隔离级别）set session transaction isolation level read uncommitted;  set session transaction isolation level read committed;  set session transaction isolation level repeatable read;  -- 默认的set session transaction isolation level serializable;  start transaction ;select * from account where id = 1;
实例
（必须是两个事务都开始以后执行的操作才会影响）


在read uncommitted的情况下，开始两个事务：

事务一



事务二




事务一查询操作：



事务二更新操作，且没提交



事务一再次查询：

读到了在脏数据


如果设置为
set session transaction isolation level read committed;
事务二就不会读到脏数据。


2. 视图
概念
视图（view）是一个从单张或多张基础数据表或其他视图中构建出来的虚拟表。同基础表一样，视图中也包含了一系列带有名称的列和行数据，但是数据库中只是存放视图的定义，也就是动态检索数据的查询语句，而并不存放视图中的数据，这些数据依旧存放于构建视图的基础表中，只有当用户使用视图是才去数据库请求相对应的数据，即视图中的数据是在引用视图时动态生成的。因此视图中的数据发生了变化，视图中相应的数据也会跟着改变。
PS：视图本质上就是：一个查询语句，是一个虚拟的表，不存在的表，你查看视图，其实就是查看视图对应的sql语句。
优点
简化用户操作：视图可以使用户将注意力集中在所关心地数据上，而不需要关心数据表的结构、与其他表的关联条件以及查询条件等。
对机密数据提供安全保护：有了视图，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，避免机密数据（如，敏感字段“salary”）出现在不应该看到这些数据的用户视图上。这样视图就自动提供了对机密数据的安全保护功能
实例一：单表视图


创建/替换单表视图：
-- 创建/替换单表视图：create or replace view myview01asselect empno,ename,job,deptno from empwhere deptno = 20


查看视图：
-- 查看视图：select * from myview01;


向视图中插入满足条件的数据
-- 在视图中插入数据：insert into myview01 (empno,ename,job,deptno) values (9999,&#x27;lili&#x27;,&#x27;CLERK&#x27;,20);
查看视图：



向视图中插入不满足条件的数据
insert into myview01 (empno,ename,job,deptno) values (8888,&#x27;nana&#x27;,&#x27;CLERK&#x27;,30);
查看原来的表，发现成功插进去了



解决上面问题：
需要加上check option
-- 创建/替换单表视图：create or replace view myview01asselect empno,ename,job,deptno from empwhere deptno = 20with check option;
这样不满足条件的数据就不会轻易被加进去：



实例二：多表视图
-- 创建/替换多表视图：create or replace view myview02as select e.empno,e.ename,e.sal,d.deptno,d.dnamefrom emp ejoin dept don e.deptno = d.deptnowhere sal &gt; 2000 ;select * from myview02;
实例三：统计视图
-- 创建统计视图：create or replace view myview03asselect e.deptno,d.dname,avg(sal),min(sal),count(1)from emp ejoin dept dusing(deptno)group by e.deptno ;select * from myview03;
实例四：基于视图的视图
-- 创建基于视图的视图：create or replace view myview04asselect * from myview03 where deptno = 20;select * from myview04;
3. 存储过程
概念


通过前面章节的学习，我们已经知道SQL是一种非常便利的语言。从数据库抽取数据，或者对特定的数据集中更新时，都能通过简洁直观的代码实现。


但是这个所谓的“简洁”也是有限制，SQL基本是一个命令实现一个处理，是所谓的非程序语言。


在不能编写流程的情况下，所有的处理只能通过一个个命令来实现。当然，通过使用连接及子查询，即使使用SQL的单一命令也能实现一些高级的处理，但是，其局限性是显而易见的。例如，在SQL中就很难实现针对不同条件进行不同的处理以及循环等功能。


这个时候就出现了存储过程这个概念，简单地说，存储过程就是数据库中保存(Stored)的一系列SQL命令（Procedure）的集合。也可以将其看作相互之间有关系的SQL命令组织在一起形成的一个小程序。


优点

提高执行性能。存储过程执行效率之所高，在于普通的SQL语句，每次都会对语法分析，编译，执行，而存储过程只是在第一次执行语法分析，编译，执行，以后都是对结果进行调用。
可减轻网络负担。使用存储过程，复杂的数据库操作也可以在数据库服务器中完成。只需要从客户端(或应用程序)传递给数据库必要的参数就行，比起需要多次传递SQL命令本身，这大大减轻了网络负担。
可将数据库的处理黑匣子化。应用程序中完全不用考虑存储过程的内部详细处理，只需要知道调用哪个存储过程就可以了

实例


定义一个没有返回值的存储过程
-- 定义一个没有返回值 存储过程-- 实现：模糊查询操作：select * from emp where ename like &#x27;%A%&#x27;;create procedure mypro01(name varchar(10))begin        if name is null or name = &quot;&quot; then                select * from emp; -- 传入null，就查看全表        else    select * from emp where ename like concat(&#x27;%&#x27;,name,&#x27;%&#x27;);         end if;	end;-- 删除存储过程：drop procedure mypro01;-- 调用存储过程：call mypro01(null);call mypro01(&#x27;R&#x27;);
结果：



定义一个有返回值的存储过程
-- 定义一个有返回值的存储过程-- in 参数前面的in可以不写-- out -- found_rows() 是mysql定义的一个函数，作用返回查询结果的条数-- into create procedure mypro02 (in name varchar(10),out num int(4))begin 		if name is null or name = &quot;&quot; then				select * from emp;		else 				select * from emp where name like concat(&#x27;%&#x27;,name,&#x27;%&#x27;);		end if;		select found_rows() into num;end;-- 调用存储过程call mypro02(null,@num);select @num;call mypro02(&#x27;A&#x27;,@aaa); -- 传入的参数名不一定要一样select @aaa;
结果：



]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaEE</title>
    <url>/2021/07/20/JavaEE/</url>
    <content><![CDATA[引入
​


Tomcat
HTTP协议
协议：Protocol
定义
HTTP协议是**Hyper Text Transfer Protocol（超文本传输协议）**的缩写, HTTP是万维网（WWW:World Wide Web）的数据通信的基础。
HTTP是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。

HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

特点
1支持客户/服务器模式
HTTP协议支持客户端服务端模式，需要使用浏览器作为客户端来访问服务端。
2简单快速
客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST等。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
3灵活
HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。
4无连接
每次请求一次，释放一次连接。所以无连接表示每次连接只能处理一个请求。优点就是节省传输时间，实现简单。我们有时称这种无连接为短连接。对应的就有了长链接，长连接专门解决效率问题。当建立好了一个连接之后，可以多次请求。但是缺点就是容易造成占用资源不释放的问题。当HTTP协议头部中字段Connection：keep-alive表示支持长链接。
5单向性
服务端永远是被动的等待客户端的请求。
6无状态
HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。为了解决HTTP协议无状态，于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。
HTTP协议发展和版本
http协议在1991年发布第一个版本版本号为0.9。随后WWW联盟（WWW Consortium-W3C）于1994年成立，http协议被纳入到W3C组织中进行维护和管理。
http1.0
最早在1996年在网页中使用，内容简单，所以浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）,请求只能由客户端发起（单向性）。
http1.1
到1999年广泛在各大浏览器网络请求中使用，HTTP/1.0中默认使用Connection: close。在HTTP/1.1中已经默认使用Connection: keep-alive（长连接），避免了连接建立和释放的开销，但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。
1.1中最重要的一个特点是支持“长连接”，即“一次连接可以多次请求”。
HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。
http2.0
长连接
在HTTP/2中，客户端向某个域名的服务器请求页面的过程中，只会创建一条TCP连接，即使这页面可能包含上百个资源。  单一的连接应该是HTTP2的主要优势，单一的连接能减少TCP握手带来的时延。HTTP2中用一条单一的长连接，避免了创建多个TCP连接带来的网络开销，提高了吞吐量。
多路复用 (Multiplexing)
HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。
多路复用，连接共享。不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成正常的请求）。
HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。
帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。
首部压缩（Header Compression）
由于1.1中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的hearder大小。
服务端推送（Server Push）
在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。
可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。
更安全
HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。
Servlet
1.   引入
介绍
Servlet是Server Applet的简称，称为服务端小程序，是JavaEE平台下的技术标准，基于Java语言编写的服务端程序。Web容器或应用服务器实现了Servlet标准所以Servlet需运行在Web容器或应用服务器中。Servlet主要功能在于能在服务器中执行并生成数据。
特点
使用单进程多线程方式运行

应用程序中的位置

静态资源和动态资源的区分

静态资源：每次访问都不需要运算，直接就可以返回的资源，如HTML CSS JS 多媒体文件等等 每次访问获得地资源都是一样的
动态资源：每次访问都需要运算代码生成的资源如 Servlet JSP 每次访问获得的结果可能都是不一样的

Servlet 作为一种动态资源技术 是后面学习框架的基础
Servlet在程序中的地位
Servlet是可以接受Http请求并作出相应的一种技术,是JAVA语言编写的一种动态资源
Servlet是前后端衔接的一种技术,不是所有的JAVA类都可以接收请求和作出相应,Servlet可以
在MVC模式中,Servlet作为Controller层(控制层)主要技术,用于和浏览器完成数据交互,控制交互逻辑
==servlet三大域对象==
Servlet三大域对象的应用 request、session、application（ServletContext）
ServletContext是一个全局的储存信息的空间，服务器开始就存在，服务器关闭才释放。
request，一个用户可有多个；session，一个用户一个；而servletContext，所有用户共用一个。所以，为了节省空间，提高效率，ServletContext中，要放必须的、重要的、所有用户需要共享的线程又是安全的一些信息。
案例1：初步认识


创建一个JAVAWEB项目，并在项目中开发一个自己的Servlet，继承HttpServlet类




在MyServlet类中重写service方法



在service方法中定义具体的功能代码
@Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    //动态生成数据    //随机生成一个整数    int num = new Random().nextInt();    String message = (num%2==0)?&quot;happy birthday&quot;:&quot;happy new year&quot;;    //对浏览器做出响应    PrintWriter writer = resp.getWriter();//该打印流指向了浏览器    writer.write(message);&#125;


在web.xml中配置Servlet的映射路径
&lt;!--向Tomcat声明一个Servlet--&gt;&lt;servlet&gt;    &lt;servlet-name&gt;myFirstServlet&lt;/servlet-name&gt;&lt;!--这只是别名--&gt;    &lt;servlet-class&gt;com.chs.servlet.Myservlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--给Servlet匹配一个请求的映射路径--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;myFirstServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/mySerlvet.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;


打开浏览器请求Servlet资源



案例2：登录页
需求：
准备一个登陆页，可以输入要用户名和密码
输入完毕向Servlet提交用户名和密码
Servlet接收到用户名和密码之后校验是否正确
如果正确响应success
如果不正确响应Failed
具体步骤：


项目结构：



开发登录页：
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form method=&quot;get&quot; action=&quot;loginServlet.do&quot;&gt;            &lt;table style=&quot;margin: 0px auto&quot; width=&quot;300px&quot; cellpadding=&quot;0px&quot; cellspacing=&quot;0px&quot; border=&quot;1px&quot;&gt;                &lt;tr&gt;                    &lt;td&gt;用户名&lt;/td&gt;                    &lt;td&gt;                        &lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;密码&lt;/td&gt;                    &lt;td&gt;                        &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr align=&quot;center&quot;&gt;                    &lt;td colspan=&quot;2&quot;&gt;                        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;                    &lt;/td&gt;                &lt;/tr&gt;            &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;


开发后台Servlet
public class LoginServlet extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;login servlet invoked&quot;);        // 获取请求中的数据        String username = req.getParameter(&quot;username&quot;);        String pwd = req.getParameter(&quot;pwd&quot;);        // 判断数据        String message=null;        if(username.equals(&quot;mashibing&quot;)&amp;&amp; pwd.equals(&quot;123456&quot;))&#123;            message=&quot;Success&quot;;        &#125;else&#123;            message=&quot;Fail&quot;;        &#125;        // 作出响应        resp.getWriter().write(message);    &#125;


配置Servlet
&lt;servlet&gt;    &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.mashibing.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/loginServlet.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;welcome-file-list&gt;    &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;


运行测试


2. HttpServletRequest
一个http可以分为三个部分：请求行 请求头 请求体
请求行

请求方式：GET
请求的URL： http://192.168.56.220:8080/logOnDemo/logon.html
协议及版本： HTTP/1.1

请求头

请求体
get方式提交的请求数据通过地址栏提交 ,没有请求体
post方式提交请求数据单独放到请求体中,请求时所携带的数据 (post方式)
http支持的请求方式

==get和post的区别==
==(面试）==


GET在浏览器回退时是无害的，而POST会再次提交请求。


GET产生的URL地址可以被Bookmark，而POST不可以。


GET请求会被浏览器主动cache，而POST不会，除非手动设置。


GET请求只能进行url编码，而POST支持多种编码方式。


GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。


GET请求在URL中传送的参数是有长度限制的，而POST则没有。对参数的数据类型GET只接受ASCII字符，而POST即可是字符也可是字节。


GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。


GET参数通过URL传递，POST放在Request body中。


具体操作：获得客户端请求信息
HttpServletRequest对象代表客户端浏览器的请求，当客户端浏览器通过HTTP协议访问服务器时，HTTP请求中的所有信息都会被Tomcat所解析并封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。
1.获取请求行信息
req.getRequestURL()://返回客户端浏览器发出请求时的完整URL。req.getRequestURI()://返回请求行中指定资源部分。req.getRemoteAddr()://返回发出请求的客户机的IP地址。req.getLocalAddr()://返回WEB服务器的IP地址。req.getLocalPort()://返回WEB服务器处理Http协议的连接器所监听的端口。
2.获取请求头信息
req.getHeader(&quot;headerKey&quot;)://根据请求头中的key获取对应的value。String headerValue = req.getHeader(&quot;headerKey&quot;);req.getHeaderNames()://获取请求头中所有的key，该方法返回枚举类型。Enumeration&lt;String&gt; headerNames = req.getHeaderNames();
测试代码
public class Servlet3 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(req.getRequestURL());//返回客户端浏览器发出请求时的完整URL。        System.out.println(req.getRequestURI());//返回请求行中指定资源部分。        System.out.println(req.getRemoteAddr());//返回发出请求的客户机的IP地址。        System.out.println(req.getLocalAddr());//返回WEB服务器的IP地址。        System.out.println(req.getLocalPort());//返回WEB服务器处理Http协议的连接器所监听的端口。        System.out.println(&quot;主机名: &quot; + req.getLocalName());        System.out.println(&quot;客户端PORT: &quot; + req.getRemotePort());        System.out.println(&quot;当前项目部署名: &quot; + req.getContextPath());        System.out.println(&quot;协议名:&quot;+req.getScheme());        System.out.println(&quot;请求方式:&quot;+req.getMethod());        // 根据请求头名或者请求头对应的值        System.out.println(req.getHeader(&quot;Accept&quot;));        // 获得全部的请求头名        Enumeration&lt;String&gt; headerNames = req.getHeaderNames();        while (headerNames.hasMoreElements())&#123;            String headername = headerNames.nextElement();            System.out.println(headername+&quot;:&quot;+req.getHeader(headername));        &#125;    &#125;&#125;
3.获取请求数据


根据key获取指定value:
req.getParameter(&quot;key&quot;)://根据key获取指定value。


获java取复选框(checkbox组件)中的值（多个值）：
req.getParameterValues(&quot;checkboxkey&quot;)://获取复选框(checkbox组件)中的值，返回一个String[]。


获取所有提交数据的key
req.getParameterNames()://获取请求中所有数据的key，该方法返回一个枚举类型。


使用Map结构获取提交数据
req.getParameterMap()://获取请求中所有的数据并存放到一个Map结构中，该方法返回一个Map，其中key为String类型value为String[]类型。


设置请求编码
req.setCharacterEncoding(&quot;utf-8&quot;)
请求的数据包基于字节在网络上传输，Tomcat接收到请求的数据包后会将数据包中的字节转换为字符。在Tomcat中使用的是ISO-8859-1的单字节编码完成字节与字符的转换，所以数据中含有中文就会出现乱码，可以通过req.setCharacterEncoding(“utf-8”)方法来对提交的数据根据指定的编码方式重新做编码处理。


案例3:HTTP请求
需求 ：获得前端客户端表单中请求的数据信息
前端代码
开发form表单注意事项


form 不是from


form表单内部不是所有的标签信息都会提交 一些输入信息  input select textarea … …


提交的标签必须具备name属性  name属性的作用是让后台区分数据  id便于在前端区分数据


提交的标签一般都要具备value属性  value属性确定我们要提交的具体的数据


==get post==区别
get方式数据是通过URL携带
提交的数据只能是文本
提交的数据量不大
get方式提交的数据相对不安全
post 将数据单独打包放到请求体中
提交的数据可以是文本可以是各种文件
提交的数据量理论上没有上限
post方式提交数据相对安全


==readonly只读== 也是会提交数据的
==hidden==  隐藏 也是会提交数据
==disabled== 不可用 显示但是不提交
代码：
&lt;form method=&quot;get&quot; action=&quot;myServlet&quot;&gt;    &lt;table style=&quot;margin: 0px auto&quot; width=&quot;300px&quot; cellpadding=&quot;0px&quot; cellspacing=&quot;0px&quot; border=&quot;1px&quot;&gt;        &lt;tr&gt;            &lt;td&gt;用户名&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;in1&quot; value=&quot;12345&quot; disabled &gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;密码&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;性别&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; checked&gt;男                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;女            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;爱好&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt;蓝球                &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt;足球                &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;3&quot;&gt;羽毛球                &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;4&quot;&gt;乒乓球            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;个人简介&lt;/td&gt;            &lt;td&gt;                &lt;!--文本域 双标签 页面上显示的文字是双标签中的文本 不是value属性                    文本域提交的数据不是value属性值,是双标签中的文本                --&gt;                &lt;textarea name=&quot;introduce&quot; &gt;b&lt;/textarea&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;籍贯&lt;/td&gt;            &lt;td&gt;                &lt;!--                select                option没有定义value属性 那么就提交option中间的文字(不推荐)                --&gt;                &lt;select name=&quot;provience&quot;&gt;                    &lt;option value=&quot;1&quot;&gt;a京&lt;/option&gt;                    &lt;option value=&quot;2&quot;&gt;b津&lt;/option&gt;                    &lt;option value=&quot;3&quot;&gt;c冀&lt;/option&gt;                &lt;/select&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td colspan=&quot;2&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交数据&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;
效果：

Servlet代码
public class MyServlet extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // req获取参数        // 如果 前端发过来的数据由数据名但是没有值, getParameter返回的是一个空字符串  &quot;&quot;        // 获取的参数在提交的数据中名都没有,getParameter返回的是null        String username = req.getParameter(&quot;username&quot;);        System.out.println(&quot;username:&quot;+username);        System.out.println(&quot;password:&quot;+req.getParameter(&quot;pwd&quot;));        System.out.println(&quot;gender:&quot;+req.getParameter(&quot;gender&quot;));        // hobby=1&amp;hobby=2&amp;hobby=3 想要获得多个同名的参数 getParameterValues 返回的是一个Sting数组        String[] hobbies = req.getParameterValues(&quot;hobby&quot;);        System.out.println(&quot;hobbies:&quot;+ Arrays.toString(hobbies));        // textarea        System.out.println(&quot;introduce:&quot;+req.getParameter(&quot;introduce&quot;));        // select        System.out.println(&quot;provience:&quot;+req.getParameter(&quot;provience&quot;));        System.out.println(&quot;___________________________&quot;);        // 如果不知道参数的名字?        // 获取所有的参数名        Enumeration&lt;String&gt; pNames = req.getParameterNames();        while(pNames.hasMoreElements())&#123;            String pname = pNames.nextElement();            String[] pValues = req.getParameterValues(pname);            System.out.println(pname+&quot;:&quot;+Arrays.toString(pValues));        &#125;        System.out.println(&quot;________________________________&quot;);        Map&lt;String, String[]&gt; pmap = req.getParameterMap();        Set&lt;Map.Entry&lt;String, String[]&gt;&gt; entries = pmap.entrySet();        for (Map.Entry&lt;String, String[]&gt; entry : entries) &#123;            System.out.println(entry.getKey()+&quot;:&quot;+Arrays.toString(entry.getValue()));        &#125;    &#125;&#125;
运行结果：

3. HttpServletResponse
http响应部分可以分为三部分：响应行，响应头，响应体
响应行

响应状态码列表

响应头
Content-Type：响应内容的类型(MIME)

响应实体
即服务器响应回来的内容
​		HttpServletResponse对象代表服务器的响应，封装了响应客户端浏览器的流对象，以及向客户端浏览器响应的响应头、响应数据、响应状态码等信息。
ContentType:响应设置
resp.setContentType(&quot;MIME&quot;)://该方法可通过MIME-Type设置响应类型。
MIME
全称是Multipurpose Internet Mail Extensions，即多用途互联网邮件扩展类型。
这是HTTP协议中用来定义文档性质及格式的标准。对HTTP传输内容类型进行了全面定义。
服务器通过MIME告知响应内容类型，而浏览器则通过MIME类型来确定如何处理文档。
HTTP content-type 类型表：
https://www.runoob.com/http/http-content-type.html
常见的媒体格式类型如下：

text/html ： HTML格式
text/plain ：纯文本格式
text/xml ： XML格式
image/gif ：gif图片格式
image/jpeg ：jpg图片格式
image/png：png图片格式

以application开头的媒体格式类型：

application/xhtml+xml ：XHTML格式
application/xml： XML数据格式
application/atom+xml ：Atom XML聚合格式
application/json： JSON数据格式
application/pdf：pdf格式
application/msword ： Word文档格式
application/octet-stream ： 二进制流数据（如常见的文件下载）
application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

另外一种常见的媒体格式是上传文件之时使用的：

multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式

常见的字节型响应：


image/jpeg：图片类型为jpeg或jpg格式。


image/gif: 图片类型为gif格式。


设置响应编码
response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;text/html;charset=utf-8&quot;);
设置服务端为浏览器产生响应的响应编码，服务端会根据此编码将响应内容的字符转换为字节。同时客户端浏览器会根据此编码方式显示响应内容。
在响应中添加附加信息（文件下载）
在实现文件下载时，我们需要修改响应头，添加附加信息。
response.setHeader(&quot;Content-Disposition&quot;,   &quot;attachment; filename=&quot;+文件名);
==Content-Disposition:attachment==
该附加信息表示作为对下载文件的一个标识字段。不会在浏览器中显示而是直接做下载处理。
filename=文件名,表示指定下载文件的文件名。
解决文件名中文乱码问题:
resp.addHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+new String (file.getName().getBytes(&quot;gbk&quot;),&quot;iso-8859-1&quot;));
测试代码
public class MyServlet2 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 设置响应码        //resp.setStatus(500);        //resp.setStatus(405, &quot;request method not supported&quot;);        // 设置响应头        //resp.setHeader(&quot;Date&quot;,&quot;2022-11-11&quot;);        // 自定义头        // resp.setHeader(&quot;aaa&quot;, &quot;bbb&quot;);        // 高速浏览器响应的数据是什么? 浏览器根据此头决定 数据如何应用        // 设置MIME类型 json  xml 文件下载  ... ...        // resp.setHeader(&quot;content-type&quot;, &quot;text/css&quot;);        resp.setContentType(&quot;text/html&quot;);// 专门用于设置Content-Type 响应头        resp.getWriter().write(&quot;&lt;h1&gt;this is tag h1&lt;/h1&gt;&quot;);    &#125;&#125;
乱码问题
1 控制台乱码
设置Tomcat中 conf下logging.properties中所有的UTF-8编码为GBK即可
2 post请求乱码
通过HttpServletRequest设置请求编码
req.setCharacterEncoding(&quot;UTF-8&quot;);
3 get请求乱码
需要手动进行编码解码,或者设置tomcat中的server.xml中的URI编码.tomcat9已经解决了该问题
&lt;Connector   port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;    connectionTimeout=&quot;20000&quot;    redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot;  /&gt;
4 响应乱码
通过HttpServletResponse设置响应编码
//以UTF-8编码处理数据resp.setContentType(&quot;UTF-8&quot;);//设置响应头,以便浏览器知道以何种编码解析数据resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
4. servlet生命周期
四个阶段
Servlet的生命周期是由容器管理的，分别经历四个阶段：



阶段
次数
时机




创建 new
1次
第一次请求


初始化 init()
1次
实例化之后


执行服务 service()
多次
每次请求


销毁 destroy()
1次
停止服务



当客户端浏览器第一次请求Servlet时，容器会实例化这个Servlet，然后调用一次init方法，并在新的线程中执行service方法处理请求。service方法执行完毕后容器不会销毁这个Servlet而是做缓存处理，当客户端浏览器再次请求这个Servlet时，容器会从缓存中直接找到这个Servlet对象，并再一次在新的线程中执行Service方法。当容器在销毁Servlet之前对调用一次destory方法。
在Servlet中我们一般不要轻易使用成员变量!!! 可能会造成线程安全问题
如果要使用的话,应该尽量避免对成员变量产生修改
如果要产生修改我们应该注意线程安全问题
如果我们自己添加线程安全编码处理,会严重影响效率
综上所述:原则,能不用成员变量就不用!!!
servlet代码：
public class MyServlet4 extends HttpServlet &#123;    // 成员变量    public MyServlet4()   &#123;// 构造一个Servlet对象的方法        System.out.println(&quot;MyServlet4 Constructor invoked&quot;);        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void init() throws ServletException &#123;// 初始化        System.out.println(&quot;MyServlet4 init invoked&quot;);        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 执行服务        System.out.println(&quot;MyServlet4 service invoked&quot;);    &#125;    @Override    public void destroy() &#123;// 销毁        System.out.println(&quot;MyServlet4 destory invoked&quot;);    &#125;&#125;
配置：
&lt;servlet&gt;    &lt;servlet-name&gt;myServlet4&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.mashibing.servlet.MyServlet4&lt;/servlet-class&gt;    &lt;load-on-startup&gt;6&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;myServlet4&lt;/servlet-name&gt;    &lt;url-pattern&gt;/myServlet4.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;
​		多次请求servlet并查看控制台输出即可印证上述结论,值得注意的是,如果需要Servlet在服务启动时就实例化并初始化,我们可以在servlet的配置中添加load-on-startup配置启动顺序,配置的数字为启动顺序,应避免冲突且应**&gt;6**

Servlet处理请求的过程
​		当浏览器基于get方式请求我们创建Servlet时，我们自定义的Servlet中的doGet方法会被执行。doGet方法能够被执行并处理get请求的原因是，容器在启动时会解析web工程中WEB-INF目录中的web.xml文件，在该文件中我们配置了Servlet与URI的绑定，容器通过对请求的解析可以获取请求资源的URI，然后找到与该URI绑定的Servlet并做实例化处理(注意：只实例化一次，如果在缓存中能够找到这个Servlet就不会再做次实例化处理)。在实例化时会使用Servlet接口类型作为引用类型的定义，并调用一次init方法，由于HttpServlet中重写了该方法所以最终执行的是HttpServlet中init方法(HttpServlet中的Init方法是一个空的方法体)，然后在新的线程中调用service方法。由于在HttpServlet中重写了Service方法所以最终执行的是HttpServlet中的service方法。在service方法中通过request.getMethod()获取到请求方式进行判断如果是Get方式请求就执行doGet方法，如果是POST请求就执行doPost方法。如果是基于GET方式提交的，并且在我们自定义的Servlet中又重写了HttpServlet中的doGet方法，那么最终会根据Java的多态特性转而执行我们自定义的Servlet中的doGet方法。


老程序员喜欢重写doGet()和doPost()方法 然后挑一个方法里面直接调用另一个方法，因为两个方法很相似。
但是又可以直接重写service，可以同时处理get和post

5. ServletContext和ServletConfig
ServletContext(application)
定义
ServletContext官方叫Servlet上下文。服务器会为每一个Web应用创建一个ServletContext对象。这个对象全局唯一，而且Web应用中的所有Servlet都共享这个对象。所以叫全局应用程序共享对象

作用

相对路径转绝对路径
获取容器的附加信息
读取配置信息
全局容器

操作


获取项目的部署名
==context.getContextPath()==


相对路径转绝对路径(文件上传下载时需要注意)
==context.getRealPath(“path”)==
该方法可以将一个相对路径转换为绝对路径，在文件上传与下载时需要用到该方法做路径的转换。


获取容器的附加信息
==servletContext.getServerInfo()==


返回Servlet容器的名称和版本号


返回Servlet容器所支持Servlet的主版本号
==servletContext.getMajorVersion()==


返回Servlet容器所支持Servlet的副版本号
==servletContext.getMinorVersion()==




获取web.xml文件中的信息
&lt;context-param&gt;    &lt;param-name&gt;key&lt;/param-name&gt;    &lt;param-value&gt;value&lt;/param-value&gt;&lt;/context-param&gt;


读取web.xml文件中标签中的配置信息
==servletContext.getInitParameter(“key”)==


读取web.xml文件中所有param-name标签中的值。
==servletContext.getInitParameterNames()==




全局容器


向全局容器中存放数据。
==servletContext.setAttribute(“key”,ObjectValue)==


从全局容器中获取数据。
==servletContext.getAttribute(“key”)==


根据key删除全局容器中的value。
==servletContext.removeAttribute(“key”)==




测试代码：
xml配置
&lt;context-param&gt;    &lt;param-name&gt;username&lt;/param-name&gt;    &lt;param-value&gt;mashibing&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt;    &lt;param-name&gt;password&lt;/param-name&gt;    &lt;param-value&gt;123456&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt;    &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.msb.testServlet.Servlet1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;    &lt;url-pattern&gt;/servlet1.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;
servlet
public class Servlet1 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //1 通过req获取Servlet对象        ServletContext servletContext1 = req.getServletContext();        //通过继承的方法获取Servlet对象        ServletContext servletContext2 = this.getServletContext();        //比较两种获取方法获取的对象        System.out.println(servletContext1==servletContext2);        //2 获取部署名        String contextPath = servletContext1.getContextPath();        System.out.println(&quot;contextPath&quot;+contextPath);        //3 将一个相对路径转换为项目的绝对路径        String fileUpload = servletContext1.getRealPath(&quot;fileUpload&quot;);        System.out.println(fileUpload);        //4 获取容器的附加信息        String serverInfo = servletContext1.getServerInfo();        System.out.println(serverInfo);        //5 获取Servlet容器的名称和版本号        //主版本号        int majorVersion = servletContext1.getMajorVersion();        //副版本号        int minorVersion = servletContext1.getMinorVersion();        System.out.println(&quot;majorVersion&quot;+majorVersion);        System.out.println(&quot;minorVersion&quot;+minorVersion);        //6 读取web.xml文件信息        //获取配置的全局初始信息        String username = servletContext1.getInitParameter(&quot;username&quot;);        String password = servletContext1.getInitParameter(&quot;password&quot;);        System.out.println(&quot;username&quot;+username);        System.out.println(&quot;password&quot;+password);        //配置信息名称未知情况下 获取全局初始信息        Enumeration&lt;String&gt; pNames = servletContext1.getInitParameterNames();        while (pNames.hasMoreElements())&#123;            String e = pNames.nextElement();            System.out.println(e+&quot;:&quot;+ servletContext1.getInitParameter(e));        &#125;        //7 向ServletContext对象中增加数据域对象        List&lt;String&gt; data = new ArrayList&lt;&gt;();        Collections.addAll(data,&quot;张三&quot;,&quot;李四&quot;,&quot;王武&quot;);        servletContext1.setAttribute(&quot;list&quot;,data);        servletContext1.setAttribute(&quot;gender&quot;,&quot;boy&quot;);        //getAttribute也可以获得初始信息对象        List&lt;String&gt; list = (List&lt;String&gt;) servletContext1.getAttribute(&quot;list&quot;);        System.out.println(list);        String gender = (String) servletContext1.getAttribute(&quot;gender&quot;);        System.out.println(gender);    &#125;&#125;
测试结果

生命周期
​		当容器启动是会创建ServletContext对象并一直缓存该对象，知道容器关闭后该对象生命周期结束。ServletContext对象的生命周期非常长，所以在使用全局容器时不建议存放业务数据
ServletConfig
定义
ServletConfig对象对应web.xml文件中的节点。当Tomcat初始化一个Servlet时，会将该Servlet的配置信息，封装到一个ServletConfig对象中。
操作
我们通过Config对象读取servlet节点中的配置信息
&lt;servlet&gt;    &lt;servlet-name&gt;servletName&lt;/servlet-name&gt;    &lt;servlet-class&gt;servletClass&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;key&lt;/param-name&gt;        &lt;param-value&gt;value&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;


读取web.xml文件中标签中标签中的配置信息。
==servletConfig.getInitParameter(“key”);==


读取web.xml文件中当前标签中所有标签中的值。
==servletConfig.getInitParameterNames();==


测试代码
xml配置
&lt;servlet&gt;    &lt;servlet-name&gt;servlet3&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.msb.testServlet.Servlet3&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;brand&lt;/param-name&gt;        &lt;param-value&gt;ASUS&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;screen&lt;/param-name&gt;        &lt;param-value&gt;三星&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet&gt;    &lt;servlet-name&gt;servlet4&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.msb.testServlet.Servlet4&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;pinpai&lt;/param-name&gt;        &lt;param-value&gt;联想&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;pingmu&lt;/param-name&gt;        &lt;param-value&gt;京东方&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;servlet3&lt;/servlet-name&gt;    &lt;url-pattern&gt;/servlet3.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;servlet4&lt;/servlet-name&gt;    &lt;url-pattern&gt;/servlet4.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;
servlet
public class Servlet3 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        ServletConfig servletConfig = this.getServletConfig();        System.out.println(servletConfig.getInitParameter(&quot;brand&quot;));        System.out.println(servletConfig.getInitParameter(&quot;screen&quot;));    &#125;&#125;
public class Servlet4 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        ServletConfig servletConfig = this.getServletConfig();        System.out.println(servletConfig.getInitParameter(&quot;pinpai&quot;));        System.out.println(servletConfig.getInitParameter(&quot;pingmu&quot;));    &#125;&#125;
6. URL的匹配规则
精确匹配
精确匹配是指中配置的值必须与url完全精确匹配。
&lt;servlet-mapping&gt;    &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/demo.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;
http://localhost:8888/demo/demo.do 匹配
http://localhost:8888/demo/suibian/demo.do 不匹配
扩展名匹配
在允许使用统配符“”作为匹配规则，“”表示匹配任意字符。在扩展名匹配中只要扩展名相同都会被匹配和路径无关。注意，在使用扩展名匹配时在中不能使用“/”，否则容器启动就会抛出异常。
&lt;servlet-mapping&gt;    &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;
http://localhost:8888/demo/abc.do 匹配
http://localhost:8888/demo/suibian/haha.do 匹配
http://localhost:8888/demo/abc 不匹配
路径匹配
根据请求路径进行匹配，在请求中只要包含该路径都匹配，“*”表示任意路径以及子路径
&lt;servlet-mapping&gt;    &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/suibian/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;
http://localhost:8888/demo/suibian/haha.do 匹配
http://localhost:8888/demo/suibian/hehe/haha.do 匹配
http://localhost:8888/demo/hehe/heihei.do 不匹配
任意匹配
匹配“/ 匹配所有但不包括JSP页面
&lt;url-pattern&gt;/&lt;/url-pattern&gt;
http://localhost:8888/demo/suibian.do匹配
http://localhost:8888/demo/addUser.html匹配
http://localhost:8888/demo/css/view.css匹配
http://localhost:8888/demo/addUser.jsp不匹配
http://localhost:8888/demo/user/addUser.jsp不匹配
匹配所有
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
http://localhost:8888/demo/suibian.do匹配
http://localhost:8888/demo/addUser.html匹配
http://localhost:8888/demo/suibian/suibian.do匹配
优先顺序
当一个url与多个Servlet的匹配规则可以匹配时，则按照 “ 精确路径 &gt; 最长路径 &gt;扩展名”这样的优先级匹配到对应的Servlet。
案例分析
Servlet1映射到 /abc/*
Servlet2映射到 /*
Servlet3映射到 /abc
Servlet4映射到 *.do
当请求URL为“/abc/a.html”，“/abc/”和“/”都匹配，Servlet引擎将调用Servlet1。
当请求URL为“/abc”时，“/abc/*”和“/abc”都匹配，Servlet引擎将调用Servlet3。
当请求URL为“/abc/a.do”时，“/abc/”和“.do”都匹配，Servlet引擎将调用Servlet1。
当请求URL为“/a.do”时，“/”和“.do”都匹配，Servlet引擎将调用Servlet2。
当请求URL为“/xxx/yyy/a.do”时，“/”和“.do”都匹配，Servlet引擎将调用Servlet2。
URL映射方式
在web.xml文件中支持将多个URL映射到一个Servlet中，但是相同的URL不能同时映射到两个Servlet中。
方式一
&lt;servlet-mapping&gt;    &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/suibian/*&lt;/url-pattern&gt;    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;
方式二
&lt;servlet-mapping&gt;    &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/suibian/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;
7. 注解开发
基于注解式开发Servlet
​	在Servlet3.0以及之后的版本中支持注解式开发Servlet。对于Servlet的配置不在依赖于web.xml配置文件而是使用@WebServlet将一个继承于javax.servlet.http.HttpServlet的类定义为Servlet组件。
@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet &#123;    String name() default &quot;&quot;;    String[] value() default &#123;&#125;;    String[] urlPatterns() default &#123;&#125;;    int loadOnStartup() default -1;    WebInitParam[] initParams() default &#123;&#125;;    boolean asyncSupported() default false;    String smallIcon() default &quot;&quot;;    String largeIcon() default &quot;&quot;;    String description() default &quot;&quot;;    String displayName() default &quot;&quot;;&#125;
相关属性

8. forward 请求转发
forward处理流程

清空Response存放响应正文数据的缓冲区
如果目标资源为Servlet或JSP，就调用它们的service()方法，把该方法产生的响应结果发送到客户端；如果目标资源文件系统中的静态HTML，就读取文档中的数据把它发送到客户端。



请求转发是一种服务器的行为,是对浏览器屏蔽
浏览器的地址栏不会发生变化
请求的参数是可以从源组件传递到目标组件的
请求对象和响应对象没有重新创建,而是传递给了目标组件
请求转发可以帮助我们完成页面的跳转
请求转发可以转发至WEB-INF里
请求转发只能转发给当前项目的内部资源,不能转发至外部资源
常用forward

forword处理特点

由于forword()方法先清空用于存放响应正文的缓冲区，因此源Servlet生成的响应结果不会被发送到客户端，只有目标资源生成的响应结果才会被发送到客户端。
如果源Servlet在进行请求转发之前，已经提交了响应结（flushBuffer(),close()方法），那么forward()方法抛出IllegalStateException。为了避免该异常，不应该在源Servlet中提交响应结果。

注意


在forward转发模式下,请求应该完全交给目标资源去处理,我们在源组件中,不要作出任何的响应处理


在forward方法调用之后,也不要在使用req和resp对象做其他操作了


测试代码
servlet1 请求转发至 servlet2
servlet1
@WebServlet(urlPatterns = &quot;/servlet1.do&quot;)public class Servlet1 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;servlet1 service invoked&quot;);        String money = req.getParameter(&quot;money&quot;);        System.out.println(&quot;money:&quot;+money);        // 设置响应类型和编码(include模式下)        /*  resp.setCharacterEncoding(&quot;UTF-8&quot;);        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);*/        // 增加响应内容        //resp.getWriter().println(&quot;servlet1在转发之前增加的响应内容&quot;);        // 请求转发给另一个组件        // 获得一个请求转发器        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;servlet2.do&quot;);        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;aaa.html&quot;);        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;index.jsp&quot;);        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/bbb.html&quot;);        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;https://www.baidu.com&quot;);        // 由请求转发器作出转发动作        requestDispatcher.forward(req,resp);// 托管给目标资源(forward多一些)        //requestDispatcher.include(req,resp);  // 让目标资源完成部分工作        // 继续增加响应信息 (include模式)        //resp.getWriter().println(&quot;servlet1在转发之后增加的响应内容&quot;);           &#125;&#125;
Servlet2
@WebServlet(urlPatterns = &quot;/servlet2.do&quot;)public class Servlet2 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;servlet2 service invoked&quot;);        // 接收参数        String money = req.getParameter(&quot;money&quot;);        System.out.println(&quot;money:&quot;+money);        // 作出响应 (在forWord模式下)        resp.setCharacterEncoding(&quot;UTF-8&quot;);        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter writer = resp.getWriter();        writer.println(&quot;支付宝到账:&quot;+money+&quot;元&quot;);    &#125;&#125;
include（了解）
在include转发模式下,设置响应可以在转发之前,也可以在转发之后
/*servlet1在转发之前增加的响应内容*/// 设置响应类型和编码(include模式下)        resp.setCharacterEncoding(&quot;UTF-8&quot;);        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);        // 增加响应内容        resp.getWriter().println(&quot;servlet1在转发之前增加的响应内容&quot;);// 获得一个请求转发器        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;servlet2.do&quot;);// 让目标资源完成部分工作		requestDispatcher.include(req,resp);  /*servlet1在转发之后增加的响应内容*/// 继续增加响应信息 (include模式)		resp.getWriter().println(&quot;servlet1在转发之后增加的响应内容&quot;);
但是不常用的
9. sendRedirect 响应重定向
响应重定向是通过HttpServletResponse对象sendRedirect(“路径”)的方式。实现是——服务器通知浏览器,让浏览器去自主请求其他资源的一种方式

运作流程：

用户在浏览器端输入特定URL，请求访问服务器端的某个Servlet。
服务器端的Servlet返回一个状态码为302的响应结果，该响应结果的含义为：让浏览器端再请求访问另一个Web资源，在响应结果中提供了另一个Web资源的URL。另一个Web资源有可能在同一个Web服务器上，也有可能不再同一个Web服务器上。
当浏览器端接收到这种响应结果后，再立即自动请求访问另一个Web资源。
浏览器端接收到另一个Web资源的响应结果。

测试代码:
servlet3
@WebServlet(urlPatterns = &quot;/servlet3.do&quot;)public class Servlet3 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;servlet3 service invoked&quot;);        String money = req.getParameter(&quot;money&quot;);        System.out.println(&quot;money:&quot;+money);        // 响应重定向        resp.sendRedirect(&quot;servlet4.do?money=&quot;+money);        //resp.sendRedirect(&quot;WEB-INF/bbb.html&quot;);        //resp.sendRedirect(&quot;https://www.baidu.com&quot;);    &#125;&#125;
servlet4
@WebServlet(urlPatterns = &quot;/servlet4.do&quot;)public class Servlet4 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;servlet4 service invoked&quot;);        String money = req.getParameter(&quot;money&quot;);        System.out.println(&quot;money:&quot;+money);    &#125;&#125;
注意

重定向是服务器给浏览器重新指定请求方向 是一种浏览器行为 地址栏会发生变化
重定向时,请求对象和响应对象都会再次产生,请求中的参数是不会携带
重定向也可以帮助我们完成页面跳转
重定向不能帮助我们访问WEB-INF中的资源
重定向可以定向到外部资源

10. 路径问题
前端路径
项目结构

测试代码
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;!--    base标签的作用是在相对路径之前自动补充base[href]中的值    如果base标签不写,那么默认就是当前文件所在的路径    --&gt;    &lt;base href=&quot;http://127.0.0.1:8080/testServlet4_war_exploded/&quot;&gt;    &lt;!--&lt;base href=&quot;http://127.0.0.1:8080/testServlet4_war_exploded/a/a2/&quot;&gt;--&gt;&lt;/head&gt;&lt;body&gt;this is page a1&lt;br/&gt;    &lt;!--    相对(基准)路径:以当前文件本身的位置去定位其他文件,相对自己的路径,以当前文件所在的位置为基准位置    绝对(基准)路径:以一个固定的位置去定位其他文文件,以一个固定的路径作为定位文件的基准位置,和文件本身位置无关    相对路径,不以/开头,就是相对路径  ..代表向上一层    绝对路径,以/开头   在页面上 /代表从项目的部署目录开始找  从webapps中开始找    页面的绝对路径要有项目名,除非我们的项目没有设置项目名    --&gt;    &lt;a href=&quot;a2.html&quot; TARGET=&quot;_self&quot;&gt;相对路径跳转至A2&lt;/a&gt;    &lt;a href=&quot;../../b/b2/b1.html&quot; TARGET=&quot;_self&quot;&gt;相对路径跳转至b1&lt;/a&gt;    &lt;br/&gt;    &lt;a href=&quot;a/a2/a2.html&quot; TARGET=&quot;_self&quot;&gt;base相对路径跳转至A2&lt;/a&gt;    &lt;a href=&quot;b/b2/b1.html&quot; TARGET=&quot;_self&quot;&gt;base相对路径跳转至b1&lt;/a&gt;    &lt;br/&gt;    &lt;a href=&quot;/testServlet4_war_exploded/a/a2/a2.html&quot; TARGET=&quot;_self&quot;&gt;绝对路径跳转至A2&lt;/a&gt;    &lt;a href=&quot;/testServlet4_war_exploded/b/b2/b1.html&quot; TARGET=&quot;_self&quot;&gt;绝对路径跳转至b1&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;
总结


以/开头的路径是绝对路径,不以/开头是相对路径


绝对路径/后面要写当前服务的上下文路径名


==…/==代表向上一层的路径


==base标签==可以简化相对路径,当使用相对路径时,默认会在相对路径之前补充 base中的内容；如果没有定义base 默认就是当前文件所在的路径


11. 会话管理
认识Cookie和Session
Cookie对象与HttpSession对象的作用是维护客户端浏览器与服务端的会话状态的两个对象。由于HTTP协议是一个无状态的协议，所以服务端并不会记录当前客户端浏览器的访问状态，但是在有些时候我们是需要服务端能够记录客户端浏览器的访问状态的，如获取当前客户端浏览器的访问服务端的次数时就需要会话状态的维持。在Servlet中提供了Cookie对象与HttpSession对象用于维护客户端与服务端的会话状态的维持。二者不同的是Cookie是通过客户端浏览器实现会话的维持，而HttpSession是通过服务端来实现会话状态的维持。


Cookie
Cookie是一种保存少量信息至浏览器的一种技术,第一请求时,服务器可以响应给浏览器一些Cookie信息,第二次请求,浏览器会携带之前的cookie发送给服务器,通过这种机制可以实现在浏览器端保留一些用户信息.为服务端获取用户状态获得依据
特点


Cookie使用字符串存储数据


Cookie使用Key与Value结构存储数据


单个Cookie存储数据大小限制在4097个字节


Cookie存储的数据中不支持中文，Servlet4.0中支持


Cookie是与域名绑定所以不支持跨一级域名访问


Cookie对象保存在客户端浏览器内存上或系统磁盘中


Cookie分为持久化Cookie(保存在磁盘上)与状态Cookie(保存在内存上)


浏览器在保存同一域名所返回Cookie的数量是有限的。不同浏览器支持的数量不同，Chrome浏览器为50个


浏览器每次请求时都会把与当前访问的域名相关的Cookie在请求中提交到服务端。


创建对象和响应
Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;)//通过new关键字创建Cookie对象response.addCookie(cookie)//通过HttpServletResponse对象将Cookie写回给客户端浏览器。
数据的获取
//通过HttpServletRequest对象获取Cookie，返回Cookie数组。Cookie[] cookies = request.getCookies()
Cookie持久化和状态Cookie

==状态Cookie==：浏览器会缓存Cookie对象。浏览器关闭后Cookie对象销毁。
==持久化Cookie==：浏览器会对Cookie做持久化处理，基于文件形式保存在系统的指定目录中。在Windows10系统中为了安全问题不会显示Cookie中的内容。

​       当Cookie对象创建后默认为状态Cookie。可以使用Cookie对象下的==cookie.setMaxAge(60)==方法设置失效时间，单位为秒。一旦设置了失效时间，那么该Cookie为持久化Cookie，浏览器会将Cookie对象持久化到磁盘中。当失效时间到达后文件删除。
测试代码
通过响应对象 向浏览器响应cookie
@WebServlet(urlPatterns = &quot;/servlet1.do&quot;)public class Servlet1 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 通过响应对象,向浏览器响应一些Cookie        Cookie c1=new Cookie(&quot;age&quot;,&quot;10&quot;);// 状态Cookie 重启即清除        Cookie c2=new Cookie(&quot;gender&quot;, &quot;男&quot;);//持久化Cookie 让浏览器保留1分钟        //c2.setMaxAge(60);// 秒钟    持久化Cookie 让浏览器保留1分钟        resp.addCookie(c1);        resp.addCookie(c2);    &#125;&#125;
获取请求中cookie
@WebServlet(urlPatterns = &quot;/servlet2.do&quot;)public class Servlet2 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 读取请求中的Cookie        Cookie[] cookies = req.getCookies();        //cookies不为null        if(null != cookies)&#123;            for (Cookie cookie : cookies) &#123;                System.out.println(cookie.getName()+&quot;=&quot;+cookie.getValue());            &#125;        &#125;    &#125;&#125;
案例：通过Cookie判断用户是否访问过当前Servlet
需求：
​                                                                                                                                                                                      当客户端浏览器第一次访问Servlet时返回“您好，欢迎您第一次访问！”，第二次访问时返回“欢迎您回来！”
@WebServlet(urlPatterns = &quot;/servlet3.do&quot;)public class Servlet3 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 如果是第一访问当前Servlet.向浏览器响应一个cookie (&quot;servlet3&quot;,&quot;1&quot;)        // 如果是多次访问,就再次数上+1        Cookie[] cookies = req.getCookies();        boolean  flag =false ;        if(null !=cookies)&#123;            for (Cookie cookie : cookies) &#123;                String cookieName = cookie.getName();                if(cookieName.equals(&quot;servlet3&quot;))&#123;                    // 创建Cookie次数+1                    Integer value = Integer.parseInt(cookie.getValue())+1;                    Cookie c=new Cookie(&quot;servlet3&quot;, String.valueOf(value));                    resp.addCookie(c);                    System.out.println(&quot;欢迎您第&quot;+value+&quot;访问&quot;);                    flag=true;                &#125;            &#125;        &#125;        if(!flag)&#123;            System.out.println(&quot;欢迎您第一次访问&quot;);            Cookie c=new Cookie(&quot;servlet3&quot;, &quot;1&quot;);            resp.addCookie(c);        &#125;    &#125;&#125;
Session
案例:判断用户是否登录
需求:
实现登录一次即可,在一次会话内,可以反复多次访问WEB-INF/ welcome.html,如果没有登录过,跳转到登录页,登录成功后,可以访问
项目结构:

组件介绍：
login.html
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;get&quot; action=&quot;loginServlet.do&quot;&gt;    用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; &gt;&lt;br/&gt;    密码:&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; &gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
main.html
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   this is main page&lt;/body&gt;&lt;/html&gt;
LoginServlet
用来校验登录的，登陆成功将用户信息存户HttpSession，否则返回到登录页。
@WebServlet(urlPatterns = &quot;/loginServlet.do&quot;)public class LoginServlet extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 获取用户名和密码        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        // 如果用户名和密码为 msb 1234        if(&quot;msb&quot;.equals(username)  &amp;&amp; &quot;1234&quot;.equals(password))&#123;            // 将用户信息放在HTTPSession中            User user =new User(null, null, &quot;msb&quot;, &quot;1234&quot;);            HttpSession session = req.getSession();            session.setAttribute(&quot;user&quot;, user);            // 登录成功 跳转至 main.html            resp.sendRedirect(req.getContextPath()+&quot;/mainServlet.do&quot;);        &#125;else&#123;            // 登录失败 回到login.html            resp.sendRedirect(req.getContextPath()+&quot;/login.html&quot;);        &#125;    &#125;&#125;
MainServlet
用来向mian.html中跳转的，同时验证登录的，可以直接跳转，否则回到登录页。
@WebServlet(urlPatterns = &quot;/mainServlet.do&quot;)public class MainServlet extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //跳转至main.html        HttpSession session = req.getSession();        User user = (User)session.getAttribute(&quot;user&quot;);        if(null != user)&#123;            // 判断如果登录过 允许跳转  HTTPSession中如果有登陆过的信息            req.getRequestDispatcher(&quot;/WEB-INF/main.html&quot;).forward(req,resp);        &#125;else&#123;            // 如果没有登录过 回到登录去登录  HTTPSession中如果有登陆过的信息            resp.sendRedirect(&quot;login.html&quot;);        &#125;    &#125;&#125;
User
存储用户信息的实体类
public class User implements Serializable &#123;    private Integer uid;    private String realname;    private String username;    private String pasword;
JSP
指令标签
三种指令标签



指令
描述




&lt;%@ page %&gt;
定义网页依赖属性，如脚本语言，error页面、缓存需求等


&lt;%@ include %&gt;
包含其他文件


&lt;%@ taglib%
引入标签库的定义



page标签
&lt;%--告知浏览器以什么格式和编码解析 响应的数据--%&gt;    &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot;  %&gt;    &lt;%--设置JSP页面转换的语言--%&gt;    &lt;%@ page language=&quot;java&quot;%&gt;    &lt;%--导包--%&gt;    &lt;%@ page import=&quot;com.msb.entity.User&quot; %&gt;    &lt;%--在转换成java代码时使用的编码 一般不用设置--%&gt;    &lt;%@ page pageEncoding=&quot;UTF-8&quot; %&gt;    &lt;%--指定错误页 当页面发生错误时 指定跳转的页面--%&gt;    &lt;%@ page errorPage=&quot;error500.JSP&quot; %&gt;    &lt;%--指定当前页为异常提示页 当前页面可以接收异常对象 --%&gt;    &lt;%@page isErrorPage=&quot;true&quot; %&gt;
errorPage是一种处理错误提示也的功能除了JSP有的错误提示页功能
javaEE中自带其他的错位提示页处理功能，具体配置如下
&lt;error-page&gt;    &lt;error-code&gt;500&lt;/error-code&gt;    &lt;location&gt;/error500.JSP&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;    &lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/error404.JSP&lt;/location&gt;&lt;/error-page&gt;
当JSP中发生了异常时,如果JSP中配置的错误页和web.xml 中配置的错误页冲突了,JSP page指令的 errorPage优先级更高

include标签
JSP可以通过Include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。除了include指令标签可以实现引入以外，使用jsp:include也可以实现引入
&lt;%--静态引入使用的是 include 指令标签    被引入的JSP页面不会生成java代码 被引入的网页和当前页生成代码后形成了一个java文件--%&gt;&lt;%@include file=&quot;head.JSP&quot;%&gt;&lt;%--动态引入 JSP标签中的 include选项    被引入的JSP页面会生成独立的java代码     在生成的java代码中 使用JSPRuntimeLibrary.include(request, response, &quot;head.JSP&quot;, out, false);引入其他页面    --%&gt;&lt;jsp:include page=&quot;head.JSP&quot;/&gt;
查看转译以后的java源代码文件中的区别
静态引入：@include被引入的网页和当前页生成代码后形成了一个java文件
动态引入：jsp:include被引入的JSP页面会生成独立的java代码
taglib指令标签
JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。
语法：
&lt;%@ taglib   uri=&quot;uri&quot; prefix=&quot;prefixOfTag&quot; %&gt;
内置对象
九大对象
四大域对象


pageContext  page域     当前页面内可用


request       reqeust域  单次请求


session       session域   单次会话


application   application 域项目运行


响应对象

response

输出流对象

out 打印流

其他三个对象


servletConfig:由于JSP本身也是一个Servlet,所以容器也会给我们准备一个ServletConfig


page        就是他this对象 当前JSP对象本身


exception   异常对象,在错误提示页上使用,当isErrorpage=true 才具有该对象


案例一：在浏览器上访问Emp表 动态地分等级
EmpDaoImpl.java
实现类
public class EmpDaoImpl implements EmpDao &#123;    private String url=&quot;jdbc:mysql://127.0.0.1:3306/mydb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;;    private String username=&quot;root&quot;;    private String password=&quot;root&quot;;    @Override    public List&lt;Emp&gt; findAll() &#123;        List&lt;Emp&gt; list =new ArrayList&lt;&gt;();        Connection connection =null;        PreparedStatement pstat=null;        ResultSet resultSet=null;        try &#123;            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);            connection = DriverManager.getConnection(url, username, password);            pstat = connection.prepareStatement(&quot;select * from emp&quot;);            resultSet = pstat.executeQuery();            while(resultSet.next())&#123;                Integer empno=resultSet.getInt(&quot;empno&quot;);                Integer deptno=resultSet.getInt(&quot;deptno&quot;);                Integer mgr=resultSet.getInt(&quot;mgr&quot;);                String ename=resultSet.getString(&quot;ename&quot;);                String job=resultSet.getString(&quot;job&quot;);                Double sal=resultSet.getDouble(&quot;sal&quot;);                Double comm=resultSet.getDouble(&quot;comm&quot;);                Date hiredate=resultSet.getDate(&quot;hiredate&quot;);                Emp emp =new Emp( empno,  ename,  job,  mgr,  hiredate,  sal,  comm,  deptno);                list.add(emp);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;finally &#123;            if(null!=resultSet)&#123;                try &#123;                    resultSet.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null!=pstat)&#123;                try &#123;                    pstat.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(null!=connection)&#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return list;    &#125;&#125;
Emp.java
public interface EmpDao &#123;    List&lt;Emp&gt; findAll();&#125;
EmpServlet
@WebServlet(&quot;/empServlet.do&quot;)public class EmpServlet extends HttpServlet &#123;    // dao对象    EmpDao empDao=new EmpDaoImpl();    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 获取数据        List&lt;Emp&gt; list = empDao.findAll();        // 将数据放入请求域        req.setAttribute(&quot;emps&quot;, list);        // 请求转发给JSP        req.getRequestDispatcher(&quot;showEmp.jsp&quot;).forward(req,resp);    &#125;&#125;
showEmp.jsp
&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;com.msb.pojo.Emp&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        table&#123;            border: 3px solid blue;            width: 80%;            margin: 0px auto;        &#125;        td,th&#123;            border: 2px solid green;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;table cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot;&gt;        &lt;tr&gt;            &lt;th&gt;编号&lt;/th&gt;            &lt;th&gt;姓名&lt;/th&gt;            &lt;th&gt;上级编号&lt;/th&gt;            &lt;th&gt;职务&lt;/th&gt;            &lt;th&gt;入职日期&lt;/th&gt;            &lt;th&gt;薪资&lt;/th&gt;            &lt;th&gt;补助&lt;/th&gt;            &lt;th&gt;部门号&lt;/th&gt;            &lt;th&gt;薪资等级&lt;/th&gt;        &lt;/tr&gt;        &lt;%            List&lt;Emp&gt; emps = (List&lt;Emp&gt;) request.getAttribute(&quot;emps&quot;);            for (Emp emp : emps) &#123;        %&gt;            &lt;tr&gt;                &lt;td&gt;&lt;%=emp.getEmpno()%&gt;&lt;/td&gt;                &lt;td&gt;&lt;%=emp.getEname()%&gt;&lt;/td&gt;                &lt;td&gt;&lt;%=emp.getMgr()%&gt;&lt;/td&gt;                &lt;td&gt;&lt;%=emp.getJob()%&gt;&lt;/td&gt;                &lt;td&gt;&lt;%=emp.getHiredate()%&gt;&lt;/td&gt;                &lt;td&gt;&lt;%=emp.getSal()%&gt;&lt;/td&gt;                &lt;td&gt;&lt;%=emp.getComm()%&gt;&lt;/td&gt;                &lt;td&gt;&lt;%=emp.getDeptno()%&gt;&lt;/td&gt;                &lt;td&gt;&lt;%--out.print(&quot;&lt;td&gt;&quot;)--%&gt;         &lt;%             Double sal = emp.getSal();             if(sal&lt;=500)&#123;                 out.print(&quot;A&quot;);             &#125;else if( sal &lt;=1000)&#123;                 out.print(&quot;B&quot;);             &#125;else if( sal &lt;=1500)&#123;                 out.print(&quot;C&quot;);             &#125;else if( sal &lt;=2000)&#123;                 out.print(&quot;D&quot;);             &#125;else if( sal &lt;=3000)&#123;                 out.print(&quot;E&quot;);             &#125;else if( sal &lt;=4000)&#123;                 out.print(&quot;F&quot;);             &#125;else &#123;                 out.print(&quot;G&quot;);             &#125;         %&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;%            &#125;        %&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;
EL表达式
Expression Languaga
EL表达式中定义了一些可以帮助我们快捷从域对象中取出数据的写法,基本语法为
$&#123;域标志.数据名.属性名(可选)&#125;
四个域标志关键字分别为


requestScope         request域


sessionScope          session域


applicationScope   application域


pageScope             page域


EL表达式快捷取出域对象


requestScope         request域


sessionScope          session域


applicationScope   application域


pageScope             page域


&lt;%@ page import=&quot;com.msb.pojo.User&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;%--向pageContext域中放数据--%&gt;        &lt;%        pageContext.setAttribute(&quot;msg&quot;, &quot;pageContextMessage&quot;);        pageContext.setAttribute(&quot;userx&quot;, new User(1,&quot;大黄&quot;,&quot;abcdefg&quot;));        %&gt;        &lt;%--    从域中取出数据    El表达式在获取对象属性值得时候,是通过对象的属性的get方法获取的    保证对象的要获取的属性必须有对应get方法才可以    EL表达式在使用时是不需要import其他类的    El如果获取的是NULL值,是不展示任何信息的    --%&gt;        pageContext域中的数据:&lt;br/&gt;        msg:$&#123;pageScope.msg&#125;&lt;br/&gt;        username:$&#123;pageScope.userx.name&#125;&lt;br/&gt;        &lt;hr/&gt;        request域中的数据:&lt;br/&gt;        msg:$&#123;requestScope.msg&#125;&lt;br/&gt;        username:$&#123;requestScope.user.name&#125;&lt;br/&gt;        &lt;hr/&gt;        session域中的数据:&lt;br/&gt;        msg:$&#123;sessionScope.msg&#125;&lt;br/&gt;        username:$&#123;sessionScope.users[1].name&#125;&lt;br/&gt;        &lt;hr/&gt;        application域中的数据:&lt;br/&gt;        msg:$&#123;applicationScope.msg&#125;&lt;br/&gt;        username:$&#123;applicationScope.userMap.a.name&#125;&lt;br/&gt;        &lt;hr/&gt;        &lt;%--EL表达式在取出数据的时候是可以省略域标志的    EL表达式会自动依次到四个域中去找数据    --%&gt;        PageContext username:$&#123;userx.name&#125;&lt;br/&gt;        Request username:$&#123;user.name&#125;&lt;br/&gt;        Session username:$&#123;users[1].name&#125;&lt;br/&gt;        Application username:$&#123;userMap.a.name&#125;&lt;br/&gt;        &lt;hr/&gt;        &lt;%--    $&#123;数据的名字&#125;如果省略域标志,取数据的顺序如下    pageContext    request    session    application    --%&gt;        $&#123;msg&#125;        &lt;hr/&gt;        &lt;%--    移除域中的数据    --%&gt;        &lt;%        //pageContext.removeAttribute(&quot;msg&quot;);// pageContext.removeAttribute()方法会移除四个域中的所有的同名的数据        //request.removeAttribute(&quot;msg&quot;);        %&gt;        pagecontextMsg:$&#123;pageScope.msg&#125;&lt;br/&gt;        requestMsg:$&#123;requestScope.msg&#125;&lt;br/&gt;        sessionMsg:$&#123;sessionScope.msg&#125;&lt;br/&gt;        applicationMsg:$&#123;applicationScope.msg&#125;&lt;br/&gt;        &lt;hr/&gt;        &lt;%--    EL表达式获取请求中的参数    --%&gt;        username:$&#123;param.username&#125;&lt;br/&gt;        hobby:$&#123;paramValues.hobby[0]&#125;        hobby:$&#123;paramValues.hobby[1]&#125;    &lt;/body&gt;&lt;/html&gt;
总结


EL表达式定义在JSP页面上,在转译之后的java文件中,会被转化成java代码


EL表达式是一种后台技术,服务器上运行,不是在浏览器上运行,不能用于HTML页面


EL表达式底层是通过反射实现的,在获取对象属性值时是通过对象的get方法实现的


EL表达式运算符
运算符
算数运算符: + - * / %
比较运算符:
==  eq equals
&gt;gt greater then
&lt;     lt   lower then
&gt;=  ge  greater then or equals
&lt;=  le   lower then or equals
!=   ne   not equals
逻辑运算符: || or    &amp;&amp; and
三目运算符: ${条件 ?表达式1 : 表达式2}
判空运算符: empty
使用
&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--+两端如果有字符串,会尝试将字符串转换成数字之后进行加法运算/如果除以0 结果为Infinity 而不是出现异常%如果和0取余数,那么会出现异常--%&gt;    算数运算符：    &lt;hr/&gt;    $&#123;10 + 10&#125;&lt;br/&gt;    $&#123;&quot;10&quot; + 10&#125;&lt;br/&gt;    $&#123;&quot;10&quot; + &quot;10&quot;&#125;&lt;br/&gt;    &lt;%--$&#123;&quot;10a&quot; + 10&#125;&lt;br/&gt;--%&gt;    $&#123;10/0&#125;&lt;br/&gt;    &lt;%-- $&#123;10%0&#125;&lt;br/&gt;--%&gt;    关系运算符/比较运算符    &lt;%--    比较运算符推荐写成字母形式,不推荐使用 == &gt;=  &lt;=    --%&gt;    &lt;hr/&gt;    $&#123;10 == 10&#125;&lt;br/&gt;    $&#123;10 eq 10&#125;&lt;br/&gt;    $&#123;10 gt 8&#125;&lt;br/&gt;    逻辑运算符    &lt;hr/&gt;    $&#123; true || false&#125;&lt;br/&gt;    $&#123; true or false&#125;&lt;br/&gt;    $&#123; true &amp;&amp; false&#125;&lt;br/&gt;    $&#123; true and false&#125;&lt;br/&gt;    条件运算符/三目运算符    &lt;hr/&gt;    $&#123;(100-1)%3==0?10+1:10-1&#125;&lt;br/&gt;    判断空运算符    &lt;%--empty 为null 则为true--%&gt;    &lt;%  //向域中放入数据        pageContext.setAttribute(&quot;a&quot;,null);        pageContext.setAttribute(&quot;b&quot;,&quot;&quot;);        int[] arr =&#123;&#125;;        pageContext.setAttribute(&quot;arr&quot;,arr);        List list =new ArrayList();        pageContext.setAttribute(&quot;list&quot;,list);    %&gt;    &lt;hr/&gt;    $&#123;empty a&#125;&lt;br/&gt;    $&#123;empty b&#125;&lt;br/&gt;&lt;%--字符串长度为0 则认为是空--%&gt;    $&#123;empty arr&#125;&lt;br/&gt;&lt;%--数组长度为0 认为不是空--%&gt;    $&#123;empty list&#125;&lt;br/&gt;&lt;%--集合长度为0 认为是空--%&gt;    $&#123;list.size() eq 0&#125;&lt;br/&gt;&lt;%--集合长度为0 认为是空--%&gt;&lt;/body&gt;&lt;/html&gt;
案例一优化：使用EL表达式优化查询员工信息的页面处理
&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;com.msb.pojo.Emp&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Title&lt;/title&gt;        &lt;style&gt;            table&#123;                border: 3px solid blue;                width: 80%;                margin: 0px auto;            &#125;            td,th&#123;                border: 2px solid green;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot;&gt;            &lt;tr&gt;                &lt;th&gt;编号&lt;/th&gt;                &lt;th&gt;姓名&lt;/th&gt;                &lt;th&gt;上级编号&lt;/th&gt;                &lt;th&gt;职务&lt;/th&gt;                &lt;th&gt;入职日期&lt;/th&gt;                &lt;th&gt;薪资&lt;/th&gt;                &lt;th&gt;补助&lt;/th&gt;                &lt;th&gt;部门号&lt;/th&gt;                &lt;th&gt;薪资等级&lt;/th&gt;            &lt;/tr&gt;            &lt;%            List&lt;Emp&gt; emps = (List&lt;Emp&gt;) request.getAttribute(&quot;emps&quot;);            for (Emp emp : emps) &#123;                pageContext.setAttribute(&quot;emp&quot;, emp);//将员工对象放入PageContext 域                %&gt;            &lt;tr&gt;                &lt;td&gt;$&#123;emp.empno&#125;&lt;/td&gt;                &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt;                &lt;td&gt;$&#123;emp.mgr&#125;&lt;/td&gt;                &lt;td&gt;$&#123;emp.job&#125;&lt;/td&gt;                &lt;td&gt;$&#123;emp.hiredate&#125;&lt;/td&gt;                &lt;td&gt;$&#123;emp.sal&#125;&lt;/td&gt;                &lt;td&gt;$&#123;emp.comm&#125;&lt;/td&gt;                &lt;td&gt;$&#123;emp.deptno&#125;&lt;/td&gt;                &lt;td&gt;                    $&#123;emp.sal le 500?&quot;A&quot;:&quot;&quot;&#125;                    $&#123;emp.sal gt 500 and emp.sal le 1000?&quot;B&quot;:&quot;&quot;&#125;                    $&#123;emp.sal gt 1000 and emp.sal le 1500?&quot;C&quot;:&quot;&quot;&#125;                    $&#123;emp.sal gt 1500 and emp.sal le 2000?&quot;D&quot;:&quot;&quot;&#125;                    $&#123;emp.sal gt 2000 and emp.sal le 3000?&quot;E&quot;:&quot;&quot;&#125;                    $&#123;emp.sal gt 3000 and emp.sal le 4000?&quot;F&quot;:&quot;&quot;&#125;                    $&#123;emp.sal gt 4000?&quot;G&quot;:&quot;&quot;&#125;                &lt;/td&gt;            &lt;/tr&gt;            &lt;%            &#125;            %&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;
JSTL
JSTL（Java server pages standarded tag library，即JSP标准标签库）是由JCP（Java community Proces）所制定的标准规范，它主要提供给Java Web开发人员一个标准通用的标签库，并由Apache的Jakarta小组来维护。
使用前提


需要导包


页面中通过taglib指令引入标签库
&lt;%@   taglib uri=&quot;标签库的定位&quot; prefix=&quot;前缀(简称)&quot; %&gt;
uri可以在对应的tld文件中找到


核心标签库
导入语句为
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
操作对象的标签c:set/out/remove

==&lt;c:set&gt;==         向域对象中放入数据  setAttribute
==&lt;c:out&gt;==        从域对象中取出数据  getAttribute
==&lt;c:remove&gt;== 从域对象中移除数据   removeAttribute

&lt;%--    c:set        scope 指定放数据的域 可选值 page request session application        var   数据的名称        value 数据    --%&gt;    &lt;c:set scope=&quot;page&quot; var=&quot;msg&quot; value=&quot;pageMessage&quot;&gt;&lt;/c:set&gt;    &lt;c:set scope=&quot;request&quot; var=&quot;msg&quot; value=&quot;requestMessage&quot;&gt;&lt;/c:set&gt;    &lt;c:set scope=&quot;session&quot; var=&quot;msg&quot; value=&quot;sessionMessage&quot;&gt;&lt;/c:set&gt;    &lt;c:set scope=&quot;application&quot; var=&quot;msg&quot; value=&quot;applicationMessage&quot;&gt;&lt;/c:set&gt;    &lt;%--移除指定域中的值--%&gt;   &lt;%-- &lt;c:remove var=&quot;msg&quot; scope=&quot;page&quot;&gt;&lt;/c:remove&gt;    &lt;c:remove var=&quot;msg&quot; scope=&quot;request&quot;&gt;&lt;/c:remove&gt;--%&gt;    &lt;c:remove var=&quot;msg&quot; scope=&quot;session&quot;&gt;&lt;/c:remove&gt;    &lt;c:remove var=&quot;msg&quot; scope=&quot;application&quot;&gt;&lt;/c:remove&gt;    &lt;%--通过EL表达式取出域中的值--%&gt;    &lt;hr/&gt;    $&#123;pageScope.msg&#125;&lt;br/&gt;    $&#123;requestScope.msg&#125;&lt;br/&gt;    $&#123;sessionScope.msg&#125;&lt;br/&gt;    $&#123;applicationScope.msg &#125;&lt;br/&gt;    &lt;hr/&gt;    &lt;%--通过c:out标签获取域中的值--%&gt;    &lt;c:out value=&quot;$&#123;pageScope.msg&#125;&quot; default=&quot;page msg not found&quot;/&gt;    &lt;c:out value=&quot;$&#123;requestScope.msg&#125;&quot; default=&quot;request msg not found&quot;/&gt;    &lt;c:out value=&quot;$&#123;sessionScope.msg&#125;&quot; default=&quot;session msg not found&quot;/&gt;    &lt;c:out value=&quot;$&#123;applicationScope.msg&#125;&quot; default=&quot;application msg not found&quot;/&gt;&lt;/body&gt;&lt;/html&gt;
多条件分支标签c:if和c:choose
&lt;%--    随机生成一个分数  0-100    &gt;=90 A    &gt;=80 B    &gt;=70 C    &gt;=60 D    &lt;60  E    --%&gt;    &lt;%        int score =new Random().nextInt(101);        pageContext.setAttribute(&quot;score&quot;, score);    %&gt;    &lt;%--    test  判断条件    c:if可以将test的结果放入指定的域中    scope 指定存放的域    var   数据名    --%&gt;    分数:$&#123;score&#125;&lt;br/&gt; 等级:    &lt;c:if test=&quot;$&#123;score ge 90&#125;&quot; scope=&quot;page&quot; var=&quot;f1&quot;&gt;A&lt;/c:if&gt;    &lt;c:if test=&quot;$&#123;score ge 80 and score lt 90&#125;&quot; scope=&quot;page&quot; var=&quot;f2&quot;&gt;B&lt;/c:if&gt;    &lt;c:if test=&quot;$&#123;score ge 70 and score lt 80&#125;&quot; scope=&quot;page&quot; var=&quot;f3&quot;&gt;C&lt;/c:if&gt;    &lt;c:if test=&quot;$&#123;score ge 60 and score lt 70&#125;&quot; scope=&quot;page&quot; var=&quot;f4&quot;&gt;D&lt;/c:if&gt;    &lt;c:if test=&quot;$&#123;score lt 60&#125;&quot; scope=&quot;page&quot; var=&quot;f5&quot;&gt;E&lt;/c:if&gt;    &lt;hr/&gt;    $&#123;f1&#125;    $&#123;f2&#125;    $&#123;f3&#125;    $&#123;f4&#125;    $&#123;f5&#125;    &lt;hr/&gt;    &lt;%--输出分数是否及格--%&gt;    &lt;c:if test=&quot;$&#123;score ge 60&#125;&quot; scope=&quot;page&quot; var=&quot;flag&quot;&gt;及格&lt;/c:if&gt;    &lt;c:if test=&quot;$&#123;!pageScope.flag&#125;&quot;&gt;不及格&lt;/c:if&gt;    &lt;hr/&gt;    &lt;c:choose&gt;        &lt;c:when test=&quot;$&#123;score ge 90&#125;&quot;&gt;A&lt;/c:when&gt;        &lt;c:when test=&quot;$&#123;score ge 80&#125;&quot;&gt;B&lt;/c:when&gt;        &lt;c:when test=&quot;$&#123;score ge 70&#125;&quot;&gt;C&lt;/c:when&gt;        &lt;c:when test=&quot;$&#123;score ge 60&#125;&quot;&gt;D&lt;/c:when&gt;        &lt;c:otherwise&gt;E&lt;/c:otherwise&gt;    &lt;/c:choose&gt;
迭代标签c:foreach
打印乘法表
c:forEach中的属性

==var==: 迭代变量, 存放在pageContext作用域
==begin==: 迭代起始值
==end==: 迭代结束值
==step==: 迭代变量变化的步长

&lt;%--    for ( int i =1;i&lt;=9 ;i+=2)&#123;        pageContext.setAttribute(&quot;i&quot;,i)    &#125;c:foreach 每次执时都会向page域中放入一个名为 i 值为当前值这样的一个操作    --%&gt;&lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;9&quot; step=&quot;1&quot;&gt;    &lt;c:forEach var=&quot;j&quot; begin=&quot;1&quot; end=&quot;$&#123;i&#125;&quot; step=&quot;1&quot;&gt;        $&#123;j&#125; * $&#123;i&#125; = $&#123;i*j&#125; &amp;nbsp;    &lt;/c:forEach&gt;    &lt;br/&gt;&lt;/c:forEach&gt;
遍历对象数组

==items==: 要遍历的集合, 需要使用EL表达式取值
==varStatus==: 迭代变量的状态
==index:== 索引, 从0开始
==count:== 计数, 从1开始
==first==: boolean, 表示是否是第一个
==last==: boolean, 表示是否是最后一个
==current==: 对象, 当前迭代的对象值

&lt;%--&lt;%//原来的遍历       List&lt;Emp&gt; emps = (List&lt;Emp&gt;) request.getAttribute(&quot;emps&quot;);       for (Emp emp : emps) &#123;           pageContext.setAttribute(&quot;emp&quot;, emp);//将员工对象放入PageContext 域       %&gt;       c:foreach       --%&gt;       &lt;c:forEach items=&quot;$&#123;emps&#125;&quot; var=&quot;emp&quot; varStatus=&quot;empStatus&quot;&gt;
格式化标签库fmt
导入标签
&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt;
&lt;fmt:formatDate&gt;日期格式标签
&lt;td&gt;    &lt;fmt:formatDate value=&quot;$&#123;emp.hiredate&#125;&quot; pattern=&quot;yyyy年MM月dd日 HH:mm:ss&quot;/&gt;&lt;/td&gt;
数字格式化标签
&lt;td&gt;    &lt;%--    0 代表必须有一位数字,如果对应的位置没有值怎么办?自动补充0    # 代表有一位数字,开头和结尾的所有的0不保留    --%&gt;    &amp;yen;&lt;fmt:formatNumber value=&quot;$&#123;emp.sal&#125;&quot; pattern=&quot;###,##0.00&quot;/&gt;&lt;/td&gt;
showEmp.js页面最终优化
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Title&lt;/title&gt;        &lt;style&gt;            table&#123;                border: 3px solid blue;                width: 80%;                margin: 0px auto;            &#125;            td,th&#123;                border: 2px solid green;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot;&gt;            &lt;tr&gt;                &lt;th&gt;序号&lt;/th&gt;                &lt;th&gt;索引&lt;/th&gt;                &lt;th&gt;isFirst&lt;/th&gt;                &lt;th&gt;isLast&lt;/th&gt;                &lt;th&gt;编号&lt;/th&gt;                &lt;th&gt;姓名&lt;/th&gt;                &lt;th&gt;姓名&lt;/th&gt;                &lt;th&gt;上级编号&lt;/th&gt;                &lt;th&gt;职务&lt;/th&gt;                &lt;th&gt;入职日期&lt;/th&gt;                &lt;th&gt;薪资&lt;/th&gt;                &lt;th&gt;补助&lt;/th&gt;                &lt;th&gt;部门号&lt;/th&gt;                &lt;th&gt;薪资等级&lt;/th&gt;            &lt;/tr&gt;            &lt;%-- &lt;%    List&lt;Emp&gt; emps = (List&lt;Emp&gt;) request.getAttribute(&quot;emps&quot;);            for (Emp emp : emps) &#123;                pageContext.setAttribute(&quot;emp&quot;,emp);//将员工对象放入PageContext域                %&gt;            c:foreach            items 要遍历的数组/List  可以通过EL表达式取出集合之后给改属性赋值            var   中间变量的名称            varStatus 记录每一个对象状态的设置            count 个数            index 索引            first 如果当前元素是迭代的第一个元素 true 否则为false            last  如果当前元素是迭代的最后一个元素 true 否则为false            current 当前迭代的元素本身            --%&gt;            &lt;c:forEach items=&quot;$&#123;emps&#125;&quot; var=&quot;emp&quot; varStatus=&quot;empStatus&quot;&gt;                &lt;tr&gt;                    &lt;%--使用EL表达式来取出域对象里的对象属性值--%&gt;                    &lt;%-- &lt;td&gt;&lt;%=emp.getEmpno()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=emp.getEname()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=emp.getMgr()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=emp.getJob()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=emp.getHiredate()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=emp.getSal()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=emp.getComm()%&gt;&lt;/td&gt;            &lt;td&gt;&lt;%=emp.getDeptno()%&gt;&lt;/td&gt;--%&gt;            &lt;td&gt;$&#123;empStatus.count&#125;&lt;/td&gt;            &lt;td&gt;$&#123;empStatus.index&#125;&lt;/td&gt;            &lt;td&gt;$&#123;empStatus.first&#125;&lt;/td&gt;            &lt;td&gt;$&#123;empStatus.last&#125;&lt;/td&gt;            &lt;td&gt;$&#123;emp.empno&#125;&lt;/td&gt;            &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt;            &lt;td&gt;$&#123;empStatus.current.ename&#125;&lt;/td&gt;            &lt;td&gt;$&#123;emp.mgr&#125;&lt;/td&gt;            &lt;td&gt;$&#123;emp.job&#125;&lt;/td&gt;            &lt;td&gt;                &lt;fmt:formatDate value=&quot;$&#123;emp.hiredate&#125;&quot; pattern=&quot;yyyy年MM月dd日 HH:mm:ss&quot;/&gt;            &lt;/td&gt;            &lt;td&gt;                &lt;%--    0 代表必须有一位数字,如果对应的位置没有值怎么办?自动补充0    # 代表有一位数字,开头和结尾的所有的0不保留    --%&gt;                &amp;yen;&lt;fmt:formatNumber value=&quot;$&#123;emp.sal&#125;&quot; pattern=&quot;###,##0.00&quot;/&gt;            &lt;/td&gt;            &lt;td&gt;$&#123;emp.comm&#125;&lt;/td&gt;            &lt;td&gt;$&#123;emp.deptno&#125;&lt;/td&gt;            &lt;td&gt;&lt;%--out.print(&quot;&lt;td&gt;&quot;)--%&gt;                &lt;%--&lt;%    	Double sal = emp.getSal();                if(sal&lt;=500)&#123;                    out.print(&quot;A&quot;);                &#125;else if( sal &lt;=1000)&#123;                    out.print(&quot;B&quot;);                &#125;else if( sal &lt;=1500)&#123;                    out.print(&quot;C&quot;);                &#125;else if( sal &lt;=2000)&#123;                    out.print(&quot;D&quot;);                &#125;else if( sal &lt;=3000)&#123;                    out.print(&quot;E&quot;);                &#125;else if( sal &lt;=4000)&#123;                    out.print(&quot;F&quot;);                &#125;else &#123;                    out.print(&quot;G&quot;);                &#125;                %&gt;--%&gt;                &lt;%--使用EL算数表达式来判断等级    $&#123;emp.sal le 500?&quot;A&quot;:&quot;&quot;&#125;                $&#123;emp.sal gt 500 and emp.sal le 1000?&quot;B&quot;:&quot;&quot;&#125;                $&#123;emp.sal gt 1000 and emp.sal le 1500?&quot;C&quot;:&quot;&quot;&#125;                $&#123;emp.sal gt 1500 and emp.sal le 2000?&quot;D&quot;:&quot;&quot;&#125;                $&#123;emp.sal gt 2000 and emp.sal le 3000?&quot;E&quot;:&quot;&quot;&#125;                $&#123;emp.sal gt 3000 and emp.sal le 4000?&quot;F&quot;:&quot;&quot;&#125;                $&#123;emp.sal gt 4000?&quot;G&quot;:&quot;&quot;&#125;--%&gt;                &lt;%--使用JSTL标签--%&gt;                &lt;c:choose&gt;                    &lt;c:when test=&quot;$&#123;emp.sal le 500&#125;&quot;&gt;A&lt;/c:when&gt;                    &lt;c:when test=&quot;$&#123;emp.sal le 1000&#125;&quot;&gt;B&lt;/c:when&gt;                    &lt;c:when test=&quot;$&#123;emp.sal le 1500&#125;&quot;&gt;C&lt;/c:when&gt;                    &lt;c:when test=&quot;$&#123;emp.sal le 2000&#125;&quot;&gt;D&lt;/c:when&gt;                    &lt;c:when test=&quot;$&#123;emp.sal le 3000&#125;&quot;&gt;E&lt;/c:when&gt;                    &lt;c:when test=&quot;$&#123;emp.sal le 4000&#125;&quot;&gt;F&lt;/c:when&gt;                    &lt;c:when test=&quot;$&#123;emp.sal gt 4000&#125;&quot;&gt;G&lt;/c:when&gt;                &lt;/c:choose&gt;            &lt;/td&gt;            &lt;/tr&gt;        &lt;/c:forEach&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;
Filter
案例：通过过滤验证登录
需求：通过过滤器控制，只有登陆之后可以反复进入welcome.jsp欢迎页，如果没有登录，提示用户进入登录页进行登陆操作。

login.jsp
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;$Title%sSourceCode%lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;img src=&quot;static/img/logo.png&quot;&gt;  please login ... ... &lt;br/&gt;  &lt;form action=&quot;loginController.do&quot; method=&quot;post&quot;&gt;    用户名:&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; &lt;br/&gt;    密码:&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;  &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;
welcome.jsp
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;static/img/logo.png&quot;&gt;欢迎$&#123;user.username&#125;登陆!!!&lt;/body&gt;&lt;/html&gt;
aaa.jsp
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;this is page aaa&lt;/body&gt;&lt;/html&gt;
准备Controller代码
@WebServlet(urlPatterns = &quot;/loginController.do&quot;)public class LoginController extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 获取用户名和密码        String username = req.getParameter(&quot;user&quot;);        String password = req.getParameter(&quot;pwd&quot;);        System.out.println(username);        System.out.println(password);        // 链接数据库校验登录        // 登录成功,将用户信息放入Session域        User user =new User(username,password);        req.getSession().setAttribute(&quot;user&quot;, user);        // 跳转到欢迎页        resp.sendRedirect(&quot;welcome.jsp&quot;);    &#125;&#125;
准备登录控制过滤器
@WebFilter(urlPatterns = &quot;/*&quot;)// 任何资源都要进行过滤,public class Filter1_LoginFilter  implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest req=(HttpServletRequest)servletRequest;        HttpServletResponse resp=(HttpServletResponse) servletResponse;        //无论是否登录过,都要放行的资源   登录页  登录校验Controller 和一些静态资源        String requestURI = req.getRequestURI();        System.out.println(requestURI);        if(requestURI.contains(&quot;login.jsp&quot;)|| requestURI.contains(&quot;loginController.do&quot;)|| requestURI.contains(&quot;/static/&quot;))&#123;            // 直接放行            filterChain.doFilter(req,resp);            // 后续代码不再执行            return;        &#125;        // 需要登录之后才能访问的资源,如果没登录,重定向到login.jsp上,提示用户进行登录        HttpSession session = req.getSession();        Object user = session.getAttribute(&quot;user&quot;);        if(null != user)&#123;// 如果登录过 放行            filterChain.doFilter(req,resp);        &#125;else&#123;// 没有登录过,跳转至登录页            resp.sendRedirect(&quot;login.jsp&quot;);        &#125;    &#125;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void destroy() &#123;    &#125;&#125;
Listener
案例：记录请求日志
RequestLoginListener.java
@WebListenerpublic class RequestLogListener implements ServletRequestListener &#123;    private SimpleDateFormat simpleDateFormat=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    @Override    public void requestDestroyed(ServletRequestEvent sre) &#123;    &#125;    @Override    public void requestInitialized(ServletRequestEvent sre) &#123;        // 获得请求发出的IP        // 获得请求的URL        // 获得请求产生的时间        HttpServletRequest request = (HttpServletRequest)sre.getServletRequest();        String remoteHost = request.getRemoteHost();        String requestURL = request.getRequestURL().toString();        String reqquestDate = simpleDateFormat.format(new Date());        // 准备输出流        try &#123;            PrintWriter pw =new PrintWriter(new FileOutputStream(new File(&quot;d:/msb.txt&quot;),true));            pw.println(remoteHost+&quot; &quot;+requestURL+&quot; &quot;+reqquestDate );            pw.close();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
案例：显示在线人数
需求：开启一次会话session 在线人数加一 销毁会话以后在线人数减一
使用count来计数，然后存在application域中
OnlineNumberListener:
获取application域对象，存入数据count，如果一次session开启，++count；一次session关闭，–count
@WebListenerpublic class OnlineNumberListener implements HttpSessionListener &#123;    @Override    public void sessionCreated(HttpSessionEvent se) &#123;        //向application域中增加一个数字        HttpSession session = se.getSession();        ServletContext application = session.getServletContext();        Object count = application.getAttribute(&quot;count&quot;);        if (null == count) &#123;            //第一次放入数据            application.setAttribute(&quot;count&quot;,1);        &#125;else&#123;            int c = (int) count;            application.setAttribute(&quot;count&quot;, ++c);        &#125;    &#125;    @Override    public void sessionDestroyed(HttpSessionEvent se) &#123;        //向application域中减少一个数字        HttpSession session = se.getSession();        ServletContext application = session.getServletContext();        Object count = application.getAttribute(&quot;count&quot;);        int count1 = (int) count;        application.setAttribute(&quot;count&quot;,--count1);    &#125;&#125;
案例：重启免登录
Session序列化和反序列化
1、序列化与反序列
把对象转化为字节序列的过程称为序列化（保存到硬盘，持久化）
把字节序列转化为对象的过程称为反序列化（存放于内存）
2、序列化的用途
把对象的字节序列永久保存到硬盘上，通常放到一个文件中。
把网络传输的对象通过字节序列化，方便传输本节作业
3、实现步骤
想实现序列化和反序列化需要手动配置

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context&gt;    &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot;&gt;        &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;d:/session&quot;/&gt;    &lt;/Manager&gt;&lt;/Context&gt;
==注意实体类必须实现serializable 接口==
开发过程
1 准备实体类
public class User  implements Serializable &#123;    private String username;    private String pwd;&#125;
2 开发登录信息输入页面
&lt;form action=&quot;loginController.do&quot; method=&quot;post&quot;&gt;  用户名:&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; &lt;br/&gt;  密码:&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;
3开发登录信息验证Servlet
@WebServlet(&quot;/loginController.do&quot;)public class LoginController extends HttpServlet &#123;@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    String username = req.getParameter(&quot;user&quot;);    String pwd = req.getParameter(&quot;pwd&quot;);    // user    User user =new User(username,pwd);    // session    HttpSession session = req.getSession();    session.setAttribute(&quot;user&quot;, user);&#125;&#125;
4 开发校验当前是否已经登录的Controller
loginCheckController.java
@WebServlet(urlPatterns = &quot;/loginCheckController.do&quot;)public class LoginCheckController extends HttpServlet &#123;@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    // 判断是否登录    HttpSession session = req.getSession();    Object user = session.getAttribute(&quot;user&quot;);    Object listener = session.getAttribute(&quot;listener&quot;);// 获得对应的监听器    String message =&quot;&quot;;    if(null != user)&#123;        message=&quot;您已经登录过&quot;;    &#125;else&#123;        message=&quot;您还未登录&quot;;    &#125;    resp.setCharacterEncoding(&quot;UTF-8&quot;);    resp.setContentType(&quot;text/html;charset=UTF-8&quot;);    resp.getWriter().println(message);&#125;&#125;
5  测试
先登录,然后请求loginCheckController.do 校验是否登录过,然后重启项目,再起请求loginCheckController.do 校验是否登录过,发现重启后,仍然是登录过的
6 监听钝化和活化
MySessionActivationListener.java
public class MySessionActivationListener implements HttpSessionActivationListener, Serializable &#123;@Overridepublic void sessionWillPassivate(HttpSessionEvent se) &#123;    System.out.println(se.getSession().hashCode()+&quot;即将钝化&quot;);&#125;@Overridepublic void sessionDidActivate(HttpSessionEvent se) &#123;    System.out.println(se.getSession().hashCode()+&quot;已经活化&quot;);&#125;&#125;
LoginController登录时绑定监听器
 @WebServlet(&quot;/loginController.do&quot;)public class LoginController extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String username = req.getParameter(&quot;user&quot;);        String pwd = req.getParameter(&quot;pwd&quot;);        // user        User user =new User(username,pwd);        // session        HttpSession session = req.getSession();        session.setAttribute(&quot;user&quot;, user);        // 绑定监听器        session.setAttribute(&quot;listener&quot;, new MySessionActivationListener());    &#125;&#125;
重启项目 重复测试即可


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel</title>
    <url>/2024/03/17/23-Sentinel/</url>
    <content><![CDATA[Sentinel



一、熔断、降级、限流
1.熔断
  服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。
停止是说，当前服务一旦对下游服务进行熔断，当请求到达时，当前服务不再对下游服务进行调用，而是使用设定好的策略(如构建默认值)直接返回。
暂时是说，熔断后，并不会一直不再调用下游服务，而是以一定的策略(如每分钟调用 10 次，若均返回成功，则增大调用量)试探调用下游服务，当下游服务恢复可用时，自动停止熔断。

2.降级
  降级是指当自身服务压力增大时，采取一些手段，增强自身服务的处理能力，以保障服务的持续可用。比如，下线非核心服务以保证核心服务的稳定、降低实时性、降低数据一致性。
  为了预防某些功能出现负荷过载或者响应慢的情况，在其内部暂时舍弃一些非核心接口和数据的请求（如评论、积分），而直接返回一个提前准备好的 fallback(退路) 错误处理信息。释放CPU和内存资源，以保证整个系统的稳定性和可用性。
3.限流
  限流是指上游服务对本服务请求 QPS 超过阙值时，通过一定的策略(如延迟处理、拒绝处理)对上游服务的请求量进行限制，以保证本服务不被压垮，从而持续提供稳定服务。常见的限流算法有滑动窗口、令牌桶、漏桶等。
二、Sentinel
1.其他组件对比

2.Sentinel介绍
  随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。
Sentinel 的历史：

2012 年，Sentinel 诞生，主要功能为入口流量控制。
2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。
2018 年，Sentinel 开源，并持续演进。
2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 C++ 原生版本，同时针对 Service Mesh 场景也推出了 Envoy 集群流量控制支持，以解决 Service Mesh 架构下多语言限流的问题。
2020 年，推出 Sentinel Go 版本，继续朝着云原生方向演进。

Sentinel 分为两个部分:

核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。
控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。

Sentinel 可以简单的分为 Sentinel 核心库和 Dashboard。核心库不依赖 Dashboard，但是结合 Dashboard 可以取得最好的效果。
3. 基本概念及作用
基本概念：
资源：是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。
只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。
规则：围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。
主要作用：

流量控制
熔断降级
系统负载保护

我们说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 Sentinel 来进行资源保护，主要分为几个步骤:

定义资源
定义规则
检验规则是否生效

先把可能需要保护的资源定义好，之后再配置规则。也可以理解为，只要有了资源，我们就可以在任何时候灵活地定义各种流量控制规则。在编码的时候，只需要考虑这个代码是否需要保护，如果需要保护，就将之定义为一个资源。
4.Sentinel应用
官方文档：https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel
4.1 Sentinel控制台搭建
下载对应的jar包：https://github.com/alibaba/Sentinel/releases 下载适合自己的版本
通过命令行启动：
java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar
启动后需要输入账号密码:sentinel sentinel

登录成功后看到的页面

4.2 服务监控
  如果我们需要把自己的服务被Sentinel监控，那么我们需要添加对应的依赖
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt;
然后需要添加对应的属性信息

然后我们访问请求后，在控制台就可以看到对应的监控信息了

然后我们可以指定简单的限流规则

表示1秒中内只能有一个QPS。超过就限流

测试我们发送请求快一点就会出现限流的处理
4.3 实时监控
  实时监控这块需要引入Acuator
&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;
endpoint端点：

4.4 限流信息自定义
@Componentpublic class SentinelUrlBlockHandler implements BlockExceptionHandler &#123;    @Override    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws Exception &#123;        R r = R.error(500,&quot;访问太快，稍后再试!&quot;);        httpServletResponse.setContentType(&quot;application/json;charset=UTF-8&quot;);        httpServletResponse.getWriter().write(JSON.toJSONString(r));    &#125;&#125;

5.sentinel容器安装
  直接在windows中安装Sentinel启动管理还是不太方便，所以我们还是把Sentinel安装在Docker容器中
拉取对应的镜像文件
docker pull bladex/sentinel-dashboard:1.7.2
启动容器
docker run --name sentinel  -d -p 8858:8858 -d  bladex/sentinel-dashboard:tagname
开机自启动
docker update --restart=always sentinel
访问：

对应的客户端的使用：需要调整的配置信息


6.Sentinel监控所有服务
  我们需要对每一个服务都添加Sentinel的配置。

7.熔断降级
https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel
1.添加对应的配置

2.添加托底的方法


手动配置：客户端的Sentinel版本需要和服务器的版本要保持一致。

8.自定义资源
https://github.com/alibaba/Sentinel/wiki/如何使用#定义资源
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis与MQ在项目中的运用</title>
    <url>/2025/04/06/Redis%E3%80%81MQ%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[1、Redis与MQ在项目中的运用！
Redis应用场景-缓存系统

Redis最主要的还是做缓存，一般的方案下就是把热点数据（访问频次高）的数据放入Redis缓存，用Redis的高性能去避免MySQL数据的。这种方案一般的做法都会有兜底方案，就是数据在Redis中没有话，还是会去访问MySQL然后再把数据同步到Redis缓存。
Redis应用场景-排行榜、计数器
1、Redis提供的incr方法做计数器（点赞、关注数之类）
import redis.clients.jedis.Jedis;public class RedisCounter &#123;    private Jedis jedis;    public RedisCounter() &#123;        // 连接到 Redis        this.jedis = new Jedis(&quot;localhost&quot;, 6379);    &#125;    // 用户点赞    public void likePost(String postId) &#123;        jedis.incr(&quot;post:&quot; + postId + &quot;:likes&quot;);    &#125;    // 用户关注    public void followUser(String userId) &#123;        jedis.incr(&quot;user:&quot; + userId + &quot;:followers&quot;);    &#125;    public static void main(String[] args) &#123;        RedisCounter counter = new RedisCounter();          // 示例：用户点赞        counter.likePost(&quot;post1&quot;);        counter.likePost(&quot;post1&quot;);          // 示例：用户关注        counter.followUser(&quot;user1&quot;);          // 输出点赞数和关注者数        System.out.println(&quot;Post1 Likes: &quot; + counter.jedis.get(&quot;post:post1:likes&quot;));        System.out.println(&quot;User1 Followers: &quot; + counter.jedis.get(&quot;user:user1:followers&quot;));          // 关闭连接        counter.jedis.close();    &#125;&#125;
2、Redis提供的有序集合(sorted set)可以用来创建排行榜
import redis.clients.jedis.Jedis;import java.util.Set;public class RedisLeaderboard &#123;    private Jedis jedis;    public RedisLeaderboard() &#123;        // 连接到 Redis        this.jedis = new Jedis(&quot;localhost&quot;, 6379);    &#125;    // 用户点赞时更新排行榜    public void likePost(String postId, String userId) &#123;        // 假设每个点赞增加用户的分数        jedis.zincrby(&quot;post_rank&quot;, 1, userId);    &#125;    // 获取前 N 名用户    public Set&lt;String&gt; getTopUsers(int n) &#123;        return jedis.zrevrange(&quot;post_rank&quot;, 0, n - 1);    &#125;    public static void main(String[] args) &#123;        RedisLeaderboard leaderboard = new RedisLeaderboard();          // 示例：用户点赞        leaderboard.likePost(&quot;post1&quot;, &quot;user1&quot;);        leaderboard.likePost(&quot;post1&quot;, &quot;user2&quot;);        leaderboard.likePost(&quot;post1&quot;, &quot;user1&quot;);  // user1 再次点赞        // 获取前 2 名用户        Set&lt;String&gt; topUsers = leaderboard.getTopUsers(2);        System.out.println(&quot;Top Users: &quot; + topUsers);          // 关闭连接        leaderboard.jedis.close();    &#125;&#125;
Redis应用场景-共享session
多台应用服务器可以将用户的session存储在Redis中（缓存+过期机制）
Redis应用场景-分布式锁
Redisson的API介绍：
https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器#84-红锁redlock
分布式锁加入过期时间+加入看门狗
加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。
这个守护线程我们一般也把它叫做「看门狗」线程。

Redis应用场景-布隆过滤器
1970 年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个 Hash 算法组成。
本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。
相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。
实际上，布隆过滤器广泛应用于网页黑名单系统、垃圾邮件过滤系统、爬虫网址判重系统等，Google 著名的分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的IO次数，Google Chrome浏览器使用了布隆过滤器加速安全浏览服务。

布隆过滤器的误判问题
Ø通过hash计算在数组上不一定在集合
Ø本质是hash冲突
Ø通过hash计算不在数组的一定不在集合（误判）

优化方案
增大数组(预估适合值)
增加hash函数
Redis应用场景-Bitmap海量用户存储
1、目前有10亿数量的自然数，乱序排列，需要对其排序。限制条件-在32位机器上面完成，内存限制为 2G。如何完成？

使用一个大小为 1,000,000,000 的 Bitmap（每个自然数对应一个位）。
将每个自然数的位设置为 1，表示该数存在。
然后，可以遍历 Bitmap，按顺序输出所有存在的自然数。

由于内存限制为 2G，一个大小为 1,000,000,000 的 Bitmap 在 Redis 中大约占用 119.2 MB 的内存
2、如何快速在亿级黑名单中快速定位URL地址是否在黑名单中？(每条URL平均64字节)
把URL做Hash值计算，然后将其映射到 Bitmap。

计算 URL 的哈希值，并将对应的位设置为 1。


检查 URL 是否在黑名单中，只需查看对应的位是否为 1。

3、需要进行用户登陆行为分析，来确定用户的活跃情况？
可以使用 Bitmap 来记录用户的登录状态，用户 ID 作为位的索引。

每次用户登录时，将对应的位设置为 1。
可以通过位计数来获取活跃用户的数量。

Redis应用场景-GEO地图
GEO
Redis 3.2版本提供了GEO(地理信息定位)功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。
地图元素的位置数据使用二维的经纬度表示，经度范围(-180, 180]，纬度范围(-90,90]，纬度正负以赤道为界，北正南负，经度正负以本初子午线(英国格林尼治天文台) 为界，东正西负。
业界比较通用的地理位置距离排序算法是GeoHash 算法，Redis 也使用GeoHash算法。GeoHash算法将二维的经纬度数据映射到一维的整数，这样所有的元素都将在挂载到一条线上，距离靠近的二维坐标映射到一维后的点之间距离也会很接近。当我们想要计算「附近的人时」，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就行了。
在 Redis 里面，经纬度使用 52 位的整数进行编码，放进了 zset 里面，zset 的 value 是元素的 key，score 是 GeoHash 的 52 位整数值。
操作命令
增加地理位置信息
geoadd key longitude latitude member [longitude latitude member …J
longitude、latitude、member分别是该地理位置的经度、纬度、成员，例如下面有5个城市的经纬度。
城市            经度             纬度             成员
北京            116.28          39.55            beijing
天津            117.12          39.08            tianjin
石家庄        114.29          38.02            shijiazhuang
唐山            118.01          39.38            tangshan
保定            115.29          38.51            baoding
cities:locations是上面5个城市地理位置信息的集合，现向其添加北京的地理位置信息:
geoadd cities :locations 116.28 39.55 beijing
返回结果代表添加成功的个数，如果cities:locations没有包含beijing,那么返回结果为1，如果已经存在则返回0。
如果需要更新地理位置信息，仍然可以使用geoadd命令，虽然返回结果为0。geoadd命令可以同时添加多个地理位置信息:
geoadd cities:locations 117.12 39.08 tianjin 114.29 38.02shijiazhuang 118.01 39.38 tangshan 115.29 38.51 baoding
获取地理位置信息
geopos key member [member …]下面操作会获取天津的经维度:
geopos cities:locations tianjin1)1)“117.12000042200088501”
获取两个地理位置的距离。
geodist key member1 member2 [unit]
其中unit代表返回结果的单位，包含以下四种:
m (meters)代表米。
km (kilometers)代表公里。
mi (miles)代表英里。
ft(feet)代表尺。
下面操作用于计算天津到北京的距离，并以公里为单位:
geodist cities : locations tianjin beijing km
获取指定位置范围内的地理信息位置集合
georadius key longitude latitude radius m|km|ft|mi [withcoord][withdist][withhash][COUNT count] [ascldesc] [store key] [storedist key]georadiusbymember key member radius m|km|ft|mi  [withcoord][withdist][withhash] [COUNT count][ascldesc] [store key] [storedist key]
georadius和georadiusbymember两个命令的作用是一样的，都是以一个地理位置为中心算出指定半径内的其他地理信息位置，不同的是georadius命令的中心位置给出了具体的经纬度，georadiusbymember只需给出成员即可。其中radius  m | km |ft |mi是必需参数，指定了半径(带单位)。
这两个命令有很多可选参数，如下所示:
withcoord:返回结果中包含经纬度。
withdist:返回结果中包含离中心节点位置的距离。
withhash:返回结果中包含geohash，有关geohash后面介绍。
COUNT count:指定返回结果的数量。
asc l desc:返回结果按照离中心节点的距离做升序或者降序。
store key:将返回结果的地理位置信息保存到指定键。
storedist key:将返回结果离中心节点的距离保存到指定键。
下面操作计算五座城市中,距离北京150公里以内的城市:
georadiusbymember cities:locations beijing 150 km
获取geohash
geohash key member [member ...]
Redis使用geohash将二维经纬度转换为一维字符串，下面操作会返回beijing的geohash值。
geohash cities: locations beijing
字符串越长,表示的位置更精确，geohash长度为9时,精度在2米左右，geohash长度为8时,精度在20米左右。
两个字符串越相似,它们之间的距离越近,Redis 利用字符串前缀匹配算法实现相关的命令。
geohash编码和经纬度是可以相互转换的。
删除地理位置信息
zrem key member
GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除。
MQ应用场景-异步解耦

1、灵活适应业务的快速增长：通过MQ的异步化设计，可以灵活高效的适应因业务快速发展而带来的变化，如新增业务系统。
2、高可用松耦合架构设计：通过上、下游业务系统的松耦合设计，即便下游子系统（如物流、积分等）出现不可用甚至宕机，都不会影响到核心交易系统的正常运转
MQ应用场景-削峰填谷

秒杀、抢红包、企业开门红等大型活动时皆会带来较高的流量脉冲，或因没做相应的保护而导致系统超负荷甚至崩溃，或因限制太过导致请求大量失败而影响用户体验。用MQ的削峰填谷是解决该问题的有效方式。
1、超高流量脉冲处理能力：MQ 超高性能的消息处理能力可以承接流量脉冲而不被击垮，在确保系统可用性同时，因快速有效的请求响应而提升用户的体验
2、海量消息堆积能力：确保下游业务在安全水位内平滑稳定的运行，避免超高流量的冲击
3、合理的成本控制：削峰填谷可控制下游业务系统的集群规模，从而降低投入成本
RocketMQ应用场景-分布式事务消息

**传统事务：**多个系统或者应用组件之间的业务处理会耦合到一个大事务中，响应时间长，业务链路长从而影响系统的整体性能和可用性，甚至引起系统崩溃
**RocketMQ分布式事务：**将核心链路业务与可异步化处理的分支链路进行拆分，将大事务拆分成小事务，减少系统间的交互，既高效又可靠；RocketMQ 的可靠传输与多副本技术能确保消息不丢失。
RocketMQ/Kafka-流式数据处理

数据在&quot;流动&quot;中产生价值，传统数据分析大多是基于批量计算模型，而无法做到实时的数据分析，利用 RocketMQ /Kafka与流式计算引擎相结合，可以很方便的实现将业务数据进行实时分析。
RocketMQ/Kafka-分布式模缓存同步

大型项目做了分布式缓存（分会场），各个分会场琳琅满目的商品需要实时感知价格变化，大量并发访问数据库导致会场页面响应时间长，集中式缓存因为带宽瓶颈限制商品变更的访问流量，通过 RocketMQ 构建分布式缓存，实时通知商品数据的变化。
大促众多分会场，多缓存的架构设计，满足对商品变更的大量访问需求。
2、为什么选用Redis缓存，MQ如何进行技术选型！
Redis有丰富的功能，不单纯是一个缓存。如果是对比的话，MongoDB的话缺乏Redis的功能，同时稳定性和版本的延续性对比Redis也要差不少。
MQ的话：
RabbitMQ吞吐量最少。RabbitMQ的语言兼容性最好（多语言API做的很好，C、Python等等语言都支持），
RocketMQ的话，适合电商（有丰富的电商的场景）、比如延时消息之类的。（语言对接只有Java好对接点）
Kafka适合于大数据系统对接，有很多大数据组件比如Flink都有比较好的Kafka对接API之类的（多语言API做的不错，C、Python等等语言都支持。
站在存储的角度，RocketMQ和Kafka天生持久化，RabbitMQ的话需要配置（配置持久化性能会有下降）。同时RabbitMQ需要去了解AMQP模型，RokcetMQ和Kafka模型简单。RabbitMQ消费是删除消息，RocketMQ和Kafka都是消费偏移量管理，适合于存储消息，做消息回溯之类的。
3、MCA项目中Redis与MQ的运用
这些具体内容我讲了一个大概，需要看视频内容。
1、合家云社区物业管理平台:Redis
2、烽火云短信平台:Redis、RabbitMQ
3、从0到1手敲代码实现商城项目：Redis、RocketMQ
4、马士兵严选课程-IM通信中台：Redis、RocketMQ
5、飞滴出行网约车项目：Redis、RocketMQ
6、音乐数据中心综合数仓项目：Redis、Kafka
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/02/12/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[Redis是一个使用c语言编写的，开源的高性能非关系型数据库(NoSQL)

数据类型
回答：一共五种
(一)String
这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。
(二)hash
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
(三)list
使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。
(四)set
因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
(五)sorted set
sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。
内部结构

dict 本质上是为了解决算法中的查找问题（Searching）是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。 本质上是为了解决算法中的查找问题（Searching）
sds sds就等同于char * 它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。
skiplist （跳跃表） 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现，
quicklist
ziplist 压缩表 ziplist是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构，

redis怎么用
命令
1. Key操作



命令
含义
返回值




exists key 名称
判断key是否存在
数字/0


expire key 秒数
设置key过期时间
1/0


ttl key
查看key的剩余过期时间
返回剩余时间，如果不过期返回-1


del key
根据key删除键值对。
被删除key的数量



2. 字符串值(String)



命令
含义
返回值




set key value
设置指定key的值
成功OK


get key
获取指定key的值
key的值。不存在返回nil


setnx key value
当且仅当key不存在时才新增。
不存在时返回1，存在返回0


setex key seconds value
设置key的存活时间，无论是否存在指定key都能新增，如果存在key覆盖旧值。同时必须指定过期时间。
OK



3.哈希表(Hash)
​	Hash类型的值中包含多组field value。

3.1 hset
​	给key中field设置值。
​	语法：hset key field value
​	返回值：成功1，失败0
3.2 hget
​	获取key中某个field的值
​	语法：hget key field
​	返回值：返回field的内容
3.3 hmset
​	给key中多个filed设置值
​	语法：hmset key field value field value
​	返回值：成功OK
3.4 hmget
​	一次获取key中多个field的值
​	语法：hmget key field field
​	返回值：value列表
3.5 hvals
​	获取key中所有field的值
​	语法：hvals key
​	返回值：value列表
3.6 hgetall
​	获取所有field和value
​	语法：hgetall key
​	返回值：field和value交替显示列表
3.7 hdel
​	删除key中任意个field
​	语法：hdel key field field
​	返回值：成功删除field的数量
4. 列表（List）
4.1 Rpush
​	向列表末尾中插入一个或多个值
​	语法；rpush key value value
​	返回值：列表长度
4.2 lrange
​	返回列表中指定区间内的值。可以使用-1代表列表末尾
​	语法：lrange list 0 -1
​	返回值：查询到的值
4.3 lpush
​	将一个或多个值插入到列表前面
​	语法：lpush key value value
​	返回值：列表长度
4.4 llen
​	获取列表长度
​	语法：llen key
​	返回值：列表长度
4.5 lrem
​	删除列表中元素。count为正数表示从左往右删除的数量。负数从右往左删除的数量。
​	语法：lrem key count value
​	返回值：删除数量。
5 集合(Set)
​	set和java中集合一样。
5.1 sadd
​	向集合中添加内容。不允许重复。
​	语法：sadd key value value value
​	返回值：集合长度
5.2 scard
​	返回集合元素数量
​	语法：scard key
​	返回值：集合长度
5.3 **smembers **
​	查看集合中元素内容
​	语法：smembers key
​	返回值：集合中元素
6 .有序集合（Sorted Set）
​	有序集合中每个value都有一个分数（score），根据分数进行排序。
6.1 zadd
​	向有序集合中添加数据
​	语法：zadd key score value score value
​	返回值：长度
6.2 zrange
​	返回区间内容，withscores表示带有分数
​	语法：zrange key 区间 [withscores]
​	返回值：值列表
使用SpringBoot整合SpringDataRedis操作redis
​	Spring Data是Spring公司的顶级项目，里面包含了N多个二级子项目，这些子项目都是相对独立的项目。每个子项目是对不同API的封装。
​	所有Spring Boot整合Spring Data xxxx的启动器都叫做spring-boot-starter-data-xxxx
​	Spring Data 好处很方便操作对象类型。
​	把Redis不同值得类型放到一个opsForXXX方法中。
​		opsForValue : String值
​		opsForList : 列表List
​		opsForHash: 哈希表Hash
​		opsForZSet: 有序集合Sorted Set
​		opsForSet : 集合
1. 添加依赖
&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;
2. 配置配置文件
​	spring.redis.host=localhost 默认值
​	spring.redis.port=6379 端口号默认值
spring:  redis:    host: 192.168.52.133# cluster:# nodes: 192.168.93.10:7001,192.168.93.10:7002,192.168.93.10:7003,192.168.93.10:7004,192.168.93.10:7005,192.168.93.10:7006
3.编写配置类
@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory 		  factory)&#123;        RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(factory);        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));        return redisTemplate;    &#125;&#125;
4. 编写代码
4.1 编写对象新增
@Autowiredprivate RedisTemplate&lt;String, Object&gt; redisTemplate;@Testpublic void testString() &#123;    People peo = new People(1, &quot;张三&quot;);    redisTemplate.opsForValue().set(&quot;peo1&quot;, peo);&#125;
4.2 编写对象获取
此处必须编写值序列化器。不指定时返回类型为LinkedHashMap
@Testpublic void testGetString() &#123;    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;People&gt;(People.class));    People peo = (People) redisTemplate.opsForValue().get(&quot;peo1&quot;);    System.out.println(peo);&#125;
4.3 编写List
@Testpublic void testList() &#123;    List&lt;People&gt; list = new ArrayList&lt;&gt;();    list.add(new People(1, &quot;张三&quot;));    list.add(new People(2, &quot;李四&quot;));    redisTemplate.opsForValue().set(&quot;list2&quot;, list);&#125;
4.4 编写List取值
@Testpublic void testGetList()&#123;    redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;List&gt;(List.class));    List&lt;People&gt; list2 = (List&lt;People&gt;) redisTemplate.opsForValue().get(&quot;list2&quot;);    System.out.println(list2);&#125;
redis持久化
​	Redis不仅仅是一个内存型数据库，还具备持久化能力。
1. RDB
​	rdb模式是默认模式，可以在指定的时间间隔内生成数据快照（snapshot），默认保存到dump.rdb文件中。当redis重启后会自动加载dump.rdb文件中内容到内存中。用户可以使用SAVE（同步）或BGSAVE（异步）手动保存数据。比如save 900 1 的设置就会让服务器在900 秒以内，如果对数据库修改了至少一次的时候就会执行BGSAVE。
优点就是这样的恢复效率会比aof高，而且直接用文件就可以还原，但是如果出现不可预知的关闭的时候，就会可能丢失数据。并且每次保存数据的时候都会进行fork()子进程，这样会导致大量的耗费性能。
2 AOF
​	AOF默认是关闭的，需要在配置文件中开启AOF。Redis支持AOF和RDB同时生效，如果同时存在，AOF优先级高于RDB，也就是Redis重新启动时会使用AOF进行数据恢复，他存储的是redis所有的修改数据的操作。开启方法就是修改redis.conf文件里面appendonly yes（默认是no）
优点就是比RDB数据更加安全不容易丢失数据，在重启的时候就会进行数据恢复，但是就是数据集很大，比RDB也会更慢一点。
# 默认noappendonly yes# aof文件名appendfilename &quot;appendonly.aof&quot;
穿透、击穿、雪崩、预热、更新过期key
穿透
就是数据库和缓存都没有这个数据，这样就导致了用户查询的时候再缓存里面找不到，每次又去数据库里面找，然后返回空，相当于进行了两次无效请求，要解决这种重复的无效请求，可以用两种办法，第一种就是简单暴力的将key对应null值存入缓存，但是这样就会有对空间的占用，第二种就是使用布隆过滤器，布隆过滤器是将所有可能存在的数据hash到一个足够大的bitmap里面，一个一定不会存在的数据，就会被这个bitmap给拦截掉，从而避免了直接对底层数据库查询的压力，并且因为有hash冲突的可能，底层算法使用多个hash函数来解决“冲突”，因为同一个hash函数算出来的值有可能相等，所以引入多个hash，通过一个hash某元素不在集合里面，说明就不在，判断在的时候就得当所有hash算出来在才算在。这是布隆过滤器的实现核心。
击穿
击穿就是当一个key很热点的时候，大并发集中对这个点进行访问，当这个key在缓存过期失效的一瞬间，就会持续的穿破缓存，直接对数据库进行一个请求，简单来说就是缓存里面没有，数据库里面有。
解决的话可以在访问key之前，把这些请求用锁锁起来，设置一个短期的key来锁，访问结束再删除短期key。 处理的案例之前做项目的时候我记得，多个机器拿token，token再存一份到redis里面，保证系统再token过期的时候只有一个线程去获取token，使用分布式锁。
雪崩
缓存雪崩也是一种缓存里面没有数据库里面有的情况，只不过是比击穿多了很多过期的key，比如设置了相同的过期时间，同一时间内出现了大面积的缓存过期，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。
解决办法：
大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。
预热
缓存预热就是在系统上线后，我们将相关的缓存数据直接加载到系统之中，这样提前就避免了一个用户请求直接去查询数据库的情况。
具体操作可以是先写一个缓存刷新页面，然后数据量如果不打就自行加载，后面再定时刷新
更新
自定义的缓存淘汰（更），第一种是定时去清理过期的缓存； 第二种是用户请求过来时再去判断这个缓存是否过期。
两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！
降级
降级服务，是为了防止redis服务故障导致数据库一起发生雪崩问题，所以对于不要的缓存数据，可以进行降级，举个例子就是，redis出现问题了，就不去数据库查询，而是返回默认值给用户。
redis单线程

Redis是单线程的，做的都是纯内存操作，使用单线程就避免了频繁的上下文切换，并且在6.x版本以后就增加了非阻塞I/O多路复用机制，但是工作线程其实还是单线程，计算都是串行的，redis从内核读取数据搬运数据的操作在6.x版本以后就是并行的在多个cpu上进行，但是主要的计算工作线程里还是将多个事件进行串行处理的，多路复用器里面使用selec、epoll等进行读写事件的一个判断，有就取出来进行处理。
快的关键
(一)纯内存操作
(二)单线程操作，避免了频繁的上下文切换
(三)采用了非阻塞I/O多路复用机制
分布式锁
Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。
将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作
解锁：使用 del key 命令就能释放锁
解决死锁：
1）通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。
2） 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。
锁续期：好像是redission这个客户端里面自动就会实现的一个，底层我看过一篇文章好像是watchdog来每30秒判断是否client还持有锁，如果还持有就不断延长key，我还记得好像还使用的是可重入锁。
redis的过期策略以及内存淘汰机制
redis采用的是定期删除+惰性删除策略。定期删除呢举个例子就是每一段时间去检查是否有过期的key，但是这个检查不是说检查所有的，是随机抽取检查，所以如果只采用定期删除的话，就会导致很多key没有被定时删除，所以就引入惰性删除，就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间，就判断是否过期进行删除操作。
但是即使采用了这两种策略，也会有这种情况，就是如果定期删除没删掉，也没有及时去请求一个key，也就是惰性删除也没生效，就会导致一个内存越来越高，所以就还有一个内存淘汰机制。
内存淘汰机制是redis.conf文件的一行配置， 使用maxmemory-policy 加上 具体淘汰机制的这个名称： 机制我记得有这几种：

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。

主从复制 集群（cluster）
支持集群功能，并且还支持主从复制，就是每个节点有N个复制品，然后其中一个复制品是主，另外都是slave从，支持一个 一主多从，每个从又可以看作主，优点就是增强单一节点的健壮性，从节点可以对主节点做一个复制数据备份，提升了容灾能力。还有一点就是redis里面主节点一般用来写，从节点只能读，这样实现了读写分离，减少并发出现的一些同步错误。
搭建主从节点： replicaof + 主节点ip+ 端口
启动：在starup.sh文件里面进行设置 cd + 目录+ redis.conf
收于权限：chmod a+x startup.sh
哨兵
由于主从复制默认从只有读能力，所以如果主节点出现宕机，整个节点就不具备写能力了，所以呢我们用哨兵Sentinel来监控节点，如果主节点宕机，就重新选取主节点。
Memcache与Redis的区别都有哪些？
(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
(2) redis的速度比memcached快很多
(3) redis可以持久化其数据：存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据
(4)使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3 Day2 —— BlockChain Basic 2</title>
    <url>/2025/06/17/WEB3%20Day2%20%E2%80%94%E2%80%94%20BlockChain%20Basic%202/</url>
    <content><![CDATA[WBE3 DAY2 —— BlockChain Basics 2
Layer1
​	blockChain的base layer，例如bitcoin、BNB chain、Solana,and Avalanche.
Layer2
构建在L1区块链外部但是也与之连接的任何应用application。有各种类型，比如for example ChainLink(去中心化预言机网络) ，以及像The Graph(事件索引网络)。
RollUp
是L2的扩容解决方案，通过将多笔交易打包成一笔来增加以太坊上的交易数量，从而降低gas费
1 optimistic rollups
默认链下交易是有效的，操作者回提出rollup链的有效状态，在挑战期间内，其他的操作者可以通过计算欺诈证明来质疑潜在的欺诈交易。
2 zero-knowledge rollups
零知识证明， 使用有效性证明来验证交易的批次。 zk证明即有效性证明，
3 witness
验证者通过检查zk证明来验证输出是否和预期匹配。 而这整个证明者(prover)用来展示输入满足zk证明中的数学方程的方案就是见证(witness).
RollUp stage (Rollup 发展阶段)
Stage 0
在这个初始的阶段，RollUp的治理主要由运营方和安全委员会掌控，确保关键决策并且有可信的团体去专门监督（中心化的），此阶段的用户拥有退出机制，可以在七天内离开rollup，但是通常需要实体和运营方的操作进行结合。
Stage 1
中心化的治理演化为智能合约管理，当然安全委员会同时发挥作用。
证明系统完全开始运作，支持去中心化的有效证明。
退出机制也得到改进，用户可独立退出而无需运营方协调。
Stage 2
通过完全由智能合约管理的治理机制实现完全去中心化。
无需运营方和安全委员会干预。
证明系统是无许可的，退出机制也完全去中心化。
ZKSync Risk Analysis[风险分析]
https://l2beat.com/scaling/summary  L2Beat摘要中可以查看各Rollup所处的stage
Risks那一列的饼图可以体现当前阶段的一些风险，例如ZkSync Era专属页面中：



Data Availability: refers to the ability to reconstruct the L2 state from L1 data, ensuring that anyone can verify and rebuild the L2 state if necessary.
能够从L1的数据中重建L2状态


State Validation: involves verifying the legitimacy of a set of bundled transactions. For ZK Sync, this is done using zero-knowledge proofs through an algorithm known as PLONK (Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge).
涉及验证一组打包交易的合法性。


Sequencer Failure: describes the ability to process transactions even if the sequencer is down. In ZK Sync, transactions can still be submitted to L1, though not necessarily enforced immediately.
排序器故障，描述了即使排序器宕机还能够处理交易的能力，这里黄色区块表示，在ZKsync中，交易仍然可以提交到L1，但不一定能够强制执行。

排序器：是负责对打包的用户交易进行排序的操作方（运营商）
The sequencer is the operator responsible for ordering user transactions and often batching them before committing them to Layer 1.



Proposer Failure: describes the ability to process transactions even if the proposer is down. In this case, ZK Sync will halt all withdrawals and transactions executions.
提议者宕机但是可以处理交易的能力。在Zksync中回暂停所有的提款和交易执行。


Exit Window: In the current ZK Sync stage, there is no window for exit during unwanted upgrades.
红色区块表示Zksync在非预期的升级时不存在退出窗口期。


First Transaction On ZKSync
chainList 官网搜索ZKsync sepolia
https://chainlist.org/?search=zksync+sepolia&amp;testnets=true

进行connect


在zkSync官网的block explorer 中，可搜索到自己的账户，查看交易详情
如何获取测试网络的基金？

📒 NOTE
Network Fauncets

这里可以通过brige桥接源链和目标链来进行，也有两种方式，一种是lock和unlock 另一种是烧毁和铸造；
可能会有安全问题，但是基于ZkSync使用过程的经验来说，是比较安全的。

了解原理之后，我们在推荐的fauncet里获取我们的fund

这里我recive失败了，重新找了其他funsets ，可以用回tenderly试试看
Solidity
Remix IDE

first solidity program
simpleStorge.sol
// SPDX-License-Identifier: MITpragma solidity 0.8.19; // chose our solidity version contract SimpleStorage &#123;    uint256 public myFavoriteNumber; // 初始值就是0 而且是internal 也就是内部不可见的    function store(uint256 favoriteNumber) public &#123;        myFavoriteNumber = favoriteNumber;    &#125;&#125;

Deployed contracts are the same as modifying the blockchain. Whenever we modify anything on the blockchain, it is actually done by sending a transaction. Therefore, deploying contracts will cost a gas fee.

返回体函数：
// view 可读不可写 pure 不可读不可写  function recive() public view returns (uint256) &#123;      return myFavoriteNumber;  &#125;
数组与结构
  // 数组  uint256[] public myFavoriteNumbers;  // 结构  struct Person &#123;      uint256 personNumber;      string name;  &#125;  Person public newPerson = Person(1, &#x27;jack&#x27;);  Person public myPerson;// 数组加结构  Person[] public myPersonArray;  function setPerson(string memory name, uint256 person_number) public &#123;      myPersonArray.push(Person(person_number,name));  &#125;
// SPDX-License-Identifier: MITpragma solidity 0.8.19; // stating our version contract SimpleStorage &#123;    uint256 public myFavoriteNumber; // 初始值就是0 而且是internal 也就是内部不可见的    // 数组    uint256[] public myFavoriteNumbers;    // 结构    struct Person &#123;        uint256 personNumber;        string name;    &#125;    Person public newPerson = Person(1, &#x27;jack&#x27;);    Person public myPerson;    Person[] public myPersonArray;    function setPerson(string memory name, uint256 person_number) public &#123;        myPerson = Person(person_number, name);        myPersonArray.push(myPerson);    &#125;    function store(uint256 favoriteNumber) public &#123;// 存储        myFavoriteNumber = favoriteNumber;    &#125;    // view 可读不可写 pure 不可读不可写    function recive() public view returns (uint256) &#123;        return myFavoriteNumber;    &#125;&#125;
]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2021/08/13/git/</url>
    <content><![CDATA[概念
Git是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的项目。
版本控制：版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统 。
代码托管中心
我们已经有了本地库，本地库可以帮我们进行版本控制，为什么还需要代码托管中心呢？
它的任务是帮我们维护远程库，下面说一下本地库和远程库的交互方式，也分为两种：


团队内部协作



跨团队协作

https://github.com/SoniaChan33/SoniaChan33.github.io


初始化本地仓库


创建一个文件夹



打开Git终端：Git Bash Here


查看Git安装版本
git --version


清屏
clear


设置签名
git config --global user.name &quot;TeaSea33&quot;git config --global user.email &quot;TeaSea33@outlook.com&quot;


本地仓库的初始化操作(目录在本地仓库里)
git init



查看.git下的内容

注意事项： .git目录下的本地库相关的子目录和子文件不要删除，不要胡乱修改。


Git常用命令
add和commit


先创建文件


将文件提交到暂存区
git add Demo2.txt


将暂存区的内容提交到本地库



注意：

不放在本地仓库中的文件，git是不进行管理
即使放在本地仓库的文件，git也不管理，必须通过add,commit命令操作才可以将内容提交到本地库。



Status
查看工作区和暂存区的状态


创建一个文件，然后查看状态
git status



然后将Demo2.txt通过git add命令提交到暂存区
git add &quot;Demo3.txt&quot;


status查看状态



commit提交文件



修改文件 并查看状态



重新添加至暂存区 并查看状态



提交以后查看状态




log
可以查看提交的日志，显示最近到最远的日志
日志展示方式


git log 
   &lt;img src=&quot;git/20210716165040.png&quot; alt=&quot;image-20210716164533294&quot; style=&quot;zoom:67%;&quot; /&gt;   ---&gt; 分页   当历史记录过多的时候使用**空格**翻页，**b**  回到上一页，到尾页显示END,   退出：**q**2. ```shell   git log --pretty=oneline

&lt;img src=&quot;git/20210716165022.png&quot; alt=&quot;image-20210716165022038&quot; style=&quot;zoom:67%;&quot; /&gt;




git log --oneline
   &lt;img src=&quot;git/20210716165148.png&quot; alt=&quot;image-20210716165147993&quot; style=&quot;zoom:67%;&quot; /&gt;4. ```shell   git reflog

多了信息：HEAD@&#123;数字&#125;

数字：指针回到当前这个历史版本需要多少步

&lt;img src=&quot;git/20210716165501.png&quot; alt=&quot;image-20210716165500983&quot; style=&quot;zoom:67%;&quot; /&gt;




reset
前进或者后退历史版本

先查看历史log状态




将文件后退到版本1



再次查看



三个参数(hard\mixed\soft)
git reset --[参数] [索引]


hard
本地库的指针移动的同时，重置暂存区，重置工作区



mixed
本地库的指针移动的同时，重置暂存区，但是工作区不动



soft
本地库的指针移动的时候，暂存区，工作区都不动



用得最多的就是第一种hard参数
hard
1.找回本地库删除的文件


新建一个Test2.txt文件 并将它add到暂存区中



再通过commit提交到本地库



删除工作区中的Test2.txt 并将删除操作同步到暂存区



将删除操作同步到本地库



查看日志



找到本地库中删除的文件，实际上就是将历史版本切换到刚才添加文件的那个版本即可



2.找回暂存区删除的文件


删除工作区数据



同步到缓存区



查看日志



找到当前指针 然后返回到该状态




diff


比对工作区和暂存区
git diff [文件名]

添加并提交一个内容为aaaa的Test3.txt



更改工作区的文件加入bbb，再用dif进行比对，发现不同



如果修改了多个文件，多个文件的比对命令直接是git diff




比对暂存区和本地库 ：
git diff [历史版本] [文件]


文件添加不提交到本地库，此时暂存区就和工作区相同为aaaabbb


查看日志

此刻的本地库还停留在之前第一次修改


比对暂存区和本地库中的HEAD当前指针状态

发现不一样，说明没有提交的时候就是不一样的


HEAD部分可以改成其他历史版本的标号





分支
查看分支

创建新分支

切换分支

进入branch01分支，增加内容


再次查看两个分支发现主分支没有改变

查看文件

将branch01合并到主分支

因为在同一文件的同一位置修改了文件

解决冲突：
人为决定，留下想要的就可以，然后再添加

提交冲突，不能带文件名


Github
创建远程库
为远程库取别名

将本地库数据推送到远程库中



查看远程库

SSH免密操作


进入用户的主目录中：


执行命令，生成一个.ssh目录



发现.ssh目录下有两个文件



第二个文件里面的密钥复制，去github下新建密钥


密钥生成：



免密操作使每次需要push仓库的时候，都不用再输入密码434
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3 Day1 —— BlockChain Basic 1</title>
    <url>/2025/06/17/WEB3%20Day1%20%E2%80%94%E2%80%94%20BlockChain%20Basic%201/</url>
    <content><![CDATA[WEB3 Day1 —— BlockChain Basic 1
转型方向
从 Java 开发转型至智能合约开发。
学习资源
学习视频
推荐 patrick collins 【Cyfrin】的教学视频 。
同时，Cyfrin Updraft 官网提供了文字笔记和视频课程。不过，某些翻译插件的双语字幕不支持该网站，因此我选择在 YouTube 上观看完整视频，并且将两者结合起来学习。
翻译插件推荐
这里推荐一款翻译插件——沉浸式翻译
创建自己的钱包
安装 MetaMask 插件
首先，进入 MetaMask 官网，将其作为 Chrome 浏览器插件添加到浏览器中。
创建钱包
创建自己的钱包后，会得到三个关键信息：私钥（private key）、助记词（Mnemonic Key）和公钥地址（public Address）。其中，私钥和助记词极其重要，务必安全保存！因为拥有私钥就可以直接访问你的钱包账户，所以千万不能有侥幸心理。建议将助记词记录在纸上，而不是存储在电脑里，如果能记在大脑中（如使用记忆宫殿的方法）则是最安全的。三者的重要性排序为：【Mnemonic &gt; Private Key &gt; public Address】。
相关图示如下：


模拟交易
创建虚拟测试网络
登录 Tenderly 测试网站（https://tenderly.co/?mtm_campaign=partner&amp;mtm_kwd=cyfrin ），通过该链接注册并创建账户是免费的。在网站左侧点击“virtual TestNets”，创建虚拟测试网络。

网络设置
进行简单设置，无特定要求。设置完成后，会创建一个模拟区块链，接下来可以将其添加到 MetaMask 中。

手动添加网络问题处理
在连接后，可能会遇到 MetaMask 中未显示创建的虚拟网络的问题，此时需要手动添加。注意，原系统默认的 chainId（11155111）无法修改，因此需要重新创建一个链，并在创建时在“custom”处修改自己的 ID。

有其他开发者也遇到了同样的问题，可参考：https://github.com/Cyfrin/foundry-full-course-cu/discussions/4066?sort=old
注资操作
完成上述步骤后，进行注资。

查看注资结果
注资完成后，等待几分钟，就可以在自定义虚拟网络中看到资金到账啦，仿佛瞬间“暴富”（当然这只是模拟）。

账户间转账
在模拟网络中，从一个账户向另一个账户转账非常简单，直接进行发送操作即可。


另外，Tenderly 与 Cypher 有合作，账户可以续期。

区块链数据结构
可以通过 BlockChain Demo 网站（https://andersbrownworth.com/blockchain/block ）来帮助理解区块链的底层数据结构。
交易费用相关概念
交易费用（Transaction Fee）
交易费用是支付给区块生产者处理交易的奖励金额，通常通过以太币或者 Gwei 支付。
燃气价格（Gas Price）
同样以以太币或者 Gwei 来定义，燃气价格是交易中指定的每单位燃气（Gas）的成本。价格越高，交易被打包进区块的机会就越大，它用于设定交易中每单位燃气的成本。
燃气（Gas）
不要将燃气与燃气价格混淆。燃气指的是执行交易所需要的工作量，而燃气价格则是每单位工作量的成本。
交易费用的计算公式为：
Transaction fee =  gasPrice * gasUsed
简单来说，当大量用户进行交易时，特定区块的空间竞争会变得激烈，此时提高燃气价格可以在拥堵时限制交易，并优先处理部分交易。
]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql8项目连接出错&amp;端口为0</title>
    <url>/2022/05/10/mysql8%E9%A1%B9%E7%9B%AE%E8%BF%9E%E6%8E%A5%E5%87%BA%E9%94%99-%E7%AB%AF%E5%8F%A3%E4%B8%BA0/</url>
    <content><![CDATA[MySQL8端口为0
今天连接数据库的时候，密码正确，配置也没毛病，但是就是连不上


于是去查了查端口
show global variables like &#x27;port&#x27;;
显示
+---------------+-------+| Variable_name | Value |+---------------+-------+| port          | 0     |+---------------+-------+1 row in set (0.00 sec)
竟然不是3306
去网上查资料发现可能是之前某些操作让skip-networking打开了
mysql&gt; SHOW VARIABLES LIKE &quot;skip_networking&quot;;+-----------------+-------+| Variable_name   | Value |+-----------------+-------+| skip_networking | ON    |+-----------------+-------+1 row in set (0.01 sec)
查了果然
解决办法
需要将my.cnf中的skip_networking注释掉
还是不行！！！
最终 我还是重装了mysql5
重装过程
卸载原来的mysql8 删干净点 我主要删了下面这些
sudo rm /usr/local/mysqlsudo rm -rf /Library/StartupItems/Msudo rm -rf /Library/PreferencePanes/My*sudo rm -rf /Library/Receipts/mysqlsudo rm -rf /var/db/receipts/com.mysql.sudo rm /tmp/mysql.socksudo rm /tmp/mysql.sock.locksudo rm /tmp/mysqlx.sock.locksudo rm /tmp/mysqlx.sock
安装地址https://downloads.mysql.com/archives/community/

然后注意安装完毕开启mysql服务
在系统偏好里面


然后在iterm里面先要设置mysql命令行
alias mysql=/usr/local/mysql/bin/mysqlalias mysqladmin=/usr/local/mysql/bin/mysqladmin
设置新密码
mysqladmin -u root -p password 你的密码
然后输入初始密码，应为mysql5.7会在通知栏里面把初始的密码发送给你
这样就修改完了。
查看数据库端口：
mysql&gt; show global variables like &#x27;port&#x27;;+---------------+-------+| Variable_name | Value |+---------------+-------+| port          | 3306  |+---------------+-------+1 row in set (0.01 sec)
!!!端口终于对了，打开项目连接数据库终于没有出错了！！！
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>踩雷</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式笔记【RabbitMQ+Zookeeper+FastDFS】</title>
    <url>/2022/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[分布式(更新ing)
分布式项目的整合：
https://www.processon.com/view/link/6281b28c0e3e746f2b12d0ee

分布式架构会把一个项目按照特定要求（多按照模块或功能）拆分成多个项目，每个项目分别部署到不同的服务器上。

RMI
运程方法调用

API
Remote
​			远程调用接口
RemoteException
​			承了Remote接口的接口中，如果方法是允许被远程调用的，需要抛出此异常。
UnicastRemoteObject
​				java.rmi.server.UnicastRemoteObject
​				此类实现了Remote接口和Serializable接口。
​				自定义接口实现类除了实现自定义接口还需要继承此类。
LocateRegistry
​				java.rmi.registry.LocateRegistry
​				可以通过LocateRegistry在本机上创建Registry，通过特定的端口就可以访问这个Registry。
Naming
​				java.rmi.Naming
​				Naming定义了发布内容可访问RMI名称。也是通过Naming获取到指定的远程方法。
zookeeper注册中心

客户端常用命令
ls [-s][-R] /path			查看列表get [-s] /path			查看内容create /path [data]			创建指定路径信息set /path data			设置节点内容delete /path			删除节点
注册内容
创建/demo
2     添加依赖
3     编写代码
创建zk对象获取连接
new watcher()内部重写process()
发布任务create()
ZooDefs.Ids.OPEN_ACL_UNSAFE
表示权限
CreateMode.PERSISTENT_SEQUENTIAL
永久存储，文件内容编号递增
4     查看上传数据
查看内容
​		创建zk对象获取连接
​			new watcher()内部重写process()
​		获取列表
​			zookeeper.getChildren(“/demo”, false)
​			zookeeper.getData(“/demo/” + child, false, null);
RPC实现(RMI+Zookeeper)
Dubbo

​	分布式服务框架
​	负载均衡
​		负载均衡是在集群前提下，当访问整个集群时，集群中每个节点被访问次数或频率的规则。
​		设置
​			@Reference 客户端
​				注入的是分布式中的远程服务对象
​				@Reference(loadbalance = “roundrobin”)
​					调用的服务采用的负载均衡算法
​			@Service服务端
​				@Service(loadbalance = “random”)
​					当前服务采用的负载均衡算法
​				@Service(weight = 4)
​					设置权重
​		内置策略
​			Random
​					随机。随机访问集群中节点。访问概率和权重有关。
​			RoundRobin
​					轮询。访问频率和权重有关。
​				性能好的服务器权重应该高一些。
​			LeastActive
​					活跃数相同的随机,活跃数高的放前面。
​			ConsistentHash
​				hash 相同参数发送到同一个提供者
​	完整项目
​		provider
​			dubbo.protocal.port
​				需要设置端口
RabbitMQ

​	由Erlang语言编写的基于AMQP的消息中间件。
​	消息中间件作为分布式系统重要组件之一，可以解决应用耦合，异步消息，流量削峰等问题。
​	账号管理
​		1 创建账户
​			./rabbitmqctl add_user username password
​		2 给用户授予管理员角色
./rabbitmqctl set_user_tags mashibing administrator
​		3 给用户授权
​			./rabbitmqctl set_permissions -p “/” mashibing “.&quot; &quot;.” “.*”
​		4 登录
​	交换机
​		direct 默认
​		fanout 广播
​			FanoutExchage
​			Binding
​				绑定交换器和队列
​			BindingBuilder
​				Bind构造器
​			amq.fanout
​				内置fanout交换器名称
​		topic主题
​			运行RoutingKey包含匹配规则
​				binding方法里面第二个参数
​			BindingBuilder.bind(topicQueue).to(topicExchange).with(“com.a”);
​		Header首部
FastDFS
​	分布式文件系统
​	架构
​		角色
​			client
​			Tracker Server
​				跟踪服务器
​					调度 负载均衡、记录集群状态信息、连接client和storage的枢纽
​			Storage Server
​				存储服务器
​					文件和文件属性存储的地方
​		文件上传流程
​			1.  客户端访问Tracker
​			2.  Tracker 返回Storage的ip和端口
​			3.  客户端直接访问Storage，把文件内容和元数据发送过去。
​			4.  Storage返回文件存储id。包含了组名和文件名
Nginx
​	反向代理服务
​		代理方式
​			正向
​				架设在客户机和目标主机之间
​				代理客户端，服务端不知道实际发起请求的客户端；
​			反向
​				架设在服务器端；
​				代理服务端，客户端不知道实际提供服务的服务端；
​	作用
​		HTTP协议代理
​		  搭建虚拟主机
​		负载均衡
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>RabbitMQ</tag>
        <tag>Zookeeper</tag>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>四月面经</title>
    <url>/2022/05/09/%E5%9B%9B%E6%9C%88%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[这次春招拖到四月才面…先已收到兴业数金、华为、平安的offer，签了平安。
总结几篇我认为有必要记录的面经：字节、华为（有时间就更新）

字节面经
第一次面字节 真的很紧张 其他面试也就经历过一两轮 面试小白真的害怕 没想到字节一面没有很刁钻也不会很难 都是简单的八股 算法也是简单dp


自我介绍


hashmap put() 工作流程 （讲了一下源码）


concurrenthashmap怎么做到并发安全（简单讲了1.7/8 的锁实现）


面试官从上面引出CAS 叫我描述一下（乐观、预值、新值、底层原理）


java的其他锁（巴拉巴拉讲了sych、AQS框架下的几个锁）


ThreadLocal什么时候使用（说了下底层、声明式事务保证同一个connection）


垃圾回收（算法、回收器都简单讲了讲）


网络http头有哪些字段、长连接短连接、状态码、https原理、hash不可逆（http请求头这里我真的弱，具体就私钥公钥，CA证书这里讲的还可以😭 然后还把hash说成可逆😭


TCP三次、四次；timewait状态只有客户端吗？（还好猜对了，timewait只是针对一个发起者）、可靠性怎么理解


I/O多路复用，哪些地方用到了（select poll epoll ，redis）


掩码、网络地址转换（网络真的我软肋 后面要恶补呜呜


堆 和建堆过程、 排序有哪些、快排过程


算法：最小路径和，要求返回路径（返回路径这里我死脑阔 可以for循环dp就返回的 我在那duo键盘duo半天去搞了一个dfs去原矩阵找😓 最后面试官看出来我想干啥 就提示了一下 我就是一整个恍然大悟）


反问
因为面试经验很少，就问了面试官可不可以说一下我需要注意的点，面试官说很多时候知识比技巧更重要吧，很实诚就给我讲面试要把知识掌握全面，就比如我网络http这方面就需要加强。
总结
整体还是网络方面出问题，感觉面试官很耐心听我扯，没有像之前面的某公司老打断我，真的挺温柔的；然后我觉得后期应该多深入一下知识，把问题说得更加全面，一方面留好印象，一方面就可以让面试官少问点，少暴露自己的缺点，网络方面补一补
---------
二面 4.25
自我介绍之后挑了一个项目讲，通过项目问了一些扩展的点 在mybatis一些语句的细节上没有答出来 大概是35min左右就面完了 面试官很温柔 但是因为细节 我觉得多半寄了

后续打电话捞我去面试说是重庆和北京的岗位，我因为已经签了，不想去卷，放弃了
华为面经(已offer)
大概流程

机考
总共三道算法，第一题就是简单的字符串转换器，第二题忘了，第三题是一个路径题，应该会用到图
第一题过了百分之80% 第三题 过了15%
总分一百分以上就过了，这个比较好过
性格测评
听说华为的性格测评还刷了很多人，反正秘诀我认为就是实话实说，然后在30分钟左右做完。
专业面试1 4.16
本来学的后端开发，然后报的是软件测试的岗位，以为面试会问很多测试方面知识，准备了很多，结果华为注重的大多是学校里的经历和获奖以及成绩。

自我介绍完毕后简单问了一下比赛和成绩。
问学了哪些课程，然后根据我说的课程问了些基础
数据结构问了：排序、有哪些结构分别讲讲（说了说链表、图、栈、队列）
计算机网路问了：http、RIP协议（不擅长的千万不要说出来！！我可能是因为这科拉胯了我的综测我一直记恨在心，没多想结果就说出口了）
软件工程问了： 直接讲学了什么（我大概把程序从需求设计到实现然后再小心机的把测试部分讲了讲）

还有细碎问题忘了
主管面4.18
主要就是聊天，然后问问对华为公司的了解，是否定居成都，然后想不想转岗，我都按着求稳来答的，也问了问在校成绩。
4.18面结束以后就审批等了很久，然后hr人非常好，一直持续跟进，
5.9 拒绝offer
在5.6说我的offer稳了，综合考虑薪资待遇和工作环境，我认为我可能不适合测试岗，并且华为的环境我有所耳闻，如果9116，我受不了，前两年都需要时间去学习，而不是全部都栽进工作。
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2022/02/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[并发编程三大特性
可见性
MESI 多线程的底层并不是通过mesi
多线程提高效率，本地缓存数据，造成数据修改不可见，
要想保证可见，要么触发同步指令，要么加上volatile，被修饰的内存，只要有修改，马上同步涉及到的每个线程。

==volatile==
==介绍一下volatile的功能？==
volatile关键字保证了可见性和禁止指令重排
提供了happen-before的保证，确保一个线程的修改可以对其他线程是可见的。当一个共享变量被修饰的时候，就会保证修改的值立即被更新到内存，当其他线程需要读取的时候，就会去内存中读取新值。从实际角度来说，其中的一个重要作用就是与CAS结合，保证了原子性。volatile经常用在多线程环境下的单次操作。
通俗来讲就是 ab线程要用一个变量，然后java默认是a线程中保留一份copy，这样如果b线程来修改，则a线程未必知道，如果使用这个关键字，线程之间数据修改都能可见。
==volatile的可见性和禁止指令重排序怎么实现的？==
volatile本质上是通过内存屏障来实现可见性的，被修饰的变量在被修改之后可以立即同步到主内存，该变量每次使用之前都从主内存刷新，而禁止指令重排序也是通过内存屏障来禁止的，本来现在的cpu为了提高效率会见指令并发执行，一个指令从JMM内存屏障的策略来看，就是在volatile的写操作的前面插入一个StoreStore屏障，后面插入一个StoreLoad，在读操作前面加入一个LoadLoad，后面加一个LoadStore屏障。
==volatile 的底层实现？==
volatile 底层jmm
==实现一下DCL(单例模式下的双重检查)/ volatile的实践==
是否lazy化？ 是
是否线程安全？ 是
实现难度： 针对需要双重检查的操作
public class Singleton &#123;    // volatile防止指令重排    private static volatile Singleton singleton;    private Singleton() &#123;            &#125;        public static Singleton getInstance() &#123;        // 第一层判断singleton是不是null        if(Singleton == null)&#123;            //现在再加锁            synchronized(Singleton.class)&#123;                // 第二层判断                // 如果A,B 两个线程都在synchronized等待                // A 创建完对象之后，B还会再进入，如果不再检查一遍，B又会创建一个对象                if(singleton == null)&#123;                    singleton = new Singleton();                &#125;            &#125;        &#125;        return singleton;    &#125;&#125;                                                                                
==单例里面要不要加volatile？==
要加，如果不加volatile问题就会出现在指令重排序上，
比如有一行初始化对象的代码，被编译器执行之后就会分成三步，1 给指令申请内存，2 给成员变量初始化，3 把这块内存的内容赋值，重排序以后 既然已经有这个值，在另外一个线程上来先去检查就会发现已经存在该值，就不会进入锁部分的代码，但是加了volatile就不会允许指令重排序，一定会保证你初始化完了才会给你赋值这个变量。
有序性
程序真的是按照顺序执行的吗？
并不是 cpu为了提高效率，通常都是乱序
在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：在单线程环境下不能改变程序运行的结果；存在数据依赖关系的不允许重排序需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。
单线程也不是顺序执行
单线程有一个 a i s 语义保证了其单线程执行结果不被改变，其实也不是顺序执行的。
as-if-serial语义保证单线程内程序的执行结果不被改变，happensbefore关系保证正确同步的多线程程序的执行结果不被改变。 as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before指定的顺序来执行的。
as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。
原子性
保证操作的原子性可以通过synchronized(悲观锁) 和 cas(乐观锁)
CAS
CAS 是 compare and swap 的缩写，即我们所说的比较交换。
cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。
悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。
CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。
CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。
java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的(AtomicInteger,AtomicBoolean,AtomicLong)。
==CAS底层==
以AtomicInterger 这个类为例，里面的incrementAndGet() 就调用了compareAndSet()方法 里面有一个unsafe对象 查看jdk里面的c语言代码就会有一个底层的指令  cmpxchg指令 意思是cas修改变量值 这个指令不是原子的所以需要 lock ，而在硬件层面lock指令在执行的时候看情况来采用总线锁或者缓存锁，所以底层层面cas是用的lock指令。
==如何解决ABA问题==
如果是基础类型就无所谓，就是两个线程去同时修改一个变量值，一个线程被某些原因发生阻塞等待过程中另一个线比较更新 变量值从A到B，这个时候再来第三个线程想把变量改为B到A，进行比较更新更改完毕以后，原来被阻塞的线程这个时候获得CPU时间片发现是A 于是更新为B 可是其实该值已经更新过了，这个问题可以通过加版本号或者时间戳解决，但是一般是每次版本号加一，时间戳不容易指定精度一般不用。
线程调度与同步
线程调度器
负责将runnable的线程分配CPU
怎么进行多线程抢占cpu的调度呢？（线程调度算法

分时调度 大家平均分配时间片
抢占式 优先级高的线程占用 ，如果优先级都相等就随机选一个，都是等线程结束才放弃CPU

线程同步以及线程调度方


wait(): 释放锁； 需要被唤醒 ；是object的方法；用于进程通信；


sleep()：不释放锁 ；自动苏醒；是thread的静态方法


notify()：随机唤醒一个进入锁池


notifyAll()： 唤醒所有进入锁池
sleep() 和 wait() 不同
sleep()和yeild() 不同
sleep()是成为阻塞状态，其他线程不考虑优先级，抛出interrupted异常，移植性更好
yeild()是成为就绪状态，其他线程和当前一起按优先级，没有声明异常，不怎么建议使用
sleep()和yeild()为啥是静态
两个方法是在正在执行的线程运行，在处于等待状态里面调用无意义


==wait() 和 notify()实际使用==
这里是一个面试题，就是两个线程实现线程a打印1～10，然后另外一个线程b在a打到5的时候执行，然后a在b执行完之后打印剩下的
这里具体就是线程b先启动然后wait ，然后等到a打印1～5以后唤醒线程b，同时也要wait()释放锁，b执行完毕又要notify a。
public class T03_NotifyHoldingLock &#123; //wait notify	//添加volatile，使t2能够得到通知	volatile List lists = new ArrayList();	public void add(Object o) &#123;		lists.add(o);	&#125;	public int size() &#123;		return lists.size();	&#125;	public static void main(String[] args) &#123;		T03_NotifyHoldingLock c = new T03_NotifyHoldingLock();		final Object lock = new Object();           //需要注意先启动t2再启动t1    new Thread(() -&gt; &#123;			synchronized(lock) &#123;				System.out.println(&quot;t2 启动&quot;);				if(c.size() != 5) &#123;					try &#123;						lock.wait();					&#125; catch (InterruptedException e) &#123;						e.printStackTrace();					&#125;				&#125;				System.out.println(&quot;t2 结束&quot;);			&#125;            //通知t1继续执行            lock.notify()。		&#125;, &quot;t2&quot;).start();		try &#123;			TimeUnit.SECONDS.sleep(1);		&#125; catch (InterruptedException e1) &#123;			e1.printStackTrace();		&#125;				new Thread(() -&gt; &#123;			System.out.println(&quot;t1 启动&quot;);			synchronized(lock) &#123;				for(int i=0; i&lt;10; i++) &#123;					c.add(new Object());					System.out.println(&quot;add &quot; + i);					if(c.size() == 5) &#123;						lock.notify();                        //释放锁，让t2得以执行                        try&#123;                           lock.wait();                        &#125;catch(InterruptedException e)&#123;					  	 e.printStackTrace();                        &#125;					&#125;					try &#123;						TimeUnit.SECONDS.sleep(1);					&#125; catch (InterruptedException e) &#123;						e.printStackTrace();					&#125;				&#125;			&#125;		&#125;, &quot;t1&quot;).start();        	&#125;&#125;
描述notify和notifyAll区别
嗯一般呢这个object里面当我调wait的时候它就会放到等待队列里面，当我去拿的时候，就会在wait列表里面，这个时候如果我调notify等待列表就是那个等待池里面就会随机唤醒一个线程来进入锁池竞争锁，如果我调notifyAll就会将该对象所有wait的线程唤醒。其中那个锁池就是等待获得该对象锁拥有权的线程们。
如何唤醒线程？
首先阻塞的然后可以被唤醒的线程，是调用任意对象的wait()，导致了线程阻塞进入等待队列等待被唤醒，阻塞的同时要释放该对象的锁，要唤醒就需要调用notify()或者notifyAll()，首先释放当前对象的锁，然后唤醒任意一个或者是全部线程到锁池直到线程获得当前对象的锁才能继续执行。还需要注意的是方法一定要放在同步方法或者同步方法块中，并且调用方法的对象一定和同步块或方法的对象是同一个，这样才能保证调用方法之前线程就已经获得了锁，这样才能执行线程的锁释放
为什么三个方法要定义在object里？
等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。
为什么三个方法要在同步方法或者代码块里面调用？
因为三个方法都需要线程持有对象的锁，比如调wait()的时候这个线程必须拥有该对象的锁，接着他就释放这个锁进入等待状态直到其他线程调用这个对象的notify方法，同样notify呢，也是需要先释放对象的锁，这样其他线程才能来竞争锁；所以方法都是需要通过同步实现，进而必须。。。
什么是线程同步？
当一个线程对共享的数据进行操作时，应使之成为一个&quot;原子操作&quot;， 即在没完成相关操作之前，不允许其他线程打断它，否则就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步
同步方法和非同步方法可以同时调用吗？
当然是可以的啊 当我有一个synchronized的m1方法，我调用m1的时候是可以调用m2的，因为线程访问m1的时候需要加锁，但是访问m2的时候又不需要加锁，所以允许执行m2。
模拟银行账户： 如果业务里面写方法加锁但是读方法没有加锁，这样就会容易产生脏读，但是如果业务允许，就可以，脏读过程就是没加锁的线程在没等你整个过程执行完就读到了你中间的结果产生的内存，解决办法就是将没有加锁的线程加上锁，会效率变低。
什么是线程互斥？
资源的固有特性 互斥 一个资源在同一时间只能由一个线程去调用
对于共享的进程系统资源，在单个线程访问时的排他性。就是当有若干个线程都要使用某一个资源的时候，任何时刻，都只允许一个线程来去使用，其他要使用该资源的线程必须等待，知道占用志愿者释放该资源。
Synchronized
synchronized、volatile、CAS 比较
（1）synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。
（2）volatile 提供多线程共享变量可见性和禁止指令重排序优化。
（3）CAS 是基于冲突检测的乐观锁（非阻塞）
==synchronized 和 ReentrantLock 区别是什么？==
synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量
synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。
==相同点：==
两者都是可重入锁两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0 时才能释放锁。
==不同点==

ReentrantLock 使用起来比较灵活：1. 可以使用trylock来控制，如果抢不到线程也不会一定阻塞，2. 通过lockInterruptibly()可以响应interrupt()，可以被打断。但是必须有释放锁的配合动作；
ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；
ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。
二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 markword

锁的是什么?
Java中每一个对象都可以作为锁，这是synchronized实现同步的基础: 普通同步方法，锁是当前实例对象；静态同步方法，锁是当前类的class对象；同步方法块，锁是括号里面的对象
锁重入？

可重入的原理其实就是一个线程获得锁之后，可以重复得到该锁，底层就轻量级锁来说，其实就是在线程栈里面压入lockRecord然后有一个指向一个备份当前对象markword的指针，这个备份叫做displace markword（重入以后的hashword字段也在这里面），这里就是使用这个锁记录进行一个重入计数器的作用。
重量级锁：进入重量级锁，会分配一个objectmonitor对象，然后将锁标志置为‘10’，然后markword存储指向这个对象的指针。om对象有两个队列和一个指针，每个需要获取锁的线程都会进入队列被包装为这个对象，如果是多线程指向同一段代码时，objectwaiter就会进入队列，当某个线程抢到锁了也就是获得对象的监视器monitor了就进入owner区域，并把monitor中的owner变量设为当前线程同时monitor中的计数器count+1。（锁重入）
==Sych的锁升级的原理或者是过程？==
首先主要有四种锁状态分别是：无状态锁、偏向锁、轻量级锁和重量级锁（要去操作系统申请资源）
锁的升级的目的/背景：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。


详细锁升级过程：
总：在锁对象的对象头里面有一个 threadID 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。
分：new对象之后先判断是否为可偏向状态，markword有两个字节作为锁标志：首先看是否是‘01’，然后mw前面还有一个字段来判断是否是已经拿到偏向锁‘1’表示偏向锁已启动，启动但是要判断锁线程是否是当前的线程id，如果是就开始执行代码块；但是不是的话，说明就有竞争了，这个时候cas操作去获取锁失败了的话，达到safepoint时获得偏向锁的线程就会被挂起，偏向锁会被撤销，然后升级为轻量级锁，这个时候被阻塞的线程再继续执行同步代码块。
这部分有个细节就是轻度竞争就会升级为轻量级锁，如果是重度竞争（比如耗时过长、调用了wait方法等）就会直接升级为重量级锁，先讲轻量级锁：
升级为轻量级锁以后还是在用户空间里面进行，当前线程栈会划分一部分作为锁记录lock record，并且会将锁对象的markwor复制到锁记录中，接下来jvm会进行CAS操作将markword一部分更新为指向锁记录的指针（如下图），

如果成功就会将锁标志位设为‘00’，说明已经获得轻量级锁，这个时候就会进入锁重入阶段：（底下的锁重入有解释）
但是失败了就会检查当前锁对象的markword是否指向当前锁记录，如果没有就表示已经被其他线程抢了，这个时候就会进行自旋等待（默认是10次），等到此处如果超出阈值还是没有获得锁这个时候就会升级为重量级锁
进入重量级锁，会分配一个objectmonitor对象，然后将锁标志置为‘10’，然后markword存储指向这个对象的指针。om对象有两个队列和一个指针，每个需要获取锁的线程都会进入队列被包装为这个对象，如果是多线程指向同一段代码时，objectwaiter就会进入队列，当某个线程抢到锁了也就是获得对象的监视器monitor了就进入owner区域，并把monitor中的owner变量设为当前线程同时monitor中的计数器count+1。（锁重入）
什么时候用自旋锁和系统锁？/ 为什么有了自旋锁还要重量级锁？
因为自旋锁是要占用CPU的，而系统锁是到等待队列里面，所以你，代码如果执行时间短，线程数少就用自旋，长线程数多，就用系统锁；
自旋也是要消耗cpu资源的如果锁的时间过长或者自旋线程过多，cpu就会被消耗； 而重量级锁又自己的等待队列，所有拿不到所有的进入等待队列，不需要消耗cpu资源。
什么时候升级为重量级锁？
竞争加剧，有线程超过10次自旋：-xx:PreBlockSpin ；或者是自旋线程数超过cpu核数的一半，1.6之后jvm有了自适应自旋Adapative-Self Spinning，是可以自己控制的自旋；
偏向锁是否启动？
偏向锁有一个启动时间，我记得是四秒钟，当你new一个普通对象的时候，偏向锁没有启动，它默认就是无锁态；但是一开始new的时候如果已经启动了偏向锁，那么就是一个匿名偏向，锁对象的markword里的threadkid其实就是空的，等到你加了sychronized（这个对象），才会指向当前的这个线程了，treadid字段就会更新为当前线程了。
Lock体系
Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？
ReentrantLock是lock的唯一子类。
Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。
它的优势有：
（1）  可以使锁更公平
（2）  可以使线程在等待锁的时候响应中断
（3）  可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
（4）  可以在不同的范围，以不同的顺序获取和释放锁
整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。
==实现一个阻塞队列？/ 使用Condition写生产者和消费者？==
public class ProviderConsumer&lt;T&gt;&#123;  private int length;  private Queue&lt;T&gt; queue; // 产品队列  private ReentrantLock lock = new ReentrantLock(); // 可重入锁  private Condition providerCondition = lock.newConditon();// 生产者  private Condition consumerCondition = lock.newCondition();// 消费者    public ProviderConsumer(int length)&#123;// 构造器一开始传入产品队列的长度    this.length = length;    this.queue = new LinkedList&lt;T&gt;();  &#125;    /*  * 生产  */  public void provide(T product)&#123;    lock.lock();    try&#123;      while(queue.size() &gt;= length)&#123;// 生产者队列等待        providerCondition.await();      &#125;      queue.add(product);      consumerCondition.signal();// 提醒消费者队列；    &#125; catch()&#123;          &#125; finally&#123;      lock.unlock();    &#125;  &#125;  /*  * 消费  */  public T consume()&#123;    lock.lock;    try&#123;      while(queue.isEmpty())&#123;        consumerCondition.await();      &#125;      T product = queue.remove();      provideCondition.signal();      return product;    &#125; catch()&#123;          &#125; finally&#123;      lock.unlock;    &#125;    return null;  &#125;  &#125;
AQS
AQS 原理分析
下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。
AQS 原理概览
AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。
看个AQS(AbstractQueuedSynchronizer)原理图：

源码
AQS是一个构建锁和同步器的框架，最核心的是它的一个共享的int类型值叫做state，这个state用来干什么，其实主要是看他的子类是怎么实现的，比如ReentrantLock这个state，拿这个state来记录这个线程到底重入了多少次，比如说有一个线程拿到state这个把锁了，state的值就从0变成了1，这个线程又重入了一次，state就变成2了，又重入一次就变成3等等，释放的时候一次释放减一变成0就释放了。这个数代表了什么要看子类怎么去实现它，那么在这个state核心上还会有一堆的线程节点，当然这个节点是node，每个node里面包含一个线程，我们称为线程节点，这么多的线程节点去争用这个state，谁拿到了state，就表示谁得到了这把锁，AQS得核心就是一个共享的数据和一堆互相抢夺竞争的线程，这个就是AQS。
看reentrantlock源码里面:
在lock()方法里里面，我们可以读到它调用了sync.acquire(1)，
//JDK源码public class ReentrantLock implements Lock, java.io.Serializable &#123;	public void lock()&#123;        sync.acquire(1);    &#125;&#125;
再跟进到acquire(1)里，可以看到acquire(1)里又调用了我们自己定义自己写的那个tryAcquire(arg)
//JDK源码public abstract class AbstractQueuedSynchronizer    extends AbstractOwnableSynchronizer    implements java.io.Serializable &#123;	public final void acquire(int arg)&#123;		if(!tryAcquire(arg)            &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))       	 selfInterrupt();	&#125;&#125;
tryAquire(int)是使用者需要自定义同步器时要重写的模版方法：reentrantlock()里面的这个方法又调用了nofairTryAquire(int aquire)
//JDK源码public class ReentrantLock implements Lock, java.io.Serializable &#123;    	public void lock()&#123;        sync.acquire(1);    &#125;        static final NonfairSync extends Sync&#123;        protected final boolean tryAcquire(int acquire)&#123;            return nonfairTrytAcquire(acquires);	   &#125;    &#125;        final boolean nonfairTrytAcquire(int acquire)&#123;         //获取当前线程		final Thread current = Thread.currentThread();        //拿到AQS核心数值state         int c getState();        //如果数值为0说明没人上锁         if(c == 0)&#123;             //给当线程上锁			if(compareAndSetState(0,acquires))&#123;                //设置当前线程为独一无二拥有这把锁的线程			    setExclusiveOwnerThread(current);                 return true            &#125;         &#125;        //判断当前线程是否拥有这个把锁        else if(current == getExclusiveOwnerThread)&#123;            //设置重入			int nextc = c + acquires;             if(nextc &lt; 0)                 throw new Error(&quot;Maximum lock count wxceeded&quot;);             setState(nextc);             return true;         &#125;        return false;    &#125;&#125;
nonfairTrytAcquire(acquires)我们读进去会发现它的里面就调用到了state这个值，首先拿到当前线程，拿到state的值，然后进行if判断，如果state的值为0，说明没人上锁，没人上锁怎么办呢？就给自己上锁，当前线程就拿到这把锁，拿到这个把锁的操作用到了CAS(compareAndSetState)的操作，从0让他变成1，state的值设置为1以后，设置当前线程是独一无二的拥有这把锁的线程，否则如果当前线程已经占有这把锁了，怎么办？很简单我们在原来的基础上加1就可以了，这样就能拿到这把锁了，就重入，前者是加锁后者是重入
state状态变量
AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。
private volatile int state;//共享变量，使用volatile修饰保证线程可见性
状态信息通过protected类型的getState，setState，compareAndSetState进行操作
1	//返回同步状态的当前值2	protected final int getState() &#123;3	return state;4	&#125;5	// 设置同步状态的值6	protected final void setState(int newState) &#123;7	state = newState;8	&#125;9	//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect （期望值）10	protected final boolean compareAndSetState(int expect, int update) &#123; 11 return unsafe.compareAndSwapInt(this, stateOffset, expect, update);12 &#125;
AQS队列
如果没有tryAquire() 到state呢，那么就进行aquireQueue()方法，里面会调用addwaiter()这个方法，线程添加进入队列里面，具体操作也是通过cas进行添加的，方法是compareAndAetTail(oldTail,node)，oldTail是它的预期值，假如说我们想把当前线程设置为整个链表尾巴的过程中，另外一个线程来了，它插入了一个节点，那么仔细想一下Node oldTail = tail;的整个oldTail还等于整个新的Tail吗？不等于了吧，那么既然不等于了，说明中间有线程被其它线程打断了，那如果说却是还是等于原来的oldTail，这个时候就说明没有线程被打断，那我们就接着设置尾巴，只要设置成功了OK，compareAndAetTail(oldTail,node)方法中的参数node就做为新的Tail了，所以用了CAS操作就不需要把原来的整个链表上锁，这也是AQS在效率上比较高的核心。

资源的共享方式
AQS定义两种资源共享方式


Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：
公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的


Share（共享）：多个线程可同时执行。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。


模版方法
AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：
1	isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。2	tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。3	tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。4	tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。5	tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。
再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。
一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。主要是高16位存储互斥锁的状态，高16位存储共享锁的状态。
并发工具类
CountDownLatch(倒计时器)：
CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
用法？

让主线程await()， 主线程在开始运行前等待n个业务线程执行完毕。将CountDownLatch的计数器初始化为new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownLatch.countDown()，当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。
让业务线程await()，主线程处理完数据之后进行countDownLatch.countDown(),此时业务线程被唤醒，然后去主线程拿数据，或者执行自己的业务逻辑，这样实现多个线程开始执行任务的最大并行性，

CyclicBarrier(循环栅栏)：
CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。
CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。
Semaphore(信号量)-允许多个线程同时访问：
synchronized 和ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。
Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码 多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。
Exchange(线程见交换数据的工具)
Exchanger是一个用于线程间协作的工具类，**用于两个线程间交换数据。**它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据是通过 exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。
ReadWriteLock
实现这个接口是ReentrantReadWriteLock， 这个接口是一个读写锁接口，主要就是实现了读写分离，写锁是独占锁，读锁是共享锁，实现了读读之间不会互斥，但是读写和写写之间的互斥，提高了读写效率。还实现了锁降级，写锁可以降级为读锁。
首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。
ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。
而读写锁有以下三个重要的特性：
（1）  公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。
（2）  重进入：读锁和写锁都支持线程重进入。
（3）  锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。
ThreadLocal
原理
ThreadLocal源码的set方法，ThreadLocal往里边设置值的时候是怎么设置的呢？首先拿到当前线程，这是你会发现，这个set方法里多了一个容器ThreadLocalMap，这个容器是一个map，是一个key/value对，其实这个值是设置到了map里面，key设置的是this，value设置的是我们想要的那个值，这个this就是当前对象ThreadLocal，value就是Person类，如果map不等于空的情况下就设置进去就行了，如果等于空呢？就创建一个map
//ThraedLocal源码public class ThreadLocal&lt;T&gt; &#123;    public void set(T value) &#123;        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    &#125;&#125;
我们回过头来看这个map，ThreadLocalMap map=getMap(t)，我们来看看这个map到底在哪里，我们点击到了getMap这个方法看到，它的返回值是t.threadLocals
//ThreadLocal源码public class ThreadLocal&lt;T&gt; &#123;    public void set(T value) &#123;        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    &#125;    ThreadLocalMap getMap(Thread t)&#123;        return t.threadLocals;    &#125;&#125;
我们进入这个t.threadLocals，你会发现ThreadLocalMap这个东西在哪里呢？居然是在Thread这个类里，所以说这个map是在Thred类里的
public class Thread implements Runnable&#123;	ThreadLocal.ThreadLocalMap threadLocals = null;&#125;
这个时候我们应该明白，map的set方法其实就是设置当前线程里面的map：
·set	- Thread.currentThread.map(ThreadLocal,person)
所以这个时候你会发现，原来Person类被set到了，当前线程里的某一个map里面去了，这个时候，我们是不是就能想明白了，我set了一个值以后，为什么其他线程访问不到？我们注重“当前线程”这个段话，所以个t1线程set了一个Person对象到自己的map里，t2线程去访问的也是自己的属于t2线程的map，所以是读不到值的，因此你使用ThreadLocal的时候，你用set和get就完全的把他隔离开了，就是我自己线程里面所特有的，其它的线程是没有的，以前我们的理解是都在一个map，然而并不是，所以你得读源码，读源码你就明白了
用途
声明式的事务保证同一个connetion
我们根据Spirng的声明式事务来解析，为什么要用ThreadLocal，声明式事务一般来讲我们是要通过数据库的，但是我们知道Spring结合Mybatis，我们是可以把整个事务写在配置文件中的，而这个配置文件里的事务，它实际上是管理了一系列的方法，方法1、方法2、方法3…，而这些方法里面可能写了，比方说第1个方法写了去配置文件里拿到数据库连接Connection，第2个、第3个都是一样去拿数据库连接，然后声明式事务可以把这几个方法合在一起，视为一个完整的事务，如果说在这些方法里，每一个方法拿的连接，它拿的不是同一个对象，你觉的这个东西能形成一个完整的事务吗？Connection会放到一个连接池里边，如果第1个方法拿的是第1个Connection，第2个拿的是第2个，第3个拿的是第3个，这东西能形成一个完整的事务吗？百分之一万的不可能，没听说过不同的Connection还能形成一个完整的事务的，那么怎么保证这么多Connection之间保证是同一个Connection呢？把这个Connection放到这个线程的本地对象里ThreadLocal里面，以后再拿的时候，实际上我是从ThreadLocal里拿的，第1个方法拿的时候就把Connection放到ThreadLocal里面，后面的方法要拿的时候，从ThreadLocal里直接拿，不从线程池拿。
四种引用
引用是什么？
就是一个变量值指向一个对象
强引用normalReference
普通的引用比如Object o = new Object()，这个就叫强引用; 特点就是说，只要有一个应用指向这个对象，那么垃圾回收器一定不会回收它，这就是普通的引用，也就是强引用。因为有引用指向，所以不会回收，只有没有引用指向的时候才会回收，指向谁？指向你创建的那个对象。
弱引用softReference
当有一个对象(字节数组)被一个软引用所指向的时候，只有系统内存不够用的时候，才会回收它(字节数组)
虚引用
==在threadlocal的应用 / 内存泄露==

我们来看图中从左开始看，这时候我们应该明白了，这里tl是一个强引用指向这个ThreadLocal对象，而Map里的key是通过一个弱引用指向了一个ThreadLocal对象，我们假设这是个强引用，当tl指向这个ThreadLocal对象消失的时候，tl这个东西是个局部变量，方法已结束它就消失了，当tl消失了，如果这个ThreadLocal对象还被一个强引用的key指向的时候，这个ThreadLocal对象不能被回收，而且由于这个线程有很多线程是长期存在的，比如这个是一个服务器线程，7*24小时一年365天不间断运行，那么不间断运行的时候，这个tl会长期存在，这个Map会长期存在，这个Map的key也会长期存在，这个key长期存在的话，这个ThreadLocal对象永远不会被消失，所以这里是不是就会有内存泄漏，但是如果这个key是弱引用的话还会存在这个问题吗？当这个强引用消失的时候这个弱引用是不是自动就会回收了，这也是为什么用WeakReference的原因
关于ThreadLocal还有一个问题，当我们tl这个强引用消失了，key的指向也被回收了，可是很不幸的是这个key指向了一个null值，但是这个threadLocals的Map是永远存在的，相当于说key/value对，你这个key是null的，你这个value指向的东西，你的这个10MB的字节码，你还能访问到吗？访问不到了，如果这个Map越积攒越多，越来越多，它还是会内存泄漏，怎么办呢？所以必须记住这一点，使用ThreadLocal里面的对象不用了，务必要remove掉，不然还会有内存泄漏
ThradLocalM&gt; tl = new ThreadLocal&lt;&gt;();tl.set(new M());tl.remove();
JUC同步容器
ConcurrentHashMap
集合部分
我们来看这个经常在多线程的情况下使用的这些个容器 ，从Map开始讲，Map经常用的有这么几个


ConcurrentHashMap用hash表实现的这样一个高并发容器；
既然有了ConcurrentHashMap正常情况下就应该有ConcurrentTreeMap，你可以去查查，它没有，就等于缺了一块，为什么没有呢，原因就是ConcurrentHashMap里面用的是cas操作，这个cas操作它用在tree的时候，用在树这个节点上的时候实现起来太复杂了，所以就没有这个ConcurrentTreeMap，但是有时间也需要这样一个排好序的Map，那就有了ConcurrentSkipListMap跳表结构就出现了。


ConcurrentSkipListMap通过跳表来实现的高并发容器并且这个Map是有排序的；

跳表是什么样的结构呢？底层本身存储的元素一个链表，它是排好顺序的，大家知道当一个链表排好顺序的时候往里插入是特别困难的，查找的时候也特别麻烦，因为你得从头去遍历查找这个元素到底在哪里，所以就出现了这个跳表的结构，底层是一个链表，链表查找的时候比较困难怎么办，那么我们在这些链表的基础上在拿出一些关键元素来，在上面做一层，那这个关键元素的这一层也是一个链表，那这个数量特别大的话在这个基础之上在拿一层出来再做一个链表，每层链表的数据越来越少，而且它是分层，在我们查找的时候从顶层往下开始查找，所以呢，查找容易了很多，同时它无锁的实现难度比TreeMap又容易很多，因此在JUC里面提供了ConcurrentSkipListMap这个类。


他们两个的区别一个是有序的一个是无序的，同时都支持并发的操作。下面这个小程序是一个效率的测试其实也没多大意义，大家可以去写一下跑跑。
CopyOnWriteArrayList
CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？
CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。
CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。
CopyOnWriteArrayList 的使用场景通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。
CopyOnWriteArrayList 的缺点


由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。


不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到始终一致性,但是还是没法满足实时性要求。


由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。


CopyOnWriteArrayList 的设计思想

读写分离，读和写分开
终一致性
使用另外开辟空间的思路，来解决并发冲突

BlockingQueue
ArrayBlockingQueue
ArrayBlockingQueue是有界的，你可以指定它一个固定的值10，它容器就是10，那么当你往里面扔容器的时候，一旦他满了这个put方法就会阻塞住。然后你可以看看用add方法满了之后他会报异常。offer用返回值来判断到底加没加成功，offer还有另外一个写法你可以指定一个时间尝试着往里面加1秒钟，1秒钟之后如果加不进去它就返回了。
回到那个面试经常被问到的问题，Queue和List的区别到底在哪里，主要就在这里，添加了offer、peek、poll、put、take这些个对线程友好的或者阻塞，或者等待方法。
package com.mashibing.juc.c_025;import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;public class T06_ArrayBlockingQueue &#123;   static BlockingQueue&lt;String&gt; strs = new ArrayBlockingQueue&lt;&gt;(10);   static Random r = new Random();   public static void main(String[] args) throws InterruptedException &#123;      for (int i = 0; i &lt; 10; i++) &#123;         strs.put(&quot;a&quot; + i);      &#125;            //strs.put(&quot;aaa&quot;); //满了就会等待，程序阻塞      //strs.add(&quot;aaa&quot;);      //strs.offer(&quot;aaa&quot;);      strs.offer(&quot;aaa&quot;, 1, TimeUnit.SECONDS);            System.out.println(strs);   &#125;&#125;
Queue和List的区别
区别主要就是Queue添加了许多对线程友好的API offer、peek、poll，他的一个子类型叫BlockingQueue对线程友好的API又添加了put和take，这两个实现了阻塞操作。
线程池

Executor(线程的工厂
newSingleThreadPool
这个线程池里面只有一个线程，这个一个线程的线程池可以保证我们扔进去的任务是顺序执行的。为什么会有单线程的线程池？第一个线程池是有任务队列的；生命周期管理线程池是能帮你提供的。
newCachedThreadPool没上限
来一个新的任务就必须马上执行，没有线程空着我就new一个线程。那么阿里是不会推荐使用这中线程池的，原因是线程会启动的特别多，基本接近于没有上限的。
newFixedThreadPool 固定的
指定一个参数，到底有多少个线程，他的核心线程和最大线程都是固定的，因为他的最大线程和核心线程都是固定的就没有回收之说所以把他指定成0，这里用的是LinkedBlockingQueue
newScheduledThreadPool定时任务
这是专门给定时任务用的这样的一个线程池，了解就可以了。
ThreadPoolExecutor
1. 状态
// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATEDprivate static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;private static final int STOP       =  1 &lt;&lt; COUNT_BITS;private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;
RUNNING：正常运行的；
SHUTDOWN：调用了shutdown方法了进入了shutdown状态；
STOP：调用了shutdownnow马上让他停止；
TIDYING：调用了shutdown然后这个线程也执行完了，现在正在整理的这个过程叫TIDYING；
TERMINATED：整个线程全部结束；

⚠️多线程的生命周期和线程的生命周期
2. 构造方法参数
public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) &#123;    // 基本类型参数校验    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    // 空指针校验    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    // 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;&#125;
corePoolSize核心线程数
maximumPS最大线程数
keepAliveTime销毁之前等待的时间
TimeUnit时间单位
BlockingQueue任务队列
LinkedBQ
ArrayBQ
SynchronousBQ
ThreadFactory线程工厂
RejectStrategy拒绝策略
Abort抛异常
Discard扔掉
DiscardOldest
CallerRuns
3. execute()调度任务
execute执行任务的时候判断任务等于空抛异常，这个很简单，接下来就是拿状态值，拿到值之后计算这个值里面的线程数，活着的那些线程数是不是小于核心线程数，如果小于addWorker添加一个线程，addWorker是比较难的一个方法，他的第二个参数指的是，是不是核心线程，所有上来之后如果核心数不够先添加核心线程，再次检查这个值。我们原来讲过这个线程里面上来之后刚开始为0，来一个任务启动一个核心线程，第二个就是核心线程数满了之后，放到队列里。最后核心线程满了，队列也满了，启动非核心线程。小于线程数就直接加，后面执行的逻辑就是不小于了，不小于就是超过核心线程数了直接往里扔，workQueue.offer就是把他扔进去队列里，再检查状态。在这中间可能会被改变状态值，因此需要双重检查，这个跟我们之前聊过的单例模式里面的DC是一样的逻辑。isRunning，重新又拿这个状态，拿到这个状态之后这里是要进行一个状态切换的，如果不是Running状态说明执行过shutdown命令，才会把这个Running转换成别的状态，其他情况下workerCountOf如果等于0说明里面没有线程了，没有线程我线程池正常运行就添加非核心线程。这些步骤都是通过源码可以看出来的。如果添加work本身都不行就reject把他给拒绝掉。



核心线程不够，启动核心的


core够了就加队列


核心和队列都够了，就非核心


4. addWorker()—&gt;runWorker()


addWorker() 就做了两步，使用lock()和自旋做的

count++
加进任务并且start



runWorker()是真正执行线程的部分


work类
这个work他本身是Runnable同时又是AQS。这个work类里面会记录着一个成员变量，这个成员变量是thread，很多个线程worker，这个就是为什么要用AQS的原因。另外呢，在你整个执行的过程之中你也需要加锁，不然的话你别的线程进来，因此AQS是需要的。这是这个work类，简单的你就可以把它当成线程类，然后这个线程类执行的是你自己的任务就行了。
submit()和execute()区别
Callable实现了Future接口，比runnable多了返回值并且可以抛出异常，然后这个Future是用来存储执行的线程将来才产生的结果，callable为线程池设计，配合future使用，有返回值，实现了任务交给线程池，未来要结果时再get返回。
FutureTask是继承了RunnableFuture接口和Future接口，既是一个任务又是一个Future。在ForkJoinPool 这类线程池里面用，这类线程池是每个线程都有一个阻塞队列。
杂问题
1. 怎么预防死锁？
答：首先我们要知道产生死锁的四个必要条件：第一个，资源在同一时间只能有一个线程来占用，这个也就是互斥条件；第二个，不可剥夺条件，当一个线程已经占有一个资源在释放之前是不会让其他线程抢占；在有就是线程等待的过程中不会释放自己持有的资源，也就是请求和保持条件；第四个条件就是循环等待条件 ，多个线程在互相等待对方释放资源；有了这四个条件当多个线程都持有对方想要的资源却等待对方释放资源的状态就造成了死锁；
​      所以预防死锁就需要从这四个方面入手，第一个资源互斥因为是资源固有属性不能破坏这个条件；我们去破坏第二个不可剥夺条件，可以让进程在等待过程中将其占有的资源隐性释放到系统的资源列表中，而等待的进程只有重新获得自己原有的资源和新申请的资源才能启动执行；破坏第三个请求和保持条件可以使用静态分配和动态分配两种方法；静态分配就是在每一个进程开始执行时就申请他需要的资源；动态分配就是在申请资源的时候他本身不能占用系统资源；最后就是破坏循环等待条件，将系统中的所有资源顺序编号，紧缺资源用大编号，进程在申请资源的时候必须按照编号的顺序执行。嗯，我认为就从这四个方面去着手，谢谢。
2. 线程创建方式和生命周期
有五种方式，第一种方法就是继承thread类，重写run()，调用start开启线程；第二种实现runnable接口，重写run()，实现接口比继承类要灵活；第三种是使用lamda表达式，本质是一样；第四种是实现callable接口执行call()，这种方法相对runnable不同就是执行完毕有返回值，返回值通过future接收可以通过泛型指定类型，也可以抛出异常；第五种就是通过线程池threadpool创建。
start 和 run
new 一个 thread 调用start就是启动一个线程然后进入就绪状态，但分配到时间片就可以运行，而run只是用于执行线程运行时执行代码可以重复调用，也就是说start用来真正启动多线程工作，进行准备就绪，而线程只是通过run来完成它的运行状态，是一个普通方法的调用，其实还是再主线程里执行的。
线程生命周期和五种状态

new -&gt; runnable(start()) -&gt; running (run()) --&gt;blocked (wait()、synch进入锁池、join()/sleep()/IO请求) -&gt; dead （run()结束或者异常退出）
3. 进程与线程的区别
进程是系统进行资源分配和调度的基本单位是操作系统结构的基础；线程是操作进行运算调度的最小单位。通俗来讲就是，一个程序它本来是一种静态的指令和数据，当系统开始运行这个程序就会load到内存里，然后系统为其分配资源，这个时候就是一个进程，可以理解为进程就是动态的程序；而线程就是进程实际运行的单位，一种单一顺序的控制流，一个进程可以并发多个线程，每条线程有不同任务。
4. 并发与并行
并发是指多个任务在同一个CPU核上，按照细分的时间片交替进行，如果交替时间片够短，逻辑上可以看作同时执行
并行是多个CPU核在同一时间处理多个任务，是真正意义上的同时进行
串行就是一个CPU多个任务串联在一起，按照顺序执行
5. 程序开多少线程合适/是不是线程数越高效率越高/
多线程的缺点？线程数过多会怎么样

占用内存，给垃圾处理器带来压力、
需要协调和管理CPU时间跟踪线程、
还会互相竞争共享资源这样会带来很多其他性能的开销

与线程的体制完全耦合完全相关所以这个时候就看程序要干什么；
根据I/O操作和CPU操作区分程序；如果CPU计算比例占大部分也就是cpu密集型程序，这个时候线程等待时间接近于0，也就是耗费大量时间的就是上下文切换，为了减少上下文切换，一般开CPU核数个线程再加一条保证线程意外暂停；如果是IO操作占比大部分，等待时间长，理论上是可以开无限多个线程但是考虑到节约资源又要保证性能及稳定性，一般用两倍的CPU核数，再加一条为backup，如果需要精密计算的任务就可以使用公式CPU核数/（1-阻塞系数）(阻塞系数0.8~0.9）
单个cpu设定多线程有没有意义？结合上面
根据实际需要来处理
如果你的每个线程的工作与时序无关的，并且含有外部的读写操作
那么是很有意义的，当一个线程进行读写的时候，其他线程可以占用CPU进行运行。
也即线程属于I/O密集型的时候，在CPU才会体现的多线程的好处
如果是CPU密集型的，你开了很多个线程，只是增加了CPU在各个线程中进行切换的负担
没有带来好处，和性能的提高
6.如何结束一个线程？


就是run方法结束就正常退出线程了，自然退出


使用stop ，但是不建议使用，因为stop结束线程不会在意你进行到哪突然结束，会容易产生数据不一致。


volatile标志 也可以 如果是不依赖中间状态 停止就很方便，是特定场景下比较优雅的解决方案。


不适合没有同步的时候，线程阻塞，没办法循环回去


打断时间不精确，（比如在一个阻塞容器容量为5的时候结束生产者，由于其对同步线程标志位的时间控制不是很精确，有时候生产者还会生产一部分时间。




interrupt/isinterrupt比较优雅


当然要精确停止，控制线程有时候更加需要和外面的线程进行合作吗这个时候就需要用到锁了。
interrupt和isInterrupt()


interrupt() ：实例⽅法，设置线程中断标志（打扰⼀下，你该处理⼀下中断）比如sleep()在睡眠的时候没办法中断，这个时候就需要


isInterrupted()：实例⽅法，有没有⼈打扰我？


interrupted()：静态⽅法，有没有⼈打扰我（当前线程）？复位


interrupt()是静态方法，一个线程被中断，第一次调用时返回true然后清除中断信号，后面再次调用就是false了 ;isI就是查看当前信息
7. 线程类的构造方法、静态块是被哪个线程调用的？
这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被
new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。
如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了
Thread1，main 函数中 new 了 Thread2，那么：
（1）  Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的
（2）  Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的
8. 线程安全活跃态？
死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。例如：循环递归没有写输出条件抛stackoverflow
​			活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。
饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。例子：读写锁，一直读导致写操作一直等待
​		Java 中导致饥饿的原因：

其他线程在临界区做了无限循环或无限制等待资源的操作，让其他的线程一直不能拿到锁进入临界区，对其他线程来说就进入了饥饿状态。
因为线程优先级分配的不合理，导致部分线程始终无法获得CPU资源。

9. 1～26和a~b顺序交替打印
这道面试题呢实际上是华为的一道面试题，其实它里面是一道填空题，后来就很多的开始考这道题，这个面试题是两个线程，第一个线程是从1到26，第二个线程是从A到一直到Z，然后要让这两个线程做到同时运行，交替输出，顺序打印。那么这道题目的解法有非常多。
1.LockSupport
public class T02_00_LockSupport &#123;    static Thread t1 = null, t2 = null;    public static void main(String[] args) throws Exception &#123;        char[] aI = &quot;1234567&quot;.toCharArray();        char[] aC = &quot;ABCDEFG&quot;.toCharArray();        t1 = new Thread(() -&gt; &#123;                for(char c : aI) &#123;                    System.out.print(c);                    LockSupport.unpark(t2); //叫醒T2                    LockSupport.park(); //T1阻塞                &#125;        &#125;, &quot;t1&quot;);        t2 = new Thread(() -&gt; &#123;            for(char c : aC) &#123;                LockSupport.park(); //t2阻塞                System.out.print(c);                LockSupport.unpark(t1); //叫醒t1            &#125;        &#125;, &quot;t2&quot;);        t1.start();        t2.start();    &#125;&#125;
​
2. wait() 和 notify()
public class waitNotify&#123;  final Object o = new Object();  char[] c1 = &quot;ABCDEFG&quot;.toCharArray();  char[] c2 = &quot;123456&quot;.toCharArray();    new Thread(()-&gt;&#123;    Sychronized(o)&#123;     	for(char c:c1)&#123;        System.out.println(c);        try&#123;          o.notify();        	o.wait();        &#125; catch(Exception e)&#123;          e.printStackTrace();        &#125;      &#125;      o.notify();    &#125;  &#125;,&quot;t1&quot;).start;    new Thread(()-&gt;&#123;    Sychronized(o)&#123;     	for(char c:c2)&#123;        System.out.println(c );        o.notify();        o.wait();      &#125;      o.notify();    &#125;  &#125;,&quot;t2&quot;).start;&#125;
一定要注意最后都要notify（）
10. 多线程之间是怎么通信的？


通过共享变量，变量需要volatile修饰；


使用wait和notify方法，但是由于需要使用同一把锁，所以必须通知线程释放锁，被通知的线程才能获得到多，这样导致通知不及时；


使用countDownLatch实现，通知线程到指定条件，调用countDownLatc.countDown()被通知的线程进行await()方法


使用Condition的await()和signalAll()方法。


11. 生产者消费者模型?
Condition 阻塞队列
public class ProviderConsumer&lt;T&gt; &#123;	private int length;	private Queue&lt;T&gt; queue;	private ReentrantLock lock = new ReentrantLock();	private Condition provideCondition = lock.newCondition();	private Condition consumeCondition = lock.newCondition();	public ProviderConsumer(int length) &#123;		this.length = length;		this.queue = new LinkedList&lt;T&gt;();	&#125;	public void provide(T product) &#123;		lock.lock();		try &#123;			while (queue.size() &gt;= length) &#123;				provideCondition.await();			&#125;			queue.add(product);			consumeCondition.signal();		&#125; catch (InterruptedException e) &#123;			e.printStackTrace();		&#125; finally &#123;			lock.unlock();		&#125;	&#125;	public T consume() &#123;		lock.lock();		try &#123;			while (queue.isEmpty()) &#123;				consumeCondition.await();			&#125;			T product = queue.remove();			provideCondition.signal();			return product;		&#125; catch (InterruptedException e) &#123;			e.printStackTrace();		&#125; finally &#123;			lock.unlock();		&#125;		return null;	&#125;&#125;
wait() 和 notify()
public class ProducerConsumerModel &#123;    public static void main(String[] args) &#123;        EventStorage eventStorage = new EventStorage();        Producer producer = new Producer(eventStorage);        Consumer consumer = new Consumer(eventStorage);        new Thread(producer).start();        new Thread(consumer).start();    &#125;    static class Producer implements Runnable &#123;        private EventStorage storage;        public Producer(EventStorage storage) &#123;            this.storage = storage;        &#125;        @Override        public void run() &#123;            for (int i = 0; i &lt; 100; i++) &#123;                storage.put(i);            &#125;        &#125;    &#125;    static class Consumer implements Runnable &#123;        private EventStorage storage;        public Consumer(EventStorage storage) &#123;            this.storage = storage;        &#125;        @Override        public void run() &#123;            for (int i = 0; i &lt; 100; i++) &#123;                storage.take(i);            &#125;        &#125;    &#125;    static class EventStorage &#123;        private int size;        private LinkedList&lt;String&gt; storage;        public EventStorage() &#123;            size = 10;            storage = new LinkedList&lt;&gt;();        &#125;        public synchronized void put(int i) &#123;            while (storage.size() == this.size) &#123;                try &#123;                    wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            storage.push(&quot;数据&quot; + i);            System.out.println(&quot;生产 -&gt; 数据&quot; + i + &quot; 当前仓库中已经有了 &quot; + storage.size() + &quot; 条数据&quot;);            notify();        &#125;        public synchronized void take(int i) &#123;            while (storage.size() == 0) &#123;                try &#123;                    wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            System.out.println(&quot;消费 -&gt; &quot; + storage.poll() + &quot; 当前仓库中剩下 &quot; + storage.size() + &quot; 条数据&quot;);            notify();        &#125;    &#125;&#125;
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>m1 2020配置java后端环境</title>
    <url>/2021/09/12/m1-2020%E9%85%8D%E7%BD%AEjava%E5%90%8E%E7%AB%AF%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[m1 2020配置java后端环境
1 安装JDK
OracleJDK暂时并不支持arm架构的芯片，我们需要使用openjdk：zulu版本 地址
安装完成 终端输入java --version

配置问题！！！
😭m1 默认是zsh 不是bash 一开始不知道的我 把所有配置全部输入到 bash_profile 然后看maven版本却显示

想要更换bash 和 zsh模式可以参考这个： mac中bash和zsh终端切换方法和zsh配置
./zshrc ```添加配置（可以**修改版本**）
export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home
#export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home
## 2 安装homebrewhomebrew 是macos的包管理工具在终端输入 ```/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;```选择镜像 &lt;img src=&quot;m1-2020配置java后端环境/008i3skNgy1gy2l6681ocj30vu0eytbd.jpg&quot; alt=&quot;image-20220105102727012&quot; style=&quot;zoom:50%;&quot; /&gt;安装完毕查看 ```brew -v```&lt;img src=&quot;m1-2020配置java后端环境/008i3skNgy1gy2l75gne0j30vm03aaam.jpg&quot; alt=&quot;image-20220105102825749&quot; style=&quot;zoom:50%;&quot; /&gt;## 3 安装maven在第一步里面安装的homebrew是在mac隐藏文件夹 **/opt**下的  maven也同样最好安装在**/opt**下如果找不到opt 可以将文件夹显示 在访达  **command+shift+.**  隐藏的文件夹就会显示&lt;img src=&quot;m1-2020配置java后端环境/008i3skNgy1gy2n8jgqxhj30c60dk3yt.jpg&quot; alt=&quot;image-20220105104745708&quot; style=&quot;zoom:50%;&quot; /&gt;我们将[官网的maven](https://maven.apache.org/download.cgi)（见下图）拖到 **/opt**下&lt;img src=&quot;m1-2020配置java后端环境/008i3skNgy1gy2lp0zdtvj314u088abg.jpg&quot; alt=&quot;image-20220105104526757&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;img src=&quot;m1-2020配置java后端环境/008i3skNgy1gy2n9im9rzj30ra0go0tj.jpg&quot; alt=&quot;image-20220105104910817&quot; style=&quot;zoom: 25%;&quot; /&gt;#### 配置maven```vim ~./zshrc```
export MAVEN_HOME=/opt/apache-maven-3.8.4
export PATH=PATH:PATH:PATH:MAVEN_HOME/bin
查看 ```mvn -v```&lt;img src=&quot;m1-2020配置java后端环境/image-20220614185135880.png&quot; alt=&quot;image-20220614185135880&quot; style=&quot;zoom:50%;&quot; /&gt;这样就配置成功啦！## 4 下载npmbrew install npm## 5 下载iterm21. 下载iTerm2   我是在官网下载安装的 https://www.iterm2.com/index.html也可以使用Homebrew安装$ brew cask install iterm2使用brew cask要先安装cask，下面粗略给出cask的介绍。homebrew-cask与brew的区别:brew是下载源码解压然后./configure &amp;&amp; make install, 并且会自动配置好环境变量。brew cask主要用于有GUI的软件，下载已经编译好的应用包(.dmg/.pkg)。安装brew cask:$ brew install caskroom/cask/brew-cask## 6 配置node.js + typora + picgo下载node.js &lt;img src=&quot;m1-2020配置java后端环境/image-20220614185208815.png&quot; alt=&quot;image-20220614185208815&quot; style=&quot;zoom:50%;&quot; /&gt;安装完成进行以下步骤```shell# 查看node 安装路径tinachan@tinadeair ~ % which node/usr/local/bin/node# npm安装picgotinachan@tinadeair ~ % sudo npm install picgo -g# 查看picgo安装路径tinachan@tinadeair ~ % which picgo/opt/homebrew/bin/picgo# 设置gitee插件tinachan@tinadeair ~ % picgo install gitee-uploader# 设置插件 ：只需要填repo 和 tokentinachan@tinadeair ~ % picgo set uploader? Choose a(n) uploader gitee? repo: # 填仓库名（格式：用户名/仓库名）? branch: master? token: # 填私人令牌? path: ? customPath: default? customUrl: [PicGo SUCCESS]: Configure config successfully!# 设置use uploadertinachan@tinadeair ~ % picgo use uploader? Use an uploader gitee[PicGo SUCCESS]: Configure config successfully!
到typora设置

]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务技术栈</title>
    <url>/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88-SpringCloud/</url>
    <content><![CDATA[一、微服务架构介绍
1.1 架构演变

单体架构： All in One，所有的功能模块都在一个工程里。

SOA架构： 这个架构当不当正不正，对于现在来说，有点老，甚至需要ESB，WebService之类的，基本不会使用了。
微服务架构：  微服务架构思想是马丁福勒提出的
https://martinfowler.com/articles/microservices.html
他的核心思想是这一段话：
In short, the microservice architectural style 1 is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.简而言之，微服务架构风格1是一种将单个应用程序开发为一套小型服务的方法，每个服务都在自己的进程中运行，并与轻量级机制（通常是HTTP资源API）通信。这些服务围绕业务能力构建，并可通过全自动部署机制独立部署。这些服务的集中管理最低限度，这些服务可能用不同的编程语言编写，并使用不同的数据存储技术。
将上述内容稍微整理：

微服务架构是一个软件架构风格，他不是标准。
将一个单体架构的产品拆分成多个服务，多个服务组成了完成的产品功能。
每个服务是可以完全独立部署的，互不影响。
可以采用HTTP这种轻量级的方式实现服务之间的交互。
在拆分服务时，一般是按照产品的业务领域去划分不同的服务，也可以针对单个功能做成一个服务。
采用DevOps的方式去做自动化部署。 （后面会学）
支持采用不用的语言去构建一个完整的产品。



微服务架构：是架构思想。
微服务：拆分出来的微小的服务，比如上图中的商品服务就是一个微服务。
微服务框架：对微服务的架构思想落地的一些技术。

1.2 SpringCloud生态

官方地址： https://spring.io/projects/spring-cloud
咱们要学习SpringCloud生态里的几个技术：

SpringCloud Alibaba： Nacos
SpringCloud：OpenFeign
SpringCloud Alibaba：Sentinel
SpringCloud：Gateway
链路追踪：Sleuth + Zipkin  -  SkyWalking（不玩）


Ps：这里只关注应用，底层源码之类的内容，这里不涉及。

二、Nacos注册中心
2.1 注册中心

当订单服务需要访问库存服务时，不知道库存服务的地址信息。利用注册中心，在服务启动时，将服务的基本信息都注册到Nacos中，当需要访问某一个服务之前，可以去Nacos中获取到对应的服务信息，就可以直接去访问啦~~~
如果让订单服务单独存储库存服务的基本信息，会导致耦合问题，如果库存服务的地址改变了，订单服务也需要变化，如果库存服务追加了集群的节点或者减少了集群的节点，订单服务都需要做维护，耦合性太高。


2.2 Nacos安装

Nacos可以Windows下简单的玩，也可以在Linux里安装。
直接去官方下载即可。
本地环境要求，java -version要么是JDK8，要么是JDK11
1
https://download.nacos.io/nacos-server/nacos-server-2.5.1.zip?spm=5238cd80.2ef5001f.0.0.3f613b7cKzonbx&amp;file=nacos-server-2.5.1.zip
点击即可直接下载（最好去官网）。

打开cmd准备启动Nacos服务
然后到bin目录下准备启动
启动成功要看到这个日志

启动成功后，直接访问Nacos提供的图形化界面
http://localhost:8848/nacos


2.3 Nacos初体验（注册中心）
2.3.1 构建父工程并管理版本

在玩Nacos的客户端操作前，优先了解一下常识性内容。
SpringCloud是建立在SpringBoot基础上的。
其次，SpringBoot版本，SpringCloud版本，SpringCloudAlibaba的版本都是有对应的。
版本对应可以查看这个地址：
https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E
版本不同，在使用的一些细节上可能会出现一些不一样的地方，所以最好跟我的版本保持统一！
SpringBoot咱们先不玩3.x，依然是以2.x为核心。
构建一个普通的Maven工程，在pom.xml中做四个事情。

将当前工程的packaging设置为pom类型。
声明好SpringBoot的parent，并制定好版本
声明SpringCloud的版本
声明SpringCloudAlibaba的版本

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.11&lt;/version&gt;        &lt;relativePath /&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.mashibing&lt;/groupId&gt;    &lt;artifactId&gt;springcloud&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;properties&gt;        &lt;spring-cloud.version&gt;2021.0.4&lt;/spring-cloud.version&gt;        &lt;spring-cloud-alibaba.version&gt;2021.0.4.0&lt;/spring-cloud-alibaba.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;

2.3.2 准备库存服务

这里需要完成几个操作。
1、构建好子工程……
2、导入依赖……
&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;
3、准备启动类，并添加注解……
package com.mashibing;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class StockStarterApp &#123;    public static void main(String[] args) &#123;        SpringApplication.run(StockStarterApp.class, args);    &#125;&#125;
4、准备yml文件，配置Nacos信息……
spring:  application:    name: stock  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848
5、启动测试……


2.3.3 准备订单服务

操作方式跟库存服务的套路没区别。
yml文件略微调整
spring:  application:    name: order  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848server:  port: 80
启动并测试


2.3.4 库存服务提供接口

在stock服务中提供一个可以对外访问的接口
写完记得测试一下，可以访问。
package com.mashibing.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class StockController &#123;    @GetMapping(&quot;/stock/test&quot;)    public String test() &#123;        return &quot;stock test!&quot;;    &#125;&#125;


2.3.5 订单服务准备接口访问库存服务

正常准备OrderController，并且在启动类中构建好RestTemplate对象，在OrderController中访问库存服务提供的接口。  现在是直接写死的状态，没利用Nacos。
package com.mashibing.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@RestControllerpublic class OrderController &#123;    // restTemplate是启动类里构建的！    @Autowired    private RestTemplate restTemplate;    @GetMapping(&quot;/order/test&quot;)    public String test()&#123;        //1、 直接访问库存服务的/stock/test接口，获取数据        String result = restTemplate.getForObject(&quot;http://localhost:8080/stock/test&quot;, String.class);        //2、 响应数据        return &quot;Order Test get &quot; + result;    &#125;&#125;


在确保写死的状态下，可以正常的获取到库存服务提供的接口后，咱们开始利用Nacos去获取服务的地址信息。
只需要在配置RestTemplate中，额外追加一个依赖
@Bean@LoadBalancedpublic RestTemplate restTemplate()&#123;    return new RestTemplate();&#125;
再将基于restTemplate对象访问的地址路径中的ip:port换成服务名。

希望的效果是，在restTemplate访问时，将stock服务名从Nacos中解析为具体的ip和端口。But事与愿违，报错了。

原因是因为现在玩的版本比较高，默认已经不用Ribbon，需要导入loadbalancer的依赖，就可以解决。
在order服务中，追加一个依赖。
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt;
再次访问，得到具体的结果


2.4 命名空间和分组（了解）

咱们在默认操作时，连接是的Nacos中的public命名空间以及DEFAULT_GROUP分组下的服务信息。
咱们可以在yml文件中指定要，当前服务需要连接哪个命名空间以及分组。



优先构建一个命名空间，然后指定order服务连接的命名空间

修改完毕后，因为之前的stock服务依然注册在public命名空间下，所以order服务去dev命名空间去找stock服务必然找不到，So，报了这个错误




将order服务中的注册与发现的分组设置的PDD_GROUP，再次去找Nacos实现注册与发现时，就会只找PDD_GROUP下的内容

再次去找stock服务时，发现找不到，那就对了，因为咱们配置了分组的信息，所以他会去PDD_GROUP去找对应的stock服务。


2.5 负载均衡（了解）


负载均衡的操作不是Nacos去做的。而是Nacos依赖 Ribbon或者Loadbalancer 。
（低版本默认引入Ribbon，当前版本需要手动引入Loadbalancer）
默认情况就是轮询的机制，你一个，我一个，你一个，我一个，你一个，我一个……
不需要做任何额外的配置，默认机制即可，虽然也有权重之类的操作，基本不用。
稍微修改了一下代码，方便查看具体的效果，将stock服务的test接口返回的结果追加上对应的端口号。
package com.mashibing.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class StockController &#123;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @GetMapping(&quot;/stock/test&quot;)    public String test() &#123;        return &quot;stock test!&quot; + serverPort;    &#125;&#125;
第一次启动发现错误，找不到引入的 @Value(“${server.port}”) ，原因是配置文件没写。

追加上对应的配置，就完事了。

优先启动了8080的Stock。
紧接着为了查看集群的效果，基于IDEA的配置，再次启动一个Stock服务，但是因为IDEA版本原因，需要设置一下多环境信息才ok。

然后在IDEA中追加启动项，启动配置好的这个8081的Stock服务

启动成功后，可以在Nacos中看到具体的集群信息
Ps：记住，集群的服务名必须保持一致，你写成不一样的，那就是俩服务了。

再去访问的时候，他就是默认轮询的效果了！



三、Nacos配置中心
3.1 配置中心

之前咱们的配置信息都是放在项目工程里的application.yml文件中。
但是后期服务可能会涉及到集群部署，并且部署在不同的服务器中。如果没有一个统一管理这些配置的方案，需要去多个地方维护这些配置信息。
项目在开发到发布交付的过程中，涉及很多环境开发环境，测试环境，预生产环境，生产环境，环境很多，需要提供多种环境下的配置文件。
项目中如果配置文件发生修改，一般是需要重启项目才能生效的，但是配置中心是可以实现动态刷新配置的功能，修改玩配置文件，可以立即生效，不需要重启。
其次就是配置文件现在的形式就是本地的一个文本文件，谁都能看，谁都能改，权限不好控制。配置中心就会提供这种权限的控制。
针对历史版本的记录，希望可以看到配置文件每次更改的变化，以及历史版本记录，也可以方便做一个回滚的操作。
总结下来就几点：

集中式管理配置文件的地方
环境隔离
配置动态刷新
权限的控制
历史版本记录


3.2 Nacos初体验（配置中心）

现在的目的是将order服务中的server.port=80的配置扔到Nacos服务中管理。希望Order服务启动后，可以去找对应地址的Nacos中的某个DataId的配置文件，达到启动后，依然占用80端口。
分成这几步完成上述操作：
1、导入依赖
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;
2、在Nacos服务上编写配置文件

3、Order的配置文件中指定好Nacos地址以及加载哪个配置文件
spring:  application:    # 服务名    name: order  profiles:    # 环境名    active: study  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848      config:        # nacos地址        server-addr: 127.0.0.1:8848        # 文件后缀        file-extension: yml#  order-study.yml#  $&#123;spring.application.name&#125; - $&#123;spring.profiles.active&#125; . $&#123;spring.cloud.nacos.config.file-extension&#125;
4、将application.yml修改为bootstrap.yml

5、因为版本关系，需要追加上一个依赖。
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;&lt;/dependency&gt;
6、测试，启动后查看日志信息


3.3 命名空间和分组（了解）

这里跟注册中心的思路是完全一样的，没啥变化
优先准备一个dev命名空间下的DEV_GROUP分组的配置文件。

配置文件的编写方式
spring:  application:    # 服务名    name: order  profiles:    # 环境名    active: dev  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848      config:        # nacos地址        server-addr: 127.0.0.1:8848        # 文件后缀        file-extension: yml        namespace: 06173ada-fb39-47b3-8551-7265a5177770        group: DEV_GROUP

3.4 配置动态刷新

配置的动态刷新的目的是为了实现当程序读取Nacos中的配置文件的内容时，如果Nacos中修改了某个key对应的value，项目不需要重启就可以立即生效。
准备一个环境，提供一个Controller接口，获取Nacos配置中的某个key的value，并且测试效果。
// 获取Nacos配置文件中的info@Value(&quot;$&#123;info:empty&#125;&quot;)private String info;@GetMapping(&quot;/order/info&quot;)public String info() &#123;    return info;&#125;





现在为了实现动态刷新的效果，咱们只需要做一个事情。
在引入Nacos配置文件的类上，追加一个注解即可
@RefreshScope


四、OpenFeign
4.1 OpenFeign介绍

OpenFeign是RPC框架的一种，OpenFeign不是Alibaba的组件，属于SpringCloud。
Alibaba内部提供的是Dubbo的RPC框架，作用都是一样的。

Dubbo走的是自己的Dubbo协议。
OpenFeign采用的是HTTP协议。

OpenFeign的主要目的就是为了 简化Java项目中编译HTTP请求的过程 ，并且让代码 具备更好的可维护性 。
OpenFeign他也 整合Sentinel，Nacos，Hystrix，LoadBalancer等 ，这些OpenFeign都是可以0成本整合的。
OpenFeign是 基于接口（interface）封装 ，实现代理对象去访问的，跟之前的单体项目的编写思路是一样的。

4.2 OpenFeign的初体验

按照官方文档的方式一步一步走。
1、导入依赖
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;
2、启动类追加注解
@EnableFeignClients
3、编写OpenFeign的Client接口。（映射到对应服务的接口上）
package com.mashibing.client;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;@FeignClient(&quot;stock&quot;)public interface StockClient &#123;    // 这里的内容，如果可以，最好去对应的Controller位置复制    @GetMapping(&quot;/stock/test&quot;)    String test();&#125;
4、测试，在order服务中编写测试接口
@RestController@RefreshScopepublic class OrderController &#123;    @Autowired    private StockClient stockClient;    // 基于OpenFeign，尝试访问Stock服务    @GetMapping(&quot;/order/feign&quot;)    public String feign() &#123;        String result = stockClient.test();        return result;    &#125;&#125;



4.3 OpenFeign配置
4.3.1 OpenFeign的超时配置

通过官方文档可以得知，OpenFeign的超时配置就2个东西

connectTimeout prevents blocking the caller due to the long server processing time.
readTimeout is applied from the time of connection establishment and is triggered when returning the response takes too long.

connectTimeout：关注的不多，更多的是客户端和服务端建立TCP连接的超时时间。
readTimeout：这个配置的会比较多，他是从请求发出到响应的超时时间
将Stock服务中的接口休眠一段时间，来测试达到超时时间后的效果
Order服务的配置：
feign:  client:    config:      stock:  # 服务名        readTimeout: 1000    # 响应时间1s，没响应直接报错
当超时后，抛出的错误。

Ps：这里区分版本，之前的版本，OpenFeign的超时时间是1s，现在默认情况下，5s都没超时！
也可能存在一个情况，第一次请求的时候，会初始化，速度可能会比较慢。
其次，OpenFeign也提供了全局（默认、缺省）的配置方式
feign:  client:    config:      default:  # 默认的配置，优先级低        read-timeout: 2000      stock:  # 细粒度针对服务的配置，优先级高        readTimeout: 6000

4.3.2 OpenFeign的底层技术

默认情况下，咱们当前版本的OpenFeign底层使用的HttpClient4。
咱们可以通过配置去选择使用okHttp或者是HC5（HttpClient5）
咱们是三选一：okHttp，HttpClient4，HC5。
区别的话，浅聊一下：

协议的支持：okHttp，HC5对协议支持的更好。
性能：相对来说，其实大差不差，但是还是okHttp，HC5的性能更好。
代码简洁度：其实咱们用了OpenFeign就无所谓了。
异步的支持：都支持！
okHttp是Square维护的，而HttpClient，HC5是Apache的。

默认采用的是HttpClient4：
feign:  httpclient:    enabled: true   # 默认使用的HttpClient
将配置更改为使用HC5
feign:  httpclient:    hc5:      enabled: true   # 就会采用HC5的方式访问目标服务
将配置修改为okHttp
feign:  okhttp:    enabled: true

五、Sentinel
5.1 Sentinel介绍

Sentinel帮助咱们解决的问题核心方向有两个：

流量控制： 可以实现限流的功能，同时也丰富了限流的机制，还提供了达到限制的阈值后，如何处理后续的请求。
断路器、熔断： 本质是帮助咱们去解决一些服务雪崩的问题，同时咱们可以主动的指定好降级方法，返回对应的托底数据。

可以去官网看一下。
https://sentinelguard.io/zh-cn/index.html
官方文档的介绍，可以看这个
https://sentinelguard.io/zh-cn/docs/introduction.html

5.2 Sentinel安装

Sentinel依然是用Java语言编写的，咱们安装Sentinel，其实本质就是下载一个jar包，然后用java -jar运行起来就可以登录到图形化界面。
依然去官方看文档安装。查看后，是在github上去下载对应的release版本
https://github.com/alibaba/Sentinel/tags
下载完毕之后，在确定好你的JDK环境没问题的情况下，并且JDK版本最好是1.8
暂时别弄17和21之类的版本，最高为师能接受JDK11。
同时也要确认好，当前系统的都8080端口没被占用，Sentinel默认占用8080。
然后就可以在cmd窗口中，基于
java -jar sentinel-dashboard-1.8.7
启动Sentinel项目。
Ps：因为Windows启动程序可能会存在一些小问题，比如我刚才，在启动后，需要按一下Ctrl + C让程序继续加载，才可以正常的访问到Sentinel的官方。
直接访问： http://localhost:8080/

默认的用户名和密码都是 sentinel  （都是小写）
进入后，看到这个就是安装成功


5.3 Sentinel初体验

1、导入依赖
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt;
2、编写配置连接Sentinel的dashboard
spring:  cloud:    sentinel:      transport:        port: 8719        dashboard: localhost:8080
3、启动项目后访问任何接口，不访问，dashboard上看不到

4、Sentinel的dashboard上查看服务


5.4 流控规则

这里主要的操作就是点来点去。
在设置流控规则时，发现需要设置一个资源名，咱们有两个方式可以选择


默认的资源名就是这个资源地址。


可以在Controller接口（方法）追加@SentinelResource的注解，指定资源名
@GetMapping(&quot;/order/info&quot;)@SentinelResource(value = &quot;info&quot;)public String info() &#123;    return info;&#125;




5.4.1 QPS限制
5.4.1.1 直接-快速失败

阈值类型：QPS               单体阈值：1
流控模式：直接
流控效果：快速失败
只要每秒超过2个请求，第二个请求就会触发快速失败，直接报错~


5.4.1.2 直接-WarmUp

阈值类型：QPS               单体阈值：10
流控模式：直接
流控效果：WarmUp
接口并不会一开始就支撑10的QPS，慢慢的，经过一段时间，才会将QPS限制开放到10。



5.4.1.3 直接-排队等待

阈值类型：QPS               单体阈值：2
流控模式：直接
流控效果：排队等待
QPS限制为2的时候，他会匀速的每个500ms，放一个请求进去。


5.4.1.4 关联-快速失败

阈值类型：QPS               单体阈值：2
流控模式：关联
流控效果：快速失败
首先需要准备两个资源查看效果
@GetMapping(&quot;/order/info&quot;)@SentinelResource(value = &quot;info&quot;)public String info() &#123;    return info;&#125;@GetMapping(&quot;/order/add&quot;)@SentinelResource(value = &quot;add&quot;)public String add() &#123;    return &quot;add&quot;;&#125;
给info资源设置QPS限制为1，关联的是add资源。 当频繁的访问add资源后，info就会被限制。


5.4.1.5 链路-快速失败

阈值类型：QPS               单体阈值：1
流控模式：链路
流控效果：快速失败
需要准备三个资源，其中两个资源作为入口，另外一个资源作为公共资源被访问
Ps：Controller中的方法默认就是资源，其次其他基于Spring管理的方法也可以作为资源，只是必须要追加上Sentinel的注解才可以。
@Autowiredprivate OrderService orderService;@GetMapping(&quot;/order/aaa&quot;)@SentinelResource(value = &quot;aaa&quot;)public String aaa() &#123;    orderService.common();    return &quot;aaa&quot;;&#125;@GetMapping(&quot;/order/bbb&quot;)@SentinelResource(value = &quot;bbb&quot;)public String bbb() &#123;    orderService.common();    return &quot;bbb&quot;;&#125;// ====================公共资源=======================package com.mashibing.service.impl;import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.mashibing.service.OrderService;import org.springframework.stereotype.Service;@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Override    @SentinelResource(&quot;common&quot;)    public void common() &#123;    &#125;&#125;
发现设置好之后，资源的入口是统一的，就是 sentinel_spring_web_context，导致咱们现在没有办法针对某个入口单独做链路的限制

可以通过配置，将统一入口管理的模式关闭掉。就可以将每个Controller资源作为一个入口。
spring:  cloud:    sentinel:      web-context-unify: false
追加完毕后，重新启动项目，查看簇点链路。
controller中已经有入口资源顶头了，可以开始配置链路的效果了。

具体解决问题的issue地址：
https://github.com/alibaba/Sentinel/issues/1213

5.4.2 并发线程数

因为流控里的QPS限制聊的模式基本都点到了。
这里的并发线程数看个效果即可。
阈值类型：并发线程数               单体阈值：1
流控模式：直接
这个资源内部只能有一个线程在处理，如果另外一个线程来了，需要排队等待。
为了查看效果，将代码的处理时间延长
@GetMapping(&quot;/order/info&quot;)@SentinelResource(value = &quot;info&quot;)public String info() &#123;    // ============并发线程数==============    try &#123;        Thread.sleep(3000);    &#125; catch (InterruptedException e) &#123;        throw new RuntimeException(e);    &#125;    return info;&#125;



5.5 熔断降级
5.5.1 熔断降级介绍

服务雪崩：因为某一个服务出现问题，导致其他服务，甚至整个系统崩溃的情况，就可以称为服务雪崩

为了解决这个服务雪崩的问题，可以上熔断、降级来解决这种服务雪崩问题
降级：针对一些资源，提供一个降级的方法，当这个资源出现了一些问题时，可以快速失败，去执行降级方法，返回托底数据。

熔断：就是针对某个资源提供断路器，有Closed，Open，Half Open状态。

Ps：熔断和降级不是一个东西，熔断是触发降级的手段之一。

5.5.2 熔断规则

Sentinel提供的熔断规则有三种


慢调用比例：

请求的响应时间，大于500ms，就被统计为慢调用。
在10s内，请求数量达到4个，开始统计熔断的阈值。
如果慢调用统计达到了请求量的50%，就会将断路器设置为Open状态，持续10s。
10s后，将断路器设置为Half Open状态，并放一个请求进来。

这个请求是慢调用，那就回到Open状态。
如果小于慢调用，设置为Closed状态。





异常比例：

资源访问出现异常，就认定是异常。
在10s内，请求数量达到4个，开始统计熔断的阈值。
如果异常统计达到了请求量的50%，就会将断路器设置为Open状态，持续10s。
10s后，将断路器设置为Half Open状态，并放一个请求进来。

这个请求出现异常，那就回到Open状态。
如果没异常，设置为Closed状态。





异常数：

资源访问出现异常，就认定是异常。
在10s内，请求数量达到4个，开始统计熔断的阈值。
如果异常统计达到了2个，就会将断路器设置为Open状态，持续10s。
10s后，将断路器设置为Half Open状态，并放一个请求进来。

这个请求出现异常，那就回到Open状态。
如果没异常，设置为Closed状态。








1、提供一套测试熔断效果资源，提供一个Controller
// =================================熔断降级===========================@GetMapping(&quot;/order/circuitbreaker&quot;)@SentinelResource(value = &quot;circuitbreaker&quot;)public String circuitbreaker(String value) throws InterruptedException &#123; switch (value)&#123;     case &quot;1&quot;:         Thread.sleep(1000);         break;     case &quot;2&quot;:         int i = 1 / 0; &#125; return &quot;circuitbreaker - success!&quot;;&#125;
2、启动项目开始测试！
看视频查看测试效果！！！！！

5.5.3 降级方法
5.5.3.1 blockHandler

Sentinel中提供的降级处理是基于@SentinelResource注解来实现的。
@SentinelResource是基于AOP去实现的，So，需要让方法的访问修饰符是public。
@SentinelResource注解的属性内容比较多，咱一个一个看

blockHandler：


blockHandler是专门处理BlockException的降级方法，指定降级方法名。


降级方法需要public修饰


返回类型，方法参数要匹配，方法参数最后可以追加BlockException


降级方法跟原方法在一个类里
@GetMapping(&quot;/order/sentinel&quot;)@SentinelResource(value = &quot;sentinel&quot;,blockHandler = &quot;sentinelBlock&quot;)public String sentinel(@RequestParam String value) throws InterruptedException &#123;    // 业务代码………………    return &quot;sentinel - success!&quot;;&#125;   // 是sentinel方法的降级方法，可以在方法逻辑中返回托底数据public String sentinelBlock(String value, BlockException exception)&#123;    String message = null;    if (exception instanceof FlowException)&#123;        message = &quot;流量控制！&quot;;    &#125;else if (exception instanceof DegradeException)&#123;        message = &quot;熔断控制&quot;;    &#125;       return &quot;failed  msg = &quot; + message.toString();&#125;



BlockHandlerClass：


这个属性和BlockHandler配合使用，可以将降级方法声明在其他类里
@GetMapping(&quot;/order/sentinel&quot;)@SentinelResource(value = &quot;sentinel&quot;,blockHandlerClass = OrderControllerBlock.class,blockHandler = &quot;sentinelBlock&quot;)public String sentinel(@RequestParam String value) throws InterruptedException &#123;    // 业务代码………………    return &quot;sentinel - success!&quot;;&#125;// ========================================================public class OrderControllerBlock &#123;       public static String sentinelBlock(String value, BlockException exception)&#123;        String message = null;        if (exception instanceof FlowException)&#123;            message = &quot;流量控制！&quot;;        &#125;else if (exception instanceof DegradeException)&#123;            message = &quot;熔断控制&quot;;        &#125;           return &quot;failed  msg = &quot; + message.toString();    &#125;   &#125;




BlockException：对应着Sentinel中的几种限制的方式：

FlowException：流控
DegradeException：熔断
ParamFlowException：热点
SystemBlockException：系统
AuthorityException：权限



5.5.3.2 fallback

fallback的使用跟blockHandler就是一模一样，但是blockHandler只处理BlockException。而fallback直接处理Throwable。

fallback：指定降级方法名称
fallbackClass：指定降级方法所在的Class

Ps：若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 BlockException 时只会进入 blockHandler 处理逻辑。
@GetMapping(&quot;/order/sentinel&quot;)@SentinelResource(value = &quot;sentinel&quot;,fallback = &quot;sentinelFallback&quot;,blockHandler = &quot;sentinelBlock&quot;)public String sentinel(@RequestParam String value) throws InterruptedException &#123;    switch (value)&#123;        case &quot;1&quot;:            Thread.sleep(1000);            break;        case &quot;2&quot;:            int i = 1 / 0;    &#125;    return &quot;sentinel - success!&quot;;&#125;public String sentinelFallback(String value,Throwable ex)&#123;    return &quot;failed&quot;;&#125;// 是sentinel方法的降级方法，可以在方法逻辑中返回托底数据public String sentinelBlock(String value, BlockException exception)&#123;    String message = null;    if (exception instanceof FlowException)&#123;        message = &quot;流量控制！&quot;;    &#125;else if (exception instanceof DegradeException)&#123;        message = &quot;熔断控制&quot;;    &#125;    return &quot;failed  msg = &quot; + message.toString();&#125;


5.5.3.3 defaultFallback&amp;exceptionsToIgnore

fallback只能针对单个资源去玩，defaultFallback可以针对全局。

defaultFallback：指定默认的降级方法名称

返回结果依然要统一
参数列表要为空，可以额外追加一个Throwable


fallbackClass：指定降级方法所在的Class

exceptionsToIgnore是针对fallback的，可以忽略掉一些异常不走降级方法
@GetMapping(&quot;/order/sentinel&quot;)@SentinelResource(value = &quot;sentinel&quot;,defaultFallback = &quot;defaultFallback&quot;,exceptionsToIgnore = &#123;ArithmeticException.class&#125;)public String sentinel(@RequestParam String value) throws InterruptedException &#123;    switch (value)&#123;        case &quot;1&quot;:            Thread.sleep(1000);            break;        case &quot;2&quot;:            int i = 1 / 0;    &#125;    return &quot;sentinel - success!&quot;;&#125;//==================默认的fallback=======================public String defaultFallback(Throwable ex)&#123;    return &quot;failed msg = &quot; + ex.getMessage();&#125;

5.6 热点规则（了解）

热点规则也属于流控的范畴。
因为流控规则是针对整个资源直接做一些限制。
而热点规则可以针对某一个字段中的参数做一些更细粒度化的流控。
Sentinel可以根据资源内传入的指定参数，来做热点参数的限流，Sentinel会帮你统计单位时间内这个参数值请求的次数 （利用LRU + 滑动时间窗口） ，再利用 令牌桶 来实现具体的限流操作。
为了查看效果，需要提供一个资源，接收俩个参数~
//==================热点规则=======================@GetMapping(&quot;/order/hot&quot;)@SentinelResource(value = &quot;hot&quot;)public String hot(String userId,Integer type)&#123;    return &quot;userId:&quot; + userId + &quot;,type:&quot; + type;&#125;



根据上述编写的资源，根据userId作为限流的参数。
当userId值传递的一样时，Sentinel会统计好次数，基于QPS的方式做限制。
在 统计窗口时长 时 ，当然 热点参数值 最多可以请求 单击阈值 次，超过了就异常！




可以针对参数的具体值，再做更细粒度化的限制！




测试了一波Sentinel热点规则对于接受参数的形式

默认资源内基于单个类型的参数接收是没问题的，包括@RequestParam，@PathVariable
默认如果采用对象的形式接收参数，热点规则没法生效……


5.7 授权规则（了解）

所谓的授权规则，其实就是针对某一个资源的调用方的身份做验证。
可以指定黑、白名单（指定一个），只要满足要求才会放行请求，否则会被拦截。
优先准备一个资源来测试。
//==================授权规则=======================@GetMapping(&quot;/order/author&quot;)@SentinelResource(value = &quot;author&quot;)public String author()&#123;    return &quot;author!&quot;;&#125;
设置好黑白名单后，发现无法生效。
当然服务资源在做黑白明显的限制规则时，Sentinel会基于拦截器内部调用RequestOriginParser的实现类去获取请求来源的具体身份信息。因为没有默认实现的，在这种情况下，他返回的都是空串。

那咱们需要主动实现一个RequestOriginParser实现类，直接基于请求头获取origin中的信息作为调用方的身份。
package com.mashibing.author;import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.RequestOriginParser;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;@Componentpublic class SentinelOriginParser implements RequestOriginParser &#123;    @Override    public String parseOrigin(HttpServletRequest request) &#123;        String origin = request.getHeader(&quot;origin&quot;);        return origin;    &#125;&#125;
编写后之后，在postman中发送请求，在请求头中追加了origin信息，携带上了身份，然后实现了授权的规则校验。
获取调用方身份是基于SentinelOriginParser拿到的，而校验的方式就是基于indexOf查看Sentinel中设置的授权的黑白名单身份是否包含了SentinelOriginParser获取的信息。

5.8 系统规则（了解）

系统规则不是针对某一个资源去做限制，而是针对整个服务的所有资源统一的做一些限制。
系统规则的目的是让整个系统保持可用，并且不会因为某一些资源的激增流量导致整个系统被压垮。
系统规则支持以下的模式：

Load 自适应 （仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。
CPU usage （1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。
平均 RT ：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。
并发线程数 ：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。
入口 QPS ：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。5.9 Sentinel持久化


5.9 动态规则、持久化

在Sentinel的图形化界面中配置的各种规则，都是存储在内存里的，之前配置的各种规则就全么得了。
不可能每次项目重启后，都去重新指定这些规则，成本太高了。
Sentinel也支持将一些规则持久化到某个DataSource。DataSource的种类很多。大概分为了两种

拉模式：客户端主动去查看是否变化，缺点是无法及时获取变更。
推模式：DataSource主动去通知客户端变化的内容，有更好的实时性和一致性保证。

其中Nacos就是推模式的一种实现，直接基于Nacos来持久化Sentinel中的规则。



实现步骤：
1、导入依赖
&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;
2、编写配置
spring:  cloud:    sentinel:      datasource:        flow:          nacos:            server-addr: $&#123;spring.cloud.nacos.config.server-addr&#125;            group-id: SENTINEL_GROUP            data-id: $&#123;spring.application.name&#125;-flow.json            data-type: json            rule-type: flow
3、Nacos中构建配置，编写规则，想编写这个内容

Nacos的配置

[    &#123;        &quot;resource&quot;: &quot;info&quot;,        &quot;limitApp&quot;: &quot;default&quot;,        &quot;grade&quot;: 1,        &quot;count&quot;: 1,        &quot;strategy&quot;: 0,        &quot;controlBehavior&quot;: 0    &#125;]



配置熔断规则的套路
1、依赖导入
…………
2、yml配置
spring:  cloud:    sentinel:      datasource:        degrade:          nacos:            server-addr: $&#123;spring.cloud.nacos.config.server-addr&#125;            group-id: SENTINEL_GROUP            data-id: $&#123;spring.application.name&#125;-degrade.json            data-type: json            rule-type: degrade
3、Nacos的配置


[    &#123;        &quot;resource&quot;: &quot;info&quot;,        &quot;grade&quot;: 2,        &quot;count&quot;: 2,        &quot;timeWindow&quot;: 10,        &quot;minRequestAmount&quot;: 5,        &quot;statIntervalMs&quot;: 10000    &#125;]

5.10 OpenFeign整合Sentinel

OpenFeign整合Sentinel的目的其实就是针对基于OpenFeign去访问其他服务时，如果出来了任何的问题，不要抛出异常，而是走降级方法，返回托底数据。
1、需要编写配置文件，开启OpenFeign跟Sentinel的整合
feign:  circuitbreaker:    enabled: true
2、构建Feign接口的实现类，重写Feign接口的方法（重写的方法就是降级方法）
package com.mashibing.client.fallback;import com.mashibing.client.StockClient;import org.springframework.stereotype.Component;@Componentpublic class StockClientFallback implements StockClient &#123;      @Override    public String test() &#123;        return &quot;test的降级方法，服务器正忙，请稍后再试！！&quot;;    &#125;&#125;
3、在Feign接口中指定@FeignClient的fallback属性
@FeignClient(value = &quot;stock&quot;,fallback = StockClientFallback.class)public interface StockClient &#123;

有同学会有疑问，这样OpenFeign不就有俩实现类在Spring容器中了么？ Spring怎么知道到底注入哪一个。其实OpenFeign是基于@FeignClient中的primary属性，指定了Feign接口的代理对象作为咱们注入的主要对象。
至于FallbackFactory就不实现了，大概知道可以利用fallback或者fallbackFactory两种形式，不过都是基于构建Feign接口实现类去玩的。

]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Sentinel</tag>
        <tag>Nacos</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>网络IO</title>
    <url>/2022/03/10/%E7%BD%91%E7%BB%9CIO/</url>
    <content><![CDATA[网络
TCP


是一个基于字节流的一个传输层的通信协议，在发送数据之前双方是需要建立一个连接的，这个所谓的连接就是双方都保存一个对方的ip地址还有端口等信息，然后TCP其实是一个字节流，头部就保存了这些信息，进行连接的时候有三个阶段：建立连接、传输数据、关闭连接，三次握手来建立，四次挥手来关闭，其中交换的报文都是tcp的头部。
三次握手
三次握手是一个在内核发生的一个行为，基于TCP协议，，首先呢，客户端应用启动以后，服务端进入listen状态，为了未来收到数据包做准备，然后在这个状态下内核进行了三次握手，

首先第一次是客户端向服务端发送带有SYN，代表发送连接的标识，的一个报文，自己进入一个SYN-SENT状态，然后服务器接收进入SYN-RECV状态
第二次是服务器发送带有SYN+ACK的报文，ACK是确认序号有效的标识，客户端接收进入established状态；
然后就是最后一次握手 因为服务端还需要知道自己发送和对方接收是否成功，所以客户端发送带有ACK标识的报文，服务端接收到才进入establised状态，以上三次握手就进行完毕


然后在这里以后应用要进行接收，就得将连接的socket放入accept队列，需要IO模型，调用server.accept() 如果队列里面有就取出来传到应用里，这里就有两种模型分别是阻塞等待返回的BIO和无阻塞轮询返回的NIO；还有一种模型是多路复用器，调用select,poll,epoll，但是它只是做一个和内核调用来知道队列里面是否有事件，然后再去有效性地进行一个accep()方法的调用
四次分手

客户端完成数据传输，要准备释放连接的时候：


进行第一次挥手，发一个带FIN（代表释放连接的标识）的报文给服务端然后进入FIN_WAIT1状态，服务接收到以后进入一个CLOSE-WAIT状态；


第二次挥手就是，服务器端向客户端发带ACK标识的报文，客户端接收后又进入FIN-WAIT状态，等待服务端将数据处理完毕收尾；


第三次服务端再去发送一个带FIN和ACK的报文，之前不一起发是因为服务端接收以后需要将数据发送进行完毕,在一个CLOSE-WAIT状态，搞定以后再发，客户端接收后进入TIME_WAIT状态；


然后就是第四次，客户端发送一个带ACK的报文给服务端，这里客户端的TIME-wait状态不能直接结束需要等待两倍报文寿命时间，再去closed，为什么是两倍报文寿命的时间是因为又肯呢个会出现服务器丢包的问题，但是服务端没接收到就会继续发送FIN，客户端要等待这么一个一去一回的时间来确认服务端没有再发送FIN，也就是确认服务端是否接收到，再去关闭，服务端接收到就会进入closed状态；
以上就是我了解的四次挥手过程。


与UDP的区别
udp  是用户数据协议，tcp是传输控制协议， 我就从这几个方面进行比较吧，首先一个是udp是无连接的，tcp是基于连接的， 第二个方面是他们的传输方式，udp 是报文， tcp是一个字节流，第三个是他们连接方式，udp是一对一一对多，多对多多对一的通信，而tcp只能是一对一，从这就可以看出第四方面他们的可靠性和安全性tcp明显是要高一些，也导致tcp首部要传输的信息很多，开销大，适用的场景就是文件传输，udp就可以在实时应用比如视频会议电话等场景用。
粘包
TCP协议是面向连接的可靠性协议。说它可靠并不表示数据信息一定会被对端接受，而是在传输失败后会放弃重传机制并中断连接来通知用户。它提供的只是数据可靠性的传输和故障通知。
TCP是数据流传输，数据流是只有起点和终点的字节数据序列，只有输入流和输出流。根本不存在“包”的概念。粘包的包是应用层的包，应用层协议规定了包的结构和大小，本质上就是一段数据报文。比如一段http请求，
//http 请求GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi
TCP粘包的原因
首先粘包的情况可能是recv-buffer这个缓冲区里有a包的一部分，或者a包和b包的一部分都有，原因从发送端来讲可能是send发送数据的时候因为还没收到接收端的ACK，就暂时将数据填充到缓冲区中等待，接收端方面就可能是因为处理数据不及时，数据都堆在缓冲区，致使ab包相连。
如何解决粘包呢？

固定包长度。每个包的大小都是一样的。
在包中给定包大小。例如：（固定前4个字节为包大小）
设置特定的结束标志。

struct Message &#123;undefined    int packSize;    int type;    char buf[100];&#125;;
http协议就是使用了上述的2，3方法。http使用&quot;\r\n&quot;为结束标识。
当为post请求时则有content-Length标识请求体长度。
Connection refused
可能是一个网络问题，还有可能就是内核建立连接发给程序的时候，那个accept队列阻塞了。
因为是内核帮助建立连接，程序必须通过listen里面的accept接收队列来进行一个等待程序的接收，有一个大小限制的backlog，如果队列满了可能就会造成一个报错， 是内核和程序之间发生的一个卡。
Session , Cookie, Token

因为http协议本身是一个无状态也就是浏览器没办法判断用户身份，然后cookie提供了暂时保存用户信息的一个作用，它其实是一个服务器放在浏览器上面的一个key-value形式的一个小文件，如果服务器需要保存用户状态，就通过response给客户端颁发一个cookie，下次浏览器再请求的时候再将cookie提交，服务器检查来进行辨认。
而session呢，是域对象之一，是会话过程中服务器分的一块储存空间，但也是依赖着cookie实现的，浏览器会在cookie里面设置sessionid， 服务器根据sessionid取出session中存储的信息。
两者区别呢就是存储空间的限制，session是没有限制的，cookie是有限制的，然后就是存储的位置，cookie是在浏览器上，session是在服务器端，这样安全性也就可以看出来cookie的不高，另一方面占用资源 session也会更多更加降低性能。
而token呢，是因为客户端如果频繁向服务端请求数据，服务端频繁的去数据库查询会有很多压力，使用token呢，就会降低服务器压力，减少频繁访问数据库，增强健壮性，token是服务端产生的字符串，作为一个客户端请求的令牌，第一次登陆就生成给客户端，以后客户端就拿这个token来请求数据，不用用户名和密码。 和session的区别就是session存储在服务器端，而token是在浏览器端，并且还提供认证功能，安全性比session好，不会让服务器压力很大，适用于项目级的前后端分离项目，session只能在服务器和客户端在同一台机器的场景使用。
HTTP
常用HTTP状态码：



2XX
成功（这系列表明请求被正常处理了）




200
OK，表示从客户端发来的请求在服务器端被正确处理


204
No   content，表示请求成功，但响应报文不含实体的主体部分


206
Partial   Content  ，进行范围请求成功


3XX
重定向  （表明浏览器要执行特殊处理）


301
moved permanently，永久  性重定向，表示资源已被分配了新的 URL


302
found，临时性重定向，表示资源临时被分配了新的   URL


303
see   other，表示资源存在着另一个 URL，  应使用   GET 方法获取资源  （对于  301/302/  303响应，几乎所有浏览器都会删除报文主体并  自动用  GET重新请求）


304
not   modified ，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）


307
temporary   redirect，临时重定  向，和302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求


4XX
客户端错误


400
bad   request，请求报文存在语法错误


401
unauthorized，表示发送的请求需要有通过   HTTP 认证的认证信息


403
forbidden  ，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述


404
not   found，表示在服务器上没有找到请求的资源


5XX
服务器错误


500
internal   sever   error，表  示服务器端在执行请求时发生了错误


501
Not   Implemented，表示服务器不支持当前请求所需要的某个功能


503
service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求



HTTP1和HTTP2
HTTP2 可以提高了网页的性能。
在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六
个），当在请求很多资源的时候，由于队头阻塞当浏览器达到  大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。
HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。
HTTPS
HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范



区别
HTTP
HTTPS




协议
运行在   TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份
身披 SSL(   Secure   Socket   Layer  )外壳的   HTTP，运行于 SSL 上，SSL 运行于   TCP 之  上，  是添加了加密和认证机制的   HTTP。


端口
80
443


资源消耗
较少
由于加解密处理，会消耗更  多的 CPU 和内存资源


开销
无需证书
需要证书，而证书一般需要向认证机构购买


加密机制
无
共享密钥加密和公开密钥加密并用的混合加密机制


安全性
弱
由于加密机制，安全性强



==get和post的区别==


GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST则没有。对参数的数据类型GET只接受ASCII字符，而POST即可是字符也可是字节。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。

]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存和分布式锁</title>
    <url>/2024/06/17/%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81_/</url>
    <content><![CDATA[缓存和分布式锁
一、缓存
1. 什么是缓存
  缓存的作用是减低对数据源的访问频率。从而提高我们系统的性能。


缓存的流程图

2.缓存的分类
2.1 本地缓存
  其实就是把缓存数据存储在内存中(Map &lt;String,Object&gt;).在单体架构中肯定没有问题。

单体架构下的缓存处理

2.2 分布式缓存
  在分布式环境下，我们原来的本地缓存就不是太使用了，原因是：

缓存数据冗余
缓存效率不高


  分布式缓存的结构图

3.整合Redis
  要整合Redis那么我们在SpringBoot项目中首页来添加对应的依赖
&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;
  然后我们需要添加对应的配置信息

测试操作Redis的数据
@AutowiredStringRedisTemplate stringRedisTemplate;@Testpublic void testStringRedisTemplate()&#123;    // 获取操作String类型的Options对象    ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();    // 插入数据    ops.set(&quot;name&quot;,&quot;bobo&quot;+ UUID.randomUUID());    // 获取存储的信息    System.out.println(&quot;刚刚保存的值：&quot;+ops.get(&quot;name&quot;));&#125;
查看可以通过Redis的客户端连接查看

也可以通过工具查看

4.改造三级分类
  在首页查询二级和三级分类数据的时候我们可以通过Redis来缓存存储对应的数据，来提升检索的效率。
@Override    public Map&lt;String, List&lt;Catalog2VO&gt;&gt; getCatelog2JSON() &#123;        // 从Redis中获取分类的信息        String catalogJSON = stringRedisTemplate.opsForValue().get(&quot;catalogJSON&quot;);        if(StringUtils.isEmpty(catalogJSON))&#123;            // 缓存中没有数据，需要从数据库中查询            Map&lt;String, List&lt;Catalog2VO&gt;&gt; catelog2JSONForDb = getCatelog2JSONForDb();            // 从数据库中查询到的数据，我们需要给缓存中也存储一份            String json = JSON.toJSONString(catelog2JSONForDb);            stringRedisTemplate.opsForValue().set(&quot;catalogJSON&quot;,json);            return catelog2JSONForDb;        &#125;        // 表示缓存命中了数据，那么从缓存中获取信息，然后返回        Map&lt;String, List&lt;Catalog2VO&gt;&gt; stringListMap = JSON.parseObject(catalogJSON, new TypeReference&lt;Map&lt;String, List&lt;Catalog2VO&gt;&gt;&gt;()&#123;&#125;);        return stringListMap;    &#125;
  然后对三级分类的数据做压力测试



压力测试内容
压力测试的线程数
吞吐量/s
90%响应时间
99%响应时间




Nginx
50
7,385
10
70


Gateway
50
23,170
3
14


单独测试服务
50
23,160
3
7


Gateway+服务
50
8,461
12
46


Nginx+Gateway
50





Nginx+Gateway+服务
50
2,816
27
42


一级菜单
50
1,321
48
74


三级分类压测
50
12
4000
4000


三级分类压测(业务优化后)
50
448
113
227


三级分类压测(Redis缓存)
50
1163
49
59



  通过对比可以看到Redis缓存加入后的性能提升的效果还是非常明显的。

5.缓存穿透
  指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义.

利用不存在的数据进行攻击，数据库瞬时压力增大，最终导致崩溃,解决方案也比较简单，直接把null结果缓存，并加入短暂的过期时间

6.缓存雪崩
  缓存雪崩是指在我们设置缓存时key采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

解决方案：原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

7.缓存击穿
  对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。如果这个key在大量请求同时进来前正好失效，那么所有对这个key的数据查询都落到db，我们称为缓存击穿。

解决方案：加锁， 并发只让一个去查，其他人等待，查到以后释放锁，其他人获取到锁，先查缓存，就会有数据，不用去db。

但是当我们压力测试的时候，输出的结果有点出乎我们的意料

做了两次的查询，原因是释放锁和查询结果缓存的时序问题

我们只需要调整下释放锁和结果缓存的时序问题就可以了

然后就是完整的代码处理
/**     * 查询出所有的二级和三级分类的数据     * 并封装为Map&lt;String, Catalog2VO&gt;对象     * @return     */    @Override    public Map&lt;String, List&lt;Catalog2VO&gt;&gt; getCatelog2JSON() &#123;        String key = &quot;catalogJSON&quot;;        // 从Redis中获取分类的信息        String catalogJSON = stringRedisTemplate.opsForValue().get(key);        if(StringUtils.isEmpty(catalogJSON))&#123;            System.out.println(&quot;缓存没有命中.....&quot;);            // 缓存中没有数据，需要从数据库中查询            Map&lt;String, List&lt;Catalog2VO&gt;&gt; catelog2JSONForDb = getCatelog2JSONForDb();            if(catelog2JSONForDb == null)&#123;                // 那就说明数据库中也不存在  防止缓存穿透                stringRedisTemplate.opsForValue().set(key,&quot;1&quot;,5, TimeUnit.SECONDS);            &#125;else&#123;                // 从数据库中查询到的数据，我们需要给缓存中也存储一份                // 防止缓存雪崩                String json = JSON.toJSONString(catelog2JSONForDb);                stringRedisTemplate.opsForValue().set(&quot;catalogJSON&quot;,json,10,TimeUnit.MINUTES);            &#125;            return catelog2JSONForDb;        &#125;        System.out.println(&quot;缓存命中了....&quot;);        // 表示缓存命中了数据，那么从缓存中获取信息，然后返回        Map&lt;String, List&lt;Catalog2VO&gt;&gt; stringListMap = JSON.parseObject(catalogJSON, new TypeReference&lt;Map&lt;String, List&lt;Catalog2VO&gt;&gt;&gt;() &#123;        &#125;);        return stringListMap;    &#125;    /**     * 从数据库查询的结果     * 查询出所有的二级和三级分类的数据     * 并封装为Map&lt;String, Catalog2VO&gt;对象     * 在SpringBoot中，默认的情况下是单例     * @return     */    public Map&lt;String, List&lt;Catalog2VO&gt;&gt; getCatelog2JSONForDb() &#123;        String keys = &quot;catalogJSON&quot;;        synchronized (this)&#123;            /*if(cache.containsKey(&quot;getCatelog2JSON&quot;))&#123;                // 直接从缓存中获取                return cache.get(&quot;getCatelog2JSON&quot;);            &#125;*/            // 先去缓存中查询有没有数据，如果有就返回，否则查询数据库            // 从Redis中获取分类的信息            String catalogJSON = stringRedisTemplate.opsForValue().get(keys);            if(!StringUtils.isEmpty(catalogJSON))&#123;                // 说明缓存命中                // 表示缓存命中了数据，那么从缓存中获取信息，然后返回                Map&lt;String, List&lt;Catalog2VO&gt;&gt; stringListMap = JSON.parseObject(catalogJSON, new TypeReference&lt;Map&lt;String, List&lt;Catalog2VO&gt;&gt;&gt;() &#123;                &#125;);                return stringListMap;            &#125;            System.out.println(&quot;-----------》查询数据库操作&quot;);            // 获取所有的分类数据            List&lt;CategoryEntity&gt; list = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;());            // 获取所有的一级分类的数据            List&lt;CategoryEntity&gt; leve1Category = this.queryByParenCid(list,0l);            // 把一级分类的数据转换为Map容器 key就是一级分类的编号， value就是一级分类对应的二级分类的数据            Map&lt;String, List&lt;Catalog2VO&gt;&gt; map = leve1Category.stream().collect(Collectors.toMap(                    key -&gt; key.getCatId().toString()                    , value -&gt; &#123;                        // 根据一级分类的编号，查询出对应的二级分类的数据                        List&lt;CategoryEntity&gt; l2Catalogs = this.queryByParenCid(list,value.getCatId());                        List&lt;Catalog2VO&gt; Catalog2VOs =null;                        if(l2Catalogs != null)&#123;                            Catalog2VOs = l2Catalogs.stream().map(l2 -&gt; &#123;                                // 需要把查询出来的二级分类的数据填充到对应的Catelog2VO中                                Catalog2VO catalog2VO = new Catalog2VO(l2.getParentCid().toString(), null, l2.getCatId().toString(), l2.getName());                                // 根据二级分类的数据找到对应的三级分类的信息                                List&lt;CategoryEntity&gt; l3Catelogs = this.queryByParenCid(list,l2.getCatId());                                if(l3Catelogs != null)&#123;                                    // 获取到的二级分类对应的三级分类的数据                                    List&lt;Catalog2VO.Catalog3VO&gt; catalog3VOS = l3Catelogs.stream().map(l3 -&gt; &#123;                                        Catalog2VO.Catalog3VO catalog3VO = new Catalog2VO.Catalog3VO(l3.getParentCid().toString(), l3.getCatId().toString(), l3.getName());                                        return catalog3VO;                                    &#125;).collect(Collectors.toList());                                    // 三级分类关联二级分类                                    catalog2VO.setCatalog3List(catalog3VOS);                                &#125;                                return catalog2VO;                            &#125;).collect(Collectors.toList());                        &#125;                        return Catalog2VOs;                    &#125;            ));            // 从数据库中获取到了对应的信息 然后在缓存中也存储一份信息            //cache.put(&quot;getCatelog2JSON&quot;,map);            // 表示缓存命中了数据，那么从缓存中获取信息，然后返回            if(map == null)&#123;                // 那就说明数据库中也不存在  防止缓存穿透                stringRedisTemplate.opsForValue().set(keys,&quot;1&quot;,5, TimeUnit.SECONDS);            &#125;else&#123;                // 从数据库中查询到的数据，我们需要给缓存中也存储一份                // 防止缓存雪崩                String json = JSON.toJSONString(map);                stringRedisTemplate.opsForValue().set(&quot;catalogJSON&quot;,json,10,TimeUnit.MINUTES);            &#125;            return map;        &#125; &#125;
8.本地锁的局限
  本地锁在分布式环境下，是没有办法锁住其他节点的操作的，这种情况肯定是有问题的

针对本地锁的问题，我们需要通过分布式锁来解决，那么是不是意味着本身锁在分布式场景下就不需要了呢？

  显然不是这样的，因为如果分布式环境下的每个节点不控制请求的数量，那么分布式锁的压力会非常大，这时我们需要本地锁来控制每个节点的同步，来降低分布式锁的压力，所以实际开发中我们都是本地锁和分布式锁结合使用的。
二、分布式锁
1.分布式锁的原理
  分布式锁或者本地锁的本质其实是一样的，都是将并行的操作转换为了串行的操作

2.分布式锁的常用解决方案
2.1 数据库
可以利用MySQL隔离性：唯一索引
use test;CREATE TABLE `DistributedLock` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,  `name` varchar(64) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;锁名&#x27;,  `desc` varchar(1024) NOT NULL DEFAULT &#x27;备注信息&#x27;,  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;保存数据时间，自动生成&#x27;,  PRIMARY KEY (`id`),  UNIQUE KEY `uidx_name` (`name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;锁定中的方法&#x27;;//数据库中的每一条记录就是一把锁，利用的mysql唯一索引的排他性lock(name,desc)&#123;    insert into DistributedLock(`name`,`desc`) values (#&#123;name&#125;,#&#123;desc&#125;);&#125;unlock(name)&#123;    delete from DistributedLock where name = #&#123;name&#125;&#125;
可以利用拍他说来实现 select … where …  for update;
乐观锁：乐观的任务数据不会出现数据安全问题，如果出现了就重试一次
select ...,version;update table set version+1 where version = xxx
2.2 Redis
setNX:
setNX(key,value) :如果key不存在那么就添加key的值，否则添加失败，Redisson
2.3Zookeeper

3.Redis实现分布式锁
  在Redis中是通过setNX指令来实现锁的抢占，那么利用这个命令实现分布式锁的基础代码为：
public Map&lt;String, List&lt;Catalog2VO&gt;&gt; getCatelog2JSONDbWithRedisLock() &#123;    String keys = &quot;catalogJSON&quot;;    // 加锁    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1111&quot;);    if(lock)&#123;        // 加锁成功        Map&lt;String, List&lt;Catalog2VO&gt;&gt; data = getDataForDB(keys);        // 从数据库中获取数据成功后，我们应该要释放锁        stringRedisTemplate.delete(&quot;lock&quot;);        return data;    &#125;else&#123;        // 加锁失败        // 休眠+重试        // Thread.sleep(1000);        return getCatelog2JSONDbWithRedisLock();    &#125;&#125;
  上面的代码其实是存在一些问题的，首先如果getDataForDB(keys)这个方法如果出现的异常，那么我们就不会删除该key也就是不会释放锁，从而造成了死锁，针对这个问题，我们可以通过设置过期时间来解决，具体代码如下：
public Map&lt;String, List&lt;Catalog2VO&gt;&gt; getCatelog2JSONDbWithRedisLock() &#123;    String keys = &quot;catalogJSON&quot;;    // 加锁    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1111&quot;);    if(lock)&#123;        // 给对应的key设置过期时间        stringRedisTemplate.expire(&quot;lock&quot;,20,TimeUnit.SECONDS);        // 加锁成功        Map&lt;String, List&lt;Catalog2VO&gt;&gt; data = getDataForDB(keys);        // 从数据库中获取数据成功后，我们应该要释放锁        stringRedisTemplate.delete(&quot;lock&quot;);        return data;    &#125;else&#123;        // 加锁失败        // 休眠+重试        // Thread.sleep(1000);        return getCatelog2JSONDbWithRedisLock();    &#125;&#125;
  上面虽然解决了getDataForDB方法出现异常的问题，但是如果在expire方法执行之前就中断呢？这样也会出现我们介绍的死锁的问题，那这个问题怎么办？这时我们就希望setNx和设置过期时间的操作能够保证原子性。
这时我们就可以在setIfAbsent方法中同时指定过期时间，保证这个原子性的行为
public Map&lt;String, List&lt;Catalog2VO&gt;&gt; getCatelog2JSONDbWithRedisLock() &#123;    String keys = &quot;catalogJSON&quot;;    // 加锁 在执行插入操作的同时设置了过期时间    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1111&quot;,30,TimeUnit.SECONDS);    if(lock)&#123;        // 给对应的key设置过期时间        stringRedisTemplate.expire(&quot;lock&quot;,20,TimeUnit.SECONDS);        // 加锁成功        Map&lt;String, List&lt;Catalog2VO&gt;&gt; data = getDataForDB(keys);        // 从数据库中获取数据成功后，我们应该要释放锁        stringRedisTemplate.delete(&quot;lock&quot;);        return data;    &#125;else&#123;        // 加锁失败        // 休眠+重试        // Thread.sleep(1000);        return getCatelog2JSONDbWithRedisLock();    &#125;&#125;
  如果获取锁的业务执行时间比较长，超过了我们设置的过期时间，那么就有可能业务还没执行完，锁就释放了，然后另一个请求进来了，并创建了key，这时原来的业务处理完成后，再去删除key的时候，那么就有可能删除别人的key，这时怎么办?针对这种情况我们可以查询的锁的信息通过UUID来区分，具体的代码如下：
public Map&lt;String, List&lt;Catalog2VO&gt;&gt; getCatelog2JSONDbWithRedisLock() &#123;        String keys = &quot;catalogJSON&quot;;        // 加锁 在执行插入操作的同时设置了过期时间        String uuid = UUID.randomUUID().toString();        Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid,30,TimeUnit.SECONDS);        if(lock)&#123;            // 给对应的key设置过期时间            stringRedisTemplate.expire(&quot;lock&quot;,20,TimeUnit.SECONDS);            // 加锁成功            Map&lt;String, List&lt;Catalog2VO&gt;&gt; data = getDataForDB(keys);            // 获取当前key对应的值            String val = stringRedisTemplate.opsForValue().get(&quot;lock&quot;);            if(uuid.equals(val))&#123;                // 说明这把锁是自己的                // 从数据库中获取数据成功后，我们应该要释放锁                stringRedisTemplate.delete(&quot;lock&quot;);            &#125;            return data;        &#125;else&#123;            // 加锁失败            // 休眠+重试            // Thread.sleep(1000);            return getCatelog2JSONDbWithRedisLock();        &#125;    &#125;
  上面查询key的值和删除key其实不是一个原子性操作，这就会出现我查询出来key之后，时间过期了，然后key被删除了，然后其他的请求创建了一个新的key，然后原来的执行删除了这个key，又出现了删除别人key的情况。这时我们需要保证查询和删除是一个原子性行为。
public Map&lt;String, List&lt;Catalog2VO&gt;&gt; getCatelog2JSONDbWithRedisLock() &#123;        String keys = &quot;catalogJSON&quot;;        // 加锁 在执行插入操作的同时设置了过期时间        String uuid = UUID.randomUUID().toString();        Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid,300,TimeUnit.SECONDS);        if(lock)&#123;            Map&lt;String, List&lt;Catalog2VO&gt;&gt; data = null;            try &#123;                // 加锁成功                data = getDataForDB(keys);            &#125;finally &#123;                String srcipts = &quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1]  then return redis.call(&#x27;del&#x27;,KEYS[1]) else  return 0 end &quot;;                // 通过Redis的lua脚本实现 查询和删除操作的原子性                stringRedisTemplate.execute(new DefaultRedisScript&lt;Integer&gt;(srcipts,Integer.class)                        ,Arrays.asList(&quot;lock&quot;),uuid);            &#125;            return data;        &#125;else&#123;            // 加锁失败            // 休眠+重试            // Thread.sleep(1000);            return getCatelog2JSONDbWithRedisLock();        &#125;    &#125;
https://space.bilibili.com/435498550 分布式锁的实现
4.Redisson分布式锁
4.1 Redisson的整合
添加对应的依赖
&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson&lt;/artifactId&gt;    &lt;version&gt;3.16.1&lt;/version&gt;&lt;/dependency&gt;
添加对应的配置类
@Configurationpublic class MyRedisConfig &#123;    @Bean    public RedissonClient redissonClient()&#123;        Config config = new Config();        // 配置连接的信息        config.useSingleServer()                .setAddress(&quot;redis://192.168.56.100:6379&quot;);        RedissonClient redissonClient = Redisson.create(config);        return  redissonClient;    &#125;&#125;
4.2 可重入锁
/**     * 1.锁会自动续期，如果业务时间超长，运行期间Redisson会自动给锁重新添加30s，不用担心业务时间，锁自动过去而造成的数据安全问题     * 2.加锁的业务只要执行完成， 那么就不会给当前的锁续期，即使我们不去主动的释放锁，锁在默认30s之后也会自动的删除     * @return     */    @ResponseBody    @GetMapping(&quot;/hello&quot;)    public String hello()&#123;        RLock myLock = redissonClient.getLock(&quot;myLock&quot;);        // 加锁        myLock.lock();        try &#123;            System.out.println(&quot;加锁成功...业务处理.....&quot; + Thread.currentThread().getName());            Thread.sleep(30000);        &#125;catch (Exception e)&#123;        &#125;finally &#123;            System.out.println(&quot;释放锁成功...&quot; +  Thread.currentThread().getName());            // 释放锁            myLock.unlock();        &#125;        return &quot;hello&quot;;    &#125;
4.3 读写锁
  根据业务操作我们可以分为读写操作，读操作其实不会影响数据，那么如果还对读操作做串行处理，效率会很低，这时我们可以通过读写锁来解决这个问题，
@GetMapping(&quot;/writer&quot;)    @ResponseBody    public String writerValue()&#123;        RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(&quot;rw-lock&quot;);        // 加写锁        RLock rLock = readWriteLock.writeLock();        String s = null;        rLock.lock(); // 加写锁        try &#123;            s = UUID.randomUUID().toString();            stringRedisTemplate.opsForValue().set(&quot;msg&quot;,s);            Thread.sleep(30000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            rLock.unlock();        &#125;        return s;    &#125;    @GetMapping(&quot;/reader&quot;)    @ResponseBody    public String readValue()&#123;        RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(&quot;rw-lock&quot;);        // 加读锁        RLock rLock = readWriteLock.readLock();        rLock.lock();        String s = null;        try &#123;            s = stringRedisTemplate.opsForValue().get(&quot;msg&quot;);        &#125;finally &#123;            rLock.unlock();        &#125;        return s;    &#125;
在读写锁中，只有读读的行为是共享锁，相互之间不影响，只要有写的行为存在，那么就是一个互斥锁(排他锁)
4.4 闭锁
基于Redisson的Redisson分布式闭锁（CountDownLatch）Java对象 RCountDownLatch采用了与 java.util.concurrent.CountDownLatch相似的接口和用法；
@GetMapping(&quot;/lockDoor&quot;)    @ResponseBody    public String lockDoor()&#123;        RCountDownLatch door = redissonClient.getCountDownLatch(&quot;door&quot;);                door.trySetCount(5);        try &#123;            door.await(); // 等待数量降低到0        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return &quot;关门熄灯...&quot;;    &#125;    @GetMapping(&quot;/goHome/&#123;id&#125;&quot;)    @ResponseBody    public String goHome(@PathVariable Long id)&#123;        RCountDownLatch door = redissonClient.getCountDownLatch(&quot;door&quot;);        door.countDown(); // 递减的操作        return id + &quot;下班走人&quot;;    &#125;
4.5 信号量(Semaphore)
基于Redis的Redisson的分布式信号量（Semaphore）Java对象
RSemaphore采用了与 java.util.concurrent.Semaphore相似的接口和用法。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。
@GetMapping(&quot;/park&quot;)    @ResponseBody    public String park()&#123;        RSemaphore park = redissonClient.getSemaphore(&quot;park&quot;);        boolean b = true;        try &#123;            // park.acquire(); // 获取信号 阻塞到获取成功            b = park.tryAcquire();// 返回获取成功还是失败        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return &quot;停车是否成功:&quot; + b;    &#125;    @GetMapping(&quot;/release&quot;)    @ResponseBody    public String release()&#123;        RSemaphore park = redissonClient.getSemaphore(&quot;park&quot;);        park.release();        return &quot;释放了一个车位&quot;;    &#125;
4.6 缓存数据一致性问题




针对于上的两种解决方案我们怎么选择？

缓存的所有数据我们都加上过期时间，数据过期之后主动触发更新操作
使用读写锁来处理，读读的操作是不相互影响的
读写锁

无论是双写模式还是失效模式，都会导致缓存的不一致问题。即多个实例同时更新会出事。怎么办？

如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加
上过期时间，每隔一段时间触发读的主动更新即可
如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog的方式。
缓存数据+过期时间也足够解决大部分业务对于缓存的要求。
通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。（业务不关心
脏数据，允许临时脏数据可忽略）

总结：

我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保证每天拿到当前最新数据即可。
我们不应该过度设计，增加系统的复杂性
遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。

三、SpringCache
SpringCache的不足：
1).读模式

缓存穿透：查询一个null的数据。可以解决 cache-null-values=true
缓存击穿:大量并发进来同时查询一个正好过期的数据。解决方案：分布式锁 sync=true 本地锁
缓存雪崩：大量的key同一个时间点失效。解决方案：添加过期时间 time-to-live=60000 指定过期时间

2).写模式

读写锁
引入canal，监控binlog日志文件来同步更新数据
读多写多，直接去数据库中读取数据即可

总结：

常规数据(读多写少)：而且对及时性和数据的一致性要求不高的情况，我们完全可以使用SpringCache
特殊情况：特殊情况特殊处理。

]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>算法高频题总结</title>
    <url>/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[高频题
三数之和
两数之和为基础

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

// 1 先将数组排序  // 2 从后往前遍历最后一个数 找对应的二元组：二元组 + arr[i] = 0  // 2.1 保证不重复  // 2.2 找出前面部分满足条件的二元组  // 2.3 遍历将arr[i]添加在后面  public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      // 1      Arrays.sort(nums);      int N = nums.length;      List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();      // 2      for (int i = N - 1; i &gt; 1; i--) &#123; // 三元组最后一个数，是arr[i]   之前....二元组 + arr[i]          // 2.1          if (i == N - 1 || nums[i] != nums[i + 1]) &#123;              // 2.2              List&lt;List&lt;Integer&gt;&gt; nexts = twoSum(nums, i - 1, -nums[i]);              // 2.3              for (List&lt;Integer&gt; cur : nexts) &#123;                  cur.add(nums[i]);                  ans.add(cur);              &#125;          &#125;      &#125;      return ans;  &#125;  // nums[0...end]这个范围上，有多少个不同二元组，相加==target，全返回  // &#123;-1,5&#125;     K = 4  // &#123;1, 3&#125;  // 1 两个指针  // 2 两数相加大于目标值就右缩;小于就左缩;等于就添加在结果集里面（先加左再加右）  public static List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int end, int target) &#123;      int L = 0;      int R = end;      List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();      while (L &lt; R) &#123;          if (nums[L] + nums[R] &gt; target) &#123;              R--;          &#125; else if (nums[L] + nums[R] &lt; target) &#123;              L++;          &#125; else &#123; // nums[L] + nums[R] == target              if (L == 0 || nums[L - 1] != nums[L]) &#123;                  List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();                  cur.add(nums[L]);                  cur.add(nums[R]);                  ans.add(cur);              &#125;              L++;          &#125;      &#125;      return ans;  &#125;
两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。

1 使用hashmap 结构 map.put(nums[i], i)
2 遍历一遍 如果查询到map里面有与解 就返回i和mapget的value
3 最后如果没有找到就返回new int[0]
class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for(int i = 0; i &lt; nums.length; i ++)&#123;            if(map.containsKey(target - nums[i]))&#123;                return new int[]&#123;i, map.get(target - nums[i])&#125;;            &#125;            map.put(nums[i], i);        &#125;        return new int[0];    &#125;&#125;
搜索旋转排序数组（面试）
使用二分查找

整数数组nums按升序排列，数组中的值互不相同。
arr，原本是有序数组，旋转过，而且左部分长度不知道.(以某一个下标为轴旋转 例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。)
题目需要在arr里面找到target

思路：

L = M = R 是最差的情况 不知道断点
L != M == R/ L == M != R/ L != M != R 只要三个数不全部一样就可以进行二分


public int search(int[] nums, int target) &#123;		int N = nums.length;		int L = 0;		int R = N - 1;		while (L &lt;= R) &#123;			int M = (L + R) / 2;			if (nums[M] == target) &#123;				return M;			&#125;			// nums[M] != target			// 1 左 中 右 相等 -- 》不能二分			if (nums[L] == nums[M] &amp;&amp; nums[M] == nums[R]) &#123;				// 左中一直相等 L ++				while (L != M &amp;&amp; nums[L] == nums[M]) &#123;					L++;				&#125;				// 1.1 左中直到重合都相等				if (L == M) &#123;					L = M + 1;					continue;// 回到循环开始重新来				&#125;				// 1.2 或者是 到不相等地方 继续2			&#125;			// 2 左中右不都相等 --&gt; 代表可以二分			if (nums[L] != nums[M]) &#123; // 2.1 [L] != [M] ?= [R]				if (nums[L] &lt; nums[M]) &#123;// 2.1.1 L &lt; M 左边一定有序					if (nums[L] &lt;= target &amp;&amp; target &lt; nums[M]) &#123;						R = M - 1;					&#125; else &#123;						L = M + 1;					&#125;				&#125; else &#123; // 2.1.2 L &gt; M 左边一定有断点 右边有序					if (nums[M] &lt; target &amp;&amp; target &lt;= nums[R]) &#123;						L = M + 1;					&#125; else &#123;						R = M - 1;					&#125;				&#125;			&#125; else &#123;// 2.2 [L] ?= [M] != [R]				if (nums[M] &lt; nums[R]) &#123;// 2.2.1 M &lt; R					if (nums[M] &lt; target &amp;&amp; target &lt;= nums[R]) &#123;						L = M + 1;					&#125; else &#123;						R = M - 1;					&#125;				&#125; else &#123; // 2.1.2 M &gt; R					if (nums[L] &lt;= target &amp;&amp; target &lt; nums[M]) &#123;						R = M - 1;					&#125; else &#123;						L = M + 1;					&#125;				&#125;			&#125;		&#125;		return -1;	&#125;
合并两个有序数组

给你两个有序数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。进行合并。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

public void merge(int[] nums1, int m, int[] nums2, int n) &#123;        int index = nums1.length;       while(m &gt; 0 &amp;&amp; n &gt; 0) &#123; // 相等的时候先拷贝长数组的  尽可能让空间早释放            if(nums1[m - 1] &gt;= nums2[n -1])&#123;                nums1[--index] = nums1[--m];            &#125; else &#123;                nums1[--index] = nums2[--n];            &#125;        &#125;           while(n &gt; 0) &#123;// m都被填完 就把nums2剩下的n填进nums1            nums1[--index] = nums2[--n];        &#125;    &#125;
螺旋矩阵

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。


public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;	List&lt;Integer&gt; order = new ArrayList&lt;&gt;();	if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;		return order;	&#125;	int left = 0;	int top = 0;	// 易错点一：注意right和bottom别写反了。	int right = matrix[0].length - 1;	int bottom = matrix.length - 1;	while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;		// 上层：从左到右，行不变，列变。		for (int i = left; i &lt;= right; i++) &#123;			order.add(matrix[top][i]);		&#125;		// 右层：从上到下，行变，列不变。		for (int i = top + 1; i &lt;= bottom; i++) &#123;			order.add(matrix[i][right]);		&#125;		// 易错点二：注意针对行列不相等时，下面两个循环要满足right &gt; left &amp;&amp; bottom &gt; top条件 ⚠️		if (right &gt; left &amp;&amp; bottom &gt; top) &#123;			// 下层：从右向左，行不变，列变。			for (int i = right - 1; i &gt;= left; i--) &#123;				order.add(matrix[bottom][i]);			&#125;			// 左层：从下到上，行变，列不变。			// 易错点三：此处只需要 i&gt;top, i不能=top			for (int i = bottom - 1; i &gt; top; i--) &#123;				order.add(matrix[i][left]);			&#125;		&#125;		left++;		top++;		right--;		bottom--;	&#125;	return order;&#125;
字符串相加

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。
你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

public String addStrings2(String num1, String num2) &#123;	int i = num1.length() - 1, j = num2.length() - 1, add = 0;	StringBuffer ans = new StringBuffer();	while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123;		int x = i &gt;= 0 ? num1.charAt(i) - &#x27;0&#x27; : 0;		int y = j &gt;= 0 ? num2.charAt(j) - &#x27;0&#x27; : 0;		int result = x + y + add;		ans.append(result % 10);		add = result / 10;		i--;		j--;	&#125;	// 计算完以后的答案需要翻转过来	ans.reverse();	return ans.toString();&#125;
二分查找
public int search(int[] nums, int target) &#123;        int L = 0;        int R = nums.length - 1;        while(L &lt; R)&#123; // ⚠️ 没有相等            int mid = (L + R) &gt;&gt; 1;            if(target &lt; nums[mid])&#123;                R = mid - 1;            &#125; else if(target &gt; nums[mid])&#123;                L = mid + 1;            &#125; else&#123;                return mid;            &#125;         &#125;        return (nums[L] == target) ? L : -1;    &#125;
在排序数组中找到元素第一个和最后一个位置
/** * 在排序数组中查找元素的第一个和最后一个位置 * @author chs * */public class Fre_044_FindFirstAndLastPositionOfElementInSortedArray &#123;	// 借助二分 《找到数组中比它小的最右的数 (lessMostRight	// 如果该位置右边!=target说明数组没有这个数	// 如果是 那么左边界找到 右边界就是《找到比ta+1小的最右的数》 (lessMostRight	public static int[] searchRange(int[] nums, int target) &#123;		if (nums == null || nums.length == 0) &#123;			return new int[] &#123; -1, -1 &#125;;		&#125;		int L = lessMostRight(nums, target) + 1;		if (L == nums.length || nums[L] != target) &#123;			return new int[] &#123; -1, -1 &#125;;		&#125;		return new int[] &#123; L, lessMostRight(nums, target + 1) &#125;;	&#125;	// 利用二分 	// 1 一个指针 M	// 2 ans存放结果	// 3 arr[M] 小于就去右边找 大于就去左边找	public static int lessMostRight(int[] arr, int num) &#123;		int L = 0;		int R = arr.length - 1;		// 1		int M = 0;		// 2 		int ans = -1;		// 3		while (L &lt;= R) &#123;			M = L + ((R - L) &gt;&gt; 1);			if (arr[M] &lt; num) &#123;				ans = M;				L = M + 1;			&#125; else &#123;				R = M - 1;			&#125;		&#125;		return ans;	&#125;&#125;
字符串转化整数
注意有很多特殊情况

1.需要删除无用的前导空格
2.检查下一个字符为正还是负
3.只读一开始是数字的部分


4.超出范围的数字返回边界

1. 主函数myAtoi():     1 除去空格和后面非数字的部分( 前后都要判空)【removeHeadZero()】     2 判断该部分是否是有效数字【isValid()】     3 转为负数形式（转回不会溢出，负数范围大些） posi(标志正负)     4 res是最负的情况 (用了负数就只用可以装下，如果用整数转，最小就没法装)2. removeHeadZero():     1 是否有符号     2 s标志第一个不是零的位置     3 e标志数字部分后面的非数字部分的开头     4 返回截取的带符号整数部分3. isVaild():    判断带符号整数部分是否有效     1 开头在remove部分没有判断，只要开头不是数字和符号都返回无效     2 只有符号也无效     3 夹杂着非数字字符也无效
public class Fre_072_StringToInteger &#123;  public int myAtoi(String s) &#123;        // 1 除去空格和后面不是数字的部分        if(s == null || s.equals(&quot;&quot;))&#123;// ⚠️            return 0;        &#125;        s = removeHeadZero(s.trim());        if(s == null || s.equals(&quot;&quot;))&#123;            return 0;        &#125;        // 2 判断这部分是不是有效数字        char[] str = s.toCharArray();        if(!isValid(str))&#123;            return 0;        &#125;        // 3 转为负数形式 为了防止溢出 posi(标志正负) ⚠️不要搞反了        boolean posi = str[0] == &#x27;-&#x27; ? false : true;        // 后面会有*10的操作 需要先判断会不会溢出        int minq = Integer.MIN_VALUE / 10;        int minp = Integer.MIN_VALUE % 10;        int res = 0;        int cur = 0;        for(int i = (str[0] == &#x27;-&#x27; || str[0] == &#x27;+&#x27;) ? 1 : 0; i &lt; str.length; i++)&#123;            cur = &#x27;0&#x27; - str[i]; // 转为负数            // 在乘十之前判断是否会溢出            if(res &lt; minq || (res == minq &amp;&amp; cur &lt; minp))&#123;                	return posi ? Integer.MAX_VALUE : Integer.MIN_VALUE;             &#125;            res = res * 10 + cur;        &#125;        // 4 res是最负情况（也就是本来是最大的+1）        if(posi &amp;&amp; (res == Integer.MIN_VALUE))&#123;            return Integer.MAX_VALUE; // 返回边界        &#125;        return posi ? -res : res;    &#125;    public static String removeHeadZero(String s)&#123;        // 1 是否有符号        boolean r = (s.startsWith(&quot;+&quot;) || s.startsWith(&quot;-&quot;)); // ⚠️ 不能用charat        // 2 标志第一个不是零的位置        int start = r ? 1 : 0;        for(; start&lt; s.length(); start++)&#123;            if(s.charAt(start) != &#x27;0&#x27;)&#123;                break;            &#125;        &#125;        // 3 找到数字部分后面的非数组部分开头 倒着遍历        int e = -1;        for(int i = s.length() - 1; i &gt;= (r ? 1 : 0); i--)&#123;            if(s.charAt(i) &lt; &#x27;0&#x27;  || s.charAt(i) &gt; &#x27;9&#x27;) &#123;                e = i;            &#125;        &#125;        // 4 返回截取的带符号的整数部分        return (r ? String.valueOf(s.charAt(0)): &quot;&quot;) + s.substring(start, e == -1 ? s.length() : e);    &#125;    // 判断是否是有效的数字    public static boolean isValid(char[] str) &#123;        // 1 如果开头不是数组        if(str[0] != &#x27;-&#x27; &amp;&amp; str[0] != &#x27;+&#x27; &amp;&amp; (str[0] &lt; &#x27;0&#x27; || str[0] &gt; &#x27;9&#x27;))&#123;            return false;        &#125;        // 2 只有符号也无效        if((str[0] == &#x27;-&#x27; || str[0] == &#x27;+&#x27;) &amp;&amp; str.length == 1)&#123;            return false;        &#125;        // 3 夹杂着非数字字符 无效        for(int i = 1; i &lt; str.length; i++)&#123;            if(str[i] &lt;&#x27;0&#x27; || str[i] &gt; &#x27;9&#x27;)&#123;                return false;            &#125;        &#125;        return true;    &#125;	&#125;
下一个排列

给你一个整数数组 nums ，找出 nums 的字典序中的下一个排列。
例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
必须 原地 修改，只允许使用额外常数空间。

public void nextPermutation(int[] nums) &#123;       int i = nums.length - 2;       // 1 倒着找升序对 [ i , i+ 1]       while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;           i--;       &#125;       // 2 从end -&gt; i+1 倒着找比i大的数       if(i &gt;= 0)&#123;           int j = nums.length - 1;           while(nums[i] &gt;= nums[j])&#123;               j--;           &#125;           swap(nums, i, j);       &#125;       // 3 将数组i+1以后的反转       // 因为有两种情况：1） i&lt; 0 说明本身就是字典序最大，直接翻转 2）[i+1, end]是降序需要翻转       reverse(nums, i + 1);   &#125;   public static void reverse(int[] nums, int i)&#123;       int left = i;       int right =  nums.length - 1;       while(left &lt; right)&#123;           swap(nums, left, right);           left++;           right--;       &#125;   &#125;   public static void swap(int[] nums, int i, int j)&#123;       int tmp = nums[i];       nums[i] = nums[j];       nums[j] = tmp;   &#125;
合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。


s 和 e 记录上一个区间的边界
然后复用interval数组来存储，最后复制数组size部分

class Solution &#123;    public int[][] merge(int[][] intervals) &#123;        	if (intervals.length == 0) &#123;			return new int[0][0];		&#125;    // 先按照区间的左边界来排序		Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]);		int s = intervals[0][0];		int e = intervals[0][1];// 		int size = 0;    // 然后复用interval数组来存储，最后复制数组size部分		for (int i = 1; i &lt; intervals.length; i++) &#123;			if (intervals[i][0] &gt; e) &#123;// 如果当前左边界大于e 说明没有覆盖 				intervals[size][0] = s;// 可以更新size部分的s和e 然后size++				intervals[size++][1] = e;				s = intervals[i][0];				e = intervals[i][1];// s e 更新为当前的左右边界			&#125; else &#123;				e = Math.max(e, intervals[i][1]); // 如果当前左边界小于或者等于 说明两个区间可以覆盖 先将e更新为这两个区间的最大右区间			&#125;		&#125;		intervals[size][0] = s; // 最后还有一次size处的更新		intervals[size++][1] = e;		return Arrays.copyOf(intervals, size);    &#125;&#125;
x的平方根
==二分查找==

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

1. 使用 二分 &lt;=就更新ans和L 到右边就更新R2. 注意数据类型时long主要是为了两个整型相乘不会溢出
// x一定非负，输入可以保证    public static int mySqrt(int x) &#123;        if (x == 0) &#123;            return 0;        &#125;        if (x &lt; 3) &#123;            return 1;        &#125;        // x &gt;= 3        long ans = 1;        long L = 1;        long R = x;        long M = 0;        while (L &lt;= R) &#123;            M = (L + R) / 2;            // 因为两个整数相乘可能会溢出            if (M * M &lt;= x) &#123;                ans = M;                L = M + 1;            &#125; else &#123;                R = M - 1;            &#125;        &#125;        return (int) ans;    &#125;
扩展：求出小数点后k位 其实思路与一样 只是换成double类型并且需要转换数格式
缺失的正数

给你一个未排序的整数数组，请你找出没有出现的最小的正整数 时间复杂度o(n)

除了打标记以外，我们还可以使用置换的方法，将给定的数组「恢复」成下面的形式：
如果数组中包含 x∈[1,N]x \in [1, N]x∈[1,N]，那么恢复后，数组的第 x−1x - 1x−1 个元素为 xxx。

在恢复后，数组应当有 [1, 2, …, N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以题目中的示例二 [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 2。
public int firstMissingPositive(int[] nums) &#123;        int n = nums.length;        for (int i = 0; i &lt; n; ++i) &#123;            while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123;               // ⚠️交换的条件---nums[i]∈[1,N] 且 nums[i]和本来应该在的位置的值nums[nums[i]-1]不相等                int temp = nums[nums[i] - 1];                nums[nums[i] - 1] = nums[i];                nums[i] = temp;            &#125;        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            if (nums[i] != i + 1) &#123;                return i + 1;            &#125;        &#125;        return n + 1;    &#125;
用rand7()生成rand10()

用一个不等概率返回0和1的函数, 怎么加工一个函数0和1等概率返回

public int rand10() &#123;       int ans= 0;       do&#123;           ans = f2();       &#125;while(ans &gt;9);       return ans + 1 ;   &#125;   public int f() &#123;       int ans= 0;       do&#123;           ans = rand7();       &#125;while(ans == 4);       return ans &lt; 4? 0:1;   &#125;   // 0000~1111 0~15   public int f2() &#123;       return (f() &lt;&lt; 3) + (f() &lt;&lt; 2) + (f() &lt;&lt; 1 )+ f();   &#125;
找到两个有序数组的中位数(⚠️)/两个有序数组第k小
public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;        //这里就主要处理 两个为空 一个为空 全不为空的三个情况        int size = nums1.length + nums2.length;        boolean e = (size &amp; 1) == 0;        if(nums1.length == 0 &amp;&amp; nums2.length == 0) &#123;            return 0;        &#125;else if(nums1.length == 0)&#123;            if(!e)&#123;                return nums2[size/ 2];                               &#125;else&#123;                return (double)(nums2[ size / 2- 1] + nums2[size / 2 ])/2;            &#125;        &#125;else if(nums2.length == 0)&#123;            if(!e)&#123;                return nums1[size/ 2];            &#125;else&#123;                return (double)(nums1[size / 2 - 1] + nums1[size / 2])/2;            &#125;        &#125;else&#123;            if(!e)&#123;                return findKthNum(nums1, nums2, size / 2 + 1);            &#125;else&#123;                return (double)(findKthNum(nums1, nums2, size/2)+findKthNum(nums1, nums2, size/2 +1))/2D;            &#125;        &#125;    //原型    public static int getUpMedian(int[] arr1, int s1,int e1,int[] arr2, int s2, int e2)&#123;        int mid1 = 0;        int mid2 = 0;        while(s1 &lt; e1)&#123;            //mid            mid1 = (e1 + s1) &gt;&gt; 1;            mid2 = (e2 + s2) &gt;&gt; 1;            if(arr1[mid1] == arr2[mid2] ) return arr1[mid1];            //奇数            if(((e1 - s1 + 1) &amp; 1) == 1)&#123;                if(arr1[mid1] &lt; arr2[mid2])&#123;                    if(arr1[mid1] &gt;= arr2[mid2 - 1]) return arr1[mid1];                    s1 = mid1 + 1;                    e2 = mid2 - 1;                &#125;else&#123;                    if(arr2[mid2] &gt;= arr1[mid1 - 1]) return arr2[mid2];                    s2 = mid2 + 1;                    e1 = mid1 - 1;                &#125;            &#125;            //偶数            else&#123;                if(arr1[mid1] &gt; arr2[mid2])&#123;                    e1 = mid1;                    s2 = mid2 + 1;                &#125;else&#123;                    e2 = mid2;                    s1 = mid1 + 1;                &#125;            &#125;        &#125;        //最后跳出循环 都只剩一个数        return Math.min(arr1[s1], arr2[s2]);    &#125;    //处理长度不同 返回Kth的情况    public static int findKthNum(int[] arr1, int[] arr2, int k)&#123;        int[] longs = arr1.length &gt;= arr2.length ? arr1 : arr2;        int[] shorts = arr1.length &lt; arr2.length ? arr1 : arr2;        int l = longs.length;        int s = shorts.length;        //1        if(k &lt;= s)&#123;            return getUpMedian(longs, 0, k - 1, shorts, 0, k - 1);        &#125;        //2        if(k &gt; l)&#123;            if(longs[k - s - 1] &gt;= shorts[s - 1])&#123;                return longs[k - s -1];            &#125;            if(shorts[k - l - 1] &gt;= longs[l - 1])&#123;                return shorts[k - l - 1];            &#125;            return getUpMedian(longs, k - s, l - 1, shorts, k - l, s - 1);        &#125;        //3        if(longs[k - s - 1] &gt;= shorts[s - 1])&#123;            return longs[k - s - 1];        &#125;        return getUpMedian(longs, k - s, k - 1,shorts, 0 ,s - 1);    &#125;
翻转字符串中的单词

给你一个字符串 s ，逐个翻转字符串中的所有 单词 。
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。
说明：
输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。
示例 1：
输入：s = “the sky is blue”
输出：“blue is sky the”
示例 2：
输入：s = &quot;  hello world  &quot;
输出：“world hello”
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。

思路:

去除多余的空白：
(1去掉字符串开头的空白字符
(2去掉字符串末尾的空白字符
(3将字符串间多余的空白字符去除
翻转字符串：
翻转每一个单词：
(1 遍历sb 使用start 和 end来抓单词
(2 翻转单词
(3 更新start，去找下一个单词

// 1 去除多余的空白    // 2 翻转字符串    // 3 翻转每一个单词    public String reverseWords(String s) &#123;        // 1        StringBuilder sb = trimSpaces(s);        // 2        reverse(sb, 0, sb.length() - 1);        // 3        reverseEachWord(sb);        return sb.toString();    &#125;    // 1 去掉字符串开头的空白字符    // 2 去掉字符串末尾的空白字符    // 3 将字符串间多余的空白字符去除    public StringBuilder trimSpaces(String s) &#123;        int left = 0, right = s.length() - 1;        // 1         while (left &lt;= right &amp;&amp; s.charAt(left) == &#x27; &#x27;) &#123;            ++left;        &#125;        // 2        while (left &lt;= right &amp;&amp; s.charAt(right) == &#x27; &#x27;) &#123;            --right;        &#125;        // 3        StringBuilder sb = new StringBuilder();        while (left &lt;= right) &#123;            char c = s.charAt(left);            if (c != &#x27; &#x27;) &#123;                sb.append(c);            &#125; else if (sb.charAt(sb.length() - 1) != &#x27; &#x27;) &#123;                sb.append(c);            &#125;            ++left;        &#125;        return sb;    &#125;    // 翻转任意字符    public void reverse(StringBuilder sb, int left, int right) &#123;        while (left &lt; right) &#123;            char tmp = sb.charAt(left);            sb.setCharAt(left++, sb.charAt(right));            sb.setCharAt(right--, tmp);        &#125;    &#125;    public void reverseEachWord(StringBuilder sb) &#123;        int n = sb.length();        int start = 0, end = 0;        // 1 遍历sb 使用start 和 end来抓单词        // 2 翻转单词        // 3 更新start，去找下一个单词        while (start &lt; n) &#123;            // 1            while (end &lt; n &amp;&amp; sb.charAt(end) != &#x27; &#x27;) &#123;                ++end;            &#125;            // 2            reverse(sb, start, end - 1);            // 3            start = end + 1;            ++end;        &#125;    &#125;
字符串相乘

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。
示例 1:
输入: num1 = “2”, num2 = “3”
输出: “6”
示例 2:
输入: num1 = “123”, num2 = “456”
输出: “56088”

public String multiply(String num1, String num2) &#123;        if (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;            return &quot;0&quot;;        &#125;        int m = num1.length(), n = num2.length();        int[] ansArr = new int[m + n];        for (int i = m - 1; i &gt;= 0; i--) &#123;            int x = num1.charAt(i) - &#x27;0&#x27;;            for (int j = n - 1; j &gt;= 0; j--) &#123;                int y = num2.charAt(j) - &#x27;0&#x27;;                ansArr[i + j + 1] += x * y;            &#125;        &#125;        for (int i = m + n - 1; i &gt; 0; i--) &#123;            ansArr[i - 1] += ansArr[i] /10;            ansArr[i] %= 10;        &#125;        int index = ansArr[0] == 0 ? 1 : 0;        StringBuffer ans = new StringBuffer();        while (index &lt; m + n) &#123;            ans.append(ansArr[index]);            index++;        &#125;        return ans.toString();    &#125;
删除数组中的重复项
任何删除重复的都可以用快慢指针
/** * 删除有序数组中的重复项 * @author chs * 任何删除重复的都可以用快慢指针 */public class Fre_017_RemoveDuplicatesFromSortedArray &#123;	public static int removeDuplicates(int[] nums) &#123;		if (nums == null) &#123;			return 0;		&#125;				if (nums.length &lt; 2) &#123;			return nums.length;		&#125;		int done = 0;		for (int i = 1; i &lt; nums.length; i++) &#123;			if (nums[i] != nums[done]) &#123;				nums[++done] = nums[i];			&#125;		&#125;		return done + 1;	&#125;&#125;
去除重复字母
贪心➕单调栈？

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。
示例 1：
输入：s = “bcabc”
输出：“abc”
示例 2：
输入：s = “cbacdcbc”
输出：“acdb”

public String removeDuplicateLetters(String s) &#123;       boolean[] vis = new boolean[26];       int[] num = new int[26];       for (int i = 0; i &lt; s.length(); i++) &#123;           num[s.charAt(i) - &#x27;a&#x27;]++;       &#125;       StringBuffer sb = new StringBuffer();       for (int i = 0; i &lt; s.length(); i++) &#123;           char ch = s.charAt(i);           if (!vis[ch - &#x27;a&#x27;]) &#123;               while (sb.length() &gt; 0 &amp;&amp; sb.charAt(sb.length() - 1) &gt; ch) &#123;                   if (num[sb.charAt(sb.length() - 1) - &#x27;a&#x27;] &gt; 0) &#123;                       vis[sb.charAt(sb.length() - 1) - &#x27;a&#x27;] = false;                       sb.deleteCharAt(sb.length() - 1);                   &#125; else &#123;                       break;                   &#125;               &#125;               vis[ch - &#x27;a&#x27;] = true;               sb.append(ch);           &#125;           num[ch - &#x27;a&#x27;] -= 1;       &#125;       return sb.toString();   &#125;
单词搜索

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。


public void rotate(int[][] matrix) &#123;        int a = 0;        int b = 0;        int c = matrix.length - 1;        int d = matrix[0].length - 1;        while(a &lt; c) &#123;            rotateEdge(matrix, a++, b++, c--, d--);        &#125;    &#125;    public static void rotateEdge(int[][] m, int a, int b, int c, int d) &#123;        int tmp = 0;        for (int i = 0; i &lt; d - b; i++) &#123;            tmp = m[a][b + i];            m[a][b + i] = m[c - i][b];            m[c - i][b] = m[c][d - i];            m[c][d - i] = m[a + i][d];            m[a + i][d] = tmp;        &#125;    &#125;
多数元素

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
是一个超级水王问题
1遍历 使用 candidate和HP 来一次删除两个不同的数2到最后 HP 不为0 则说明可能有水王 是当前的candidate3再遍历一次找candi 如果 HP&gt; n/2 说明就是水王 


public int majorityElement(int[] nums) &#123;        if(nums == null) &#123;            return -1;        &#125;        int n = nums.length;        int candi = 0;        int HP = 0;        for(int i  = 0; i &lt; n; i++) &#123;            if(HP == 0) &#123;                candi = nums[i];                HP++;            &#125;else if( nums[i] != candi) &#123;                HP--;            &#125;else &#123;                HP++;            &#125;        &#125;        if(HP == 0) &#123;            return -1;        &#125;        HP = 0;        for(int i = 0; i &lt; n ; i++) &#123;            if(nums[i] == candi) &#123;                HP++;            &#125;        &#125;        if(HP &gt; n / 2) &#123;            return candi;        &#125; else &#123;            return -1;        &#125;    &#125;&#125;
1 链表
1 反转链表
public ListNode reverseList(ListNode head) &#123;      ListNode pre = null;      ListNode cur = head;      while(cur != null) &#123;          ListNode next = cur.next;          cur.next = pre;          pre = cur;          cur = next;      &#125;      return pre;// ！返回的是pre  &#125;
反转链表二

就是反转链表中间一截

// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
// 第 3 步：切断出一个子链表（截取链表）先标记再切断
// 第 4 步：[同反转链表](##1 反转链表##)，反转链表的子区间
// 第 5 步：接回到原来的链表中
public ListNode reverseBetween(ListNode head, int left, int right) &#123;        //1 需要一个虚拟头        ListNode dummyNode = new ListNode(-1);        dummyNode.next = head;        //2 先找到反转部分的left前面pre        ListNode pre = dummyNode;        for(int i = 0; i &lt; left - 1;i++) &#123;            pre = pre.next;        &#125;        //2 从pre再走right - left + 1步 来到right节点        ListNode rNode = pre;        for(int i = 0; i &lt; right - left + 1;i++) &#123;            rNode = rNode.next;        &#125;        //3 切断这部分的链表        ListNode lNode = pre.next;        ListNode end = rNode.next;        pre.next = null;        rNode.next = null;        //4 反转区间内的链表        reverseLinkedList(lNode);        //5 接回去        pre.next = rNode;// ⚠️接回去的时候已经是反过来了        lNode.next = end;        return dummyNode.next;    &#125;    private void reverseLinkedList(ListNode head) &#123;        ListNode pre = null;        ListNode cur = head;        while (cur != null) &#123;            ListNode next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;    &#125;
2 LRU缓存机制

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
函数 get 和 put 必0须以 O(1) 的平均时间复杂度运行。

			
1) 总的缓存结构 和方法调用
构造方法
private MyCache&lt;Integer, Integer&gt; cache;	public Fre_278_LRUCache(int capacity)&#123;		cache = new MyCache&lt;&gt;(capacity);	&#125;	
1 get()
public int get(int key) &#123;		Integer ans = cache.get(key);		return ans == null ? -1 : ans;	&#125;
2 put()
public void put(int key, int value) &#123;		cache.set(key, value);	&#125;
2）MyCache
构造方法
public static class MyCache&lt;K, V&gt; &#123;	private HashMap&lt;K, Node&lt;K, V&gt;&gt; keyNodeMap;	private NodeDoubleLinkedList&lt;K, V&gt; nodeList;	private final int capacity;		public MyCache(int cap) &#123;		keyNodeMap = new HashMap&lt;K, Node&lt;K, V&gt;&gt;();		nodeList = new NodeDoubleLinkedList&lt;K, V&gt;();		capacity = cap;	&#125;
1 V get(K key) 通过key返回value 需要将node放到尾部
public V get(K key) &#123;		if(keyNodeMap.containsKey(key)) &#123;			Node&lt;K, V&gt; res = keyNodeMap.get(key);			nodeList.moveNodeToTail(res);			return res.value;		&#125;		return null;	&#125;
2  void set(K key, V value) 更新与新增：放到尾部，超出内存就删除最长时间没有操作的
public void set(K key, V value) &#123;		if (keyNodeMap.containsKey(key)) &#123;			Node&lt;K, V&gt; node = keyNodeMap.get(key);			node.value = value;			nodeList.moveNodeToTail(node);		&#125; else &#123;			Node&lt;K, V&gt; newNode = new Node&lt;K, V&gt;(key, value);			keyNodeMap.put(key, newNode);			nodeList.addNode(newNode);			if (keyNodeMap.size() == capacity + 1) &#123;				removeMostUnusedCache();			&#125;		&#125;	&#125;
3 void removeMostUnusedCache() 删去最长时间没有操作的缓存 ；在两个结构里面都删除
private void removeMostUnusedCache() &#123;			Node&lt;K, V&gt; removeNode = nodeList.removeHead();			keyNodeMap.remove(removeNode.key);		&#125;
3) 双向链表结构
基于LRU机制的双向链表结构
private Node&lt;K, V&gt; head;
private Node&lt;K, V&gt; tail;
构造方法：将头尾置为空
public NodeDoubleLinkedList()&#123;	head = null;	tail = null;&#125;
1 addNode() : 来新节点，挂到尾巴上
public void addNode(Node&lt;K, V&gt; newNode)&#123;			if(newNode == null) &#123;				return;			&#125;			if(head ==  null) &#123;				head = newNode;				tail = newNode;			&#125; else &#123;				tail.next = newNode;				newNode.last = tail;				tail = newNode;			&#125;		&#125;
2 moveToTail() : （修改过的节点，要保证node在表中）更新到尾部
public void moveNodeToTail(Node&lt;K, V&gt; node) &#123;		 		&#125;
3 removeHead() : 将头节点移走，返回新的头节点
public static class NodeDoubleLinkedList&lt;K, V&gt; &#123;		public Node&lt;K, V&gt; removeHead() &#123;		if (head == null) &#123;			return null;		&#125;		Node&lt;K, V&gt; res = head;		if (head == tail) &#123;			head = null;			tail = null;		&#125; else &#123;			head = res.next;			res.next = null;			head.last = null;		&#125;		return res;	&#125;&#125;
3 K个一组翻转链表
1 先将第一组k凑齐 并且反转
2 再记录上一组的结尾节点
3 循环（当结尾.next != null)
(1)更新start   (2)更新end 注意判空！！
（3） 反转 ：end 变头
(4） 上一组结尾连接到现在的开头end (5)更新lastEnd

public ListNode reverseKGroup(ListNode head, int k) &#123;       // 1       ListNode start = head;       ListNode end = getKEnd(start, k);       if (end == null) &#123;           return head;       &#125;       head = end;       reverse(start, end);       // 2       ListNode lastEnd = start;       // 3       while (lastEnd.next != null) &#123;           // 1)           start = lastEnd.next;           // 2)           end = getKEnd(start, k);           if (end == null) &#123;// ⚠️(注意判空！！！)               return head;           &#125;           // 3)           reverse(start, end);           // 4)           lastEnd.next = end;           // 5)           lastEnd = start;       &#125;       return head;   &#125;   private ListNode getKEnd(ListNode start, int k) &#123;       while (--k != 0 &amp;&amp; start != null) &#123;           start = start.next;       &#125;       return start;   &#125;   // 反转    // 1 end 往后移   // 2 三个指针进行反转   // 3 start反转后是结尾要连接到end   private void reverse(ListNode start, ListNode end) &#123;       // TODO Auto-generated method stub       end = end.next;//⚠️(注意要移动end指针)       ListNode pre = null;       ListNode cur = start;       ListNode next = null;       while (cur != end) &#123;           next = cur.next;           cur.next = pre;           pre = cur;           cur = next;       &#125;       start.next = end;   &#125;
4 合并两个有序链表

先抓小头head
cur2抓大头 cur1 = head.next pre = head
比较 c1 c2 谁小pre的next就指向谁 并且cur pre 后移

public static ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if(l1 == null || l2 ==null)&#123;            return l1 == null ? l2 : l1;        &#125;        //抓大头        ListNode head = l1.val &lt;= l2.val ? l1 : l2;        ListNode cur1 = head.next;        //抓小头        ListNode cur2 = head == l1 ? l2 : l1;        ListNode pre = head;        while(cur1 != null &amp;&amp; cur2 != null)&#123;            if(cur1.val &lt;= cur2.val)&#123;                pre.next = cur1;                cur1 = cur1.next;            &#125;else&#123;                pre.next = cur2;                cur2 = cur2.next;            &#125;            pre = pre.next;        &#125;        pre.next = cur1 != null ? cur1 :cur2;        return head;&#125;
合并k个链表

给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。


public class LianBiao_MergeMoreList &#123;  //对数器 ⚠️	public static class ListNodeComparator implements Comparator&lt;ListNode&gt; &#123;		@Override		public int compare(ListNode arg0, ListNode arg1) &#123;			// TODO Auto-generated method stub			return arg0.val - arg1.val;		&#125;	&#125;  	public ListNode mergeKLists(ListNode[] lists) &#123;		if (lists == null) &#123;			return null;		&#125;		// 1 定义一个对数器的小根堆		PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;(				new ListNodeComparator());   		// 2 将每一条的head放在堆中		for (int i = 0; i &lt; lists.length; i++) &#123;			if (lists[i] != null) &#123;// !!! 				heap.add(lists[i]);			&#125;		&#125;    if(heap.isEmpty())&#123; // ⚠️            return null;    &#125;		// 3 抓出head 将该条后面一个节点放入堆		ListNode head = heap.poll();		if (head.next != null) &#123;// !!!			heap.add(head.next);		&#125;		ListNode pre = head;// 指针		// 4 重复弹出连接结果表 再见弹出的下一个放入堆中		while (!heap.isEmpty()) &#123;			ListNode cur = heap.poll();			pre.next = cur;			pre = cur;			if (cur.next != null) &#123;// !!!				heap.add(cur.next);			&#125;		&#125;		return head;	&#125;&#125;
5 相交链表
需要分有环和无环两种情况 [如何辨别有无环](##6 环形链表##)
无环链表相交


给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。


需要两个指针；
先用n记录两个链表长度大小以便分清楚谁长谁短，n长度差记得取绝对值；
长的走n步到和短的一样长的起点；
两个指针一起走到相等的地方 就是交点 返回；

public static ListNode getNoLoop(ListNode headA, ListNode headB) &#123;	  if(headA == null || headB == null)&#123;	      return null;	  &#125;	  ListNode cur1 = headA;	  ListNode cur2 = headB;	  int n = 0;	  while(cur1 != null)&#123;		  n++;		  cur1 = cur1.next;	  &#125;	  while(cur2 != null)&#123;		  n--;		  cur2 = cur2.next;	  &#125;	   if(cur1 != cur2)&#123;		  return null;	  &#125;	  cur1 = n &gt; 0 ? headA : headB;//cur1指向长的头	  cur2 = (cur1 == headA) ? headB : headA;//cur2指向短头	  //将两个链表长度差取绝对值	  n = Math.abs(n);	  	  //将指向长链表的指针cur1往下移动n,到达和短链表cur2指针与相交点相同距离的位置	  while(n != 0)&#123;		  n--;		  cur1 = cur1.next;	  &#125;	  //两个指针向下 相遇点便是相交点	  while(cur1 != cur2)&#123;		  cur1 = cur1.next;		  cur2 = cur2.next;	  &#125;	  return cur1;           &#125;	
有环链表相交
有环的链表比较复杂 有三种情况
1 两个入环节点相同 即相交在入环前 (loop1 =loop2)
2 两个相交在环内相交 有两个相交点
3 两个不相交

public static ListNode bothLoop(ListNode headA,ListNode loop1,ListNode headB, ListNode loop2)&#123;		ListNode cur1 = null;		ListNode cur2 = null;		if(loop1 == loop2)&#123;//2 			//方法与两个无环链表方法一样只不过把loop1/2看作结尾			cur1 = headA;			cur2 = headB;			int n = 0;			while(cur1 != loop1)&#123;				  n++;				  cur1 = cur1.next;			  &#125;			  while(cur2 != loop2)&#123;				  n--;				  cur2 = cur2.next;			  &#125;			  if(cur1 != cur2)&#123;				  return null;			  &#125;			  cur1 = n &gt; 0 ? headA : headB;			  cur2 = (cur1 == headA) ? headB : headA;			  n = Math.abs(n);			  while(n != 0)&#123;				  n--;				  cur1 = cur1.next;			  &#125;			  while(cur1 != cur2)&#123;				  cur1 = cur1.next;				  cur2 = cur2.next;			  &#125;			  return cur1;		&#125;else&#123;			//loop1往后移动 如果在遇到自己之前遇到了loop2就是情况3			cur1 = loop1.next;			while(cur1 != loop1)&#123;				if(cur1 == loop2)&#123;					return loop1;//3					&#125;				&#125;				return null;//1			&#125;&#125;
6 环形链表

返回入环节点，没有环就返回null；

1.先将从头节点快慢指针开始往后，如果两个指针相遇那一定有环，期间如果快指针到null，可以直接判断无环。
2.如果要找到入环节点，就将fast指针指向head，slow不动，然后让两个指针都只移动一步，最后一定会在入环处相遇。
public static ListNode hasCycle(ListNode head) &#123;        if(head == null || head.next == null || head.next.next == null)&#123;            return null;        &#125;        ListNode slow = head.next;        ListNode fast = head.next.next;        while(slow != fast)&#123;            if(fast.next ==  null || fast.next.next == null)&#123;                return null;            &#125;            fast = fast.next.next;            slow = slow.next;        &#125;        fast = head;        while(slow != fast)&#123;            fast = fast.next;            slow = slow.next;        &#125;        return slow;    &#125;
7 重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：
L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。


找到原表的中点

快慢指针从head开走
fast.next == null || fast.next.next = null 返回慢指针


将右半端反转：[反转链表](##1 反转链表##)
将左右端合并

public void reorderList(ListNode head) &#123;		 public void reorderList(ListNode head) &#123;        if(head == null) &#123; // ⚠️判空            return;        &#125;        ListNode mid = middleNode(head);        ListNode l1 = head;        ListNode l2 = mid.next;        mid.next =null; // ⚠️分离        l2 = reverse(l2);        mergeList(l1, l2);    &#125;    public ListNode middleNode(ListNode head) &#123;        ListNode fast = head;        ListNode slow = head;        while(fast.next != null &amp;&amp; fast.next.next != null) &#123;            fast = fast.next.next;            slow = slow.next;        &#125;        return slow;    &#125;    public ListNode reverse(ListNode head) &#123;        ListNode pre = null;        ListNode cur = head;        while(cur != null) &#123;            ListNode next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre; // ⚠️返回的是pre    &#125;    // 合并过程就是使用两个指针来标志两个的下一个    public void mergeList(ListNode l1, ListNode l2) &#123;        ListNode l1_next;        ListNode l2_next;        while(l1 != null &amp;&amp; l2 != null) &#123;            l1_next = l1.next;            l2_next = l2.next;            l1.next = l2;            l1 = l1_next;            l2.next = l1;            l2 = l2_next;        &#125;    &#125;	&#125;
8 删除链表重复节点
设置虚拟节点
往后遍历  （条件：cur的下一个和下下个都是空）
2.1如果当前两个节点值相等就将当前cur.next的值保存在x;
​	循环（第一个节点后面的节点是否有重复的）cur.next指向不等于该x值的节点
​    2.2 不相等就直接next
public ListNode deleteDuplicates(ListNode head) &#123;		 if(head == null) &#123;            return head;        &#125;        ListNode dummy = new ListNode(0, head);        ListNode cur = dummy;        while(cur.next != null &amp;&amp; cur.next.next != null)&#123; // 当前节点下一个和下下个不为空            if(cur.next.val == cur.next.next.val)&#123; // 两个节点相等                int x = cur.next.val;                 while(cur.next != null &amp;&amp; cur.next.val == x)&#123; // 遍历第一个节点后面的节点是否有重复的                     cur.next = cur.next.next;// 有就直接讲指针指向下下个                &#125;            &#125; else &#123; // 两个节点不相等 指针后移                cur = cur.next;            &#125;        &#125;        return dummy.next;&#125;
9 排序链表

就是给链表排序

public static ListNode sortList(ListNode head) &#123;		// 1 遍历一遍链表的长度		int N = 0;		ListNode cur = head;		while (cur != null) &#123;			N++;			cur = cur.next;		&#125;		// 2 len是每次分组节点数 一直乘二		ListNode h = head;		ListNode teamFirst = head;		ListNode pre = null;		for (int len = 1; len &lt; N; len &lt;&lt;= 1) &#123;			while (teamFirst != null) &#123;				// 3 F就是将五个参数处理返回方便利用				// 左组从哪到哪   ls le				// 右组从哪到哪   rs re				// 左 右  next				ListNode[] f1 = f(teamFirst, len);				// ls...le  rs...re -&gt; merge去				// 整体的头、整体的尾				ListNode[] f2 = merge(f1[0], f1[1], f1[2], f1[3]);				if (h == teamFirst) &#123;					h = f2[0];					pre = f2[1];				&#125; else &#123;					pre.next = f2[0];					pre = f2[1];				&#125;				teamFirst = f1[4];// next			&#125;			teamFirst = h;			pre = null;		&#125;		return h;	&#125;	public static ListNode[] f(ListNode teamFirst, int len) &#123;		// 返回五个参数		ListNode ls = teamFirst;		ListNode le = teamFirst;		ListNode rs = null;		ListNode re = null;		ListNode next = null;		int pass = 0;		while (teamFirst != null) &#123;			pass++;			if (pass &lt;= len) &#123;				le = teamFirst;			&#125;			if (pass == len + 1) &#123;				rs = teamFirst;			&#125;			if (pass &gt; len) &#123;				re = teamFirst;			&#125;			if (pass == (len &lt;&lt; 1)) &#123;				break;			&#125;			teamFirst = teamFirst.next;		&#125;		// 左边结尾断开		le.next = null;		// 记录右边结尾的next并断开结尾断开 		if (re != null) &#123;			next = re.next;			re.next = null;		&#125;		return new ListNode[] &#123; ls, le, rs, re, next &#125;;	&#125;	public static ListNode[] merge(ListNode ls, ListNode le, ListNode rs, ListNode re) &#123;		if (rs == null) &#123;			return new ListNode[] &#123; ls, le &#125;;		&#125;		ListNode head = null;		ListNode pre = null;		ListNode cur = null;		ListNode tail = null;		while (ls != le.next &amp;&amp; rs != re.next) &#123;			if (ls.val &lt;= rs.val) &#123;				cur = ls;				ls = ls.next;			&#125; else &#123;				cur = rs;				rs = rs.next;			&#125;			if (pre == null) &#123;				head = cur;				pre = cur;			&#125; else &#123;				pre.next = cur;				pre = cur;			&#125;		&#125;		if (ls != le.next) &#123;			while (ls != le.next) &#123;				pre.next = ls;				pre = ls;				tail = ls;				ls = ls.next;			&#125;		&#125; else &#123;			while (rs != re.next) &#123;				pre.next = rs;				pre = rs;				tail = rs;				rs = rs.next;			&#125;		&#125;		return new ListNode[] &#123; head, tail &#125;;	&#125;
10 两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;		//两个链表分长短		//分为三个阶段 ：1 长短都还有节点 2 短没有节点 长有节点 3 长也走到没节点		ListNode l = listLength(l1) &gt; listLength(l2) ? l1 : l2;		ListNode s = (l == l1) ? l2 : l1;		ListNode curl = l;		ListNode curs = s;				int carry = 0;		int curNum = 0;		ListNode last = curl;						//1 		while(curs != null)&#123;			curNum = curs.val + curl.val + carry;			carry = curNum / 10;			curl.val = curNum % 10;			last = curl;//last一直在抓住最后一个节点			curl = curl.next;			curs = curs.next;		&#125;				//2 		while(curl != null)&#123;			curNum =  curl.val + carry;			carry = curNum / 10;			curl.val = curNum % 10;			last = curl;//last一直在抓住最后一个节点			curl = curl.next;		&#125;				//3 到		if(carry != 0)&#123;			last.next = new ListNode(1);		&#125;		return l;	&#125;				public static int listLength(ListNode l)&#123;		int length = 0;		while(l != null)&#123;			length++;			l = l.next;		&#125;		return length;	&#125;
11 链表中倒数第k个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

public class Fre_070_removeNthFromEnd &#123; public ListNode getKthFromEnd(ListNode head, int k) &#123;        ListNode slow = head;        ListNode fast = head;        while(k - 1 != 0)&#123;            fast = fast.next;            k--;        &#125;        while(fast.next != null) &#123;            slow = slow.next;            fast = fast.next;        &#125;        return slow;    &#125;
12 删除链表倒数第k个节点
public ListNode removeNthFromEnd(ListNode head, int n) &#123;       ListNode dummy = new ListNode(-1);       dummy.next = head;  			// 1 用两个指针截出n+1长度       ListNode slow = dummy;       ListNode fast = head;       for(;n&gt;0;n--)&#123;           fast=fast.next;       &#125;  			// 2 两个指针一直往后直到fast到结尾       while(fast != null)&#123;           fast = fast.next;           slow = slow.next;       &#125;  			// 3 slow在目标的前面一位 直接将next指针指向下下位        slow.next = slow.next.next;       return dummy.next;// 使用虚拟节点以防删除的是头节点   &#125;
13 回文链表
需要convert 和 然后判断对称 然后再convert恢复回去
public boolean isPalindrome(ListNode head) &#123;        ListNode slow = head;        ListNode fast = head;        while(fast.next != null &amp;&amp; fast.next.next != null)&#123;            slow = slow.next;            fast = fast.next.next;        &#125;        // 1 现在slow就走到了中间（偶数是上中）        // 2 将后半部分convert        ListNode l1 = null; //pre        ListNode l2 = slow.next;        ListNode l3 = null;        while(l2 != null)&#123;            l3 = l2.next;            l2.next = l1;            l1 = l2;            l2 = l3;        &#125;        // 3 后面部分已经翻转 现在对比两部分是否对称        boolean ans = true;        l2 = head;        l3 = l1;        while(l3 != null)&#123;            if(l2.val != l3.val)&#123; // ⚠️比较val                ans = false;                break;            &#125;            l2 = l2.next;            l3 = l3.next;        &#125;        // 4 把后半部分又恢复原样        l2 = null;// pre        l3 = null;// next        while(l1 != null)&#123;            l3 = l1.next;            l1.next = l2;            l2 = l1;            l1 = l3;        &#125;        slow.next = l2;        return ans;    &#125;
14 删除排序链表中的重复元素

给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

删除重复元素 留下一个
直接快慢指针
public ListNode deleteDuplicates(ListNode head) &#123;       if(head == null)&#123;           return null;       &#125;       ListNode ans = head;       ListNode left = head;       ListNode right = head.next;       while( right != null) &#123;           ListNode next = right.next;           if(left.val == right.val) &#123;               left.next = next;               right.next = null;           &#125; else&#123;               left =  right;           &#125;           right = next;       &#125;       return ans;   &#125;
15 复制带有随机指针的链表
/* * 深度复制带有rand的链表 */public class LiaoBiao_copyListWithRandom &#123;	public static class Node &#123;		public int value;		public Node next;		public Node rand;		public Node(int data) &#123;			value = data;		&#125;	&#125;		/*	 * 最优解：人工构造关系	 * 1 每一个节点后面加一个克隆节点	 * 2 遍历关系 （同时复制rand	 * 3 遍历分离（同时复制next	 */    public static Node copyListWithRandom(Node head)&#123;    	if(head == null)&#123; return null; &#125;    	Node cur = head;    	Node next = null;    	// 1    	while(cur != null)&#123;    		next = cur.next;    		cur.next = new Node(cur.value);    		cur.next.next = next;    		cur = next;    	&#125;    	    	cur = head;    	Node curCopy = null;    	// 2    	while(cur != null)&#123;    		next = cur.next.next;    		curCopy = cur.next;    		curCopy.rand = cur.rand != null ? cur.rand.next : null;    		cur = next;    	&#125;    	    	cur = head;    	Node res = head.next;    	// 3    	while(cur != null)&#123;    		next = cur.next.next;    		curCopy = cur.next;    		curCopy.next = cur.next != null ? cur.next.next : null;    		cur = next;    	&#125;    	return res;	&#125;	    /**     * 使用hashMap一一对应关系     * 1 遍历第一遍一一对应     * 2 遍历第二遍复制关系     * @param head     * @return     */	public static Node copyListWithRandom2(Node head)&#123;		HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;();		Node cur = head;		// 1 		while(cur != null)&#123;			map.put(cur, new Node(cur.value));			cur = cur.next;		&#125;				cur = head;		// 2		while(cur != null)&#123;			map.get(cur).next = map.get(cur.next);			map.get(cur).rand = map.get(cur.rand);			cur = cur.next;		&#125;				return map.get(head);			&#125;&#125;
2 动态规划
具体步骤 可以参考[零钱兑换](###2 返回凑齐的所有方法数)
基础问题 背包问题
/** * 传入货物的重量和价值 不能超过bag背包容量，返回最大价值 *  * @author chs * */public class DP2_knapsack &#123;	/**	 * 暴力递归	 */	public static int maxValue(int[] w, int[] v, int bag) &#123;		if (w == null || v == null || w.length == 0) &#123;			return 0;		&#125;		return process(w, v, 0, bag);	&#125;	public static int process(int[] w, int[] v, int i, int rest) &#123;		if (rest &lt; 0) &#123;			return -1;		&#125;		if (i == w.length) &#123;			return 0;		&#125;		// 加上i		int p1 = process(w, v, i + 1, rest - w[i]);		// 没加		int p2 = process(w, v, i + 1, rest);		if (p1 != -1) &#123;			p1 += v[i];		&#125;		return Math.max(p1, p2);	&#125;   	/**	 * 动态规划版	 */	public static int dp(int[] w, int[] v, int bag) &#123;		if (w == null || v == null || w.length != v.length || w.length == 0) &#123;			return 0;		&#125;		int N = w.length;		int[][] dp = new int[N + 1][bag + 1];		for(int i = N - 1; i &gt;= 0; i --)&#123;			for(int j = 0; j &lt;= bag; j ++)&#123;				int ans = 0;				if(j - w[i] &gt;= 0)&#123;					ans = dp[i + 1][j - w[i]] + v[i];				&#125;else&#123;					ans = dp[i + 1][j];				&#125;				dp[i][j] = Math.max(dp[i+1][j], ans);			&#125;		&#125;		return dp[0][bag];	&#125;		
1. 最大子数组和
用贪心
只需要一个pre反复更新记录以i为底的最大累加和，然后max存最大的
//用两个变量存	public static int maxSubArray4(int[] nums)&#123;		if (nums.length == 0 || nums == null) &#123;			return 0;		&#125;        int max = nums[0];        int pre = 0;		for(int i = 0; i &lt; nums.length; i++)&#123;			pre = Math.max(pre + nums[i], nums[i]);			max = Math.max(pre, max);        &#125;		return max;	&#125;
如果需要返回该子数组
int res = nums[0], l = 0, r = 0;for (int i = 0; i &lt; nums.size(); i++) &#123;	if (nums[i - 1] &lt; 0) &#123;		l = i;	&#125;	nums[i] += max(0, nums[i - 1]);	if (res &lt; nums[i]) &#123;		r = i;		res = nums[i];	&#125;&#125;
2. 买卖股票的最佳时机 maxProfit
(1) 从头至尾买一次一股 返回最大利润:
遍历一遍 min标记， max最大利润更新 就是找到最低点和最高点
class Solution &#123;    public int maxProfit(int prices[]) &#123;        int minprice = Integer.MAX_VALUE;        int maxprofit = 0;        for (int i = 0; i &lt; prices.length; i++) &#123;            if (prices[i] &lt; minprice) &#123;                minprice = prices[i];            &#125; else if (prices[i] - minprice &gt; maxprofit) &#123;                maxprofit = prices[i] - minprice;            &#125;        &#125;        return maxprofit;    &#125;&#125;
(2) 买一股但是可以买无限次
遍历累加所有的爬坡
// 一股随便买	// 相当于在每次爬坡前后买卖 将所有爬坡累加就行	public static int maxProfit2(int[] prices) &#123;		if (prices == null || prices.length == 0) &#123;			return 0;		&#125;		int ans = 0;		for(int i = 1; i &lt; prices.length; i++)&#123;			ans += prices[i] - prices[i - 1] &gt;= 0 ? prices[i] - prices[i - 1] : 0;		&#125;		return ans;	&#125;
3. 最长回文子串
(1) 动态规划O(N^2)


/**    * 自己改动态规划    * @param s    * @return    */   public String longestPalindrome33(String s) &#123;       if (s.length() &lt; 2) &#123;           return s;       &#125;       char[] str = s.toCharArray();       int N = str.length;       boolean[][] dp = new boolean[N][N];       for(int i = 0; i &lt; N; i++) &#123;           dp[i][i] = true;       &#125;       //边填dp 边抓最长和该最长开始节点       int max = 1;       int index = 0;      //按对角线遍历       // 最外循环不是dp的坐标      // i代表了n - len 每个循环行是不变的       // j是横坐标L       for(int i = N - 1; i &gt; 0; i--)&#123;           for(int L = 0; L &lt; i; L++)&#123;               int R = L + N - i;               if(str[L] == str[R])&#123;                   if(R - L &lt; 3)&#123;                       dp[L][R] = true;                   &#125;else&#123;                       dp[L][R] = dp[L + 1][R - 1];                   &#125;               &#125;               if(dp[L][R] &amp;&amp; R - L + 1 &gt; max)&#123;                   max = R - L + 1;                   index = L;	               &#125;           &#125;       &#125;       return s.substring(index, index + max);   &#125;
(2) Manacher!
面试讲一讲
假设字符串str长度为N，想返回最长回文子串的长度
时间复杂度O(N)
Manacher算法核心
1）理解回文半径数组
2）理解所有中心的回文最右边界R，和取得R时的中心点C
3）理解 L…(i’)…C…(i)…R 的结构，以及根据i’回文长度进行的状况划分
4）每一种情况划分，都可以加速求解i回文半径的过程
最长回文子串就是我知道可以进行。
最长回文子序列
子序列就是三种情况 L+1 ~R 和 L ~ R-1 和 L +1 ~ R - 1
public int longestPalindromeSubseq(String s) &#123;      public int longestPalindromeSubseq(String s) &#123;       if(s.length() == 0 || s == &quot;&quot;)&#123;           return 0;       &#125;       char[] str = s.toCharArray();       int N = str.length;       int[][] dp = new int[N][N];       for(int i = 0; i &lt; N; i++)&#123;           dp[i][i] = 1;       &#125;       //对角线遍历       for(int i = N - 1; i &gt;= 0; i--)&#123;         for(int L = 0; L &lt; i; L++)&#123;           int R = L + N - i;           dp[L][R] = Math.max(dp[L + 1][R],dp[L][R - 1]);           if(str[L] == str[R])&#123;             dp[L][R] = Math.max(dp[L + 1][R - 1] + 2, dp[L][R]);           &#125;				&#125;       &#125;       return dp[0][N - 1];      &#125;   
4. 最长递增子序列
DP版  O(n^2)
public int lengthOfLIS(int[] nums) &#123;      if (nums.length == 0) &#123;           return 0;      &#125;      int[] dp = new int[nums.length];      dp[0] = 1;      int maxans = 1;      for (int i = 1; i &lt; nums.length; i++) &#123;          dp[i] = 1;          for (int j = 0; j &lt; i; j++) &#123;              if (nums[i] &gt; nums[j]) &#123;                  dp[i] = Math.max(dp[i], dp[j] + 1);              &#125;          &#125;          maxans = Math.max(maxans, dp[i]);      &#125;      return maxans;  &#125;
二分查找+贪心  O(nlogn)
维护一个end数组存储


end[i] 代表  i+1 长度下子序列的最后下标


len = 递增子序列的长 度 - 1（end数组的下标 ）


设当前已求出的最长上升子序列的长度为 len（初始时为1），从前往后遍历数组nums，在遍历到 nums[i] 时：

如果 nums[i] &gt;[len] ，则[++len] = nums[i]；
否则，在end数组中[0 ~ len-1]二分查找，找到第一个比 nums[i] 小的数 end[k] ，并更新 end[k+1]=nums[i]。

代码
public static int lengthOfLIS(int[] nums) &#123;	if (nums.length == 0 || nums == null) &#123;		return 0;	&#125;	// end[i]存储 第i+1长度下子序列的最后下标	int[] end = new int[nums.length];	end[0] = nums[0];//!!!	// end数组的下标 = 递增子序列的长度 - 1	int len = 0;	// 二分查找的下标	for (int i = 1; i &lt; nums.length; i++) &#123;		//		if (nums[i] &gt; end[len]) &#123;			end[++len] = nums[i];		&#125; else &#123;// 在end里面二分查找 &lt; num[i] 的数			int L = 0;			int R = len - 1;			int pos = 0;//因为如果没有比他小的 说明都比他大 就更新的是end[0]			while (L &lt;= R) &#123;				int mid = (R + L) &gt;&gt; 1;				if(end[mid] &lt; nums[i])&#123;					pos = mid + 1;//抓住当前小于numi的数的后面一位 后面会更新					L = mid + 1;				&#125;else&#123;					R = mid - 1;				&#125;			&#125;			end[pos] = nums[i];//更新		&#125;	&#125;	return len + 1;&#125;
5. 接雨水

左右两个指针 left right
左右两个变量存储左右最大的值
每次更新左右任意一边靠着lmax或者rmax的指针的雨水大小
相当于是把每一下标积的水累加。

相当于是从左右两边来进行更新 哪边的max最大就比较那一边的L/R与max大小 累加并且更新最大值
最后返回累加和
public int trap(int[] arr) &#123;	int ans = 0;	int L = 1;	int R = arr.length - 2;	int leftMax = arr[0];	int rightMax = arr[arr.length - 1];z	while(L &lt;= R) &#123; // ！！！！ &lt;=		if(leftMax &lt;= rightMax) &#123;			ans += Math.max(0, leftMax - arr[L]);			leftMax = Math.max(leftMax, arr[L++]);		&#125;else &#123;			ans += Math.max(0, rightMax - arr[R]);			rightMax = Math.max(rightMax, arr[R--]);		&#125;	&#125;		return ans;&#125;
6. 最长上升子序列
设当前已求出的最长上升子序列的长度为 len（初始时为1），从前往后遍历数组nums，在遍历到 nums[i] 时：

如果 nums[i] d[len] ，则直接加入到 ddd 数组末尾，并更新 len= len+1；
否则，在 d数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k+1]=nums[i].

/**	 * 这道题要用 二分查找和贪心	 * 暴力递归XXX不用了老子 	 * @param nums	 * @return	 */	public static int lengthOfLIS(int[] nums) &#123;		if (nums.length == 0 || nums == null) &#123;			return 0;		&#125;		// end[i]存储 第i+1长度下子序列的最后下标		int[] end = new int[nums.length];		end[0] = nums[0];		// end数组的下标 = 递增子序列的长度 - 1		int len = 0;		// 二分查找的下标		for (int i = 1; i &lt; nums.length; i++) &#123;			//			if (nums[i] &gt; end[len]) &#123;				end[++len] = nums[i];			&#125; else &#123;// 在end里面二分查找 &lt; num[i] 的数				int L = 0;				int R = len - 1;				int pos = 0;//因为如果没有比他小的 说明都比他大 就更新的是end[0]				while (L &lt;= R) &#123;					int mid = (R + L) &gt;&gt; 1;					if(end[mid] &lt; nums[i])&#123;						pos = mid + 1;//抓住当前小于numi的数的后面一位 后面会更新						L = mid + 1;					&#125;else&#123;						R = mid - 1;					&#125;				&#125;				end[pos] = nums[i];//更新			&#125;		&#125;		return len + 1;	&#125;
7. 爬楼梯
递归 笔试
状态转移方程 f(n) = f(n - 1) + f(n - 2); ----&gt; 可以看出就是斐波拉契数列
用三个常量所以空间复杂度为O(1)
class Solution &#123;    public int climbStairs(int n) &#123;        int p = 0, q = 0, r = 1;        for (int i = 1; i &lt;= n; ++i) &#123;            p = q;             q = r;             r = p + q;        &#125;        return r;    &#125;+&#125;
矩阵快速幂 o(logn)

public class Code4_ClimbStairs &#123;	public static int climbStairs(int n) &#123;		if (n == 0) &#123;			return 0;		&#125;		// [ 1 ,1 ]		// [ 1, 0 ]		int[][] base = &#123; &#123; 1, 1 &#125;, &#123; 1, 0 &#125; &#125;;		int[][] res = matrixPower(base, n);		return res[0][0];     // 如果是斐波拉契数列 就要从1 1 2 3 5     // 返回的就是res[0][0]+res[0][1]	&#125;  /*  快速幂 方法就是将指数循环 每次循环内矩阵平方 然后指数右移一位  */	public static int[][] matrixPower(int[][] m, int p) &#123;    // res初始化为单位1		int[][] res = &#123;&#123;1, 0 &#125;, &#123;0,1&#125;&#125;;    // m ---&gt; 一次方		int[][] tmp = m;		for (; p != 0; p &gt;&gt;= 1) &#123;			if ((p &amp; 1) != 0) &#123; // ！！！先乘一次方 注意是不等于0 				res = muliMatrix(res, tmp);			&#125;			tmp = muliMatrix(tmp, tmp);		&#125;		return res;	&#125;	public static int[][] muliMatrix(int[][] m1, int[][] m2) &#123;		int[][] res = new int[m1.length][m2[0].length];		for (int i = 0; i &lt; m1.length; i++) &#123;			for (int j = 0; j &lt; m2[0].length; j++) &#123;				for (int k = 0; k &lt; m2.length; k++) &#123;					res[i][j] += m1[i][k] * m2[k][j]; // k = m1的列 = m2的行				&#125;			&#125;		&#125;		return res;	&#125;
主要就是注意快速幂里面要先进行 一次方的判断
8. 编辑距离(dp3)
DP 样本对应模型：往往用最后的位置来判断可能性
给两个单词，返回第一个单词转换为第二个单词最少的操作数， 有增删改三种操作
（扩展：可以增加a d c分别代表增删改的代价）
根据最后一个位置有四种可能
public class DP3_EditDistance &#123;		public int minDistance(String word1, String word2) &#123;      	if(word1 == null || word2 == null) &#123;          return 0;        &#125;       char[] str1 = word1.toCharArray();        char[] str2 = word2.toCharArray();        int N = str1.length;         int M = str2.length;        int[][] dp = new int[N+1][M+1];        // 1 处理边界：其中有字符串是空的情况 全是增加操作        for(int i = 0; i &lt;= N; i++) &#123;            dp[i][0] = i;        &#125;         for(int i = 0; i &lt;= M; i++) &#123;            dp[0][i] = i;        &#125;        // 2 普通情况 从最后位置比较word1该如何处理        for(int i = 1; i &lt;= N; i++) &#123;            for(int j = 1; j &lt;= M; j++) &#123;                // 2.1 最后一个位置修改或者保留                if(str1[i- 1] == str2[j - 1]) &#123;// ！！！ 注意                    dp[i][j] = dp[i - 1][j - 1];                &#125; else &#123;                    dp[i][j] = dp[i - 1][j - 1] + 1;                &#125;                // 2.2 最后一个位置删除                dp[i][j] = Math.min(dp[i- 1][j] + 1, dp[i][j]);                // 2.3 最后一个位置增加                 dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i][j]);            &#125;        &#125;        return dp[N][M];&#125;
⚠️ 因为有为0的情况 所以总的就是[0, N] 所以循环范围需要是[0,N]  并且str下标 对应 dp下标减一

9. 最长公共子序列(dp3)

⚠️填边界的时候先将dp[0][0]填了 防止 i - 1 越界
public int longestCommonSubsequence(String text1, String text2) &#123;        if(text1 == null || text2 == null) &#123;            return 0;        &#125;        char[] str1 = text1.toCharArray();        char[] str2 = text2.toCharArray();        int[][] dp = new int[str1.length][str2.length];        // 1 填完第一行和第一列        dp[0][0] = str1[0] == str2[0] ? 1 : 0; // !!!        for(int i = 1; i &lt; str2.length; i++) &#123;           dp[0][i] = str1[0] == str2[i] ? 1 : dp[0][i - 1];        &#125;         for(int i = 1; i &lt; str1.length; i++) &#123;           dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];        &#125;        // 2 按每行没列填        for(int i = 1; i &lt; str1.length; i++) &#123;            for(int j = 1; j &lt; str2.length; j++) &#123;              // 1 不看当前的情况 比较[i - 1]和[j ]或者[ i]和[j - 1]                int p1 = dp[i - 1][j];                int p2 = dp[i][j - 1];              // 2 将这个位置的情况纳入 比较 [i]和 [j]                int p3 = str1[i] == str2[j] ? dp[i - 1][j - 1] + 1 : dp[i - 1][j - 1];                dp[i][j] = Math.max(p1, Math.max(p2, p3));            &#125;        &#125;        return dp[str1.length - 1][str2.length - 1];    &#125;
10 最小路径和

m ✖️n 的网格 从左下角走到右下角 怎么走路径最短

⚠️[1, 1] 开始填表
public int minPathSum2(int[][] grid) &#123;        if (grid == null || grid.length == 0) &#123;            return 0;        &#125;        int m = grid.length;        int n = grid[0].length;        int[][] dp = new int[m][n];        dp[0][0] = grid[0][0];        for (int i = 1; i &lt; m; i++) &#123; // !!! 注意别写反了            dp[i][0] = dp[i - 1][0] + grid[i][0];        &#125;        for (int j = 1; j &lt; n; j++) &#123;            dp[0][j] = dp[0][j - 1] + grid[0][j];        &#125;        for (int i = 1; i &lt; m; i++) &#123;            for (int j = 1; j &lt; n; j++) &#123;                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];            &#125;        &#125;        return dp[m - 1][n - 1];    &#125;
扩展
记录路径也可以开一个字典，应该知道了每个 [i,j] 上一个来源坐标 last， path[(i,j)] = (lasti,lastj)，最后用一个死循环输出所有path，当 (i,j) == (0,0 ) 时候退出 然后最后进行一个死循环 就可以将循环打出来了
不同路径

m ✖️n 的网格 从左下角走到右下角 有多少种走法 （方法数）

public int uniquePaths(int m, int n) &#123;        int[][] dp = new int[m][n];        for(int i = 0; i &lt; m; i++) &#123;            dp[i][0] = 1;        &#125;        for(int i = 0; i &lt; n; i++) &#123;            dp[0][i] = 1;        &#125;        for(int i = 1; i &lt; m; i++) &#123;            for(int j = 1; j &lt; n; j++) &#123;                dp[i][j] = dp[i - 1][j]+ dp[i][j - 1];            &#125;        &#125;        return dp[m-1][n-1];    &#125;
11  最长公共子数组(最长重复子数组)

注意的还是边界； 应为需要最开始的状态来依赖 所以要不选择dp外围加一圈 要不就是dp内围循环从1开始


public int findLength(int[] A, int[] B) &#123;		int n = A.length, m = B.length;		int[][] dp = new int[n + 1][m + 1];		int ans = 0;		for (int i = n - 1; i &gt;= 0; i--) &#123;			for (int j = m - 1; j &gt;= 0; j--) &#123;				dp[i][j] = A[i] == B[j] ? dp[i + 1][j + 1] + 1 : 0;				ans = Math.max(ans, dp[i][j]);			&#125;		&#125;		return ans;	&#125;
public int findLength(int[] nums1, int[] nums2) &#123;       int[][] dp = new int[nums1.length+1][nums2.length+1];       int ans = 0;       for(int i = 1; i &lt;= nums1.length;i++) &#123;           for(int j = 1; j &lt;= nums2.length; j++) &#123;               dp[i][j] = nums1[i-1] == nums2[j-1] ? dp[i - 1][j - 1] + 1 : 0; //！！！               ans = Math.max(dp[i][j], ans);           &#125;       &#125;       return ans;   &#125;
12 零钱兑换问题 &lt;完全背包&gt;(dp4) 难
关于背包问题 吃透背包所有问题
从左向右的尝试模型

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

1 返回需要最少的硬币个数

计算并返回可以凑成总金额所需的 最少硬币个数 。
每个硬币都可以说使用无限次。

动态规划
public int coinChange(int[] arr, int aim) &#123;        if (aim == 0) &#123;			return 0;		&#125;		int N = arr.length;		int[][] dp = new int[N + 1][aim + 1];		dp[N][0] = 0;		for (int j = 1; j &lt;= aim; j++) &#123;			dp[N][j] = Integer.MAX_VALUE;		&#125;		for (int index = N - 1; index &gt;= 0; index--) &#123;			for (int rest = 0; rest &lt;= aim; rest++) &#123;				dp[index][rest] = dp[index + 1][rest];// 下边				if (rest - arr[index] &gt;= 0 						&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;          // 最小值 相当于（ 左边+1）与（下边 ）进行比较					dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + 1);				&#125;			&#125;		&#125;		return dp[0][aim] == Integer.MAX_VALUE ? -1 : dp[0][aim];// 无解情况返回-1    &#125;
2 返回凑齐的所有方法数

返回硬币或者货币可以凑齐钱的所有方法数

暴力递归的尝试

public static int coinsWay(int[] arr, int aim) &#123;		if (arr == null || arr.length == 0 || aim &lt; 0) &#123;			return 0;		&#125;		return process(arr, 0, aim);	&#125;	// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？	public static int process(int[] arr, int index, int rest) &#123;		if (index == arr.length) &#123; // 没钱了			return rest == 0 ? 1 : 0;		&#125;		int ways = 0;		for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123; 			ways += process(arr, index + 1, rest - (zhang * arr[index]));		&#125;		return ways;	&#125;

说明是有重复解的,所以可以进一步进行记忆化搜索
记忆化搜索
就是用一个结构存储f(i, rest)结果 后面就不会重复解

如果该题没有枚举行为那么傻缓存的方法和严格表结构（动态规划）的方法就是一样的。
严格的表结构： 就是在记忆化搜索的基础上，进一步梳理了依赖关系，从简单位置算出复杂位置，严格规定好了计算顺序
有枚举行为：需要搞出严格的表结构进行继续优化。
动态规划
第一版dp:有枚举行为，和上面记忆化搜索的方法是等效的
public static int dp1(int[] arr, int aim) &#123;		if (arr == null || arr.length == 0 || aim &lt; 0) &#123;			return 0;		&#125;		int N = arr.length;		int[][] dp = new int[N + 1][aim + 1];		dp[N][0] = 1;		for (int index = N - 1; index &gt;= 0; index--) &#123;			for (int rest = 0; rest &lt;= aim; rest++) &#123;				int ways = 0;				for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123;					ways += dp[index + 1][rest - (zhang * arr[index])];				&#125;				dp[index][rest] = ways;			&#125;		&#125;		return dp[0][aim];	&#125;
第二版：将枚举行为的规律找出来，利用严格的表结构


public int coinChange(int[] coins, int amount) &#123;		if (coins == null || coins.length == 0 || amount &lt; 0) &#123;			return 0;		&#125;		int N = coins.length;		int[][] dp = new int[N + 1][amount + 1];		dp[N][0] = 1;		for (int index = N - 1; index &gt;= 0; index--) &#123;			for (int rest = 0; rest &lt;= amount; rest++) &#123;				dp[index][rest] = dp[index + 1][rest];				if (rest - coins[index] &gt;= 0) &#123;					dp[index][rest] += dp[index][rest - coins[index]];				&#125;			&#125;		&#125;		return dp[0][amount];	&#125;	
3 最终代码
零钱兑换1
public int coinChange(int[] arr, int aim) &#123;        if (aim == 0) &#123;			return 0;		&#125;		int N = arr.length;		int[][] dp = new int[N + 1][aim + 1];		dp[N][0] = 0;		for (int j = 1; j &lt;= aim; j++) &#123;			dp[N][j] = Integer.MAX_VALUE;		&#125;		for (int index = N - 1; index &gt;= 0; index--) &#123;			for (int rest = 0; rest &lt;= aim; rest++) &#123;				dp[index][rest] = dp[index + 1][rest];				if (rest - arr[index] &gt;= 0 						&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;          // 最小值判断					dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + 1);				&#125;			&#125;		&#125;		return dp[0][aim] == Integer.MAX_VALUE ? -1 : dp[0][aim];// 无解情况返回-1    &#125;/** 一维 难理解*/public int coinChange(int[] coins, int amount) &#123;        int max = amount + 1;        int[] dp = new int[amount + 1];        Arrays.fill(dp, max);        dp[0] = 0;        for (int i = 1; i &lt;= amount; i++) &#123;            for (int j = 0; j &lt; coins.length; j++) &#123;                if (coins[j] &lt;= i) &#123;                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);                &#125;            &#125;        &#125;        return dp[amount] &gt; amount ? -1 : dp[amount];    &#125;
零钱兑换2
public int coinChange(int[] coins, int amount) &#123;		if (coins == null || coins.length == 0 || amount &lt; 0) &#123;			return 0;		&#125;		int N = coins.length;		int[][] dp = new int[N + 1][amount + 1];		dp[N][0] = 1;		for (int index = N - 1; index &gt;= 0; index--) &#123;			for (int rest = 0; rest &lt;= amount; rest++) &#123;				dp[index][rest] = dp[index + 1][rest];				if (rest - coins[index] &gt;= 0) &#123;					dp[index][rest] += dp[index][rest - coins[index]];				&#125;			&#125;		&#125;		return dp[0][amount];	&#125;/** 一维 不是很好理解怕写错*/public int change(int amount, int[] coins) &#123;        int[] dp = new int[amount + 1];        dp[0] = 1;        for (int coin : coins) &#123;            for (int i = coin; i &lt;= amount; i++) &#123;                dp[i] += dp[i - coin];            &#125;        &#125;        return dp[amount];    &#125;
13 最长有效括号

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

思路：    是子串类型，看以i结尾1 如果当前是‘）’ 就找可以和他配对的最前左括号pre下标   pre = i - dp[i - 1] - 1;            （dp[i - 1] 前一个已经配好对的长度 2 如果pre是左括号(注意pre&gt;= 0 防止越界)      更新dp[i] == 2 + dp [i - 1]+ (pre &gt; 0? dp [pre - 1] : 0);
public int longestValidParentheses(String s) &#123;        if(s == null || s.length()== 0) &#123;            return 0;        &#125;        char[] str= s.toCharArray();        int[] dp = new int[s.length()];        int max = 0;        for(int i = 1; i &lt; str.length; i++) &#123;            if( str[i] == &#x27;)&#x27;) &#123;                 int pre = i - dp[i - 1] - 1;                if( pre &gt;= 0 &amp;&amp; str[pre] == &#x27;(&#x27; ) &#123; // !! pre &gt;= 0在前 pre                     dp[i] = 2 + dp[i - 1] + (pre &gt; 0? dp[pre - 1] : 0);  //!!! pre -1                 &#125;            &#125;            max = Math.max(dp[i], max);        &#125;        return max;    &#125;
14 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
链接：https://leetcode-cn.com/problems/house-robber

public int rob(int[] nums) &#123;       if (nums == null || nums.length == 0) &#123;           return 0;       &#125;       if (nums.length == 1) &#123; // ！！！            return nums[0];       &#125;       int n = nums.length;       int[] dp = new int[n];       dp[0] = nums[0];       dp[1] = Math.max(dp[0], nums[1]); // ！！!注意要将[0][1] 先填 i从2开始       for(int i = 2; i &lt; n; i++) &#123;           int p1 = nums[i];           int p2 = dp[i - 1];           int p3 = nums[i] + dp[i - 2];           dp[i] = Math.max(p1, Math.max(p2, p3));       &#125;       return dp[n - 1];   &#125;
打家劫舍Ⅱ

这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。

是滚动数组，可以分成两个数组来判断[0]-[N-2] 和 [1]-[N-1]
public int rob(int[] nums) &#123;        if (nums == null || nums.length == 0) &#123;        return 0;    &#125;    if (nums.length == 1) &#123;        return nums[0];    &#125;    if (nums.length == 2) &#123;        return Math.max(nums[0], nums[1]);    &#125;        int[] dp = new int[nums.length];        dp[0] = nums[0];        dp[1] = Math.max(nums[0], nums[1]);        for(int i = 2; i &lt; nums.length-1; i++) &#123;            int p1 = nums[i];            int p2 = dp[i - 1];            int p3 = dp[i - 2] + nums[i];            dp[i] = Math.max(p1, Math.max(p2, p3));        &#125;        int ans1 = dp[nums.length - 2];        dp[1] = nums[1];        dp[2] = Math.max(nums[1], nums[2]);        for(int i = 3; i &lt; nums.length; i++) &#123;            int p1 = nums[i];            int p2 = dp[i - 1];            int p3 = dp[i - 2] + nums[i];            dp[i] = Math.max(p1, Math.max(p2, p3));        &#125;        int ans2 = dp[nums.length - 1];        return Math.max(ans1, ans2);            &#125;
15 矩阵的递增路径

给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。


public static int longestIncreasingPath(int[][] matrix) &#123;	int ans = 0;	int N = matrix.length;	int M = matrix[0].length;	int[][] dp = new int[N][M];	for (int i = 0; i &lt; N; i++) &#123;		for (int j = 0; j &lt; M; j++) &#123;			ans = Math.max(ans, process1(matrix, i, j, dp));		&#125;	&#125;	return ans;&#125;private static int process1(int[][] m, int i, int j,int[][] dp) &#123;	if(dp[i][j] != 0)&#123;//存了数就不用再算了		return dp[i][j];	&#125;	// 上下左右四个方向	int up = i &gt; 0 &amp;&amp; m[i][j] &lt; m[i - 1][j] ? process1(m, i - 1, j, dp) : 0;	int down = i &lt; (m.length - 1) &amp;&amp; m[i][j] &lt; m[i + 1][j] ? process1(m,			i + 1, j, dp) : 0;	int left = j &gt; 0 &amp;&amp; m[i][j] &lt; m[i][j - 1] ? process1(m, i, j - 1,dp) : 0;	int right = j &lt; (m[0].length - 1) &amp;&amp; m[i][j] &lt; m[i][j + 1] ? process1(			m, i, j + 1, dp) : 0;	int ans = Math.max(Math.max(up, down), Math.max(left, right)) + 1;	dp[i][j] = ans;	return ans;&#125;
16 机器人walk
/* * 机器人在n长度的数组中，位置在M，要走k步到p，有多少种方法 */public class DP_RobortWalk &#123;	/* 1	 * 暴力递归尝试	 * 每次走一步： 1. rest - 1 ；2. 位置cur更新	 */	public static int way1(int N, int M, int K, int P)&#123;		if (N &lt; 2 || M &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N || K &lt; 1) &#123;			return -1;		&#125;		return process1(N, M, K, P);	&#125; 		// 1 当剩下0步 ：到了aim 返回1;没到 返回0	// 2 两个边界条件	// 3 返回递归结果	public static int process1(int n, int cur, int rest, int aim)&#123;		// 1 		if(rest == 0 )&#123;// base case			return cur == aim ? 1 : 0;		&#125;		// 2		if(cur == 1)&#123;			return process1(n, 2, rest - 1, aim);		&#125;		if(cur == n)&#123;			return process1(n, n - 1, rest - 1, aim);		&#125;		// 3		return process1(n, cur - 1, rest - 1, aim) +  process1(n, cur + 1, rest - 1, aim);	&#125;		/*	 * DP:直接使用矩阵来替代递归的过程	 */	public static int way3(int N,int M, int K, int P)&#123;		if (N &lt; 2 || M &lt; 1 || M &gt; N || P &lt; 1 || P &gt; N || K &lt; 1) &#123;			return -1;		&#125;		int[][] dp = new int[N + 1][K + 1];		// 1		dp[P][0] = 1;//base case 		for (int rest = 1; rest &lt;= K; rest++) &#123;			// 2			dp[1][rest] = dp[2][rest - 1];			dp[N][rest] = dp[N - 1][rest - 1];			// 3			for (int cur = 2; cur &lt; N; cur++) &#123;				dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];			&#125;					&#125;		return dp[M][K];	&#125;		public static void main(String[] args) &#123;		System.out.println(way1(4, 2, 3, 3));		System.out.println(way3(4, 2, 3, 3));	&#125;&#125;
17 纸牌博弈
/* 纸牌博弈问题 * 两个会预判的人 从左右选卡片 返回胜利的人的分数 */public class DP1_TwoSmartManPeekCard &#123;	    public static int win1(int[] arr)&#123;        if(arr==null||arr.length==0)&#123;            return 0;        &#125;        return Math.max(f(arr,0,arr.length-1), s(arr,0,arr.length-1)) ;    &#125;    // f() 在i~j范围 先拿    public static int f(int[] arr,int i,int j)&#123;        //纸牌被聪明人先拿，获得的分数        if(i==j)&#123;            return arr[i];        &#125;        //拿走一张（i或者j）后，聪明人成了后拿的人，在两种决策中选最优        return Math.max(arr[i]+s(arr,i+1,j),arr[j]+s(arr,i,j-1));    &#125;    // g() 在i~j范围 后拿    public static int s(int[] arr,int i,int j)&#123;        //纸牌被聪明人后拿，获得的分数        if(i==j)&#123;            return 0;        &#125;        //对方拿走一张（i或者j）后，聪明人成了先拿的人，对方也是聪明人，会留下最差的情况        return Math.min(f(arr,i+1,j),f(arr,i,j-1));    &#125;    /*     * DP     */    public static int win2(int[] arr)&#123;    	int N = arr.length;		int[][] fmap = new int[N][N];		int[][] gmap = new int[N][N];						//先处理L == R （gmap在初始化就是0，不用管		for(int i = 0; i &lt;= N - 1; i++)&#123;			fmap[i][i] = arr[i];		&#125;		//按着对角线来一步步求！！！		for (int startCol = 1; startCol &lt; N; startCol++) &#123;			int L = 0;			int R = startCol;			while (R &lt; N) &#123;				fmap[L][R] = Math.max(arr[L] + gmap[L + 1][R], arr[R] + gmap[L][R - 1]);				gmap[L][R] = Math.min(fmap[L + 1][R], fmap[L][R - 1]);				L++;				R++;			&#125;		&#125;		return Math.max(fmap[0][N - 1], gmap[0][N-1]);    &#125;&#125;
3 排序
-快速排序-
1.0 partition

partition 以arr[R] 为界分为 &lt;=arr[R]   arr[R]    &gt;arr[R] 三个部分
每次可以找到一个位置的数

public static int partition(int[] arr, int L, int R) &#123;    if (L &gt; R) &#123;        return -1;    &#125;    if (L == R) &#123;        return L;    &#125;    int lessEqual = L - 1;    int index = L;    while (index &lt; R) &#123;        if (arr[index] &lt;= arr[R]) &#123;            swap(arr, index, ++lessEqual);        &#125;        index++;    &#125;    swap(arr, ++lessEqual, R);    return lessEqual;&#125;public static void quickSort1(int[] arr) &#123;    if (arr == null || arr.length &lt; 2) &#123;        return;    &#125;    process1(arr, 0, arr.length - 1);&#125;public static void process1(int[] arr, int L, int R) &#123;    if (L &gt;= R) &#123;        return;    &#125;    // L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]    int M = partition(arr, L, R);    process1(arr, L, M - 1);    process1(arr, M + 1, R);&#125;
2.0 荷兰国旗

在[l, r]上以arr[R]为界 将数组分为&lt; = &gt; 三个部分
每次可以找到中间等等于那部分的数

public static int[] netherlandsFlag(int[] arr, int L, int R) &#123;  if(L &gt; R) &#123;return new int[]&#123;-1, -1&#125;;&#125;  if(L == R) &#123;return new int[]&#123;L, R&#125;;&#125;  int less = L - 1;  int index = L;  int more = R; 	while(index &lt; more) &#123; // !!! index &lt; more    if(arr[index] == arr[R]) &#123;// 1 == 情况 index++      index++;    &#125; else if(arr[index] &lt; arr[R]) &#123; // 2 &lt; 情况 交换index和less的右边 然后index++      swap(arr, index, ++less);      index++;    &#125; else&#123; // 3 &gt; 情况 交换index和more左边  不用index++！      swap(arr, index, --more);    &#125;  &#125;  swap(arr, R, more);  return new int[]&#123;	less+1, more&#125;; // ！！！&#125;
随机快排

在荷兰国旗基础上 将数组的arr[R]进行随机交换 然后递归将数组所有部分都排完
最终期望求出来的复杂度就是O(logN*N)

public static void quickSort(int[] arr) &#123;  if(arr == null || arr.length == 0) &#123;    return;  &#125;  process(arr, 0, arr.length - 1);&#125;public static void proces(int[] arr, int L, int R) &#123;  if(L &gt; R) &#123;return;&#125;  // 随机交换  int random = L + Math.random() * (R - L + 1);  swap(arr, R, random);  int[] area = netherlandsFlag(arr, L, R);  process(arr, L, area[0] - 1);  process(arr, area[1] + 1, R);&#125;
递归版本

迭代，自己压栈，把任务做了然后再放出来
最开始做一次递归里做的 然后在迭代过程中再做递归里做的

// 定义任务public static class Op&#123;  public int L;  public int R;  public Op(int left, int right) &#123;    L = left;    R = right;  &#125;&#125;// 压栈：开始是从[0,N - 1]public static void quickSort2(int[] arr) &#123;  if(...) &#123;return;&#125;  int N = arr.length;  // 随机交换 分界  int random = (int)(Math.random() * N);  swap(arr, N - 1, random);  int[] area = netherlandsFlag(arr, 0, N - 1);    Stack&lt;Op&gt; stack = new Stack&lt;&gt;();  stack.push(new Op(0, area[0]-1));  stack.push(new Op(area[1]+1, N - 1));    while(!stack.isEmpty()) &#123;    Op op = stack.pop();    if(op.L &lt; op.R) &#123;      // 随机交换和分界      random = op.L + (int)(Math.random() * (op.R - op.L + 1));      swap(arr, op.R, random);      area = netherlandsFlag(arr, op.L, op.R);            stack.push(new Op(op.L, area[0]-1));  		stack.push(new Op(area[1]+1, op.R));          &#125;  &#125;    &#125;
&lt;随机快排的时间复杂度分析&gt;
1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差
2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N
4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！
时间复杂度O(N logN)，额外空间复杂度O(logN)都是这么来的。*
!!! ==找到数组中的第k个最大元素==
⚠️是k大还是k小
改写快速排序
时间复杂度O(N)
1 原先数组不能改变 复制一个新数组
2 随机选一个数来分区
3 分区: 返回两个边界 partition
4 如果分区中间=部分包含k 就找到了
没有就根据k与边界大小比较大小去其中一部分去找
public int findKthLargest(int[] array, int k) &#123;       // 1 原来的数组不好更改       int[] arr = copyArray(array);       return process2(arr, 0, arr.length - 1, arr.length - k);// k 小的话就 k - 1   &#125;      // 2 partition分区返回两个边界 分区中间等于部分包含k 就是找到了   public static int process2(int[] arr, int L, int R, int index) &#123;       if(L == R) &#123;           return arr[L];       &#125;       int random = L + (int)(Math.random() * (R - L + 1));       int[] area = partition(arr, L, R, arr[random]);            	       if(index &gt;= area[0] &amp;&amp; index &lt;= area[1]) &#123;           return arr[index];       &#125; else if(index &lt; area[0]) &#123;// 没有找到就到另外两个部分继续找           return process2(arr, L, area[0] - 1, index);       &#125; else &#123;           return process2(arr, area[1] + 1, R, index);       &#125;   &#125;
注意这里的partition

因为是使用num来分区 所以边界注意⚠️对比快排用arr[R]来分区

public static int[] partition(int[] arr, int L , int R, int num) &#123;    int less = L - 1;    int more = R + 1; //！！    int index = L;    while(index &lt; more) &#123;        if(arr[index] &lt; num) &#123;            swap(arr, index, ++less);            index++;        &#125;else if(arr[index] &gt; num) &#123;            swap(arr, index, --more);        &#125;else&#123;            index++;        &#125;    &#125;  // 快排还需要交换more和R    return new int[]&#123;less + 1, more - 1&#125;; //！！！ 返回的右边界是more - 1 快排是more&#125;
BFPRT(面试聊)
俗称&quot;中位数之中位数算法&quot;。依靠一种精心设计的 pivot 选取方法，该算法从理论上保证了最坏情形下的线性时间复杂度，打败了平均线性、最坏 O(n^2) 复杂度的传统算法

bfprt算法


改进部分就是将快排中随机选数的过程改为五个一组 分组组中排好序


找出每一段的中位数 组成m[]


找到m的中位数返回


medianOfMedian():
// 1 arr[L…R] 五个数一组
// 2 每个小组内部排序，找到中位数领出来，组成m
// 3 m[]中，找到中位数 反调bfprt



public static int process(int[] arr, int L, int R, int index)&#123;    if(L == R)&#123;        return arr[L];    &#125;    // 改进部分：随机部分改成一个方法    int r = medianOfMedian(arr, L ,R);      int[] range = partition(arr, L, R, r);    if(index &gt;= range[0] &amp;&amp; index &lt;= range[1])&#123;        return arr[index];    &#125; else if (index &lt; range[0])&#123;        return process(arr, L , range[0] - 1, index);    &#125; else &#123;        return process(arr, range[1] + 1, R, index);    &#125;&#125;// 1 arr[L...R] 五个数一组 // 2 每个小组内部排序，找到中位数领出来，组成m // 3 m[]中，找到中位数 反调bfprtprivate static int medianOfMedian(int[] arr, int L, int R) &#123;    int size = R - L + 1;    // 1    int offset = size % 5 == 0 ? 0 : 1;    int[] m = new int[size/5 + offset];    // 2    for(int i = 0; i &lt; m.length - 1; i++)&#123;        int first = L + i * 5;        m[i] = sortAndMedian(arr, first, Math.min(R, first + 4));    &#125;    // 3    return process(m, 0, m.length - 1, m.length / 2);&#125;public static int sortAndMedian(int[] arr, int L, int R) &#123;    // SORT    for (int i = L + 1; i &lt;= R; i++) &#123;        for (int j = i - 1; j &gt;= L &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;            swap(arr, j, j + 1);        &#125;    &#125;    // MEDIAN    return arr[(L + R) / 2];&#125;
-堆排序-
/**     * 1 从下至上让整个数组变为大根堆 并将堆顶(max)与结尾交换 再去重新调整     * 2 遍历调整 直到heapSize = 0     * @param arr     */public static void heapSort(int[] arr) &#123;        if (arr.length &lt; 2 || arr == null) &#123;            return;        &#125;        int heapSize = arr.length;        // 1        for (int i = arr.length - 1; i &gt;= 0; i--) &#123;            heapify(arr, i, arr.length);        &#125;        swap(arr, 0, --heapSize);        // 2        while(heapSize &gt; 0)&#123;            heapify(arr, 0, heapSize);            swap(arr, 0, --heapSize);        &#125;    &#125;    // 从下到上将整个数组变为大根堆结构    private static void heapify(int[] arr, int i, int heapSize) &#123;        //先找到左孩子 如果有孩子 将最大的找到并与根比较 谁大放在上面        int left = 2 * i + 1;        while(left &lt; heapSize)&#123;            int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;            largest = arr[largest] &gt; arr[i] ? largest : i;            if(largest == i)&#123;                break;            &#125;            swap(arr, largest, i);            i = largest;            left = 432 * i + 1;        &#125;    &#125;    private static void swap(int[] arr, int largest, int i) &#123;        // TODO Auto-generated method stub        int temp = arr[i];        arr[i] = arr[largest];        arr[largest] = temp;    &#125;
-归并排序-

1）整体是递归，左边排好序+右边排好序+merge让整体有序
2）让其整体有序的过程里用了排外序方法
3）利用master公式来求解时间复杂度
4）当然可以用非递归实现

递归版本
// 递归方法实现public static void mergeSort1(int[] arr) &#123;    if (arr == null || arr.length &lt; 2) &#123;        return;    &#125;    process(arr, 0, arr.length - 1);&#125;// arr[L...R]范围上，变成有序的// L...R    N    T(N) = 2*T(N/2) + O(N)  -&gt;public static void process(int[] arr, int L, int R) &#123;    if (L == R) &#123; // base case        return;    &#125;    int mid = L + ((R - L) &gt;&gt; 1);    process(arr, L, mid);    process(arr, mid + 1, R);    merge(arr, L, mid, R);&#125;public static void merge(int[] arr, int L, int M, int R) &#123;    int[] help = new int[R - L + 1];    int i = 0;    int p1 = L;    int p2 = M + 1;    while (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];    &#125;    // 要么p1越界了，要么p2越界了    while (p1 &lt;= M) &#123;        help[i++] = arr[p1++];    &#125;    while (p2 &lt;= R) &#123;        help[i++] = arr[p2++];    &#125;    for (i = 0; i &lt; help.length; i++) &#123;        arr[L + i] = help[i];    &#125;&#125;
非递归版本
流程就在于折腾  步长 这个概念
步长 = 1 开始, 步长的变化一定是2的某次方
最后一组: 凑不齐左组就不管了, 右组有多少算多少
步长一旦超过总长度, 说明搞完了, 停止就行了
public static void mergeSort3(int[] arr) &#123;    if (arr == null || arr.length &lt; 2) &#123;        return;    &#125;    int N = arr.length;    int step = 1;    while (step &lt; N) &#123;        int L = 0;        while (L &lt; N) &#123;            int M = 0;            if ( N - L &gt;= step) &#123;                M = L + step - 1;            &#125; else &#123;                M = N - 1;            &#125;            if (M == N -1) break;            int R = 0;            if (N -1 - M &gt;= step) &#123;                R = M + step;            &#125; else &#123;                R = N - 1;            &#125;            merge(arr, L, M, R);            if (R == N - 1) &#123;                break;            &#125; else &#123;                L = R + 1;            &#125;        &#125;        if (step &gt; N / 2) &#123;            break;        &#125;        step &lt;&lt;= 1;    &#125;&#125;
注意最后一组左组: L + step - 1 可能越界
从右往左合并就不用考虑越界问题了
if (step &gt; N / 2) &#123;    break;&#125;
此处不用等号的原因:
如果17个数, 最后一个调整是步长为16的时候的调整:
前16个数做左组, 后一个数做右组
而 N/2 是向下取整的, 17/2 =8 , 所以 mergeSize &gt;= N / 2,
在等于的时候就停止的话, 最后一个步长是8, 不会有最后一个步长为16的时候, 导致你出错了
优化后的最终版本
// 非递归方法实现public static void mergeSort2(int[] arr) &#123;    if (arr == null || arr.length &lt; 2) &#123;        return;    &#125;    int N = arr.length;    int mergeSize = 1;// 当前有序的，左组长度    // 一组是2倍的mergeSize    while (mergeSize &lt; N) &#123; // log N        int L = 0;        // 0....         while (L &lt; N) &#123;            // L...M  左组（mergeSize）            int M = L + mergeSize - 1;            if (M &gt;= N) &#123; // 当前组凑不齐,只有左边, 肯定有序                break;    // 预防越界风险            &#125;            //  L...M   M+1...R(mergeSize)            // 有可能最后一组右组数目不够            int R = Math.min(M + mergeSize, N - 1);            merge(arr, L, M, R);            L = R + 1; // 下一次左组        &#125;        // 防止溢出, INT_MAX        if (mergeSize &gt; N / 2) &#123;            break;        &#125;        mergeSize &lt;&lt;= 1;    &#125;&#125;
复杂度
一共执行次数  log2Nlog_2Nlog2​N, merge 一次的复杂度 O(N)
总的复杂度: O(N∗logN)O(N*logN)O(N∗logN)
-前缀树-
1）单个字符串中，字符从前到后的加到一棵多叉树上
2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）
3）所有样本都这样添加，如果没有路就新建，如有路就复用
4）沿途节点的pass值增加1，每个字符串结束时来-到的节点end值增加1
可以完成前缀相关的查询
例子
设计一种结构。用户可以：
1）void insert(String str)            添加某个字符串，可以重复添加，每次算1个2）int search(String str)             查询某个字符串在结构中还有几个3) void delete(String str)           删掉某个字符串，可以重复删除，每次算1个4）int prefixNumber(String str)       查询有多少个字符串，是以str做前缀的
前缀树的实现方式
public static class Node &#123;        public int pass;// 经过几次        public int end;// 作为end几次        public Node[] nexts; // 后面的数组        public Node()&#123;            pass = 0;            end = 0;            nexts = new Node[26];// 一条最长就26 所以这个方式不适合很多类型的节点        &#125;    &#125;    public static class Trie1&#123;        private Node root;// 头节点        // 构造方法        public Trie1()&#123;            root = new Node();        &#125;        /*         * insert()         */        // 1 先抓住头节点  pass ++         // 2 从左向右遍历字符，next[path]== null则新建节点 pass++        // 3 最后end++        public void insert(String word)&#123;            if(word == null)&#123;                return;            &#125;            char[] str = word.toCharArray();            Node node = root;            node.pass++;            int path = 0;            for(int i = 0; i &lt; str.length; i++)&#123;                path = str[i] - &#x27;a&#x27;;                if(node.nexts[path] == null)&#123;                    node.nexts[path] = new Node();                &#125;                node = node.nexts[path];                node.pass++;            &#125;            node.end++;        &#125;        /*         * search():查找word出现了几次         */        public int search(String word)&#123;            if(word ==  null)&#123;                return 0;            &#125;            char[] str = word.toCharArray();            Node node = root;            int path = 0;            for(int i = 0; i &lt; str.length; i++)&#123;                path = str[i] - &#x27;a&#x27;;                if(node.nexts[path] == null)&#123;                    return 0;                &#125;                node = node.nexts[path];            &#125;            return node.end;        &#125;        /*         * delete() 内存泄漏问题jvm可以解决的         */        // 1 先search是否存在        // 2 遍历经过要把pass-- 且当pass==0时将next[path]置空，后面的节点JVM自动会清除        // 3 end --        public void delete(String word)&#123;            if(this.search(word) != 0)&#123;                char[] str = word.toCharArray();                Node node = root;                node.pass--;                int path = 0;                for(int i = 0; i &lt; str.length; i++)&#123;                    path = str[i] - &#x27;a&#x27;;                    if(--node.nexts[path].pass == 0)&#123;                        node.nexts[path] = null;                        return;                    &#125;                    node = node.nexts[path];                &#125;                node.end--;            &#125;        &#125;        /*         * prefixNode:有几个是以pre作为前缀的字符         *          */        //和search步骤差不多 最后return的是pass        public int prefixNode(String pre)&#123;            Node node = root;            int path = 0;            char[] str = pre.toCharArray();            for(int i = 0; i &lt; str.length;i++)&#123;                path = str[i] - &#x27;a&#x27;;                if(node.nexts[path] == null)&#123;                    return 0;                &#125;                node = node.nexts[path];            &#125;            return node.pass;        &#125;    &#125;
-（桶排序）不基于比较的-
桶排序思想下的排序：计数排序 &amp; 基数排序
1)桶排序思想下的排序都是不基于比较的排序
2)时间复杂度为O(N)，额外空间负载度O(M)
3)应用范围有限，需要样本的数据状况满足桶的划分
计数排序和基数排序
题目3: 计数排序
计数排序要求，样本是整数，且范围比较窄
// only for 0~200 valuepublic static void countSort(int[] arr) &#123;    if (arr == null || arr.length &lt; 2) &#123;        return;    &#125;    int max = Integer.MIN_VALUE;    for (int i = 0; i &lt; arr.length; i++) &#123;        max = Math.max(max, arr[i]);    &#125;    int[] bucket = new int[max + 1];    for (int i = 0; i &lt; arr.length; i++) &#123;        bucket[arr[i]]++;    &#125;    int i = 0;    for (int j = 0; j &lt; bucket.length; j++) &#123;        while (bucket[j]-- &gt; 0) &#123;            arr[i++] = j;        &#125;    &#125;&#125;
题目4: 基数排序代码
一般来讲，基数排序要求，样本是10进制的正整数
// only for no-negative valuepublic static void radixSort(int[] arr) &#123;    if (arr == null || arr.length &lt; 2) &#123;        return;    &#125;    radixSort(arr, 0, arr.length - 1, maxbits(arr));&#125;public static int maxbits(int[] arr) &#123;    int max = Integer.MIN_VALUE;    for (int i = 0; i &lt; arr.length; i++) &#123;        max = Math.max(max, arr[i]);    &#125;    int res = 0;    while (max != 0) &#123;        res++;        max /= 10;    &#125;    return res;&#125;// arr[l..r]排序  ,  digit// l..r    3 56 17 100    3public static void radixSort(int[] arr, int L, int R, int digit) &#123;    final int radix = 10;    int i = 0, j = 0;    // 有多少个数准备多少个辅助空间    int[] help = new int[R - L + 1];    for (int d = 1; d &lt;= digit; d++) &#123; // 有多少位就进出几次        // 10个空间        // count[0] 当前位(d位)是0的数字有多少个        // count[1] 当前位(d位)是(0和1)的数字有多少个        // count[2] 当前位(d位)是(0、1和2)的数字有多少个        // count[i] 当前位(d位)是(0~i)的数字有多少个        int[] count = new int[radix]; // count[0..9]        for (i = L; i &lt;= R; i++) &#123;            // 103  1   3            // 209  1   9            j = getDigit(arr[i], d);            count[j]++;        &#125;        for (i = 1; i &lt; radix; i++) &#123;            count[i] = count[i] + count[i - 1];        &#125;        for (i = R; i &gt;= L; i--) &#123;            j = getDigit(arr[i], d);            help[count[j] - 1] = arr[i];            count[j]--;        &#125;        for (i = L, j = 0; i &lt;= R; i++, j++) &#123;            arr[i] = help[j];        &#125;    &#125;&#125;public static int getDigit(int x, int d) &#123;    return ((x / ((int) Math.pow(10, d - 1))) % 10);&#125;
1）一般来讲，计数排序要求，样本是整数，且范围比较窄
2）一般来讲，基数排序要求，样本是10进制的正整数
一旦要求稍有升级，改写代价增加是显而易见的
排序算法的稳定性
稳定性是指同样大小的样本再排序之后不会改变相对次序
对基础类型来说，稳定性毫无意义
对非基础类型来说，稳定性有重要意义
有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的
排序算法总结




时间复杂度
额外空间复杂度
稳定性




选择排序
O(N^2)
O(1)
无


冒泡排序
O(N^2)
O(1)
有


插入排序
O(N^2)
O(1)
有


归并排序
O(N* logN)
O(N)
有


随机快排
O(N* logN)
O(logN)
无


堆排序
O(N* logN)
O(1)
无








计数排序
O(N)
O(M)
有


基数排序
O(N)
O(N)
有



1）不基于比较的排序，对样本数据有严格要求，不易改写
2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3）基于比较的排序，时间复杂度的极限是O(N∗logN)
4）时间复杂度O(N∗logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存 在的。
5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并
4 滑动窗口
滑动窗口更新结构
1 无重复数组的最长子串

给定一个字符串 找出里面没有重复的最长子串

// 1 使用窗口 因为不重复 可以用hashset来存储 结果集是char[] str// 2 遍历数组 L 向右// 2.1 R向右遍历:更新表// 2.2 更新max、更新set:删除头public static int lengthOfLongestSubstring(String s) &#123;	if(s.length() == 0 || s ==  &quot;&quot;)&#123;		return 0;	&#125;	// 1	HashSet&lt;Character&gt; set = new HashSet&lt;Character&gt;();	char[] str = s.toCharArray();	int ans = 0;	int L = 0;	int R = 0;	// 2	while(L &lt; str.length)&#123;		// 2.1		while(R &lt; str.length &amp;&amp; !set.contains(str[R]))&#123; // !!! 注意是不包含			set.add(str[R]);			R++;		&#125;				// 2.2		ans = Math.max(ans, R - L );		set.remove(str[L]);		L++;	&#125;	return ans;			&#125;
动态规划版
使用256数组进行存储 先都初始化为-1 下标是字符串值
public static int lengthOfLongestSubstring2(String s) &#123;	if (s.length() == 0 || s == &quot;&quot;) &#123;		return 0;	&#125;		char[] str = s.toCharArray();	int[] map = new int[256];	for (int i = 0; i &lt; 256; i++) &#123;		map[i] = -1;	&#125;	map[str[0]] = 0;	int N = str.length;	int ans = 1;	int pre = 1;	for (int i = 1; i &lt; N; i++) &#123;		pre = Math.min(i - map[str[i]], pre + 1);		ans = Math.max(ans, pre);		map[str[i]] = i;	&#125;	return ans;&#125;
2 最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。

  // 1 使用map[256]来记录 t中需要的每种字符的数量;	//all来记录所有字符剩下没找到的数量；start记录最小子串开头下标	// 2 遍历字符集  L = 0 遍历 R 向右 	// 2.1 右边界扩大 同时map相应-- 并且没有减到0的话all--	// 2.2 当all还完之后 要将左边界缩小 	// 2.2.1 map对应的str[L] 左边界有可能有重复值 对应map小于0 要缩到不能缩的地方	// 2.2.2 更新minLen 和开头start 	// 2.2.3 左边界L++、map对应++、 all++	public static String minLength2(String s1, String s2) &#123;		if (s1 == null || s2 == null || s1.length() &lt; s2.length()) &#123;			return &quot;&quot;;		&#125;		char[] str1 = s1.toCharArray();		char[] str2 = s2.toCharArray();		// 1		int[] map = new int[256]; // map[37] = 4  37  4次		for (int i = 0; i != str2.length; i++) &#123;			map[str2[i]]++;		&#125;		int all = str2.length;				int L = 0;		int R = 0;// [L,R)  -&gt; [0,0)		int minLen = Integer.MAX_VALUE;		int start = 0;// 记录最小子串开头下标 		// 2		while (R != str1.length) &#123;			// 2.1			map[str1[R]]--;			if (map[str1[R]] &gt;= 0) &#123;				all--;			&#125;			// 2.2			if (all == 0) &#123; // 还完了 就是一个解				// 2.2.1				while (map[str1[L]] &lt; 0) &#123;// ！！！左边界有可能有重复值 对应的map就是小于0的 我们要避免 所以缩到没有重复的地方才开始记录minlen					map[str1[L]]++;         	L++;				&#125;				// 2.2.2				if(minLen &gt; R - L + 1)&#123; 					minLen = R - L + 1;					start = L;				&#125;				// 2.2.3				all++;				map[str1[L++]]++;			&#125;			R++;		&#125;		return minLen == Integer.MAX_VALUE ? &quot;&quot; : s1.substring(start, start + minLen);	&#125;
就是all还完之前r++往右展开 all==0 就要l++ 往左边缩

3 滑动窗口的最大值

假设一个固定大小为W的窗口;依次划过arr 返回每一次滑出状况的最大值

定义一个队列来作为窗口，里面放的是下标
循环遍历数组： L R边界
\1) 当窗口不为空&amp;窗口结尾小于当前R 结尾弹出（window是单调递减）
\2) 添加arr[R]
\3) 当队首元素已经不再滑动窗口内，将其从队首移除
\4) 当窗口右边界right+1大于等于窗口大小k时窗口形成。此时，队首元素就是该窗口内的最大值。
if( arr == null || w &lt; 1 || arr.length == 0 )&#123;        return null;    &#125;    // 1    LinkedList&lt;Integer&gt; window = new LinkedList&lt;&gt;();    int[] res = new int[arr.length - w + 1];    // 2    for(int R = 0; R &lt; arr.length; R++)&#123;        // 1)        while(!window.isEmpty() &amp;&amp; arr[window.peekLast()] &lt; arr[R])&#123;            window.pollLast();        &#125;        // 2)        window.addLast(R);        int L = R - w + 1;        // 3)        if(window.peekFirst() &lt; L)&#123;            window.pollFirst();        &#125;        // 4)        if(R &gt;= w - 1)&#123;            res[L] = arr[window.peekFirst()];        &#125;    &#125;    return res;
4 满足绝对值差达标的子数组数量

给定一个整型数组arr, 和一个整数num 某一个arr中的子数组sub 如果想达标必须满足 sub中最大值 - sub中国最小值 &lt;= num 返回arr中达标子数组的数量

public class SW_AllLessNumSubArray &#123;	// 1 需要两个双端队列来存储max和min	// 2 遍历数组每一个数都做一次L开头	// 2.1 往右R直到当前窗口内子数组不达标	// 2.1.1 滑动窗口比较弹出末尾添加当前值	// 2.1.2 不达标要break	// 2.2 到达了不达标的位置 就可以结束当前L开头的收集 并弹出开头	// 2.2.1 更新res:对收集达标的数组个数 进行累加	// 2.2.2 更新窗口:弹出L开头	public static int allLessNumSubArray(int[] arr, int num) &#123;		if (arr.length == 0 || arr == null) &#123;			return 0;		&#125;		// 1 		LinkedList&lt;Integer&gt; qmin = new LinkedList&lt;&gt;();		LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;();		int L = 0;		int R = 0;		int res = 0;		// 2 		while (L &lt; arr.length) &#123;			// 2.1			while (R &lt; arr.length) &#123;				// 2.1.1				while (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) &#123;					qmax.pollLast();				&#125;				qmax.addLast(R);				while (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) &#123;					qmin.pollLast();				&#125;				qmin.addLast(R);				// 2.1.2				if (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; num) &#123;					break;				&#125;				R++;			&#125;			// 2.2			// 2.2.1			res += R - L;			// 2.2.2			if (qmax.peekFirst() == L) &#123;				qmax.pollFirst();			&#125;			if (qmin.peekFirst() == L) &#123;				qmin.pollFirst();			&#125;			L++;		&#125;		return res;	&#125;&#125;
5 二叉树
public class TreeNode&#123;  private int val;  private TreeNode left;  private TreeNode right;  public TreeNode(int val, int left, int right) &#123;    this.val = val;    this.left = left;    this.right = right;  &#125;&#125;
1 二叉树先、中、后序遍历(DFS)
递归
public void process(TreeNode head)&#123;  // 前  process(head.left);  // 中  process(head.right);  // 后&#125;
非递归(压栈)

先： 先压右再压左 输出—》头左右

public void front(TreeNode head) &#123;  if(head == null) &#123;    return;  &#125;  Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();  stack.push(head);  while(!stack.isEmpty()) &#123;    TreeNode cur = stack.pop();    // 打印     sysout();    if(cur.right != null) &#123; // !!! 判空      stack.push(cur.right);    &#125;    if(cur.left != null) &#123; // !!! 判空      stack.push(cur.left);    &#125;  &#125;  return;&#125;

后：用两个栈 1）先压左再压右 同时答应弹出改为压入另一个栈 输出—》 头右左 2）最后输出的时候就是左右头  头左右

public void process(TreeNode head) &#123;  if(head == null) &#123;return;&#125;  Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();  Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;();  while(!stack.isEmpty()) &#123;    TreeNode cur = stack.pop();    // 前序打印行为改成压栈    stack2.push(cur.val);    if(cur.left != null) &#123; // 左      stack.push(cur.left);    &#125;    if(cur.right != null) &#123;// 右      stack.push(cur.right);    &#125;  &#125;  // 栈2 弹出打印  while(!stack2.isEmpty()) &#123;    TreeNode cur = stack.pop();    // 打印    sysout();  &#125;  return;&#125;


中： 1）先将左边界压入栈 2）直到null，弹出并打印进入右树



public void process(TreeNode head) &#123;  if(head != null) &#123;    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();// ⚠️一开始不用塞head    while(!stack.isEmpty() || head != null) &#123;      if(head != null) &#123;        stack.push(head);        head = head.left;      &#125; else&#123; // 空了 就弹出打印 进入右边        head = stack.pop();        sysout(head.val);        head = head.right;      &#125;    &#125;  &#125;  return;&#125;
二叉搜索树也可以用这个
2 二叉树的层序遍历(BFS）
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）
 
1) 打印每一层

给你二叉树的根节点root， 返回其节点值的层序遍历，就是逐层打印

1.先定义结果集res 和判空操作
2.定义队列容器，head放入队列中。
3.定义结果集元素list 即每一层。
public static List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode head) &#123;		// 1		List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();		if (head == null) &#123;			return res;		&#125;		// 2		Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();		q.add(head);		// 3		while (!q.isEmpty()) &#123;			int size = q.size();			List&lt;Integer&gt; list = new ArrayList&lt;&gt;();			for (int i = 0; i &lt; size; i++) &#123; // size !!!				TreeNode cur = q.poll();				list.add(cur.val);				if (cur.left != null) &#123;					q.add(cur.left);				&#125;				if (cur.right != null) &#123;					q.add(cur.right);				&#125;			&#125;			res.add(list);		&#125;		return res;	&#125;
二叉树的锯齿形遍历

就是在层序遍历基础上 使用flag来判断打印的顺序 ⚠️list.add(0, root.val) 就是添加到开头

public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;     List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();     if(root == null)&#123;         return res;     &#125;     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();     queue.add(root);     boolean flag = true;     while(! queue.isEmpty())&#123;         List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();         int size = queue.size();         for(int i = 0; i &lt; size; ++i)&#123;             root =  queue.poll();             if(flag)&#123;//通过flag判断打印顺序                 list.add(root.val);             &#125;else&#123;                 list.add(0, root.val);// ！！！             &#125;             if(root.left != null)&#123;                 queue.add(root.left);             &#125;             if(root.right != null)&#123;                 queue.add(root.right);             &#125;         &#125;         flag = !flag;//这里易错         res.add(list);     &#125;     return res; &#125;
2）返回节点最多的那一层

需要curEnd记录是否当前到层的结尾 需要nextEnd记录下一层的最后节点
将上面层序遍历添加每层元素的过程改为记录层的curSize
当cur == curEnd 时 更新 ans (maxWidth

public static int maxWidth(TreeNode head) &#123;  int ans = 0;  if(head == null) &#123;    return ans;  &#125; int curSize = 0;  &#125;
3）二叉树的右视图

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。


需要curEnd记录是否当前到层的结尾 需要nextEnd记录下一层的最后节点
List&lt;Integer&gt; res = new ArrayList&lt;&gt;();		if (head == null) &#123;			return res;		&#125;		// 1		TreeNode curEnd = head;		TreeNode nextEnd = null;		Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();		q.add(head);		while (!q.isEmpty()) &#123;			TreeNode cur = q.poll();			// 2 用nextEnd记录最后一个节点			if (cur.left != null) &#123;				q.add(cur.left);				nextEnd = cur.left;			&#125;			if (cur.right != null) &#123;				q.add(cur.right);				nextEnd = cur.right;			&#125;			// 3 更新当前最后的节点			if (cur == curEnd) &#123;				res.add(cur.val);				curEnd = nextEnd;			&#125;		&#125;		return res;
4）最大宽度（左右节点的距离）

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。
每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。
避免不了要记录每一个节点的index 所以需要一个新的节点结构newnode&#123;​	treenode node;​	int level;​	int pos;&#125;



在层序遍历基础上 队列添加的是一个新的节点结构来对每个节点的层数和position进行记录 不需要


每次队列进行一次poll循环都要检查 如果curlever != cur.level 说明到了下一层，将curlevel更新，用first抓住第一个的pos


更新max


public int widthOfBinaryTree(TreeNode root) &#123;        Queue&lt;NewNode&gt; q = new LinkedList&lt;&gt;();        q.add(new NewNode(root, 0, 0)); // ⚠️一开始添加的就是newnode        int ans = 0;         int curlevel = 0; // 记录当前层        int firstpos = 0; // 记录每层最前                while(!q.isEmpty())&#123;            NewNode cur = q.poll();            if(cur.node.left != null)&#123;                q.add(new NewNode(cur.node.left, cur.level + 1, cur.pos * 2)); // ⚠️结构不能搞错 参数不要穿错            &#125;            if(cur.node.right != null)&#123;                q.add(new NewNode(cur.node.right, cur.level + 1 , cur.pos * 2 + 1)); // ⚠️            &#125;                        if(curlevel != cur.level)&#123;                curlevel = cur.level;                firstpos = cur.pos;            &#125;            ans = Math.max(ans, cur.pos - firstpos + 1);                    &#125;        return ans;    &#125;    public class NewNode&#123;        private TreeNode node;        private int level;        private int pos;        public NewNode(TreeNode node, int level, int pos)&#123;            this.node = node;            this.level = level;            this.pos = pos;        &#125;    &#125;
3 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

Info&#123;boolean findP, boolean findQ, treenode ans&#125;
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;       return process(root,p,q).ans;   &#125;public static class Info&#123;	public boolean findP;// 是否包含p	public boolean findQ;// 是否包含q	public TreeNode ans;// 保存结果	public Info(boolean findP, boolean findQ, TreeNode ans)&#123;		this.findP = findP;		this.findQ = findQ;		this.ans = ans;	&#125;&#125;private Info process(TreeNode root, TreeNode p, TreeNode q) &#123;		if(root == null)&#123;		return new Info(false, false, null);	&#125;		Info leftInfo = process(root.left, p, q);	Info rightInfo = process(root.right, p, q);	   // 填充当前info	boolean findP = leftInfo.findP || rightInfo.findP || (root == p);	boolean findQ = leftInfo.findQ || rightInfo.findQ || (root == q);		TreeNode ans = null;	if(leftInfo.ans != null)&#123;// leftInfo.findP &amp;&amp; leftInfo.findQ		ans = leftInfo.ans;	&#125;else if(rightInfo.ans != null)&#123; // rightInfo.findP &amp;&amp; rightInfo.findQ		ans = rightInfo.ans;	&#125;else if(findP &amp;&amp; findQ)&#123;		ans = root;	&#125;	return new Info(findP, findQ, ans);&#125;
4 二叉树最大路径和

public int maxPathSum(TreeNode root) &#123;       if(root == null)&#123;           return 0;       &#125;       return process(root).maxSum;   &#125;   public static class Info&#123; // z	public int maxGain;//如果连上父节点的贡献值	public int maxSum ;	public Info(int m1, int m2)&#123;		maxGain = m1;		maxSum = m2;	&#125;&#125;public static Info process(TreeNode head)&#123;	if(head == null)&#123;		return new Info(0, Integer.MIN_VALUE); // ⚠️ maxsum返回minvalue	&#125;	Info leftInfo = process(head.left);	Info rightInfo = process(head.right);		int leftGain = Math.max(leftInfo.maxGain, 0); // ⚠️ &gt;0	int rightGain = Math.max(rightInfo.maxGain, 0);		int maxGain = Math.max(leftGain,rightGain) + head.val;		int maxSum = Math.max(			Math.max(leftInfo.maxSum,rightInfo.maxSum),			leftGain + rightGain + head.val);		return new Info(maxGain, maxSum);&#125;
5 对称二叉树

给你一个二叉树的根节点 root ， 检查它是否轴对称。

public boolean isSymmetric(TreeNode root) &#123;      return isMirror(root, root); // 复制一个自己的树      &#125;  public static boolean isMirror(TreeNode h1, TreeNode h2) &#123;      if(h1 == null &amp;&amp; h2 == null)&#123; //两个树都是空          return true;      &#125;      if(h1 != null &amp;&amp; h2 != null)&#123;// 两个树都不是空 就返回：1.当前节点值要相等 2.左边和右边也是mirror          return (h1.val == h2.val) &amp;&amp; isMirror(h1.left, h2.right) &amp;&amp; isMirror(h1.right, h2.left); //       &#125;      return false; //一个是空一个不是空  &#125;
6 从前序和中序序列构造二叉树

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

/**	 * 利用二叉树前序 头左右 找到头 再利用中序左右头进行左右树分离	 */    public TreeNode buildTree(int[] pre, int[] in) &#123;        if(pre == null || in == null || pre.length != in.length)&#123;            return null;        &#125;        return f(pre, 0, pre.length- 1, in, 0, in.length - 1);    &#125;    private TreeNode f(int[] pre, int L1, int R1, int[] in, int L2, int R2)&#123;        // 越界情况        if(L1 &gt; R1)&#123;            return null;        &#125;      	// 利用前序找到头        TreeNode head = new TreeNode(pre[L1]);        if(L1 == R1)&#123;            return head;        &#125;       //中序对应找到头的下标find        int find = L2;        while(in[find] != pre[L1])&#123;            find++;        &#125;				// （find - L2)就是左树的长度        head.left = f(pre, L1 + 1, L1 + (find - L2), in, L2, find - 1);        head.right = f(pre,  L1 + (find - L2) + 1, R1, in, find + 1, R2);        return head;    &#125;&#125;	
7 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

/** 用中序遍历*/public static boolean isValidBST(TreeNode head)&#123;		if(head != null)&#123;			Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();			double last = -Double.MAX_VALUE;// ⚠️			while(!stack.isEmpty() || head != null)&#123;				// 1 				if(head != null)&#123;					stack.push(head);					head = head.left;				&#125;else&#123;// 2					head = stack.pop();					if(head.val &lt;= last)&#123;						return false;					&#125;					last = head.val;					head = head.right;				&#125;			&#125;		&#125;		return true;	&#125;
8 平衡二叉树
使用递归套路
INFO &#123;	高度；	是否是平衡二叉树；&#125;
public boolean isBalanced(TreeNode root) &#123;      return process(root).isBt;  &#125;  //需要的信息  public static class Info&#123;      private int height;      private boolean isBt;      public Info(int h, boolean ib)&#123;          height = h;          isBt = ib;      &#125;  &#125;  //找信息的过程  public static Info process(TreeNode head)&#123;      if(head == null)&#123;          return new Info(0, true);      &#125;      Info leftInfo = process(head.left);      Info rightInfo = process(head.right);      //解决当前的Info的方法（也就是所有递归都会用到的方法）      int height = Math.max(leftInfo.height, rightInfo.height) + 1; // ⚠️       boolean isBalanced = false;      if(leftInfo.isBt &amp;&amp; rightInfo.isBt &amp;&amp; Math.abs(leftInfo.height - rightInfo.height) &lt;= 1)&#123;          isBalanced = true;      &#125;      return new Info(height, isBalanced);  &#125;
9 二叉树的序列化和反序列化

思路
序列化： 准备一个string的队列 然后按照先序顺序将结点转为String类型然后加入队列，左边和右边结点按照顺序递归执行该方法
反序列化： 将要转化为二叉树的队列传入，然后弹出结点为head（注意转换回为Int类型），head左边递归执行preb（prelist），右边递归执行preb（prelist）
错误
判断null值注意判断哈 特别是递归里面 就算是方法前面判断了 当时不代表递归以后不会再次出现，所以方法内还要再判断一次

/* * 二叉树的前中后序列化 */public class BT_09_preSerial &#123;		/**	 * 序列化 使用队列	 * @param head	 * @return	 */	public static Queue&lt;String&gt; preSerial(TreeNode head)&#123;		Queue&lt;String&gt; ans = new LinkedList&lt;&gt;();		pre(head, ans);		return ans;	&#125;	private static void pre(TreeNode head, Queue&lt;String&gt; ans) &#123;				if(head == null)&#123;			ans.add(null);// 用来规定用什么来占位		&#125;else&#123;			ans.add(String.valueOf(head.val));			pre(head.left, ans);			pre(head.right, ans);		&#125;	&#125;			/**	 * 反序列化	 * @param head	 * @return	 */	public static TreeNode buildByPreQueue(Queue&lt;String&gt; prelist)&#123;		if(prelist == null || prelist.size() == 0)&#123;			return null;		&#125;		return preb(prelist);	&#125;	private static TreeNode preb(Queue&lt;String&gt; prelist) &#123;		String value = prelist.poll();		if(value == null)&#123;			return null;		&#125;		TreeNode head = new TreeNode(Integer.valueOf(value));		head.left = preb(prelist);		head.right = preb(prelist);		return head;	&#125;&#125;
10 二叉树的最大深度

给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，
3
/ 
9  20
/  
15   7
返回它的最大深度 3 。

class Solution &#123;    public int maxDepth(TreeNode root) &#123;        return findDepth(root).height;    &#125;    public static class Info&#123;        public int height;        public Info(int h)&#123;            height = h;        &#125;    &#125;    public static Info findDepth(TreeNode head)&#123;        if(head == null)&#123;            return new Info(0);        &#125;        Info leftInfo = findDepth(head.left);        Info rightInfo = findDepth(head.right);        int height = Math.max(leftInfo.height, rightInfo.height) + 1;        return new Info(height);    &#125;&#125;
11 最大直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树
   1
  / \
 2   3
/ \     

4   5
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

/* * 二叉树最大直径 */public class BT_05_ZhiJing &#123;	static int ans = 1;	public int max(TreeNode head)&#123;				return process(head) - 1;	&#125;		public static int process(TreeNode head)&#123;		if(head == null)&#123;			return 0;		&#125;				int lM = process(head.left);		int rM = process(head.right);		ans = Math.max(lM + rM + 1, ans);				return Math.max(lM, rM) + 1;	&#125;		/**	 * 递归套路	 * @param root	 * @return	 */	public int max2(TreeNode root) &#123;        if(root == null)&#123;            return 0;        &#125;        return process2(root).max;    &#125;	public static class Info&#123;		public Integer height;		public Integer max;		public Info(Integer h, Integer m)&#123;			height = h;			max = m;		&#125;	&#125;	private Info process2(TreeNode root) &#123;		if(root == null)&#123;			return new Info(0, 0);		&#125;				Info leftInfo = process2(root.left);		Info rightInfo = process2(root.right);			int height = Math.max(leftInfo.height, rightInfo.height) + 1;				int max = Math.max(Math.max(leftInfo.max, rightInfo.max),				leftInfo.height + rightInfo.height);				return new Info(height, max);	&#125;&#125;
12 路径总和
/**	 * 路径总和 Ⅰ	 * @return 要求返回是否存在总和为target的从根到节点的路径	 */	public static boolean isSum;		public boolean hasPathSum(TreeNode root, int targetSum) &#123;		if (root == null) &#123;			return false;		&#125;		isSum = false;		process(root, 0, targetSum);		return isSum;	&#125;	public void process(TreeNode head, int preSum, int sum) &#123;		// 是叶子节点		if (head.left == null &amp;&amp; head.right == null) &#123;			if (preSum + head.val == sum) &#123;				isSum = true;			&#125;			return;		&#125;		// 不是叶子节点		preSum += head.val;		if (head.left != null) &#123;			process(head.left, preSum, sum);		&#125;		if (head.right != null) &#123;			process(head.right, preSum, sum);		&#125;	&#125;	/**	 * 路径总和Ⅱ	 * @return 要求返回所有满足target的路径	 */	// 1 	// 2 注意现场要恢复，因为只有一个path来存路 如果没有清空，后面根本装不下	public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;		List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();		if (root == null) &#123;			return ans;		&#125;		List&lt;Integer&gt; path = new ArrayList&lt;&gt;();		process(root, path, 0, targetSum, ans);		return ans;	&#125;	public void process(TreeNode head, List&lt;Integer&gt; path, int preSum, int sum,			List&lt;List&lt;Integer&gt;&gt; ans) &#123;		// 叶子节点		if (head.left == null &amp;&amp; head.right == null) &#123;			if (head.val + preSum == sum) &#123;				path.add(head.val);				ans.add(new ArrayList&lt;&gt;(path));// 传递是引用不能直接传path				path.remove(path.size() - 1);			&#125;		&#125;		preSum += head.val;		path.add(head.val);		// 不是叶子节点		if (head.left != null) &#123;			process(head.left, path, preSum, sum, ans);		&#125;		if (head.right != null) &#123;			process(head.right, path, preSum, sum, ans);		&#125;		// 恢复现场		path.remove(path.size() - 1);	&#125;
13 翻转二叉树

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

翻转二叉树 // 有点像数组swap    public TreeNode invertTree(TreeNode root) &#123;        if(root == null) &#123;            return null;        &#125;        TreeNode left = root.left;        root.left = invertTree(root.right);        root.right = invertTree(left);        return root;    &#125;
6 栈
1 有效括号

给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。


遍历所有左边的括号变成对应的右括号压入栈
遇到的右边的括号

如果stack是空的，则false
弹出栈顶比较不相等 false


最后stack 必须是空的才能满足

public boolean isValid(String s) &#123;	 	char[] str = s.toCharArray();        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for(int i = 0; i &lt; str.length; i++) &#123;            if(str[i] == &#x27;(&#x27; || str[i] == &#x27;[&#x27; || str[i] == &#x27;&#123;&#x27;) &#123;                stack.push(str[i]);            &#125; else&#123;                if(stack.isEmpty()) &#123;                    return false;                &#125;                 char cur = stack.pop();                if((str[i] == &#x27;)&#x27; &amp;&amp; cur != &#x27;(&#x27;) || (str[i]                 == &#x27;&#125;&#x27; &amp;&amp; cur != &#x27;&#123;&#x27;) || (str[i] == &#x27;]&#x27; &amp;&amp; cur != &#x27;[&#x27;)) &#123;                    return false;                &#125;            &#125;        &#125;        return stack.isEmpty();&#125;
2 用栈实现队列
class MyQueue &#123;		private Stack&lt;Integer&gt; sPop;    private Stack&lt;Integer&gt; sPush;    public MyQueue() &#123;        sPop = new Stack&lt;Integer&gt;();        sPush = new Stack&lt;Integer&gt;();    &#125;        public void push(int x) &#123;        sPush.push(x);    &#125;        public int pop() &#123;        if(sPop.isEmpty())&#123;            while(!sPush.isEmpty())&#123;                sPop.push(sPush.pop());            &#125;        &#125;        return sPop.pop();            &#125;        public int peek() &#123;        if(sPop.isEmpty())&#123;            while(!sPush.isEmpty())&#123;                sPop.push(sPush.pop());            &#125;        &#125;        return sPop.peek();    &#125;        public boolean empty() &#123;        if(sPop.isEmpty() &amp;&amp; sPush.isEmpty())&#123;            return true;        &#125; else&#123;            return false;        &#125;    &#125;&#125;
3 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。


public class MinStack &#123;	public Stack&lt;Integer&gt; data;	public Stack&lt;Integer&gt; min;		public MinStack() &#123;		this.data = new Stack&lt;Integer&gt;();		this.min = new Stack&lt;Integer&gt;();		    &#125;        public void push(int val) &#123;    	if(this.min.isEmpty())&#123;    		this.min.push(val);    	&#125;else if(val &lt; this.getMin())&#123;    		this.min.push(val);    	&#125;else&#123;    		this.min.push(this.getMin());    	&#125;    	this.data.push(val);    	    &#125;        public void pop() &#123;    	this.data.pop();    	this.min.pop();    &#125;        public int top() &#123;    	return this.data.peek();    &#125;        public int getMin() &#123;    	return this.min.peek();    &#125;&#125;
4 两个队列实现栈
在push操作里进行改进就可以：
通过
class MyStack &#123;           public Queue&lt;Integer&gt; q1;        public Queue&lt;Integer&gt; q2;        /** Initialize your data structure here. */        public MyStack()&#123;            q1 = new LinkedList&lt;Integer&gt;();            q2 = new LinkedList&lt;Integer&gt;();        &#125;        /** Push element x onto stack. */        public void push(int x) &#123;            q2.offer(x);            while(!q1.isEmpty())&#123;                q2.offer(q1.poll());            &#125;            Queue&lt;Integer&gt; tmp = q1;            q1 = q2;            q2 = tmp;        &#125;        /** Removes the element on top of the stack and returns that element. */        public int pop() &#123;            return q1.poll();        &#125;        /** Get the top element. */        public int top() &#123;            return q1.peek();        &#125;        /** Returns whether the stack is empty. */        public boolean empty() &#123;            return q1.isEmpty();        &#125;&#125;
用一个队列也可以
public void push(int x) &#123;       int n = queue.size();       queue.offer(x);       for (int i = 0; i &lt; n; i++) &#123;           queue.offer(queue.poll());       &#125;   &#125;
5 单调栈
为了解决给定的一个可能含有重复值的arr，i位置一定有以下信息
1）arr[i] 左边有离它最近比它小的（大）的数
2）arr[i] 右边有离它最近比它小的（大）的数
找到左边和右边离i最近比其小的下表对 res[n][2]
public class Code1_MonotonousStack &#123;	public static int[][] getNearLessNoRepeat(int[] arr)&#123;		int[][] res = new int[arr.length][2];		Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();				for(int i = 0; i &lt; arr.length; i++)&#123;			//新的数压栈 如果比栈底小 栈底弹出 并记录			while(!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i])&#123;				int popIndex = stack.pop();				int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();				res[popIndex][0] = leftLessIndex;				res[popIndex][1] = i;			&#125;			stack.push(i);		&#125;		while(!stack.isEmpty())&#123;			int popIndex = stack.pop();			int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();			res[popIndex][0] = leftLessIndex;			res[popIndex][1] = -1;					&#125;		return res;	&#125;			//数组中有重复的情况	public static int[][] getNearLess(int[] arr)&#123;		int[][] res = new int[arr.length][2];				// List&lt;Integer&gt; -&gt; 放的是位置，同样值的东西，位置压在一起		// 代表值    底  -&gt;  顶   小  -&gt; 大		Stack&lt;List&lt;Integer&gt;&gt; stack = new Stack&lt;&gt;();				for(int i = 0; i &lt; arr.length; i++)&#123;			//新的数压栈 如果比栈底小 栈底弹出 并记录			while(!stack.isEmpty() &amp;&amp; arr[stack.peek().get(0)] &gt; arr[i])&#123;				List&lt;Integer&gt; popIndex = stack.pop();				int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);				for(Integer popi : popIndex)&#123;					res[popi][0] = leftLessIndex;					res[popi][1] = i;				&#125;			&#125;			//相等的比你小的 都要把存入栈的格式改为存储了位置的list数组			if(!stack.isEmpty() &amp;&amp; arr[stack.peek().get(0)] == arr[i])&#123;				stack.peek().add(Integer.valueOf(i));							&#125;else&#123;				List&lt;Integer&gt; pushIndex = new ArrayList&lt;&gt;();				pushIndex.add(Integer.valueOf(i));				stack.push(pushIndex);			&#125;					&#125;				while(!stack.isEmpty())&#123;			List&lt;Integer&gt; popIndex = stack.pop();			//取决于最晚加入的那个			int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);			for(Integer popi : popIndex)&#123;				res[popi][0] = leftLessIndex;				res[popi][1] = -1;			&#125;		&#125;		return res;	&#125;&#125;
正数数组arr中（sub的累加和*min）的最大值

给定一个只包含正数的数组arr，arr中任何一个子数组sub，一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
那么所有子数组中，这个值最大是多少？

直接找每个数两边最近比它小中间部分累加和（这部分该数一定最小）
1 建立前缀和数组sums[i](这样求累加和就可以[0~R] -[0~L-1])
2 和上面单调栈思路差不多
​	1）栈顶弹出[j]后更新max
​	2）再遍历栈里的元素 右边没有比它最小所以累加直接用sums[N-1]来减

7 递归
1 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案


public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        List&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;();//选择的路        if(nums.length == 0 || nums == null)&#123;        	return ans;        &#125;        for (int num : nums) &#123;            path.add(num);        &#125;        process(path, 0, ans);        return ans;    &#125;		//  DFS	// 1 for是在树形结构里平行进行  - - -&gt;	// 2 先交换成为一种情况	// 3 往下|递归将剩余部分的情况搞定	//      |	//      v	// 4 恢复原来状态 因为平行的分支需要同样的状态	public static void process(List&lt;Integer&gt; path, int i, List&lt;List&lt;Integer&gt;&gt; ans)&#123;		if(i == path.size())&#123;			ans.add(new ArrayList&lt;Integer&gt;(path));		&#125;		boolean[] vis = new boolean[256];				// 1		for(int j = i; j &lt; path.size(); j++)&#123;			if(!vis[path.get(j) + 128])&#123; // 剪枝				vis[path.get(j) + 128] = true;				// 2				Collections.swap(path, i, j);				// 3				process(path, i + 1, ans);				// 4				Collections.swap(path, i, j);			&#125;					&#125;	&#125;
全排列2⃣️ 不重复
/* * 全排列 * 将给定数组进行排列组合  */public class Recursion回溯_Permutation &#123;    public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();// 不同打印结果存储        for(int num : nums)&#123;            path.add(num);        &#125;        process(path, 0, ans);        return ans;    &#125;    //  DFS    // 1 for是在树形结构里平行进行  - - -&gt;    // 2 先交换成为一种情况    // 3 往下|递归将剩余部分的情况搞定    //      |    //      v    // 4 恢复原来状态 因为平行的分支需要同样的状态    public static void process(List&lt;Integer&gt; path, int i, List&lt;List&lt;Integer&gt;&gt; ans)&#123;        if(i == path.size())&#123;            ans.add(new ArrayList&lt;Integer&gt;(path));        &#125;        boolean[] vis = new boolean[256];        // 1        for(int j = i; j &lt; path.size(); j++)&#123;            if(!vis[path.get(j)]+128)&#123; // 剪枝 数组有负数要加上128                vis[path.get(j)+128] = true;                // 2                Collections.swap(path, i, j);                // 3                process(path, i + 1, ans);                // 4                Collections.swap(path, i, j);            &#125;        &#125;    &#125;&#125;
2 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

利用一个原理是 当前面已经做了选择的左括号比右括号多的时候就添加右括号 需要剪枝 在往path里面添加括号的时候进行条件剪枝
public List&lt;String&gt; generateParenthesis(int n) &#123;        char[] path = new char[n &lt;&lt; 1];        List&lt;String&gt; ans = new ArrayList&lt;&gt;();        process(path,0, n, 0, ans); // ⚠️传进去的参数！        return ans;    &#125;// 剪枝 左边括号还有 和左边-右边》0    public static void process(char[] path, int i,int leftRest, int leftMinusRight, List&lt;String&gt; ans )&#123;        if(i == path.length)&#123; // 到结尾            ans.add(String.valueOf(path)); // 一种可能        &#125; else &#123;            if(leftRest &gt; 0)&#123; // 左边的括号还有 将当前的位置设为左， 剩下的去递归                path[i] = &#x27;(&#x27;;                process(path, i + 1, leftRest - 1, leftMinusRight + 1, ans);            &#125;            if(leftMinusRight &gt; 0)&#123;// 左边的括号大于右边的括号                path[i] = &#x27;)&#x27;;                process(path, i + 1, leftRest, leftMinusRight - 1, ans);            &#125;        &#125;    &#125;
3 复原ip地址

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。
例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

 static final int COUNT = 4;int[] segment; // segment[i]存储第i段List&lt;String&gt; ans = new ArrayList&lt;&gt;();public List&lt;String&gt; restoreIpAddresses(String s) &#123;	segment = new int[COUNT];	dfs(s, 0, 0);// s 字符串 id 段数 segstart	return ans;&#125;public void dfs(String s, int id, int segStart) &#123;	// 1 已经递归到第四段	if (id == COUNT) &#123;		if (segStart == s.length()) &#123;// 并且 所有数字都完成			StringBuffer str = new StringBuffer();			for (int i = 0; i &lt; COUNT; i++) &#123;				str.append(segment[i]);				if (i != COUNT - 1) &#123;					str.append(&#x27;.&#x27;);				&#125;			&#125;			ans.add(str.toString());		&#125;		return; // 记得向上返回！！！	&#125;	// 2 四段没玩但是已经到结尾	if (segStart == s.length()) &#123;		return;	&#125;	// 3 有0的情况	if (s.charAt(segStart) == &#x27;0&#x27;) &#123; // 有零		segment[id] = 0;		dfs(s, id + 1, segStart + 1);	&#125;	// 4 一般情况	int ans = 0;	for (int segEnd = segStart; segEnd &lt; s.length(); segEnd++) &#123;		ans = ans * 10 + (s.charAt(segEnd) - &#x27;0&#x27;);		if (ans &gt; 0 &amp;&amp; ans &lt;= 0xFF) &#123;// ans属于[0, 255]			segment[id] = ans;			dfs(s, id + 1, segEnd + 1);		&#125; else &#123;			break;		&#125;	&#125;&#125;
4 单词搜索
dfs+回溯
class Solution &#123;    public boolean exist(char[][] board, String word) &#123;        int h = board.length, w = board[0].length;        boolean[][] visited = new boolean[h][w];        for (int i = 0; i &lt; h; i++) &#123;            for (int j = 0; j &lt; w; j++) &#123;                boolean flag = check(board, visited, i, j, word, 0);                if (flag) &#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) &#123;        if (board[i][j] != s.charAt(k)) &#123;            return false;        &#125; else if (k == s.length() - 1) &#123;            return true;        &#125;        visited[i][j] = true;        int[][] directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;        boolean result = false;        for (int[] dir : directions) &#123;            int newi = i + dir[0], newj = j + dir[1];            if (newi &gt;= 0 &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].length) &#123;                if (!visited[newi][newj]) &#123;                    boolean flag = check(board, visited, newi, newj, s, k + 1);                    if (flag) &#123;                        result = true;                        break;                    &#125;                &#125;            &#125;        &#125;        visited[i][j] = false;        return result;    &#125;&#125;
5 子集

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：
输入：nums = [0]
输出：[[],[0]]

public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums)&#123;		List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();		List&lt;Integer&gt; path = new ArrayList&lt;&gt;();//用来存放之前决定		if(nums.length == 0 || nums == null)&#123;			return res;		&#125;		process2(nums, 0, res, path);		return res;			&#125;	private static void process2(int[] nums, int i, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path) &#123;		if(i == nums.length)&#123;			res.add(new ArrayList&lt;&gt;(path));			return;		&#125;		// 两种可能		process2(nums, i + 1, res, path);		List&lt;Integer&gt; path2 = new ArrayList&lt;&gt;(path);		path2.add(nums[i]);		process2(nums, i + 1, res, path2);	&#125;
8 并查集
并查集
用来解决图的连通性和环的数量
结构（hash表）
public class Code01_UnionFind &#123;	public static class Node&lt;V&gt; &#123;		V value;		public Node(V v) &#123;			value = v;		&#125;	&#125;		/**	 * 并查集 	 */	// 1 构造方法	// 2 Node&lt;V&gt; findFather(Node&lt;V&gt; cur)	// 3 boolean isSameSet(V a, V b)	// 4 void union(V a, V b)	// 5 int sets()	public static class UnionFind&lt;V&gt; &#123;		public HashMap&lt;V, Node&lt;V&gt;&gt; nodes;// 点		public HashMap&lt;Node&lt;V&gt;, Node&lt;V&gt;&gt; parents;// 最高父亲		public HashMap&lt;Node&lt;V&gt;, Integer&gt; sizeMap;// 所在集合大小				public UnionFind(List&lt;V&gt; values) &#123;      //1 初始化参数			nodes = new HashMap&lt;&gt;();			parents = new HashMap&lt;&gt;();			sizeMap = new HashMap&lt;&gt;();      //2 遍历：先new一个node 然后更新点集，更新父亲表（自己是自己爹），最后更新sizemap			for (V cur : values) &#123;				Node&lt;V&gt; node = new Node&lt;&gt;(cur);				nodes.put(cur, node);				parents.put(node, node);				sizeMap.put(node, 1);			&#125;		&#125;		    // 找爹		public Node&lt;V&gt; findFather(Node&lt;V&gt; cur) &#123;       //1 new 一个 栈			Stack&lt;Node&lt;V&gt;&gt; path = new Stack&lt;&gt;();      //2 如果当前cur不是自己爹 ：1）压栈 2）cur更新为自己爹			while (cur != parents.get(cur)) &#123;				path.push(cur);				cur = parents.get(cur);			&#125;      //3 如果栈不空 cur就是当前最爹 所以循环弹出 将cur设为他们爹			while (!path.isEmpty()) &#123;				parents.put(path.pop(), cur);			&#125;			return cur;		&#125;		    // 返回两爹是否相等		public boolean isSameSet(V a, V b) &#123;			return findFather(nodes.get(a)) == findFather(nodes.get(b));		&#125;    		// 并		public void union(V a, V b) &#123;			Node&lt;V&gt; aHead = findFather(nodes.get(a));			Node&lt;V&gt; bHead = findFather(nodes.get(b));			// 如果两爹不同			if(aHead != bHead) &#123;        // 1 抓住size大小				int aSize = sizeMap.get(aHead);				int bSize = sizeMap.get(bHead);                // 2 小的那个接在大的下面（big是small的父				Node&lt;V&gt; small = aSize &lt; bSize ? aHead : bHead;				Node&lt;V&gt; big = small == aHead ? bHead : aHead;				parents.put(small, big);                // 3 更新大集的size 并转移小集的sizemap				sizeMap.put(big, aSize + bSize);				sizeMap.remove(small);			&#125;					&#125;				public int sets() &#123;			return sizeMap.size();		&#125;	&#125;&#125;
1 岛屿数量

给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

public static int numIslands(char[][] board) &#123;		int islands = 0;		for (int i = 0; i &lt; board.length; i++) &#123;			for (int j = 0; j &lt; board[0].length; j++) &#123;				if (board[i][j] == &#x27;1&#x27;) &#123;					islands++;					infect(board, i, j);				&#125;			&#125;		&#125;		return islands;	&#125;	// 从(i,j)这个位置出发，把所有练成一片的&#x27;1&#x27;字符，变成0	// DFS	public static void infect(char[][] board, int a, int b) &#123;		if (i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length				|| board[i][j] != &#x27;1&#x27;) &#123;			return;		&#125;		board[i][j] = 0;		infect1(board, i, j - 1);		infect1(board, i, j + 1);		infect1(board, i + 1, j);		infect1(board, i - 1, j);		&#125;	&#125;	/*	 * BFS	 */	public static void infect2(char[][] board, int a, int b) &#123;		Queue&lt;int[]&gt; list = new LinkedList&lt;&gt;();		list.add(new int[] &#123; a, b &#125;);		while(!list.isEmpty()) &#123;			int[] cur = list.poll();			int i = cur[0];			int j = cur[1];			if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; board.length &amp;&amp; j &lt; board[0].length					&amp;&amp; board[i][j] == &#x27;1&#x27;) &#123;				board[i][j] = 0;				list.add(new int[] &#123; i - 1, j &#125;);				list.add(new int[] &#123; i + 1, j &#125;);				list.add(new int[] &#123; i, j - 1 &#125;);				list.add(new int[] &#123; i, j + 1 &#125;);			&#125;    &#125;	
使用并查集（面试）
为什么要并查集？ 如果有多台cpu 大岛变成小岛就会很容易
面试就讲一下怎么通过并查集来进行union ： 并查集就是可以将a, b所在的集合进行合并；需要每个岛的位置 所以需要一个index方法来返回每格子的位置就是行数乘以矩阵宽度再加上列数， 然后要进行union（） 具体过程就是先找到两个要合并的点的父亲，如果不相同就再调出两个所在集合的大小sizemap，然后将小的集合接在大的集合下面， 更新sizemap。 这里找父亲的操作可以用一个help数组倒序遍历来代替栈
/**	 * 使用并查集	 * @param board	 * @return	 */	public static int numIslands2(char[][] board) &#123;		int row = board.length;		int col = board[0].length;		UnionFind2 uf = new UnionFind2(board);		// 把第一行第一列先处理 就不需要后面考虑边界		for (int j = 1; j &lt; col; j++) &#123;			if (board[0][j - 1] == &#x27;1&#x27; &amp;&amp; board[0][j] == &#x27;1&#x27;) &#123;				uf.union(0, j - 1, 0, j);			&#125;		&#125;		for (int i = 1; i &lt; row; i++) &#123;			if (board[i - 1][0] == &#x27;1&#x27; &amp;&amp; board[i][0] == &#x27;1&#x27;) &#123;				uf.union(i - 1, 0, i, 0);			&#125;		&#125;		// 除了第一行第一列的部分		for (int i = 1; i &lt; row; i++) &#123;			for (int j = 1; j &lt; col; j++) &#123;				if (board[i][j] == &#x27;1&#x27;)  // 看上面和左边					if (board[i][j - 1] == &#x27;1&#x27;) &#123;						uf.union(i, j - 1, i, j);					&#125;					if (board[i - 1][j] == &#x27;1&#x27;) &#123;						uf.union(i - 1, j, i, j);					&#125;				&#125;			&#125;		&#125;		return uf.sets();	&#125;		public static class UnionFind2 &#123;		private int[] parent;		private int[] size;		private int[] help;		private int col;// 用来计算矩阵数r*col + c		private int sets;		public UnionFind2(char[][] board) &#123;			col = board[0].length;			sets = 0;			int row = board.length;			int len = row * col;			parent = new int[len];			size = new int[len];			help = new int[len];			for (int r = 0; r &lt; row; r++) &#123;				for (int c = 0; c &lt; col; c++) &#123;					if (board[r][c] == &#x27;1&#x27;) &#123;						int i = index(r, c);						parent[i] = i;						size[i] = 1;						sets++;					&#125;				&#125;			&#125;		&#125;		// (r,c) -&gt; i		private int index(int r, int c) &#123;			return r * col + c;		&#125;		// 原始位置 -&gt; 下标		private int find(int i) &#123;			int hi = 0;			while (i != parent[i]) &#123;				help[hi++] = i;				i = parent[i];			&#125;			for (hi--; hi &gt;= 0; hi--) &#123;				parent[help[hi]] = i;			&#125;			return i;		&#125;		public void union(int r1, int c1, int r2, int c2) &#123;			int i1 = index(r1, c1);			int i2 = index(r2, c2);			int f1 = find(i1);			int f2 = find(i2);			if (f1 != f2) &#123;				if (size[f1] &gt;= size[f2]) &#123;					size[f1] += size[f2];					parent[f2] = f1;				&#125; else &#123;					size[f2] += size[f1];					parent[f1] = f2;				&#125;				sets--;			&#125;		&#125;		public int sets() &#123;			return sets;		&#125;	&#125;
2 省份数量（朋友圈）

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

public int findCircleNum(int[][] M) &#123;        int N = M.length;        UnionFind unionFind = new UnionFind(N);        for(int i = 0; i &lt; N; i++) &#123;            for(int j = i+1; j &lt; N; j++) &#123;                if(M[i][j] == 1) &#123;                    unionFind.union(i, j);                &#125;            &#125;        &#125;        return unionFind.sets();    &#125;    // 使用数组结构的并查集    public static class UnionFind &#123;        private int[] parents;        private int[] size;        private int[] help;        private int sets;        public UnionFind(int N) &#123;            parents = new int[N];            size = new int[N];            help = new int[N];            sets = N;            for(int i = 0; i &lt; N; i++) &#123;                parents[i] = i;                size[i] = 1;            &#125;        &#125;        // 1 定义一个指针        // 2 while(i不是自己爹）&#123;        // 2.1 压help栈（虚拟的        // 2.2 i指向自己的爹    &#125;        // 3 for遍历help：模拟栈弹出 &#123;所有人爹设为i&#125;        // 4 返回i:此时i指向最爹        public int findFather(int i) &#123;            int hi = 0;            while( i != parents[i]) &#123;                help[hi++] = i;                i = parents[i];            &#125;            for(hi--; hi &gt;=0; hi--)&#123;                parents[help[hi]] = i;            &#125;            return i;        &#125;        public void union(int i, int j) &#123;            int iF = findFather(i);            int jF = findFather(j);            if(iF != jF) &#123;                if(size[iF] &lt; size[jF]) &#123;                    size[jF] += size[iF];                    parents[iF] = jF;                &#125;else &#123;                    size[iF] += size[jF];                    parents[jF] = iF;                &#125;                sets--;            &#125;        &#125;        public int sets() &#123;            return sets;        &#125;    &#125;
7 图
将矩阵转化为自己的结构(creatGraph)

new一个自己的graph
遍历矩阵每一行 for(matrix.length)

weight:matrix[i][0] from[i][1] to:[i][2]
判断是否contanskey(from和to) 分别放入点集
edge初始化 并赋值 (weight,fromNode,toNode)
更新出入度、直接点、直接边
边放入边集



1 图的bfs
public class Code01_BFS &#123;	// 从node出发，进行宽度优先遍历	public static void bfs(Node start) &#123;		if (start == null) &#123;			return;		&#125;		Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();		HashSet&lt;Node&gt; set = new HashSet&lt;&gt;();		queue.add(start);		set.add(start);		while (!queue.isEmpty()) &#123;			Node cur = queue.poll();			System.out.println(cur.value);			for (Node next : cur.nexts) &#123;				if (!set.contains(next)) &#123;					set.add(next);					queue.add(next);				&#125;			&#125;		&#125;	&#125;&#125;
2 DFS
package all.Graph;import java.util.HashSet;import java.util.Stack;public class Code02_DFS &#123;	public static void dfs(Node node) &#123;		if (node == null) &#123;			return;		&#125;		Stack&lt;Node&gt; stack = new Stack&lt;&gt;();		HashSet&lt;Node&gt; set = new HashSet&lt;&gt;();		stack.add(node);		set.add(node);		System.out.println(node.value);		while (!stack.isEmpty()) &#123;			Node cur = stack.pop();			for (Node next : cur.nexts) &#123;				if (!set.contains(next)) &#123;					stack.push(cur);					stack.push(next);					set.add(next);					System.out.println(next.value);					break;				&#125;			&#125;		&#125;	&#125;&#125;
3 拓扑排序
/** * 拓扑排序 ： 有向无环图 *  * @author chs * */public class Code03_TopologySort &#123;	// directed graph and no loop	public static List&lt;Node&gt; sortedTopology(Graph graph) &#123;		// key 某个节点   value 剩余的入度		HashMap&lt;Node, Integer&gt; inMap = new HashMap&lt;&gt;();		// 只有剩余入度为0的点，才进入这个队列		Queue&lt;Node&gt; zeroInQueue = new LinkedList&lt;&gt;();		for (Node node : graph.nodes.values()) &#123;			inMap.put(node, node.in);			if (node.in == 0) &#123;				zeroInQueue.add(node);			&#125;		&#125;		List&lt;Node&gt; result = new ArrayList&lt;&gt;();		while (!zeroInQueue.isEmpty()) &#123;			Node cur = zeroInQueue.poll();			result.add(cur);			for (Node next : cur.nexts) &#123;				inMap.put(next, inMap.get(next) - 1);				if (inMap.get(next) == 0) &#123;					zeroInQueue.add(next);				&#125;			&#125;		&#125;		return result;	&#125;&#125;
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Twikoo评论系统的Cloudflare部署方案</title>
    <url>/2025/06/17/Twikoo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%9A%84Cloudflare%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[Twikoo评论系统的Cloudflare部署方案
Twikoo是一款简洁、安全且免费的静态网站评论系统，在提升网站互动性方面表现出色。通常，Twikoo可部署在诸如腾讯云开发环境、Vercel等平台，但借助Cloudflare进行部署，能极大改善冷启动延迟问题，实现快速加载，为用户带来更流畅的评论体验，同时利用Cloudflare强大的全球网络提升访问速度。以下为详细的Cloudflare部署Twikoo评论系统的步骤与要点。
一、前期准备
在开始部署前，需提前准备好相关工具与资源：

Cloudflare账户：若尚未注册，前往Cloudflare官网完成注册流程。
Node.js环境：确保本地开发环境安装了Node.js，可通过Node.js官网下载并安装对应系统的最新版本，安装完成后，在命令行输入node -v验证是否安装成功及查看版本号。
文本编辑器：推荐使用Visual Studio Code、Sublime Text等，方便进行代码编辑与配置文件修改。

二、安装依赖包

首先，创建一个新的项目目录，用于存放Twikoo相关代码与配置文件，在命令行中进入该目录，执行以下命令安装项目依赖：

npm install

由于Cloudflare Workers的免费套餐对捆绑包大小有严格的1MiB限制，部分与Cloudflare Workers的Node.js兼容性存在问题的包即便安装了也无法使用，为控制捆绑包大小，需手动删除这些包，在命令行中依次执行：

echo &quot;&quot; &gt; node_modules/jsdom/lib/api.jsecho &quot;&quot; &gt; node_modules/tencentcloud-sdk-nodejs/tencentcloud/index.jsecho &quot;&quot; &gt; node_modules/nodemailer/lib/nodemailer.js
上述命令会清空jsdom、tencentcloud-sdk-nodejs、nodemailer这三个包中特定文件的内容，使其不占用捆绑包空间，同时规避兼容性问题。
三、登录Cloudflare账户
通过Wrangler工具登录Cloudflare账户，Wrangler是Cloudflare提供的用于管理Workers、D1数据库等资源的命令行工具，执行以下命令进行登录：
npx wrangler login
运行该命令后，系统会自动打开浏览器，跳转到Cloudflare的授权页面，按照提示完成授权操作，授权成功后，Wrangler便与你的Cloudflare账户建立连接，后续可通过它对Cloudflare资源进行操作。
四、创建Cloudflare D1数据库并设置架构

使用Wrangler创建名为twikoo的D1数据库，在命令行执行：

npx wrangler d1 create twikoo
执行此命令后，终端会输出数据库的相关信息，其中database_name和database_id这两行信息至关重要，需将其复制下来，用于后续配置。
&#123;  &quot;d1_databases&quot;: [    &#123;      &quot;binding&quot;: &quot;DB&quot;,      &quot;database_name&quot;: &quot;twikoo&quot;,      &quot;database_id&quot;: &quot;56def18d-b46a-42c8-bc99-0214e58f9a54&quot;    &#125;  ]&#125;

打开项目目录下的wrangler.toml文件（若不存在，可手动创建），将刚刚复制的database_name和database_id粘贴进去，替换原有的对应值，使项目与创建的D1数据库建立关联。
为D1数据库设置架构，Twikoo项目中包含定义数据库表结构和初始数据的schema.sql文件，执行以下命令，将该架构应用到Cloudflare D1数据库：

npx wrangler d1 execute twikoo --remote --file=./schema.sql
此命令会远程连接到之前创建的twikoo数据库，并依据schema.sql文件的内容创建相应的表结构及可能的初始数据，确保数据库满足Twikoo评论系统的存储需求。

五、创建Cloudflare R2存储
Cloudflare R2可用于存储Twikoo评论系统相关的文件，如上传的图片等（尽管当前部署方案中对R2的使用存在一定限制，但创建步骤仍需完成），通过以下命令创建名为twikoo的R2存储桶：
npx wrangler r2 bucket create twikoo
创建完成后，找到wrangler.toml文件中r2_public_url字段，将其值更新为新创建的R2存储桶的域名，确保项目能正确访问R2存储资源。
[vars]
R2_PUBLIC_URL = “https://twikoo.soniachen.com”

六、部署Cloudflare Worker
完成上述配置后，即可将Twikoo评论系统部署到Cloudflare Workers，执行以下命令进行部署：
npx wrangler deploy --minify
--minify参数用于对代码进行压缩，以进一步减小捆绑包大小，提升部署效率与性能。部署过程可能需要一些时间，完成后，命令行中会输出类似https://twikoo-cloudflare.&lt;your username&gt;.workers.dev的访问地址。若部署成功，在浏览器中访问该地址，应能看到类似于&#123;&quot;code&quot;: 100, &quot;message&quot;: &quot;twikoo云函数运行正常，请参考https://twikoo.js.org/frontend.html完成前端的配置&quot;, &quot;version&quot;: &quot;1.6.33&quot;&#125;的提示信息，这表明Twikoo的后端服务已在Cloudflare上成功部署。
七、前端配置

在博客或网站的前端代码中，找到需要添加评论功能的页面。若使用Twikoo官方提供的前端初始化代码，需将其中的envId字段值设置为第六步中得到的Cloudflare Worker访问地址（包含https://前缀）。例如：

twikoo.init(&#123;    envId: &quot;https://twikoo-cloudflare.&lt;your username&gt;.workers.dev&quot;,    el: &quot;#tcomment&quot;,    // region: &#x27;ap-guangzhou&#x27;, // 环境地域，默认为ap-shanghai，如果您的环境地域不是上海，需传此参数    // path: &#x27;window.location.pathname&#x27;, // 用于区分不同文章的自定义js路径，如果您的文章路径不是location.pathname，需传此参数    // lang: &#x27;zh-CN&#x27;, // 用于手动设定评论区语言，支持的语言列表https://github.com/imaegoo/twikoo/blob/dev/src/js/utils/i18n/index.js    // onCommentLoaded: function () &#123;    //     console.log(&quot;评论加载或评论成功&quot;);    // &#125;&#125;);

确保前端页面包含用于显示评论区的HTML元素，其id需与上述代码中el字段指定的值一致（如&lt;div id=&quot;tcomment&quot;&gt;&lt;/div&gt;），这样Twikoo前端脚本才能正确渲染评论区。


八、配置邮件通知（可选）
Twikoo支持在有新评论时发送邮件通知管理员，由于nodemailer包的兼容性问题，在Cloudflare Workers环境中，无法直接通过SMTP集成发送邮件，而是通过SendGrid的HTTPS API实现邮件通知功能，具体步骤如下：

注册一个可用的SendGrid账户（SendGrid提供免费套餐，每天可发送多达100封邮件）或Mailchannels账户（每月免费3000封邮件），并在账户设置中创建一个API Key，用于后续验证身份。
在Twikoo的配置中设置相关邮件参数，找到配置文件中与邮件通知相关的部分，设置以下字段：

sender_email: &quot;发件人邮箱地址&quot;, // 需在SendGrid中进行验证sender_name: &quot;显示的发件人名称&quot;,smtp_service: &quot;sendgrid&quot;,smtp_user: &quot;提供任意非空值&quot;,smtp_pass: &quot;之前创建的SendGrid API Key&quot;,
此外，还可根据需求设置其他配置值，以自定义通知邮件的外观和内容。完成设置后，在配置页面点击“发送测试邮件”按钮，检查邮件通知功能是否正常工作，同时需确保邮件提供商不会将收到的通知邮件归类为垃圾邮件。
九、常见问题及解决方法

捆绑包大小超限：若在部署时遇到捆绑包大小超过Cloudflare Workers免费套餐1MiB限制的问题，除了前文提到的删除特定包文件内容外，还可检查项目中是否引入了不必要的大型依赖，精简代码，减少不必要的资源加载。
数据库连接问题：若出现无法连接到Cloudflare D1数据库的情况，首先确认wrangler.toml文件中database_name和database_id是否填写正确，其次检查网络连接是否正常，确保能访问Cloudflare的服务。
前端评论区无法显示：前端评论区无法正常显示时，检查浏览器控制台是否有报错信息，可能是envId配置错误、前端脚本加载失败或HTML元素id不匹配等原因导致，根据具体错误提示进行排查修复。

通过以上详细的Cloudflare部署方案，可将Twikoo评论系统高效地集成到网站中，利用Cloudflare的优质服务提升评论系统的性能与稳定性，为网站访客打造良好的互动交流环境。
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>CloudFlare</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1:用Git+CloudFlare+PicGo+Typora+Hexo搭建个人博客全流程</title>
    <url>/2025/06/17/%E4%BB%8E0%E5%88%B01-%E7%94%A8Git-CloudFlare-PicGo-Typora-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[从 0 到 1：用 Git、CloudFlare、PicGo、Typora、Hexo 搭建个人博客全流程
一、前言
22年，我用 Hexo + Next 主题搭起第一个个人博客。三年后，随着图床需求升级、对博客风格有了新想法，我决定重构 —— 替换图床工具、更换主题，用 Git、CloudFlare、PicGo、Typora 配合 Hexo 重新搭建。这篇文章复盘从旧版迭代到全新上线的全过程，既是对自己折腾经历的记录，也希望给想优化博客的朋友一份实操参考。
二、环境准备与工具选型
（一）核心工具简介

Git：分布式版本控制系统，负责博客代码的版本管理与远程仓库同步，让博客部署、内容更新更高效。
CloudFlare：提供 CDN 加速、DNS 解析、安全防护等功能，让博客访问更快、更稳定，还能隐藏真实服务器 IP 。
PicGo：图床上传工具，写博客时本地图片能一键上传到图床，解决文章中图片存储与引用问题。
Typora：简洁高效的 Markdown 编辑器，实时预览、语法简洁，专注内容创作。
Hexo：静态博客生成框架，基于 Node.js，支持 Markdown 写作，能快速生成美观博客站点，部署灵活。

（二）环境安装

Git 安装：
官网（https://git-scm.com/ ）下载对应系统版本，安装后通过 git --version 验证，看到版本号即成功。
配置用户信息：git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot;

Node.js 与 Hexo 安装（Hexo 依赖 Node.js ）：
Node.js 官网（https://nodejs.org/ ）下载 LTS 版本，安装后用 node -v、npm -v 验证。
全局安装 Hexo：npm install -g hexo-cli
验证 Hexo 安装：hexo -v 显示版本信息则成功。
Typora 安装：官网（https://typora.io/ ）下载对应系统版本，按提示安装即可，简洁直观。
PicGo 安装：官网（https://picgo.github.io/PicGo-Doc/ ）或应用商店下载，支持多平台，安装后配置图床（如 GitHub 图床、七牛云等，我用 GitHub 图床时需配置仓库、Token 等 ）。

三、Hexo 初始化与博客基础搭建
（一）初始化 Hexo 项目

创建博客目录（如 my-blog ），进入目录：mkdir my-blog &amp;&amp; cd my-blog

初始化 Hexo：hexo initnpm install
执行后，目录会生成 Hexo 基础文件结构，包含 _config.yml（配置文件 ）、source（存放文章、资源 ）、themes（主题目录 ）等。

（二）主题选择与配置

主题下载：Hexo 官网（https://hexo.io/themes/ ）选心仪主题，比如我用的 anzhiyu 主题，克隆到 themes 目录：git clone https://github.com/Anzhiyu/hexo-theme-anzhiyu.git themes/anzhiyu

主题配置：复制主题目录下的 _config.yml 到博客根目录，重命名为 _config.anzhiyu.yml ，修改基础配置（如站点标题、描述、头像、导航菜单等 ），让博客符合需求。

（三）本地预览博客
执行以下命令，启动本地服务器：
hexo clean &amp;&amp; hexo g &amp;&amp; hexo s

hexo clean：清理之前生成的静态文件。
hexo g（hexo generate ）：生成静态博客文件到 public 目录。
hexo s（hexo server ）：启动本地服务器，浏览器访问 http://localhost:4000 ，就能看到初始博客页面。

四、内容创作与管理（Typora + PicGo [S3插件] + CloudFlareR2存储桶 ）
一、Cloudflare R2 存储桶创建与基础配置
（一）登录 Cloudflare 控制台

访问 Cloudflare Dashboard 并登录账户（若无账户需先注册）。
点击左侧菜单中的 R2 选项（若未显示，点击“更多产品”查找）。

（二）创建存储桶


点击 创建存储桶 按钮，进入创建流程：

存储桶名称：自定义（如 blog-images），需全局唯一（建议包含个人标识）。
区域：选择 自动（Auto）以获得最佳分布，或手动指定区域（如 亚洲 - 新加坡）。
访问控制：勾选 公开访问（Public access），允许匿名读取图片（若仅个人使用可跳过）。
加密：默认启用服务器端加密（SSE），无需修改。



点击 创建存储桶，等待约 10 秒完成创建。


（三）获取 API 访问凭证


进入 存储桶详情页 → 权限 标签页：

点击 创建访问密钥 按钮（若提示需要创建密钥对，点击“创建”）。
记录生成的 Access Key ID 和 Secret Access Key（仅显示一次，需立即保存到安全位置）。



复制存储桶端点（Endpoint）：

存储桶详情页 → 概述 标签页，找到 外部访问 中的端点地址（格式为 https://&lt;账户ID&gt;.r2.cloudflarestorage.com）。



二、PicGo 配置 S3 插件对接 R2
（一）安装 S3 插件

打开 PicGo 软件 → 插件管理 → 搜索 s3 并安装 PicGo-S3-Plugin（若已安装可跳过）。

（二）配置插件参数


进入 PicGo 图床设置 → 选择 S3 插件：

Bucket：填写创建的存储桶名称（如 blog-images）。
Region：填 auto（R2 不区分传统区域）。
Access Key ID：粘贴 Cloudflare 生成的 Access Key。
Secret Access Key：粘贴对应的 Secret Key。
Endpoint：粘贴存储桶端点（如 https://abc123.r2.cloudflarestorage.com）。
Path：自定义图片存储路径前缀（如 blog/，可留空）。
Custom Domain：填写自定义域名（如 img.soniachen.com，后续配置）。
SSL：勾选（启用 HTTPS 访问）。



点击 设为默认图床，并点击 确定 保存配置。


（三）测试上传

在 PicGo 主界面点击 上传图片，选择本地图片：

若上传成功，下方会显示图片 URL（如 https://img.soniachen.com/blog/test.jpg）。



三、绑定自定义域名（CDN 加速）
（一）添加域名到 Cloudflare

登录 Cloudflare 控制台 → 域名 → 添加域名：

输入自定义域名（如 img.soniachen.com），点击 继续。
等待 Cloudflare 扫描 DNS 记录（约 1 - 5 分钟）。



（二）配置 DNS 解析

在域名管理界面 → DNS 标签页：

添加一条 CNAME 记录：

名称：填 @ 或 img（根据域名结构）。
目标：填存储桶端点（如 abc123.r2.cloudflarestorage.com）。
代理状态：选择 DNS Only（仅解析，不启用 CDN）或 Proxied（启用 CDN 加速）。





（三）配置 R2 自定义域名

回到 R2 存储桶 → 域名 标签页：

点击 添加自定义域名，输入已添加到 Cloudflare 的域名（如 img.soniachen.com）。
Cloudflare 会自动生成 SSL 证书（等待约 10 分钟生效）。



四、Hexo 集成 R2 图床（可选）
（一）安装 Hexo 插件

在 Hexo 项目根目录执行：npm install hexo-s3-image --save


（二）配置插件

修改 _config.yml 添加以下配置：s3_image:  bucket: blog-images          # 存储桶名称  region: auto                 # 区域  accessKeyId: your-access-key # 替换为实际 Access Key  secretAccessKey: your-secret-key # 替换为实际 Secret Key  endpoint: https://abc123.r2.cloudflarestorage.com # 端点  path: blog/                  # 存储路径  customUrl: https://img.soniachen.com # 自定义域名  public: true                 # 公开访问


（三）使用方式

在 Markdown 中插入图片时，直接使用本地路径：![示例图片](/img/test.jpg)

Hexo 生成时会自动上传图片到 R2，并替换为在线链接。

五、常见问题与解决方案
（一）403 Forbidden 错误

原因：存储桶未启用公开访问或访问密钥错误。
解决：

存储桶 → 权限 → 确保 公开访问 已启用。
重新核对 Access Key 和 Secret Key 是否正确。



（二）图片链接返回 404

原因：域名解析错误或路径配置错误。
解决：

检查 DNS 解析是否生效（可通过 ping img.soniachen.com 验证）。
确认 PicGo 中 Custom Domain 与 Cloudflare 域名一致。



（三）上传失败（网络错误）

原因：Endpoint 填写错误或网络阻断。
解决：

存储桶详情页复制端点，确保无多余字符（如末尾空格）。
尝试更换网络环境（如关闭 VPN）。



六、进阶优化：缓存与安全
（一）设置缓存策略

Cloudflare 域名 → 规则 → 页面规则：

添加规则 https://img.soniachen.com/*，设置 缓存级别 为 缓存所有，TTL 为 1 天（根据需求调整）。



（二）启用防盗链

存储桶 → 权限 → 添加 Origin Access：

配置允许访问的域名（如 soniachen.com），拒绝其他域名盗用图片。



/opt/homebrew/bin/node /opt/homebrew/bin/picgo upload

五、博客部署（Git + GitHub Pages + CloudFlare ）
（一）GitHub 仓库准备

GitHub 新建仓库，命名规则：若为用户/组织页，仓库名填 你的GitHub用户名.github.io（如 soniachan33.github.io ）；若为项目页，仓库名自定义（后续需配置路径 ）。
仓库创建后，复制仓库的 Git 地址（SSH 或 HTTPS 形式 ）。

（二）Hexo 部署配置
修改博客根目录 _config.yml 的 deploy 配置：
deploy:  type: git  repo: git@github.com:你的GitHub用户名/你的仓库名.git  # 替换为实际仓库地址  branch: main  # 部署分支，GitHub Pages 常用 main 或 gh-pages
安装 hexo-deployer-git 插件：
npm install hexo-deployer-git --save
（三）部署到 GitHub Pages
执行部署命令：
hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
Hexo 会把生成的静态文件（public 目录内容 ）推送到 GitHub 仓库对应分支，稍等片刻，访问 https://你的GitHub用户名.github.io（或项目页地址 ），能看到线上博客。
（四）CloudFlare 加速与配置

添加站点：CloudFlare 官网（https://www.cloudflare.com/ ）注册登录，添加站点（输入博客域名，若用 GitHub Pages 默认域名可跳过，若自定义域名需提前备案、解析 ）。
DNS 解析设置：添加 DNS 记录，将域名解析到 GitHub Pages 对应的 IP（或直接解析到 你的GitHub用户名.github.io  ），让 CloudFlare 接管 DNS 解析。
CDN 与安全配置：开启 CDN 加速，优化缓存、压缩等设置；启用安全防护（如 DDoS 防护、防火墙规则 ），提升博客访问速度与安全性。
自定义域名（可选）：若用自定义域名（如 soniachen.com  ），在 GitHub Pages 仓库设置中填自定义域名，同时在 CloudFlare 配置域名解析、SSL 证书（推荐开启 Full 或 Strict 模式 ），确保 HTTPS 访问正常。

六、博客优化与维护
（一）SEO 优化

站点地图（Sitemap ）：安装 hexo-generator-sitemap 插件，生成站点地图：npm install hexo-generator-sitemap --save
修改 _config.yml 配置：sitemap:  path: sitemap.xml
部署后，通过 https://你的域名/sitemap.xml 访问，提交给百度、必应、谷歌等搜索引擎，助力收录。
Meta 标签与关键词：在主题配置或文章 Front-matter 中，设置标题、描述、关键词，让搜索引擎更好理解内容，提升搜索排名。

（二）持续更新与备份

内容更新：用 Typora 写新文章，存到 source/_posts 目录，执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署，持续输出优质内容。
版本备份：借助 Git，定期提交代码到 GitHub 仓库，记录博客配置、文章修改历史，方便回退与协同。

七、遇到的问题与解决（结合之前的疑问）
（一）GitHub Pages 部署后 404

原因：部署分支与 GitHub Pages 设置不一致、root 配置错误、CNAME 文件丢失等。
解决：确保 _config.yml 中 deploy 分支正确，用户页 root 设为 / ；在 Hexo 项目 source 目录添加 CNAME 文件（填自定义域名 ），重新部署。

（二）CloudFlare 部署后域名配置清空

原因：Hexo 部署覆盖 GitHub Pages 分支内容，CNAME 文件未同步。
解决：在 Hexo 项目 source 目录添加 CNAME 文件，内容填自定义域名，部署时同步到 GitHub 仓库，CloudFlare 配置就会保留。

（三）必应收录验证问题

方法：通过 XML 文件（下载 BingSiteAuth.xml 放 Hexo source 目录，部署后验证 ）、HTML Meta 标记（添加到博客首页 &lt;head&gt;  ）、DNS CNAME 记录（域名解析后台添加 ）完成验证，提交站点地图，让博客在必应搜索可见。

八、总结
从工具安装、Hexo 初始化，到内容创作、部署上线，再到用 CloudFlare 加速、优化 SEO ，整个流程虽有波折，但一步步搭建出专属博客，成就感满满。这五个工具相互配合，让博客从本地走向公网，成为展示自我的窗口。未来，继续用它们更新内容、优化体验，让博客持续生长～
附录：关键命令与配置汇总，方便速查：

Hexo 常用命令：hexo clean、hexo g、hexo s、hexo d 。
Git 配置与部署：git config、hexo-deployer-git 插件配置。
CloudFlare 核心操作：DNS 解析、CDN 加速、SSL 配置。
PicGo + Typora 图床写作：Typora 上传图片设置、PicGo 图床配置。

希望这篇复盘能帮到想搭建博客的你，一起用技术记录生活、分享世界～
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Git</tag>
        <tag>CloudFlare</tag>
        <tag>Typora</tag>
        <tag>PicGo</tag>
      </tags>
  </entry>
</search>
