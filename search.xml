<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rust基础[part1]</title>
    <url>/2025/07/08/Rust%E5%9F%BA%E7%A1%80-part1/</url>
    <content><![CDATA[Rust基础[part1]
安装
➜  rust curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
安装成功

验证
➜  rust rustc --version
zsh: command not found: rustc
因为我是用的是zsh，所以zsh配置文件需要加入配置
➜  rust echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> ~/.zshrc
➜  rust source ~/.zshrc
➜  rust rustc --version
rustc 1.88.0 (6b00bc388 2025-06-23)
安装成功！
其他命令：
➜  rust rustup update # 安装
➜  rust rustup self uninstall # 卸载
VsCode插件
rust语言支持：

rust包支持：

toml支持：

rustc
创建目录
mkdir hello-world
cd hello-world
创建源文件main.rs
fn main() &#123;
    println!("Hello, world!");
&#125;
终端输入 rustc main.rs 会得到一个二进制的文件mian
执行mian 会得到输出

cargo
初始化


初始化项目 cargo new [项目名] 


构建 cargo build并运行./target/debug/hello_cargo ；或者直接使用cargo run


当项目最终准备好发布时，可通过以下命令对 Rust 项目进行优化编译：
cargo build --release  

输出目录：编译产物会生成在 target/release 目录下（开发阶段默认的 cargo build 会输出到 target/debug）。
优化特性：--release 会启用 Rust 编译器的性能优化（如代码内联、循环展开、冗余代码消除等），使最终程序的运行速度显著提升。

依赖
crate是Rust的一个代码库，可以包含任意能被其他程序使用的代码，但是不能只执行。
cargo.toml中 [dependencies]  增加配置
[dependencies]
rand="0.8.5"
重新构建执行cargo build 会从cargo.io拉到指定的依赖版本到cargo.lock中。
执行cargo update会忽略cargo.lock 的版本，从cargo.io拉到最新的依赖版本
配置国内镜像
➜  hello_cargo git:(main) touch ~/.cargo/config.toml
➜  hello_cargo git:(main) vim ~/.cargo/config.toml
第一种配置：
[registries]
ustc = &#123; index = "sparse+https://mirrors.ustc.edu.cn/crates.io-index/" &#125;
前缀 sparse+ 启用稀疏模式，比传统全量索引更快
Cargo.toml 指定镜像地址
[dependencies]
rand = &#123;registry = "ustc", version = "0.8.5"&#125;
第二种配置
直接覆盖原cargo.io ，不用指定镜像地址了
[source.crates-io]
replace-with = "ustc"

[source.ustc]
registry = "sparse+https://mirrors.ustc.edu.cn/crates.io-index/"
重新build一遍
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础[part2]_变量和可变类型</title>
    <url>/2025/07/10/Rust%E5%9F%BA%E7%A1%80-part2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[Rust基础[part2]_变量和可变类型
可变变量与不可变变量
可以不指定数据类型
可变变量——mutable
fn immutable() &#123;
    let x = 5;
    println!("The value of x is: &#123;&#125;", x);
&#125;
不可变变量——immutable
fn mutable() &#123;
    let mut y = 10;
    println!("The value of y is: &#123;&#125;", y);
    y = 15;
    println!("The value of y is now: &#123;&#125;", y);
&#125;
常量——constants


需要制定明确的数据类型，并且需要使用大写字母


需要使用常量表达式进行赋值


不支持重定义（遮蔽）



const NUM: i32 = 5;
const THREE_HOURS: i32 = 60 * 60 * 3;
不可变量和常量的区别

常量在编译期就就确定了值，不能在运行时进行改变； 不可变量知道运行期才能确认下来。
常量不可修改，不可变变量可以通过shadowing来进行修改
常量必须声明类型，不可变变量不需要声明类型。
常量必须使用大写字母。

静态变量——static
需要通过mut来指定可变， unsafe 块是必须的，因为静态变量在多线程环境中可能会引发数据竞争问题。
static mut NUMBER: i32 = 10;

fn static_num() &#123;
    unsafe &#123;
        println!("static NUMBER: &#123;&#125;", NUMBER);
    &#125;// 这里可以访问静态变量NUMBER 
&#125;
作用域scope和遮蔽shadowing
fn binding() &#123;
    // 绑定生存于main函数中
    let long_lived_binding = 1;
    
    // 代码块， 比main函数拥有更小的作用域
    &#123;
        // 绑定生存于代码块中
        // 这里的short_lived_binding只在这个代码块中有效
        let short_lived_binding = 2;
        println!("short_lived_binding: &#123;&#125;", short_lived_binding);
        // 遮蔽，在作用域中可以遮蔽成功
        let short_lived_binding = 3;
        println!("short_lived_binding after shadowing: &#123;&#125;", short_lived_binding);

        println!("long_lived_binding: &#123;&#125;", long_lived_binding);
        // 遮蔽长期绑定的变量
        // 这里的long_lived_binding会遮蔽外层的同名变量
        let long_lived_binding = 4;
        println!("long_lived_binding after shadowing: &#123;&#125;", long_lived_binding);
    &#125;
    println!("long_lived_binding after block: &#123;&#125;", long_lived_binding);
    // println!("short_lived_binding after block: &#123;&#125;", short_lived_binding); // 这里会报错，因为short_lived_binding在代码块外不可见
    // 遮蔽长期绑定的变量
    let long_lived_binding = 5_f32;
    println!("long_lived_binding after shadowing: &#123;&#125;", long_lived_binding);

&#125;

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础[part3]_函数、流程控制</title>
    <url>/2025/07/10/Rust%E5%9F%BA%E7%A1%80-part3-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[Rust基础[part3]_函数、流程控制
函数
组成和定义
fn add(i: i32, j: i32) -> i32 &#123;
    i + j
&#125;

声明函数的关键字 fn
函数名add()
参数i和j和参数类型 i32
返回值类型`i32``
函数题i+j

函数返回
返回形态
i+j 和 return i+j;
可以有两种形态

return + 分号
无return + 无分号

无返回值的情况：
就返回 ()
fn add(i: i32, j: i32) -> () &#123;
  
&#125;
永不返回值的情况：
!表示函数永不返回，例如panic!宏会导致程序崩溃，函数不会返回。
fn add_one(i: i32, j: i32) -> ! &#123;
    panic!("weeee");
&#125;
死循环也不会返回
fn infinite_loop() -> ! &#123;
    loop &#123;
        // 永远不会返回
    &#125;
&#125;

流程控制
if语法
 // if_else();
  let number = 3;
  if number &lt; 5 &#123;
      println!("Condition was true");
  &#125; else &#123;
      println!("Condition was false");
  &#125;
	
// else if
	let number = 3;
  if number % 4 == 0&#123;
      println!("Condition was true");
  &#125; else if number % 3 == 0 &#123;
      println!("Condition was true for number % 3");
  &#125; else if number % 2 == 0 &#123;
      println!("Condition was true for number % 2");
  &#125; else &#123;
      println!("Condition was false");
  &#125;

let 语句中使用if，需要注意分号结尾。
let condition = true;
   let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;
   println!("The value of number is: &#123;&#125;", number);
loop循环
//loop 循环
    loop &#123;
        println!("This is an infinite loop");
    &#125;

break、 continue
使用break 关键字来告诉程序停止循环，使用continue关键字来告诉程序继续循环。
let语句中也可以使用loop返回, 需要注意分号结尾。
// let语句中使用loop
   let result = loop &#123;
       count += 1;
       if count == 10 &#123;
           println!("Breaking the loop at count: &#123;&#125;", count);
           break count * 2; // 返回值
       &#125;
   &#125;;
多层loop
break退出内层循环，可以使用命名loop的方法来退出指定的循环。标签的语法是使用单引号（'）后跟一个标识符
// 多层循环可以使用标签来控制跳出特定的循环层级
   // 标签可以帮助我们在多层嵌套循环中跳出特定的循环层级
   // 标签的语法是使用单引号（'）后跟一个标识符
   let mut i = 0;
   'outerloop: loop &#123;
       loop &#123;
           i += 1;
           println!("Inner loop iteration with i: &#123;&#125;", i);
           if i == 2 &#123;
               println!("Breaking out of the inner loop at i: &#123;&#125;", i);
               break; // 跳出内层循环
           &#125;
           if i == 3 &#123;
               println!("Breaking out of the outer loop at i: &#123;&#125;", i);
               break 'outerloop; // 跳出外层循环
           &#125;
       &#125;
   &#125;
while 条件循环
fn while_example() &#123;
    let mut count: i32 = 0;
    while count &lt; 5 &#123;
        count += 1;
        println!("Current count: &#123;&#125;", count);
    &#125;
&#125;
在rust中如果是条件判断的循环，使用while是比较便捷的，如果需要遍历集合的话，可以使用for
for遍历集合
fn for_example() &#123;
    let numbers = [1, 2, 3, 4, 5];
    for i in numbers &#123;
        println!("Current number: &#123;&#125;", i)
    &#125;

    // 直接遍历数值，逆序使用rev()
    for i in (1..=4).rev() &#123;
        println!("Current number in range: &#123;&#125;", i);
    &#125;
&#125;
所有权转移与借用：
是Rust中的循环访问规则
1. 未实现Copy trait的类型：所有权会转移（Move语义）
像Vec这类集合类型没有实现Copy trait，当直接用它们进行循环遍历（for v in vec）时，循环会获取vec的所有权（即“所有权转移”）。

循环结束后，vec的所有权已被消耗，无法再被访问（编译器会报错）。

let mut vec = vec![1, 2, 3, 4, 5];
// 直接遍历vec：所有权转移给循环变量v
for v in vec &#123;
    println!("Current value: &#123;&#125;", v); // 此时v是vec中元素的所有权持有者
&#125;

// ❌ 错误：vec的所有权已转移，无法再使用
println!("Vector after loop: &#123;:?&#125;", vec); 
2. 解决办法：用“借用”避免所有权转移
若想在循环后继续使用vec，需通过引用（&amp;） 进行“借用”，而非直接转移所有权。根据是否需要修改元素，分为两种借用方式：
（1）不可变借用（&amp;vec）：仅读取，不修改
用&amp;vec进行遍历，循环获取的是vec的不可变引用，所有权仍归原变量所有。

循环中只能读取元素，不能修改。

let vec = vec![1, 2, 3, 4, 5];
// 不可变借用：&amp;vec表示“临时借用vec的读取权”
for v in &amp;vec &#123;
    println!("Current value: &#123;&#125;", v); // v是&amp;i32类型（不可变引用）
&#125;

// ✅ 合法：vec所有权未转移，可继续使用
println!("Vector after loop: &#123;:?&#125;", vec); 
（2）可变借用（&amp;mut vec）：需要修改元素
若要在循环中修改元素，需用&amp;mut vec进行可变借用，此时循环变量v是&amp;mut i32（可变引用）。

修改元素时需用*v解引用（获取引用指向的实际值）。

let mut vec = vec![1, 2, 3, 4, 5];
// 可变借用：&amp;mut vec表示“临时借用vec的修改权”
for v in &amp;mut vec &#123;
    if *v == 3 &#123;
        *v += 10; // ✅ 解引用后修改：3 → 13
    &#125;
    println!("Current value: &#123;&#125;", v); // v是&amp;mut i32，打印时自动解引用
&#125;

// ✅ 合法：所有权未转移，修改后的值已保留
println!("Vector after loop: &#123;:?&#125;", vec); // 输出 [1, 2, 13, 4, 5]
3. 实现Copy trait的类型：所有权不转移（Copy语义）
像整数、布尔值等基本数据类型，以及由它们组成的数组（[i32; n]），都实现了Copy trait。

循环遍历这类类型时，会自动复制元素（而非转移所有权），原变量的所有权仍保留，循环后可正常使用。

let arr = [1, 2, 3, 4, 5]; // 数组元素是i32（实现了Copy）
// 遍历arr：会复制每个元素给v，而非转移所有权
for v in arr &#123;
    println!("Current value: &#123;&#125;", v); // v是复制的i32值
&#125;

// ✅ 合法：arr的所有权未转移，可继续使用
println!("Array after loop: &#123;:?&#125;", arr); // 输出 [1, 2, 3, 4, 5]
核心区别总结



类型特征
循环方式
所有权状态
循环后能否使用原变量




未实现Copy（如Vec）
for v in vec
所有权转移给v
不能（已被消耗）


未实现Copy（如Vec）
for v in &amp;vec
仅借出不可变引用
能（所有权仍保留）


未实现Copy（如Vec）
for v in &amp;mut vec
仅借出可变引用
能（所有权仍保留）


实现Copy（如[i32; n]）
for v in arr
元素被复制，所有权不转移
能（原变量未被修改）



]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础[part5]_引用、数组与切片</title>
    <url>/2025/07/12/Rust%E5%9F%BA%E7%A1%80-part5-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[Rust基础[part5]_引用

不可变引用：通过不可变引用，可以读取变量，但是不能够修改数据。一个变量可以有多个不可变引用，但不能与可变引用共存。
可变引用：通过可变引用，可以读取和修改数据。一个变量在某一时刻只能有一个可变引用，且不能与不可变引用共存。

引用规则

同一时间(生命周期)内，一个变量只能有一个可变引用或多个不可变引用

多个不可变引用可以共存
可变引用必须是独占的（不能与其他引用共存）


引用必须总是有效（Rust保证引用永远不会指向无效内存）

示例1：错误示范
pub fn reference_example() &#123;
    let mut s: String = String::from("Hello");
    // 创建不可变引用
    let s1: &amp;String = &amp;s;
    // 创建可变引用（错误：此时s已有不可变引用）
    let s2: &amp;mut String = &amp;mut s;
  
    // 错误：不能创建多个可变引用
    let s3: &amp;mut String = &amp;mut s;
    
    // 错误：同一生命周期内同时使用不可变和可变引用
    println!("s1: &#123;&#125;, s2: &#123;&#125;", s1, s2); 
&#125;

示例 2：正确示范
pub fn reference_example() &#123;
    let mut s: String = String::from("Hello");
    
    // 第一阶段：仅使用不可变引用
    let s1: &amp;String = &amp;s;
    println!("s1: &#123;&#125;", s1); 
    // s1在此处不再使用
    
    // 第二阶段：创建可变引用（s1已不再活跃）
    let s2: &amp;mut String = &amp;mut s;
    println!("s2: &#123;&#125;", s2);
&#125;
切片(Slices)
数组切片
let a = [1, 2, 3];
   let b = &amp; a[0..1];
   let c = &amp; a[0..=1];
字符串切片
是对字符串部分内容的引用
// 字符串引用
    let s = String::from("Hello, Rust!");
    let slice1: &amp;str = &amp;s[0..5]; // "Hello"
    let slice2: &amp;str = &amp;s[7..]; // "Rust!"
    let slice3: &amp;str = &amp;s[..]; // "Hello, Rust!"
悬垂引用（Dangling Reference）
生命周期核心规则：引用的生命周期必须 ≤ 被引用对象的生命周期
错误示例1：
pub fn dangling_pointer_example() &#123;
    let r: &amp;String;
    &#123;
        let s = String::from("Hello"); // s的生命周期仅在&#123;&#125;内
        r = &amp;s;                        // r引用s，但s即将被销毁
    &#125; // s在此处被释放
    println!("r: &#123;&#125;", r); // 错误：r引用的s已不存在（悬垂引用）
&#125;
关键点：

s的生命周期：从创建到&#125;结束。
r的生命周期：从创建到函数结束（覆盖s的生命周期）。
错误原因：r存活时间超过s，导致引用无效。

错误示例2：
fn get_a() -> &amp;String &#123; // 错误：返回局部变量的引用
    let s = String::from("a");
    &amp;s // 函数结束后s被销毁，引用悬空
&#125;
关键点：

返回引用的合法性：只能返回参数或全局变量的引用，不能返回局部变量的引用。

正确示例：
生命周期注解（Lifetime Annotation）
pub fn lifetime_example() &#123;
    let large = longest("a", "ab");
    println!("The longest string is: &#123;&#125;", large);

    // 生命周期注解：确保返回的引用与参数生命周期一致
    fn longest&lt;'a>(x: &amp;'a str, y: &amp;'a str) -> &amp;'a str &#123;
        if x.len() > y.len() &#123; x &#125; else &#123; y &#125;
    &#125;
&#125;
关键点：

'a的含义：参数x和y以及返回值的引用必须至少存活到'a结束。
编译器检查：

验证x和y的实际生命周期是否满足'a。
确保返回值的生命周期不超过'a。


实际效果：返回的引用在调用者的作用域内有效（如large的生命周期覆盖longest的调用）。

总结：避免悬垂引用的3种方式

返回所有权（如fn get_a() -&gt; String）：转移值的控制权，无需引用。
引用外部变量（如fn get_a(s: &amp;String) -&gt; &amp;String）：确保被引用对象生命周期足够长。
生命周期注解（如fn longest&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str）：明确引用的合法存活范围。

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础[part6]_数组与切片_字符串</title>
    <url>/2025/07/13/Rust%E5%9F%BA%E7%A1%80-part6-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[Rust基础[part6]_数组与切片、字符串
数组
数组的类型格式:[T; N]

固定长度：必须在编译时指定长度 N，且无法扩容。
可变：如果声明为 mut，可以修改元素值，但不能改变长度。
存储在栈上（除非被装箱到堆上，如 Box&lt;[T; N]&gt;）。

定义
let arr = [1, 2, 3, 4, 5];
   println!("Array: &#123;:?&#125;", arr);
默认初始值
// 默认初始值
   let arr1: [i32; 4] = [10; 4];
   println!("Array with default value: &#123;:?&#125;", arr1);
数组长度
// 数组长度
   println!("Array length: &#123;&#125;", arr1.len());
遍历
for index in 0..arr.len() &#123;
        // 遍历索引
        println!("Element at index &#123;&#125;: &#123;&#125;", index, arr[index]);
    &#125;
    for element in arr1.iter() &#123;
        // 使用迭代器遍历
        println!("Element: &#123;&#125;", element)
    &#125;
    arr1.iter().for_each(|x: &amp;i32| println!("Element: &#123;&#125;", x)); // 使用闭包遍历

数组的值传递
    // 数组值传递
    println!("Before update: &#123;:?&#125;", arr2);
    update(arr2);
    println!("After update: &#123;:?&#125;", arr2); // 注意这里的 arr2 仍然是原来的值，因为数组是值传递
fn update(mut arr: [i32; 5]) &#123;
    println!("Updating array: &#123;:?&#125;", arr);
    for index in 0..arr.len() &#123;
        arr[index] = 100; // 修改每个元素
    &#125;
    println!("Updated array inside function: &#123;:?&#125;", arr);
&#125;

输出：主函数中的数组并未改变，因为是值传递
Before update: [10, 2, 3, 4, 5]
Updating array: [10, 2, 3, 4, 5]
Updated array inside function: [100, 100, 100, 100, 100]
After update: [10, 2, 3, 4, 5]
数组的引用传递
 // 数组引用传递
    println!("Before update_mut: &#123;:?&#125;", arr2);
    update_mut(&amp;mut arr2);
    println!("After update_mut: &#123;:?&#125;", arr2); // 这里的 arr2 已经被修改，因为传递的是可变引用

fn update_mut(arr: &amp;mut [i32; 5]) &#123;
    println!("Updating array with mutable reference: &#123;:?&#125;", arr);
    for index in 0..arr.len() &#123;
        arr[index] = 100; // 修改每个元素
    &#125;
    println!("Updated array with mutable reference: &#123;:?&#125;", arr);
&#125;
输出：
Before update_mut: [10, 2, 3, 4, 5]
Updating array with mutable reference: [10, 2, 3, 4, 5]
Updated array with mutable reference: [100, 100, 100, 100, 100]
After update_mut: [100, 100, 100, 100, 100]
数组的切片
也就是slice类型，他表示从包含多个元素的容器中取得局部数据，这个过程称为切片操作。 不同语言对切片的支持有所不同。 Rust可以支持Slice操作，Rust中的切片操作只允许获取一段连续的局部数据。支持的有Array、String、Vec。

⚠️ Slice切片 是单独的类型
切片的类型是 &amp;[T]（不可变切片）或 &amp;mut [T]（可变切片），它不包含长度信息。
切片也是一种引用，不包含所有权

内存结构，切片由两部分组成：

指向数据起始位置的指针（指向数组或 Vec 的内存）。
长度字段（len），表示切片包含的元素个数。

这里以Array的切片示例：
fn slice_example() &#123;
    let arr = [1, 2, 3, 4, 5];
    let slice1: &amp;[i32] = &amp;arr[1..3]; // 包含索引1和2的元素
    println!("Slice from index 1 to 3: &#123;:?&#125;", slice1);

    let slice2: &amp;[i32] = &amp;arr[..3]; // 包含前3个元素
    println!("Slice of first three elements: &#123;:?&#125;", slice2);

    let slice3: &amp;[i32] = &amp;arr[2..]; // 从索引2开始到末尾
    println!("Slice from index 2 to end: &#123;:?&#125;", slice3);
&#125;
常用的函数


len ()：取 slice 元素个数


is_empty ()：判断 slice 是否为空


contains ()：判断是否包含某个元素


repeat ()：重复 slice 指定次数


reverse ()：反转 slice


join ()：将各元素压平 (flatten) 并通过指定的分隔符连接起来


swap ()：交换两个索引处的元素，如 s.swap (1,3)


windows ()：以指定大小的窗口进行滚动迭代
for i in arr.windows(3) &#123;
        // 遍历数组的窗口
        println!("Window of size 3: &#123;:?&#125;", i);
    &#125;
Window of size 3: [1, 2, 3]
Window of size 3: [2, 3, 4]
Window of size 3: [3, 4, 5]


starts_with ()：判断 slice 是否以某个 slice 开头


练习 ⚠️

给定一个整数数组 nums，返回一个数组 answer ，使得 answer[i] 等于 nums 除 nums[i] 之外的所有元素的乘积。 任何前缀或后缀的乘积 nums 都保证适合 32 位整数。 您必须编写一个能够及时运行 O(n) 且无需使用除法运算的算法。
示例 1： 输入：nums = [1,2,3,4] 输出：[24,12,8,6]
示例 2： 输入：nums = [-1,1,0,-3,3] 输出：[0,0,9,0,0] 限制： 2 &lt;= nums.length &lt;= 10^5 -30 &lt;= nums[i] &lt;= 30 任何前缀或后缀的乘积 nums 都保证适合 32 位整数。
进阶：你能以 O(1) 额外空间复杂度解决这个问题吗？（输出数组不算作空间复杂度分析的额外空间。）

#[test]
fn feature_array_practice() &#123;
    let nums: [i32; 4] = [1, 2, 3, 4];
    let answer: Vec&lt;i32> = arr_practice(&amp;nums[..]);
    println!("Result of arr_practice: &#123;:?&#125;", answer);
&#125;

fn arr_practice(nums: &amp;[i32]) -> Vec&lt;i32> &#123;
    let n: usize = nums.len();
    let mut answer = vec![1; n]; // 初始化为全1

    for i in 1..n &#123;
        answer[i] = answer[i - 1] * nums[i - 1];
    &#125;
    let mut suffix = 1;
    for i in (0..n).rev() &#123;
        answer[i] *= suffix;
        suffix *= nums[i];
    &#125;

    answer
&#125;
字符串
是字符组成的连续集合
Rust字符是Unicode类型，每个字符占四个字节，但是在字符串里面不一样，字符串是UTF-8编码。也就是字符串中的字符所占的字节数的变化的四分之一。
Rust 的字符串主要分为两种类型：

str（字符串切片）：它是不可变的引用类型，长度固定，通常以借用的形式存在，即&amp;str。
String：这是一个在堆上分配内存的可增长类型，具备所有权。

创建字符串
// 创建String类型
let s1 = String::new(); // 空字符串
let s2 = "初始内容".to_string(); // 从&amp;str转换
let s3 = String::from("直接创建"); // 使用from函数

// 创建&amp;str类型（字符串字面量）
let s4: &amp;str = "这是一个字符串切片";
String -&gt;&amp;str
三种
pub fn string_example() &#123;
    let s3 = String::from("Rust");
     say_hello(&amp;s3); // Rust自动解引用s3，&amp;String会自动转换为&amp;str
    say_hello(s3.as_str()); // 显式转换为&amp;str
    say_hello(&amp;s3[..]); // 通过切片转换为&amp;str
&#125;

fn say_hello(s: &amp;str) &#123;
    println!("Hello, &#123;&#125;!", s);
&#125;
各种转换方式

字符串拼接
都是原有的字符串添加，需要可变
let mut s = String::from("Hello");
s.push(' '); // 添加单个字符
s.push_str("world!"); // 添加字符串切片

let s2 = format!("&#123;&#125; &#123;&#125;", s, "Rust"); // 格式化拼接
字符串查找与替换
是返回的新的字符串，不需要可变
let s = "Hello, world!";
let contains = s.contains("world"); // true
let replaced = s.replace("world", "Rust"); // "Hello, Rust!"
其他常见操作
let mut s = String::from("Hello");
s.pop(); // 删除最后一个字符
   println!("After pop: &#123;&#125;", s);

   s.remove(0); // 删除第一个字符
   println!("After remove: &#123;&#125;", s);

   s.truncate(3); // 截断字符串到指定长度
   println!("After truncate: &#123;&#125;", s);

   s.clear(); // 清空字符串
   println!("After clear: &#123;&#125;", s); 

   // 字符串连接
   let s4 = String::from("Hello");
   let s5 = String::from(", Rust!");
   let s6 = s4 + &amp;s5; // 使用 + 运算符连接字符串，使用 &amp;s5 传递引用
   println!("After concat: &#123;&#125;", s6);
 //format
   let s7 = format!("&#123;&#125;&#123;&#125;", s5, " is awesome!"); // 使用 format! 宏连接字符串

	// 转义




性能考量

拼接字符串时，format!宏比+运算符更高效。
频繁修改字符串建议使用String。

练习

// 修复所有错误，并且不要新增代码行
fn main() &#123;
    let mut s = String::from("hello");
    s.push(',');
    s.push_str(" world");
    s += "!";//字面量 不能用to_string()

    println!("&#123;&#125;", s)
&#125;
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础[part7]_枚举、结构体</title>
    <url>/2025/07/14/Rust%E5%9F%BA%E7%A1%80-part7-%E6%9E%9A%E4%B8%BE%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[Rust基础[part7]_枚举、结构体
枚举
枚举用于表示一个值可能是多种变体（Variant）中的一种。每个变体可以有不同的数据类型：
enum Message &#123;
    Quit,                   // 无数据
    Move &#123; x: i32, y: i32 &#125;, // 带命名数据（类似结构体）
    Write(String),          // 带单个值（类似元组）
    ChangeColor(i32, i32, i32), // 带多个值（类似元组）
&#125;
基本使用
enum Pets &#123;
    Cat(String),
    Dog &#123; name: String, age: usize &#125;,
&#125;

fn print_pet_info() &#123;
    let a = Pets::Cat("Whiskers".to_string());
    let b = Pets::Dog &#123;
        name: "Buddy".to_string(),
        age: 5,
    &#125;;

    // Debug trait allows us to print the enum variants
    println!("cat is &#123;:?&#125;", a);
    println!("dog is &#123;:?&#125;", b);
  
    //impl是用来为枚举或结构体定义方法的
    impl Pets &#123;
        fn speak(&amp;self) &#123;
            println!("hi");
        &#125;
    &#125;
    a.speak();

    // 关联函数是与类型相关的函数，可以通过类型名直接调用
    // 关联函数不需要实例化对象就可以调用
    impl Pets &#123;
        fn log(name: String) &#123;
            println!("Logging pet: &#123;&#125;", name);
        &#125;
    &#125;

    Pets::log("Whiskers".to_string());
&#125;
语法&amp;规范


语法

field-less enum
unit-only enum



规范


Pascal Case


snake_case




用法
枚举通常与模式匹配（match）结合使用，以处理不同的变体：
match &amp; if let
// match 语句：
    // 用于模式匹配，可以根据枚举的不同变体执行不同的代码
    match a &#123;
        Pets::Cat(_) => &#123;
            println!("This is a cat");
        &#125;
        Pets::Bird => &#123;
            println!("This is a bird");
        &#125;
        Pets::Dog &#123; name, age &#125; => &#123;
            println!("This is a dog named &#123;&#125; and age &#123;&#125;", name, age);
        &#125;
        // 这里的 _ 是一个通配符，表示匹配所有未被前面分支匹配的情况
        _ => &#123;
            println!("This is not a cat");
        &#125;
    &#125;


// if let 语句：
    // 用于简化模式匹配，当只关心某个特定变体时，可以使用 if let
    // 这种方式可以避免使用 match 的冗长语法
    if let Pets::Dog &#123; name, age &#125; = &amp;b &#123;
        println!("This is a dog named &#123;&#125; and age &#123;&#125;", name, age);
    &#125; else &#123;
        println!("This is not a dog");
    &#125;
Option
Option 的作用是安全地表达“有值”或“没有值”的情况，避免空指针（null）带来的运行时错误。在 Rust 里没有 null，所有“可能为空”的场景都用 Option 来表达。

你写的函数有时可能找不到结果、读取不到数据、或者参数可能为空，这时用 Option 返回 Some(值) 或 None。
这样编译器会强制你检查“有没有值”，防止忘记判断导致程序崩溃。

 fn option_example() &#123;
    let some_value: Option&lt;i32> = Some(42);
    let none_value: Option&lt;i32> = None;
    // 使用 match 处理 Option
    match some_value &#123;
        Some(val) => println!("Got a value: &#123;&#125;", val), // Some 分支
        None => println!("No value found"),            // None 分支
    &#125;

    if let Some(val) = none_value &#123;
        println!("Got a value: &#123;&#125;", val);
    &#125; else &#123;
        println!("No value found");
    &#125;
&#125;
Result
result 是一个枚举类型，用于表示操作的结果，Result&lt;T, E&gt; 有两个变体：Ok(T) 和 Err(E)；Ok(T) 表示操作成功，并包含一个值 T，Err(E) 表示操作失败，并包含一个错误值 E；Result&lt;T, E&gt; 常用于处理可能失败的操作，例如文件读取、网络请求等

可以提高代码的安全性和可读性
可以避免异常处理（exception handling）的复杂性

fn result_example() &#123;
    let ok_value: Result&lt;i32, &amp;str> = Ok(42);
    let err_value: Result&lt;i32, &amp;str> = Err("Error occurred");

    match ok_value &#123;
        Ok(val) => println!("Got a value: &#123;&#125;", val), // Ok 分支
        Err(err) => println!("Error: &#123;&#125;", err),      // Err 分支
    &#125;

    if let Err(err) = err_value &#123;
        println!("Error: &#123;&#125;", err);
    &#125;
&#125;
Option &amp; Result 转换
option-&gt; result: ok_or()
fn option_result_convert() &#123;
    let some_value: Option&lt;i32> = Some(42);
    let none_value: Option&lt;i32> = None;

    // Option 转 Result
    let result_from_some: Result&lt;i32, &amp;str> = some_value.ok_or("No value found");
    let result_from_none: Result&lt;i32, &amp;str> = none_value.ok_or("No value found");

    match result_from_some &#123;
        Ok(val) => println!("Got a value: &#123;&#125;", val),
        Err(err) => println!("Error: &#123;&#125;", err),
    &#125;

    match result_from_none &#123;
        Ok(val) => println!("Got a value: &#123;&#125;", val),
        Err(err) => println!("Error: &#123;&#125;", err),
    &#125;

&#125;

result-&gt; option: ok()
fn option_result_convert() &#123;

    // Result 转 Option
    let ok_value: Result&lt;i32, &amp;str> = Ok(42);
    let err_value: Result&lt;i32, &amp;str> = Err("Error occurred");
    let option_from_ok: Option&lt;i32> = ok_value.ok();
    let option_from_err: Option&lt;i32> = err_value.ok();
    match option_from_ok &#123;
        Some(val) => println!("Got a value: &#123;&#125;", val),
        None => println!("No value found"),
    &#125;
    match option_from_err &#123;
        Some(val) => println!("Got a value: &#123;&#125;", val),
        None => println!("No value found"),
    &#125;
&#125;
常见api示例
fn enum_api_example() &#123;
    let option1 = Some(5);
    let option2: Option&lt;i32> = None;

    let option_mapped = option1.map(|x: i32| x * 2); // 使用 map 方法对 Some 值进行操作
    println!("Option1 after map: &#123;:?&#125;", option_mapped); // 对 Some 值进行操作
    let option2_mapped = option2.map(|x: i32| x * 2); // 对 None 值进行操作时不会执行闭包
    println!("Option2 after map: &#123;:?&#125;", option2_mapped); // 对 None 值进行操作

    option1.and_then(|x: i32| Some(x * 2)); // and_then 方法用于链式调用
    option2.and_then(|x: i32| Some(x * 2)); // 对 None 值进行操作时不会执行闭包
    let option1_or_else = option1.or_else(|| Some(0)); // or_else 方法用于提供默认值
    println!("Option1 or else: &#123;:?&#125;", option1_or_else); // 对 Some 值提供默认值
    let option2_or_else = option2.or_else(|| Some(10)); // 对 None 值提供默认值
    println!("Option2 or else: &#123;:?&#125;", option2_or_else); // 对 None 值提供默认值
    option1.unwrap_or(0); // unwrap_or 方法用于获取 Some 值或提供默认值
    option2.unwrap_or(0); // 对 None 值提供默认值
    option1.is_some(); // 检查是否为 Some 值
    option2.is_some(); // 检查是否为 Some 值
    option1.is_none(); // 检查是否为 None 值

    let result: Result&lt;i32, i32> = Ok(1);
    let error: Result&lt;(), &amp;str> = Err("An error occurred");
    result.map(|_| println!("Success!")); // 使用 map 方法对 Ok 值进行操作
    error.map(|_| println!("Success!")); // 对 Err 值进行操作时
    // 不会执行闭包
    result.and_then(|val| Ok(val)); // and_then 方法用于链式调用 返回的是result类型
    error.and_then(|val| Ok(val)); // 对 Err 值进行操作时不会执行闭包
    // ⚠️ or_else只会在 Err 分支执行
    result.or_else(|val: i32| Err(val)); // or_else 方法用于提供默认值
    error.or_else(|_| Err(())); // 对 Err 值提供默认值
    result.unwrap_or_else(|val: i32| 1); // unwrap_or_else 返回的是最终的值
    error.unwrap_or_else(|val| &#123;
        println!("Error occurred: &#123;&#125;", val);
        ()
    &#125;); // 对 Err 值提供默认值
    result.is_ok(); // 检查是否为 Ok 值
    error.is_ok(); // 检查是否为 Ok 值
    result.is_err(); // 检查是否为 Err 值
    error.is_err(); // 检查是否为 Err 值
&#125;


⚠️ 坑

unwrap_or_else 得到的是最终的值（T）。
or_else 得到的是另一个 Option/Result（Option 或 Result&lt;T, E&gt;）。
or_else 只会在 Err 的时候调用闭包，而闭包参数 val 的类型应该是 E（也就是 Err 的类型），而不是 Ok 的类型


练习：
分析enum的内存大小
#[test]
fn enum_size_analysis() &#123;
    use std::mem::size_of;

    enum MyEnum &#123;
        A(u8, u8),
        B,
        C &#123;&#125;,
    &#125;
    enum EnumA1 &#123;
        A = 255,
    &#125;
    enum EnumA2 &#123;
        A = 255,
        B,
    &#125;

    println!("MyEnum size: &#123;&#125; bytes", size_of::&lt;MyEnum>());
    println!("EnumA1 size: &#123;&#125; bytes", size_of::&lt;EnumA1>());
    println!("EnumA2 size: &#123;&#125; bytes", size_of::&lt;EnumA2>());
&#125;
结构体
创建
struct User &#123;
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
&#125;
pub fn struct_example() &#123;
    // 创建结构体实例
    // 1.每个字段都需要实例化
    // 2.字段顺序可以任意
    // 3.字段名逗号分隔
    let username = String::from("someusername123");
    let user1 = User &#123;
        active: true,
        username, // 简写
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    &#125;;

    let user2 = User &#123;
        email: String::from("another@example.com"),
        ..user1 // 结构体更新语法，没有逗号
    &#125;;
&#125;
常见使用
// 1. 访问字段
println!("The username is &#123;&#125;", user1.email);

//2 修改结构体字段（可变性）
  //      整个实例必须是可变的
  let mut user1 = User &#123;
      active: true,
      username: String::from("someusername123"),
      email: String::from("someone@example.com"),
      sign_in_count: 1,
  &#125;;
  user1.email = String::from("anotheremail@example.com");


元祖结构体(tuple struct)

struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
//3 使用元组结构体
fn tuple_strut() &#123;
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);
    let black = Color(0, 0, 0);
    println!("&#123;&#125;", black.0);
&#125;
单元结构体(unit-like struct)
// 单元结构体
fn unit_struct() &#123;
    // 单元结构体创建
    let always_equal = AlwaysEqual;
    // 我们不关心AlwaysEqual实例中的任何内容，我们只关心其类型，然后可以为它实现某个特征
    impl SomeTrait for AlwaysEqual &#123;
        // 函数体省略
    &#125;
&#125;

//单元结构体
struct AlwaysEqual;

所有权
&#123;//3 所有权
    let user1 = User &#123;
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    &#125;;

    let email = user1.email;
    println!("&#123;&#125;", user1.email);// 所有权转移


    print_user(user1);// 这里也会报错
&#125;

fn print_user(user: User) &#123;
    println!("&#123;:?&#125;", user);
&#125;
--------------------------------------------------
error[E0382]: borrow of moved value: `user1.email`
  --> src/struct_example.rs:44:20
   |
43 |     let email = user1.email;
   |                 ----------- value moved here
44 |     println!("&#123;&#125;", user1.email);// 所有权转移
   |                    ^^^^^^^^^^^ value borrowed here after move


一旦结构体中某一个字段发生了所有权移动，那么整个结构体都会不能再赋值了
使用没有实现copy特性的类型，都会发生所有权的转移。


定义方法
/**
 * 结构体方法的使用
 */

struct Rectangle &#123;
    width: u32,
    height: u32,
&#125;

impl Rectangle &#123;
    fn new(width: u32, height: u32) -> Self &#123;
              // new 方法可以创建一个 Self 的实例
        Self &#123; width, height &#125;
    &#125;
    fn set_width(&amp;mut self, width: u32) &#123;
        self.width = width;
    &#125;
    fn area(&amp;self) -> u32 &#123;
        self.width * self.height
    &#125;

    fn is_wide(&amp;self) -> bool &#123;
        self.width > self.height
    &#125;

    fn can_hold(&amp;self, other: &amp;Rectangle) -> bool &#123;
        self.width > other.width &amp;&amp; self.height > other.height
    &#125;
&#125;


#[test]
fn struct_function_example() &#123;
    let rect1 = Rectangle &#123;
        width: 30,
        height: 50,
    &#125;;
    println!(
        "The area of the rectangle is &#123;&#125; square pixels.",
        rect1.area()
    );
    let mut rect2 = Rectangle &#123;
        width: 30,
        height: 50,
    &#125;;
    rect2.set_width(20);
    println!(
        "The area of the rectangle is &#123;&#125; square pixels.",
        rect2.area()
    );
  
    if rect2.is_wide() &#123;
        println!("The rectangle is wide.");
    &#125; else &#123;
        println!("The rectangle is not wide.");
    &#125;

    // 使用new
    let rect3 = Rectangle::new(30, 50);

    // can_hold
    println!(
        "The area of the rectangle is &#123;&#125; square pixels.",
        Rectangle::area(&amp;rect3)
    );
&#125;

实现trait
实现了通用的计算逻辑
trait Shape &#123;
    fn area(&amp;self) -> u32;
&#125;

impl Shape for Rectangle &#123;
    fn area(&amp;self) -> u32 &#123;
        self.width * self.height
    &#125;
&#125;

trait Shape &#123;
    fn area(&amp;self) -> u32;
&#125;

impl Shape for Rectangle &#123;
    fn area(&amp;self) -> u32 &#123;
        self.width * self.height
    &#125;
&#125;

impl Shape for Circle &#123;
    fn area(&amp;self) -> u32 &#123;
        3 * self.radius * self.radius
    &#125;
&#125;

// 新建一个圆形
struct Circle &#123;
    radius: u32,
&#125;
impl Circle &#123;
    fn new(radius: u32) -> Self &#123;
        Circle &#123; radius &#125;
    &#125;
&#125;


/**
 * 通过impl Trait可以创建一个函数，
 * 这个函数的参数是任何实现了Shape trait的类型。
 * 这个函数可以传入圆形和矩形，都可以进行area计算，实现了通用的计算逻辑
 */
fn print_area(shape: &amp;impl Shape) &#123;
    println!("&#123;&#125;", shape.area());
&#125;

#[test]
fn test_trait_impl() &#123;
    // 使用trait通用计算
    let rect4 = Rectangle::new(30, 50);
    let circle1 = Circle::new(100);
    print_area(&amp;rect4);
    print_area(&amp;circle1);
&#125;

自己实现Display
如果我们想打印出来整个矩形，该如何处理呢
use std::fmt::Display;

impl Display for Rectangle &#123;
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_>) -> std::fmt::Result &#123;
        for _ in 0..self.height &#123;
            let mut s = String::new();
            for w in 0..self.width &#123;
                s.push('6');
            &#125;
            write!(f, "&#123;&#125;\n", s);
        &#125;

        Ok(())
    &#125;
&#125;

#[test]
fn print_the_rectangle() &#123;
    let rect1 = Rectangle &#123;
        width: 30,
        height: 50,
    &#125;;
    println!("&#123;&#125;", rect1);
&#125;

成功：

自己实现debug
一般可以通过派生来实现debug
#[derive(Debug)]
struct Rectangle &#123;
    width: u32,
    height: u32,
&#125;
就可以使用&quot;&#123;:?&#125;&quot; 打印结构体
#[test]
fn print_the_rectangle() &#123;
    let rect1 = Rectangle &#123;
        width: 30,
        height: 50,
    &#125;;

    println!("&#123;:?&#125;", rect1);
&#125;
----------------------------
Rectangle &#123; width: 30, height: 50 &#125;

不使用派生,自己实现：
use std::fmt::Debug;
impl Debug for Rectangle &#123;
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_>) -> std::fmt::Result &#123;
        write!(
            f,
            "Rectangle: width: &#123;&#125;, height: &#123;&#125;",
            self.width, self.height
        );

        Ok(())
    &#125;
&#125;
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础[part8]_模式匹配、常见集合</title>
    <url>/2025/07/15/Rust%E5%9F%BA%E7%A1%80-part8-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E3%80%81%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[Rust基础[part8]_模式匹配、常见集合
模式匹配
检查数据结构，提高代码的可读性和简洁性，减少错误，尤其在处理复杂数据结构的时候
基础模式匹配
fn match_example() &#123;
    let x = 5;
    // 必须要有所有可能的case
    match x &#123;
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("something else"),
    &#125;
&#125;
守卫
在模式匹配中，可以总使用守卫来添加额外的条件判断。
let x = 5;
match x &#123;
    n if n > 5 => println!("x is greater than 5"),
    _ => println!("x is less than or equal to 5"),
&#125;
绑定
在模式匹配中，可以使用绑定来将模式中的值绑定到变量上
@ 0..=5这个是用来指定范围的
// 绑定：可以把匹配到的值绑定到一个变量上
    let enum1 = MyEnum::Hello &#123; a: 5 &#125;;
    match enum1 &#123;
        MyEnum::Hello &#123; a: val @ 0..=5 &#125; => println!("x is &#123;&#125;", val),
        MyEnum::Hello &#123; a: val @ 5.. &#125; => println!("x is &#123;&#125;", val),
        MyEnum::B(s) => println!("s is &#123;&#125;", s),
        MyEnum::C => println!("C"),
        _ => println!("something else"),
    &#125;
应用场景


处理错误
/**
 * 匹配模式应用场景
 */
fn pattern_match_example() &#123; 
    // 1 匹配错误
    match divide(3, 2) &#123;
        Ok(result) => println!("Result: &#123;&#125;", result),
        Err(error) => println!("Error: &#123;&#125;", error),
    &#125;
&#125;

fn divide(a: i32, b: i32) -> Result&lt;i32, String> &#123;
    if b == 0 &#123;
        return Err("Division by zero is not allowed".to_string());
    &#125; else &#123;
        Ok(a / b)
    &#125;
&#125;



解析命令行参数


解析配置文件


解析数据包


解析XML或JSON


高级匹配技巧
嵌套模式
这里 Message::Move &#123; x, y &#125; 是一个嵌套模式，因为它：

匹配外层枚举变体 Message::Move
同时解构了内部的结构体字段 &#123; x: i32, y: i32 &#125;

这样你就可以在一个步骤中直接访问到 x 和 y。
enum Message &#123;
      Quit,
      Move &#123; x: i32, y: i32 &#125;,
      Write(String),
      ChangeColor(i32, i32, i32),
  &#125;
  let msg = Message::Move &#123; x: 10, y: 20 &#125;;

  match msg &#123;
      Message::Quit => println!("Quit"),
      Message::Move &#123; x, y &#125; => println!("Move to (&#123;&#125;, &#123;&#125;)", x, y),
      Message::Write(text) => println!("Write: &#123;&#125;", text),
      Message::ChangeColor(r, g, b) => println!("Change color to (&#123;&#125;, &#123;&#125;, &#123;&#125;)", r, g, b),// 可以使用enum中的参数
  &#125;
匹配模式和迭代器：结合iter和match使用

for (a, b) 中的括号结构本质上是一种模式匹配语法
它和 match 一样可以解构元组、结构体、枚举等复杂类型
iter() 提供了迭代器的能力，match（或模式匹配）提供了结构解构的能力
所以这段代码体现了 iter 和 match 的结合使用

fn iterator_match_example() &#123; 
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];
    for (a, b) in vec1.iter().zip(vec2)  &#123;
        println!("&#123;&#125; + &#123;&#125; = &#123;&#125;", a, b, a+b);
    &#125;
&#125;
if let 和while let： 简化单个模式匹配
fn if_let_example() &#123;
    let option = Some(5);
    if let Some(x) = option &#123;
        println!("&#123;&#125;", x);
    &#125;
&#125;

fn while_let_example() &#123;
    let mut vec = vec![1, 2, 3];
    while let Some(x) = vec.pop() &#123;
        println!("&#123;&#125;", x);
    &#125;
&#125;
ref和ref mut

借用数据而不转移所有权：在某些情况下，你只需要借用数据而不是转移所有权。例如在递归数据结构中，借用数据可以避免所有权转移带来的复杂性
对数据进行修改：使用ref mut 可以在模式匹配时对对数据进行修改，而无需转移所有权

fn ref_example() &#123;
    let x = 5;
    match x &#123;
        ref var => println!("&#123;&#125;", var),
        _ => &#123;&#125;
    &#125;
&#125;

fn ref_mut_example() &#123;
    let mut x = 5;
    match x &#123;
        ref mut var => &#123;
            *var += 1;
        &#125;
        _ => &#123;&#125;
    &#125;
&#125;

练习
目标

理解如何使用 Rust 的模式匹配功能解析 JSON 数据。
学会使用 serde_json 库进行 JSON 处理。
练习在实际应用场景中使用模式匹配。

要求

使用 serde_json 库解析 JSON 字符串。
使用模式匹配提取 JSON 对象中的不同字段。
处理不同类型的数据（字符串、数字、数组、嵌套对象等）。

示例
假设你有一个包含用户信息的 JSON 字符串：
&#123;
  "name": "Alice",
  "age": 30,
  "email": "alice@example.com",
  "address": &#123;
    "street": "123 Main St",
    "city": "Wonderland"
  &#125;,
  "phone_numbers": ["123-456-7890", "987-654-3210"]
&#125;
答案：
use serde_json::&#123;Result, Value&#125;;
use std::fmt;

// 定义错误类型（替代简单的 String 错误）
#[derive(Debug)]
enum ParseError &#123;
    Json(serde_json::Error),
    FieldMissing(&amp;'static str),
    TypeMismatch(&amp;'static str, &amp;'static str), // 字段名 + 期望类型
    NumberRange(&amp;'static str), // 数字超出范围
&#125;

impl fmt::Display for ParseError &#123;
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -> fmt::Result &#123;
        match self &#123;
            ParseError::Json(e) => write!(f, "JSON 解析错误: &#123;e&#125;"),
            ParseError::FieldMissing(field) => write!(f, "字段缺失: &#123;field&#125;"),
            ParseError::TypeMismatch(field, expect) => &#123;
                write!(f, "字段 &#123;field&#125; 类型错误，期望 &#123;expect&#125;")
            &#125;
            ParseError::NumberRange(field) => write!(f, "字段 &#123;field&#125; 数值超出范围"),
        &#125;
    &#125;
&#125;

impl From&lt;serde_json::Error> for ParseError &#123;
    fn from(e: serde_json::Error) -> Self &#123;
        ParseError::Json(e)
    &#125;
&#125;

#[derive(Debug)]
struct Address &#123;
    street: String,
    city: String,
&#125;

#[derive(Debug)]
struct Info &#123;
    name: String,
    age: u32,
    email: String,
    address: Address,
    phone_numbers: Vec&lt;String>,
&#125;

// 解析函数：使用模式匹配提取字段，返回 Result 处理错误
fn parse_json(json: &amp;str) -> Result&lt;Info, ParseError> &#123;
    let value: Value = serde_json::from_str(json)?;

    // 1. 提取 name（字符串类型）
    let name = match value.get("name") &#123;
        Some(Value::String(s)) => s.to_string(),
        Some(_) => return Err(ParseError::TypeMismatch("name", "字符串")),
        None => return Err(ParseError::FieldMissing("name")),
    &#125;;

    // 2. 提取 age（非负整数，且在 u32 范围内）
    let age = match value.get("age") &#123;
        Some(Value::Number(n)) => &#123;
            n.as_u64()
                .ok_or(ParseError::TypeMismatch("age", "非负整数"))?
                .try_into()
                .map_err(|_| ParseError::NumberRange("age"))?
        &#125;
        Some(_) => return Err(ParseError::TypeMismatch("age", "数字")),
        None => return Err(ParseError::FieldMissing("age")),
    &#125;;

    // 3. 提取 email（字符串类型）
    let email = match value.get("email") &#123;
        Some(Value::String(s)) => s.to_string(),
        Some(_) => return Err(ParseError::TypeMismatch("email", "字符串")),
        None => return Err(ParseError::FieldMissing("email")),
    &#125;;

    // 4. 提取嵌套对象 address
    let address = match value.get("address") &#123;
        Some(Value::Object(obj)) => &#123;
            let street = match obj.get("street") &#123;
                Some(Value::String(s)) => s.to_string(),
                Some(_) => return Err(ParseError::TypeMismatch("address.street", "字符串")),
                None => return Err(ParseError::FieldMissing("address.street")),
            &#125;;
            let city = match obj.get("city") &#123;
                Some(Value::String(s)) => s.to_string(),
                Some(_) => return Err(ParseError::TypeMismatch("address.city", "字符串")),
                None => return Err(ParseError::FieldMissing("address.city")),
            &#125;;
            Address &#123; street, city &#125;
        &#125;
        Some(_) => return Err(ParseError::TypeMismatch("address", "对象")),
        None => return Err(ParseError::FieldMissing("address")),
    &#125;;

    // 5. 提取数组 phone_numbers（元素为字符串）
    let phone_numbers = match value.get("phone_numbers") &#123;
        Some(Value::Array(arr)) => &#123;
            arr.iter()
                .map(|elem| match elem &#123;
                    Value::String(s) => Ok(s.to_string()),
                    _ => Err(ParseError::TypeMismatch("phone_numbers 元素", "字符串")),
                &#125;)
                .collect::&lt;Result&lt;Vec&lt;_>, _>>()?
        &#125;
        Some(_) => return Err(ParseError::TypeMismatch("phone_numbers", "数组")),
        None => return Err(ParseError::FieldMissing("phone_numbers")),
    &#125;;

    Ok(Info &#123;
        name,
        age,
        email,
        address,
        phone_numbers,
    &#125;)
&#125;

fn main() &#123;
    let json_str = r#"
    &#123;
        "name": "Alice",
        "age": 30,
        "email": "alice@example.com",
        "address": &#123;
            "street": "123 Main St",
            "city": "Wonderland"
        &#125;,
        "phone_numbers": ["123-456-7890", "987-654-3210"]
    &#125;
    "#;

    match parse_json(json_str) &#123;
        Ok(info) => println!("解析结果:\n&#123;:#?&#125;", info),
        Err(e) => eprintln!("解析失败: &#123;e&#125;"),
    &#125;
&#125;
常见集合
Vec
基本用法

创建和初始化
添加元素
访问元素
修改元素
遍历元素

// 创建一个空的vec
    let mut v: Vec&lt;i32> = Vec::new();
    // 使用宏来创建一个veck k
    let mut v1: Vec&lt;i32> = vec![1, 2, 3];

    // 添加元素
    v.push(5);

    // 访问元素
    // 1.使用索引
    let third: &amp;i32 = &amp;v[2];
    println!("The third element is &#123;&#125;", third);
    // 2.使用get方法
    match v.get(2) &#123;
        Some(third) => println!("The third element is &#123;&#125;", third),
        None => println!("There is no third element."),
    &#125;

    // 修改元素
    v[0] = 4;

    // 迭代元素
    for i in &amp;v &#123;
        println!("&#123;&#125;", i);
    &#125;
高阶用法：
// 进阶的用法
  // 1.使用枚举来存储多种类型
  enum SpreadsheetCell &#123;
      Int(i32),
      Float(f64),
      Text(String),
  &#125;

  let row = vec![
      SpreadsheetCell::Int(3),
      SpreadsheetCell::Text(String::from("blue")),
      SpreadsheetCell::Float(10.12),
  ];

  // 2.容量与重新分配
  let mut v = Vec::with_capacity(10);
  v.push(1);
  println!("&#123;&#125;", v.capacity());

常见错误:


不安全的索引访问，所以最好使用match
// 不安全的索引访问
    let v2 = vec![1, 2, 3, 4, 5];
    // println!("&#123;&#125;", v2[100]); // 运行时会出错



可变引用与不可变引用的混用

// 可变引用和不可变引用混用
    let mut v3 = vec![1, 2, 3, 4, 5];
    let first = &amp;v3[0];
    v3.push(6); // 这里会报错
    println!("&#123;&#125;", first);

---------------
cannot borrow `v3` as mutable because it is also borrowed as immutable
mutable borrow occurs hererustcClick for full compiler diagnostic

修复的话可以分两种，可以修改push的顺序，或者使用作用域的特性来控制引用的生命周期
// 第一种
v3.push(6);
let first: &amp;i32 = &amp;v3[0];

// 第二种
&#123;
        let first: &amp;i32 = &amp;v3[0];
        println!("&#123;&#125;", first);
    &#125;
    v3.push(6);


HashMap
基本操作
// 基本操作
  let mut scores: HashMap&lt;String, i32> = HashMap::new();
  scores.insert(String::from("Blue"), 10);
  scores.insert(String::from("Yellow"), 50);

  // 获取元素
  let team_name = String::from("Blue");
  let score: Option&lt;&amp;i32> = scores.get(&amp;team_name);

  match score &#123;
      Some(score) => println!("&#123;&#125;", score),
      None => println!("None"),
  &#125;

  // 遍历
  for (key, value) in &amp;scores &#123;
      println!("&#123;&#125; : &#123;&#125;", key, value);
  &#125;
进阶操作


更新哈希表
// 更新
   scores.insert(String::from("Blue"), 25);
   scores.entry(String::from("Blue")).or_insert(50);
  


合并哈希表
// 合并两个集合
  let mut map1 = HashMap::new();
  map1.insert(1, "one");
  let mut map2 = HashMap::new();
  map2.insert(2, "two");
  map2.insert(3, "three");
  for (k, v) in &amp;map2 &#123;
      map1.entry(*k).or_insert(&amp;v);
  &#125;
  println!("&#123;:?&#125;", map1);


常见陷阱


哈希冲突


所有权问题


fn hashmap_ownership() &#123;
    let mut scores = HashMap::new();
    let team_name = String::from("Blue");
    let team_score = 10;
    scores.insert(team_name, team_score);
    println!("&#123;:?&#125;", scores);

    println!("&#123;&#125;", team_name); // 这里会报错
修改为.clone()
scores.insert(team_name.clone(), team_score.clone());
练习

使用Vec实现一个简单的栈

struct Stack&lt;T> &#123;
    elements: Vec&lt;T>,
&#125;

impl&lt;T> Stack&lt;T> &#123;
    // 初始化空栈
    fn new() -> Self &#123;
        Stack &#123;
            elements: Vec::new(),
        &#125;
    &#125;

    // 入栈：向尾部添加元素
    fn push(&amp;mut self, item: T) &#123;
        self.elements.push(item);
    &#125;

    // 出栈：移除并返回尾部元素（空栈时返回 None）
    fn pop(&amp;mut self) -> Option&lt;T> &#123;
        self.elements.pop()
    &#125;

    // 查看栈顶：返回尾部元素的引用（空栈时返回 None）
    fn peek(&amp;self) -> Option&lt;&amp;T> &#123;
        self.elements.last()
    &#125;
&#125;
#[test]
// 测试用例
fn main() &#123;
    let mut stack = Stack::new();
    stack.push(1);
    stack.push(2);
    stack.push(3);

    println!("栈顶元素（peek）: &#123;:?&#125;", stack.peek()); // 输出: Some(3)
    println!("出栈元素（pop）: &#123;:?&#125;", stack.pop()); // 输出: Some(3)
    println!("出栈后栈顶: &#123;:?&#125;", stack.peek()); // 输出: Some(2)
&#125;


使用HashMap实现字频统计器

/**
 * 通过hashmap计算单词频率
 */

fn count_frequency(s: &amp;str) -> HashMap&lt;&amp;str, i32> &#123;
    let mut letters: HashMap&lt;&amp;str, i32> = HashMap::new();
    for ch in s.split_whitespace() &#123;
        letters
            .entry(ch)
            .and_modify(|counter| *counter += 1)
            .or_insert(1);
    &#125;
    return letters;
&#125;

#[test]
fn test_count_frequency() &#123;
    let s = "hello world hello rust";
    let letters = count_frequency(s);
    println!("&#123;:?&#125;", letters);
&#125;


使用Vec和HashMap实现一个简单的书籍库存管理系统：

// 库存管理系统
struct InventorySystem &#123;
    books: Vec&lt;Book>,                 // 存储所有书籍
    id_to_index: HashMap&lt;u32, usize>, // ID -> Vec索引的映射
    next_id: u32,                     // 下一个可用ID（自增）
&#125;

impl InventorySystem &#123;
    // 初始化空系统
    fn new() -> Self &#123;
        InventorySystem &#123;
            books: Vec::new(),
            id_to_index: HashMap::new(),
            next_id: 1, // ID从1开始
        &#125;
    &#125;

    // 添加书籍：自动分配ID，返回新书籍ID
    fn add_book(&amp;mut self, title: String, author: String, quantity: u32) -> u32 &#123;
        let id = self.next_id;
        self.next_id += 1;

        let book = Book &#123;
            id,
            title,
            author,
            quantity,
        &#125;;
        let index = self.books.len();
        self.books.push(book);
        self.id_to_index.insert(id, index); // 记录ID与索引的映射

        id
    &#125;

    // 按ID查询书籍：返回Option&lt;&amp;Book>（不存在则返回None）
    fn get_book(&amp;self, id: u32) -> Option&lt;&amp;Book> &#123;
        self.id_to_index.get(&amp;id).map(|&amp;index| &amp;self.books[index]) // 通过索引取书籍引用
    &#125;

    // 按标题模糊查询：返回所有包含该标题的书籍
    fn search_by_title(&amp;self, title: &amp;str) -> Vec&lt;&amp;Book> &#123;
        self.books
            .iter()
            .filter(|book| book.title.contains(title))
            .collect()
    &#125;

    // 更新库存：按ID修改数量，返回是否成功
    fn update_quantity(&amp;mut self, id: u32, new_quantity: u32) -> bool &#123;
        if let Some(&amp;index) = self.id_to_index.get(&amp;id) &#123;
            self.books[index].quantity = new_quantity;
            true
        &#125; else &#123;
            false
        &#125;
    &#125;

    // 删除书籍：按ID删除，返回是否成功
    // （注：删除时将最后一本书移到被删位置，保证Vec索引一致性）
    fn remove_book(&amp;mut self, id: u32) -> bool &#123;
        if let Some(index) = self.id_to_index.remove(&amp;id) &#123;
            // 若删除的不是最后一本书，将最后一本书移到删除位置
            if index &lt; self.books.len() - 1 &#123;
                let last_book = self.books.pop().unwrap(); // 取出最后一本书
                self.books[index] = last_book.clone(); // 覆盖到删除位置
                self.id_to_index.insert(last_book.id, index); // 更新最后一本书的索引映射
            &#125; else &#123;
                self.books.pop(); // 删除最后一本书，无需调整映射
            &#125;
            true
        &#125; else &#123;
            false
        &#125;
    &#125;
&#125;

// 测试用例
#[test]
fn test_inventory_system() &#123;
    let mut inventory = InventorySystem::new();

    // 添加书籍
    let id1 = inventory.add_book("Rust编程入门".to_string(), "张三".to_string(), 10);
    let id2 = inventory.add_book("Effective Rust".to_string(), "李四".to_string(), 5);

    // 查询书籍
    println!("书籍1: &#123;&#125;", inventory.get_book(id1).unwrap());
    println!("书籍2: &#123;&#125;", inventory.get_book(id2).unwrap());

    // 更新库存
    inventory.update_quantity(id1, 20);
    println!("更新后书籍1: &#123;&#125;", inventory.get_book(id1).unwrap());

    // 模糊查询
    let results = inventory.search_by_title("Rust");
    println!("含'Rust'的书籍:");
    for book in results &#123;
        println!("&#123;&#125;", book);
    &#125;

    // 删除书籍
    inventory.remove_book(id2);
    println!("删除书籍2后，查询是否存在: &#123;:?&#125;", inventory.get_book(id2));
&#125;


]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础[part4]_基本类型,所有权</title>
    <url>/2025/07/11/Rust%E5%9F%BA%E7%A1%80%5Bpart4%5D_%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B,%E6%89%80%E6%9C%89%E6%9D%83/</url>
    <content><![CDATA[Rust基础[part4]_基本类型,所有权
Rust类型
概览
以下是整合后的 Rust 类型说明表格：



类型
说明
值




i8、i16、i32、i64、i128、u8、u16、u32、u64、u128
给定位宽的有符号整数和无符号整数
42、-5i8、0x400u16、0o100i16、20_922_789_888_000u64、b'*'（u8 字节字面量）


isize、usize
与机器字（32 位或 64 位）一样大的有符号整数和无符号整数
137、-0b0101_0010isize、0xffff_fc00usize


f32、f64
单精度 IEEE 浮点数和双精度 IEEE 浮点数
1.61803、3.14f32、6.0221e23f64


bool
布尔值
true、false


char
Unicode 字符，32 位宽（4 字节）
'*'、'\n'、'字'、'\x7f'、'\u&#123;...&#125;'（Unicode 转义）


(char, u8, i32)
元组，允许混合类型
('%', 0x7f, -1)


()
“单元”（空元组）
()


struct S &#123; x: f32, y: f32 &#125;
具名字段型结构体
S &#123; x: 120.0, y: 209.0 &#125;


struct T(i32, char);
元组型结构体
T (120, 'X')


struct E;
单元型结构体，无字段
E


enum Attend &#123; OnTime, Late(u32) &#125;
枚举，或代数数据类型
Attend::Late(5)、Attend::OnTime


Box&lt;Attend&gt;
Box：指向堆中值的拥有型指针
Box::new(Late(15))


&amp;i32、&amp;mut i32
共享引用和可变引用：非拥有型指针，其生命周期不能超出引用目标
&amp;s.y、&amp;mut v


String
UTF-8 字符串，动态分配大小
&quot; ラーメン : ramen&quot;.to_string()


&amp;str
对 str 的引用：指向 UTF-8 文本的非拥有型指针
&quot; そば : soba&quot;、&amp;s[0..12]


[f64; 4]、[u8; 256]
数组，固定长度，其元素类型都相同
[1.0, 0.0, 0.0, 1.0]、[b' '; 256]


Vec&lt;f64&gt;
向量，可变长度，其元素类型都相同
vec![0.367, 2.718, 7.389]


&amp;[u8]、*mut [u8]
对切片（数组或向量某一部分）的引用，包含指针和长度
&amp;v[10..20]、&amp;mut a[..]


Option&lt;&amp;str&gt;
可选值：或者为 None（无值），或者为 Some(v)（有值，其值为 v）
Some(&quot;Dr.&quot;)、None


Result
可能失败的操作结果：或者为成功值 Ok(v)，或者为错误值 Err(e)
Ok(4096)、Err(Error::last_os_error())


&amp;dyn Any、&amp;mut dyn Read
特型对象，是对任何实现了一组给定方法的值的引用
value as &amp;dyn Any、&amp;mut file as &amp;mut dyn Read


fn(&amp;str) -&gt; bool
函数指针
str::is_empty


（闭包类型没有显式书写形式）
闭包
`


x..=y
序列
1..=4



整型



大小
有符号
无符号




8 位
i8
u8


16 位
i16
u16


32 位
i32
u32


64 位
i64
u64


128 位
i128
u128


视架构而定
isize
usize



pub fn print_int_show() &#123;
    let integer: i32 = 2147483647; // 最大值
    let integer: i32 = -2147483648; // 最小值
    let integer: i32 = 0x1F; // 十六进制
    let integer: i32 = 0o17; // 八进制
    let integer: i32 = 0b1111_0000; // 二进制
    let integer: i32 = 1_000_000; // 使用下划线分隔数字
    let integer: u8 = b'A'; // 字符转换为整数
&#125;
浮点型
浮点类型数数字，带有小数点，基本两种类型是：f32和f64
默认为f64，精度更高，速度基本和f32相同
但是一般在区块链应用中，一般都使用i128， 因为精度的问题
精度问题
精度问题，Rust 作为一门注重内存安全和性能的系统级编程语言，在处理数值精度时遵循明确的规则，但也存在一些需要开发者注意的潜在陷阱。
assert_eq!(0.1 + 0.2, 0.3); // 浮点数相加 这里会failed
println!("0.1 + 0.2 = &#123;:x&#125;", (abc.0 + abc.1).to_bits());
println!("0.3 = &#123;:x&#125;", abc.2.to_bits());
println!("0.1 + 0.2 = &#123;:x&#125;", (xyz.0 + xyz.1).to_bits());
println!("0.3 = &#123;:x&#125;", xyz.2.to_bits());
结果，发现高精度的0.1 + 0.2 的结果和0.3的结果是不同的。
0.1 + 0.2 = 3e99999a
0.3 = 3e99999a
0.1 + 0.2 = 3fd3333333333334
0.3 = 3fd3333333333333
这就是精度问题。

Rust 对整数和浮点数的类型后缀语法有细微差别：

整数：类型后缀直接紧跟数值，无下划线。
例如：1u32、42i64、0xFFu8。
浮点数：类型后缀与数值之间必须有下划线（_）。
例如：0.5_f32、3.14159_f64。


NAN
NAN(Not a Number) ， 用来定义如以下这个平方根，这种数学上未定义的结果。
pub fn nan_example() &#123;
    let nan_value: f64 = (-1.1_f64).sqrt(); // 计算负数的平方根
    assert!(nan_value.is_nan()); // 检查是否为NaN
    println!("NaN: &#123;&#125;", nan_value);
&#125;
布尔类型
占一个字节
pub fn boolean_example() &#123;
    let t = true;
    let f: bool = false;
    println!("true: &#123;&#125;, false: &#123;&#125;", t, f);
&#125;
字符
单引号去声明的，unicode字符也可以作为Rust的字符 ，占用四个字节
pub fn char_example() &#123;
    let c: char = 'A';
    let emoji: char = '😊';// unicode字符也可以作为Rust的字符
    println!("char: &#123;&#125;, emoji: &#123;&#125;", c, emoji);
&#125;

序列
包含需要加上=
pub fn _sequence_example() &#123;
    let seq = 1..=5; // 包含5的范围
    for i in seq &#123;
        println!("Sequence: &#123;&#125;", i);
    &#125;
&#125;
类型强转
as关键字用于在原始类型之间进行类型转换，不适用于复合类型，比如String或其他自定义类型
pub fn convert() &#123;
    let a: i32 = 10;
    let b: f64 = a as f64; // 将i32转换为f64
    println!("Converted value: &#123;&#125;", b);

    let c: f64 = 3.14;
    let d: i32 = c as i32; // 将f64转换为i32
    println!("Converted value: &#123;&#125;", d);
&#125;
练习
https://practice-zh.course.rs/basic-types/numbers.html
错题记录：
// 填空
use std::ops::&#123;Range, RangeInclusive&#125;;
fn main() &#123;
    assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;);
    assert_eq!((1..=5), RangeInclusive::new(1, 5));
&#125;
// 填空，并解决错误
fn main() &#123;
    // 整数加法
    assert!(1u32 + 2 == 3);

    // 整数减法
    assert!(1i32 - 2 == -1);
    assert!(1i8 - 2 == -1);
    
    assert!(3 * 50 == 150);

    assert!(9.6 / 3.2 - 3.0 &lt; 1e-9); 

    assert!(24 % 5 == 4);
    
    // 逻辑与或非操作
    assert!(true &amp;&amp; false == false);
    assert!(true || false == true);
    assert!(!true == false);

    // 位操作
    println!("0011 AND 0101 is &#123;:04b&#125;", 0b0011u32 &amp; 0b0101);
    println!("0011 OR 0101 is &#123;:04b&#125;", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is &#123;:04b&#125;", 0b0011u32 ^ 0b0101);
    println!("1 &lt;&lt; 5 is &#123;&#125;", 1u32 &lt;&lt; 5);
    println!("0x80 >> 2 is 0x&#123;:x&#125;", 0x80u32 >> 2);
&#125;
所有权

零开销内存回收的一种高效实现方式

Rust是一种系统编程语言，其设计目的是确保内存安全并防止数据竞争，而不依赖垃圾回收器。这种内存安全性主要通过所有权系统来进行实现。
为什么需要所有权？
在系统编程语言中，内存管理一直是核心挑战：

手动管理（如 C/C++）：开发者需手动分配和释放内存，易出现悬空指针、内存泄漏等问题。
垃圾回收（如 Java/Go）：自动回收不再使用的内存，但带来运行时开销和不可预测的停顿。

Rust 通过所有权系统在编译期解决内存安全问题，无需垃圾回收，同时保持高性能。
基本规则

每一个值都有所有者(owner);
在任一时刻，值都只有一个所有者;
当所有者离开作用域(scope),值会被丢弃(drop);

move语义
pub fn _ownership_example() &#123;
    let s1: String = String::from("Hello");
    let s2: String = s1; // 转移所有权
    // println!("&#123;&#125;", s1); // 此处会报错，因为s1的所有权已转移
    drop(s2); // rust中可以手动释放资源,但通常不需要这样做,因为Rust会在变量超出作用域时自动释放资源; 注意s1这个时候已经是类似空指针的状态，也不需要去释放
    println!("&#123;&#125;", s2);
&#125;

copy语义
基本数据类型
fn main() &#123;
    let x = 5;
    let y = x;  // x 的值被复制到 y
    
    println!("x = &#123;&#125;, y = &#123;&#125;", x, y); // 两个变量都有效
&#125;
练习
// 用两种方法打印成功s1 和s2的值
    let s1 = String::from("Hello, Rust!");
    let s2 = ownership::take_ownership(s1); 

    //以下代码不能修改
    println!("&#123;&#125;", s1);
    println!("&#123;&#125;", s2);
第一种方法
fn main() &#123;
   
    // 第一种方法
    let s1 = String::from("Hello, Rust!");
    let s2 = take_ownership(s1.clone()); // 使用clone方法复制s1

    //以下代码不能修改
    println!("&#123;&#125;", s1);
    println!("&#123;&#125;", s2);
&#125;
pub fn take_ownership(s: String) -> String &#123;
    s // 返回的是 s的克隆
&#125;
第二种方法
fn main() &#123;
   
    // 第二种方法
    let s1 = String::from("Hello, Rust!");
    let s2 = take_ownership(&amp;s1); // 传递s1的引用

    //以下代码不能修改
    println!("&#123;&#125;", s1);
    println!("&#123;&#125;", s2);
&#125;

// 传入类型改为引用类型
pub fn take_ownership(s: &amp;String) -> &amp;String &#123;
    println!("Taking ownership of: &#123;&#125;", s);
    &amp;s // 返回s的引用
&#125;
后面会详细讲到引用的用法
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础[part9]_返回值和错误处理、模块化</title>
    <url>/2025/07/16/Rust%E5%9F%BA%E7%A1%80%5Bpart9%5D_%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[Rust基础[part9]_返回值和错误处理、模块化
返回值
Option&lt;T&gt;
基本使用
fn option_example() &#123;
    // 创建Option
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option&lt;i32> = None;

    //使用
    let x = plus_one(some_number);
    let y = plus_one(absent_number);
    println!("x: &#123;:?&#125;, y: &#123;:?&#125;", x, y);
&#125;

fn plus_one(x: Option&lt;i32>) -> Option&lt;i32> &#123;
    match x &#123;
        None => None,
        Some(i) => Some(i + 1),
    &#125;
&#125;

辅助函数

unwrap() : 提取option中的值，但是没有值的时候会panic

fn unwrap_example() &#123;
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option&lt;i32> = None;

    println!("some_number: &#123;:?&#125;", some_number.unwrap());
    println!("some_string: &#123;:?&#125;", some_string.unwrap());
    // println!("absent_number: &#123;:?&#125;", absent_number.unwrap());
&#125;


is_some() 和is_none()

fn is_some_example() &#123;
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option&lt;i32> = None;

    println!("some_number: &#123;:?&#125;", some_number.is_some());
    println!("some_string: &#123;:?&#125;", some_string.is_some());
    println!("absent_number: &#123;:?&#125;", absent_number.is_some());
&#125;

fn is_none_example() &#123;
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option&lt;i32> = None;

    println!("some_number: &#123;:?&#125;", some_number.is_none());
    println!("some_string: &#123;:?&#125;", some_string.is_none());
    println!("absent_number: &#123;:?&#125;", absent_number.is_none());
&#125;

错误处理
Rust中的错误主要分为两类：

可恢复错误：通常用于系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响  Result&lt;T,E&gt;
不可恢复错误：全局性或系统性的错误，会比较致命  Panic

Panic

panic! 是 Rust 标准库提供的宏，用于主动引发运行时错误。
当 panic! 被调用时：

程序打印错误信息（包括文件名、行号等）。
展开（unwind）调用栈并清理资源（默认行为）。
最终终止当前线程或整个程序（取决于编译配置）。



常见场景



场景
描述




panic! 显式调用
主动触发 panic


数组越界访问
如 vec[100] 访问长度不足的向量


unwrap() 或 expect() 错误
当 Option 或 Result 为 None 或 Err 时


断言失败
使用 assert!, assert_eq! 等宏检查失败时



行为控制
1. 栈展开（Unwinding）
默认情况下，panic 会：

展开调用栈（stack unwinding）
执行析构函数（drop）
清理资源

这是最安全的方式，但可能带来一定性能开销。
2. 中止（Aborting）
在 [Cargo.toml](file:///Users/tinachan/rust/hello_cargo/Cargo.toml) 中可以配置：
[profile.release]
panic = "abort"

&quot;abort&quot;：直接终止程序，不进行栈展开（适用于嵌入式系统或性能敏感场景）
&quot;unwind&quot;：默认值，保留栈展开行为

示例代码
示例 1：显式 panic
fn main() &#123;
    panic!("这是一个主动 panic");
&#125;
示例 2：数组越界访问
let v = vec![1, 2, 3];
println!("&#123;&#125;", v[99]); // 越界访问触发 panic
示例 3：使用 unwrap() 触发 panic
let s: Option&lt;String> = None;
let _ = s.unwrap(); // 触发 panic
获取 Backtrace（调试信息）
设置环境变量以获取详细的调用栈信息：
RUST_BACKTRACE=1 cargo run
输出将包含完整的调用栈，帮助定位 panic 发生的位置。
panic 处理策略（高级）
你可以通过 std::panic::set_hook 自定义 panic 处理逻辑：
use std::panic;

panic::set_hook(Box::new(|info| &#123;
    println!("自定义 panic 处理：&#123;&#125;", info);
&#125;));

panic!("测试自定义 panic hook");

注意：此方法只能设置一次，通常用于日志记录或崩溃分析工具集成。

Result
在 Rust 中，Result 是一个标准库提供的枚举类型，用于处理可恢复错误（recoverable errors）。与 panic! 不同，Result 允许开发者通过返回值明确地处理成功或失败的情况，是编写健壮程序的核心机制之一。
定义
enum Result&lt;T, E> &#123;
    Ok(T),
    Err(E),
&#125;

T：表示操作成功时返回的值类型。
E：表示操作失败时返回的错误类型。

二、常用操作
1. match 匹配
最基础也最灵活的方式：
#[test]
fn result_example() &#123;
    match divide(19, 0) &#123;
        Ok(result) => println!("result=&#123;&#125;", result),
        Err(err) => println!("&#123;&#125;", err),
    &#125;;
&#125;

fn divide(a: i32, b: i32) -> Result&lt;i32, String> &#123;
    if b == 0 &#123;
        Err("除数不能为0".to_string())
    &#125; else &#123;
        Ok(a / b)
    &#125;
&#125;
2. 提取内部值： unwrap() 和 expect(msg)

unwrap()：如果 Ok 返回内部值；如果是 Err 则触发 panic。
expect(&amp;str)：类似 unwrap()，但可以自定义 panic 消息。

let result = divide(4, 0).unwrap(); // 如果出错会 panic
let result = divide(4, 0).expect("除法计算错误"); // 自定义 panic 消息

⚠️ 注意：仅在测试或确定不会出错的情况下使用。

3. 传播错误:? 运算符
用于在函数中快速传播错误。只能用于返回类型为 Result 的函数中。
fn read_file() -> Result&lt;String, std::io::Error> &#123;
    let content = std::fs::read_to_string("file.txt")?;
    Ok(content)
&#125;
4. 对内部值进行修改：map 、map_err和 and_then

map(f)：对 Ok 值进行映射，不影响 Err。
map_err(f): 可以修改Err类型
and_then(f)： 链式调用，只有当前为 Ok 时才继续执行。

let result = divide(10, 2)
    .map(|x| x * 2)
    .and_then(|x| divide(x, 0));
5. or 和 or_else

or(res)：如果当前是 Err，则使用给定的 Result 替代。
or_else(f)：如果当前是 Err，则调用闭包获取替代值。

let res = divide(4, 0).or(Ok(42)); // 如果出错就返回默认值 42
6. is_ok / is_err / ok() / err()
用于判断状态或转换为 Option。
if result.is_ok() &#123;
    println!("操作成功");
&#125;

let opt = result.ok(); // 转换为 Option&lt;T>
7. 对返回的错误进行处理 err.kind
use std::fs::File;
use std::io::ErrorKind;
fn error_kind_example() &#123;
    let greeting = File::open("hello.txt");

    let greeting_result = match greeting &#123;
        Ok(result) => result,
        Err(err) => match err.kind() &#123;
            ErrorKind::NotFound => File::create("hello.txt").unwrap(),
            other_error => panic!("Error: &#123;&#125;", err),
        &#125;,
    &#125;;
&#125;
三、注意事项


避免滥用 unwrap() 和 expect()：除非你非常确定某个操作不会失败，否则应优先使用 match 或 ? 来处理错误。


错误类型保持一致：在一个项目中，建议统一使用相同的错误类型（如自定义枚举或 anyhow::Error），以便集中处理。


使用 ? 时注意函数签名：只能在返回 Result 或 Option 的函数中使用 ?，否则编译器会报错。


错误信息应清晰具体：不要简单返回 &quot;error&quot;，而应该提供上下文信息，便于调试和日志分析。


配合 From trait 自动转换错误：你可以为自定义错误类型实现 From，从而简化错误传播。


impl From&lt;std::io::Error> for MyError &#123;
    fn from(e: std::io::Error) -> Self &#123;
        MyError::Io(e)
    &#125;
&#125;
这样就可以直接使用 ? 将 std::io::Result 转换为你的错误类型。



操作
用途




match
手动匹配成功或失败情况


unwrap() / expect()
快速获取值，出错 panic


?
向上层传递错误


map() / and_then()
链式处理成功值


or() / or_else()
提供备选错误处理方案



panic 与 Result 的区别



特性
panic!
Result




类型
不可恢复错误
可恢复错误


推荐使用场景
逻辑错误、非法状态
文件读写、网络请求等


是否必须处理
否
是


对性能影响
较大（栈展开）
小






最佳实践




优先使用 Result 而不是 panic!


减少 unwrap() 的使用，尤其在生产代码中


统一错误类型，方便集中处理


使用 ? 简化错误传播逻辑



练习
// 修复call函数的错误
// 当b为None时，按默认值1
fn call(a: i32, b: Option&lt;i32>) -> Result&lt;f64, String> &#123;
    let b = b.unwrap_or(1); // 处理b为None的情况，默认值1
    let r = match divide(a, b) &#123;
        Some(r) => r,
        None => return Err(String::from("Division by zero")), // 捕获除零错误
    &#125;;
    let s = match sqrt(r) &#123;
        Ok(s) => s,
        Err(MathError::NegativeSquareRoot) => &#123;
            return Err(String::from("Cannot compute square root of a negative number")) // 捕获负数平方根错误
        &#125;
    &#125;;
    Ok(s) // 正常返回结果
&#125;

fn divide(a: i32, b: i32) -> Option&lt;f64> &#123;
    if b != 0 &#123;
        Some(a as f64 / b as f64)
    &#125; else &#123;
        None
    &#125;
&#125;

pub enum MathError &#123;
    DivisionByZero,
    NegativeSquareRoot,
&#125;

fn sqrt(x: f64) -> Result&lt;f64, MathError> &#123;
    if x &lt; 0.0 &#123;
        Err(MathError::NegativeSquareRoot)
    &#125; else &#123;
        Ok(x.sqrt())
    &#125;
&#125;
模块化 Modules
Rust 的模块系统用于组织代码结构、控制作用域和可见性。它支持将程序划分为多个逻辑单元（模块），便于代码管理、复用和封装。
package
一般通过cargo new创建的就是一个package，包含library crates和 binary crates，也就是.rs
 Cargo.lock
Cargo.toml
src
├── bin
│   ├── a.rs
│   └── b.rs
├── lib.rs
└── main.rs
crate

crate 是 Rust 中最小的编译单元，可以是一个库（library）或可执行程序（binary）。
每个 crate 都有一个隐式的根模块（root module）：[main.rs](file:///Users/tinachan/rust/hello_cargo/src/main.rs) 或 lib.rs。
所有模块都是从根模块开始组织的。

例如：
src&#x2F;
├── main.rs       &#x2F;&#x2F; 根模块
├── utils.rs      &#x2F;&#x2F; 模块文件
└── utils&#x2F;
    └── logging.rs &#x2F;&#x2F; 子模块文件
Moudles
使用 mod 关键字定义一个模块：
mod a &#123;
    const num: usize = 1;
    fn log1() &#123;
        println!("&#123;&#125;", num);
    &#125;
&#125;

模块可以嵌套定义：
mod a &#123;
    const num: usize = 1;
    fn log1() &#123;
        println!("&#123;&#125;", num);
    &#125;
    mod b &#123;
        // 无论是func还是mod 在外部需要调用的话都需要加上pub
        const num2: usize = 2;
        fn log2() &#123;
            println!("&#123;&#125;", num2);
        &#125;
    &#125;
&#125;
导入模块 use
使用 use 将模块或函数引入当前作用域，简化调用：
use a::b::log2;
use a::log1;

fn main() &#123;
    log1();
    log2(); // 内部的mod需要多层调用
&#125;
重命名 as[重名的情况]：
 use a::&#123;b::log as log1, log as log2&#125;;// use合并

fn main() &#123;
    log1();
    log2(); 
&#125;


mod a &#123;
    const num: usize = 1;
    pub fn log() &#123;
        println!("&#123;&#125;", num);
    &#125;
    pub mod b &#123;
        // 无论是func还是mod 在外部需要调用的话都需要加上pub
        const num2: usize = 2;
        pub fn log() &#123;
            println!("&#123;&#125;", num2);
        &#125;
    &#125;
&#125;
可见性（Visibility）
默认模块中的项是私有的 ; pub 关键字实现公有
fn main() &#123;
    a::log1();
    a::b::log2(); // a内部的mod需要多层调用
&#125;

mod a &#123;
    const num: usize = 1;
    pub fn log1() &#123;
        println!("&#123;&#125;", num);
    &#125;
    pub mod b &#123;
        // 无论是func还是mod 在外部需要调用的话都需要加上pub
        const num2: usize = 2;
        pub fn log2() &#123;
            println!("&#123;&#125;", num2);
        &#125;
    &#125;
&#125;
pub(crate)
限定在mod a中调用
pub(in crate::a) fn log() &#123;
        println!("&#123;&#125;", num);
&#125;
pub(in path)
pub use
Path
通过路径访问

绝对路径

crate::b::log();// 绝对路径访问

相对路径

a::log();// 相对路径访问
workspace
Rust 中用于管理 多个相关包（crate）的功能。工作区允许将多个 crate 组织在同一仓库下，共享依赖、统一构建 / 测试流程。
可以通过在cargo.toml中添加
[workspace] 
members = ["course","lib_add","lib_divide"]

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part1]_智能指针概述&amp;box指针</title>
    <url>/2025/07/18/Rust%E8%BF%9B%E9%98%B6-part1-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A6%82%E8%BF%B0-box%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[Rust进阶[part1]_智能指针概述&amp;box指针
智能指针概述
在Rust中，智能指针是一类特殊的数据结构，它们不仅像普通指针一样可以引用数据，还带有额外的元数据和功能。与普通指针不同，智能指针通常使用结构体实现，并且会实现 Deref 和 Drop 等特定的trait，以提供更强大的功能和更安全的内存管理。
智能指针在Rust编程中扮演着重要的角色，它们能够帮助开发者处理复杂的内存管理场景，确保程序的安全性和性能。例如，在处理动态大小的数据、递归数据结构或者需要自定义资源释放逻辑时，智能指针就显得尤为重要。
Box指针
内存分配到堆上
在Rust中，栈内存的分配和释放是自动且高效的，但栈空间是有限的。对于一些大型的数据结构或者需要在运行时动态确定大小的数据，将其存储在栈上可能会导致栈溢出。这时，我们可以使用 Box 指针将数据分配到堆上。
Box 是Rust标准库中最基本的智能指针之一，它允许我们在堆上分配内存，并将数据存储在其中。通过 Box 指针，我们可以在栈上存储一个指向堆上数据的引用，从而实现对堆上数据的访问。
以下是一个简单的示例，展示了如何使用 Box 将一个整数分配到堆上：
fn main() &#123;
    let boxed_int = Box::new(42);
    println!("The value inside the box is: &#123;&#125;", *boxed_int);
&#125;
在这个示例中，Box::new(42) 创建了一个 Box 指针，它指向堆上存储的整数 42。
通过解引用运算符 *，我们可以访问堆上的数据。
允许处理动态大小类型（DST）
Rust中的动态大小类型（DST）是指在编译时无法确定大小的数据类型，例如切片（[T]）和特征对象（dyn Trait）。
由于栈上的内存分配需要在编译时确定大小，因此无法直接将DST存储在栈上。而 Box 指针可以用于存储DST，因为它会在堆上分配内存，从而避免了栈上内存分配的限制。
以下是一个使用 Box 存储切片的示例：
fn main() &#123;
    let slice: &amp;[i32] = &amp;[1, 2, 3];
    let boxed_slice: Box&lt;[i32]> = Box::from(slice);
    println!("The boxed slice contains: &#123;:?&#125;", boxed_slice);
&#125;
在这个示例中，我们首先创建了一个切片 slice，然后使用 Box::from 方法将其转换为 Box&lt;[i32]&gt; 类型，从而将切片存储在堆上。

// 允许处理动态大小类型，比如结构体和元组
let boxed_tuple = Box::new((String::from("hello"), 5));
println!("Boxed tuple: &#123;:?&#125;", boxed_tuple);

递归数据结构
递归数据结构是指包含自身类型的成员的结构体或枚举。由于递归数据结构的大小在编译时无法确定，因此无法直接将其存储在栈上。Box 指针可以用于解决这个问题，通过在递归数据结构中使用 Box 指针，我们可以将递归成员存储在堆上，从而避免栈溢出的问题。
以下是一个使用 Box 实现链表节点的示例：
#[derive(Debug)]
enum List &#123;
    Cons(i32, Box&lt;List>),
    Nil,
&#125;

fn main() &#123;
    let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!("The list is: &#123;:?&#125;", list);
&#125;
在这个示例中，List 枚举表示一个链表，其中 Cons 变体包含一个整数和一个指向另一个 List 节点的 Box 指针。通过使用 Box 指针，我们可以创建一个递归的链表结构。
类型擦除
类型擦除是指在编译时隐藏具体的类型信息，只保留类型的共性。在Rust中，我们可以使用 Box&lt;dyn Trait&gt; 来实现类型擦除。Box&lt;dyn Trait&gt; 是一个特征对象，它可以存储任何实现了指定特征的类型的值。
以下是一个使用 Box&lt;dyn Trait&gt; 实现类型擦除的示例：
trait Draw &#123;
    fn draw(&amp;self);
&#125;

struct Circle;
impl Draw for Circle &#123;
    fn draw(&amp;self) &#123;
        println!("Drawing a circle");
    &#125;
&#125;

struct Square;
impl Draw for Square &#123;
    fn draw(&amp;self) &#123;
        println!("Drawing a square");
    &#125;
&#125;

fn main() &#123;
    let shapes: Vec&lt;Box&lt;dyn Draw>> = vec![
        Box::new(Circle),
        Box::new(Square),
    ];

    for shape in shapes &#123;
        shape.draw();
    &#125;
&#125;
在这个示例中，我们定义了一个 Draw 特征，并为 Circle 和 Square 结构体实现了该特征。然后，我们创建了一个 Vec&lt;Box&lt;dyn Draw&gt;&gt; 类型的向量，其中存储了 Circle 和 Square 的实例。通过使用 Box&lt;dyn Draw&gt;，我们实现了类型擦除，使得向量可以存储不同类型的形状。
内存管理和性能优化
Box 指针在内存管理方面具有重要的作用。当 Box 指针离开作用域时，Rust会自动调用其 Drop 实现，从而释放堆上分配的内存。这种自动内存管理机制确保了内存的安全性，避免了内存泄漏的问题。
在性能方面，由于 Box 指针涉及到堆上的内存分配和释放，因此会比栈上的内存分配和释放稍微慢一些。但是，对于需要动态分配内存或者处理动态大小类型的场景，使用 Box 指针是必要的。在实际编程中，我们应该根据具体的需求和性能要求来选择合适的内存分配方式。
box的优缺点
优点

动态内存分配：允许在运行时动态分配内存，处理大型数据结构和动态大小类型。
递归数据结构支持：可以用于实现递归数据结构，避免栈溢出的问题。
类型擦除：支持类型擦除，使得代码更加灵活和可复用。
自动内存管理：Rust的所有权系统确保了 Box 指针离开作用域时，堆上的内存会被自动释放，避免了内存泄漏。

缺点

性能开销：堆上的内存分配和释放比栈上的内存分配和释放稍微慢一些，可能会影响性能。
额外的间接访问：使用 Box 指针需要通过指针进行间接访问，可能会增加一定的开销。

Drop Trait
Drop trait 用于自定义当值离开作用域时执行的代码，通常用于释放资源，例如内存、文件句柄、网络连接等。当一个实现了 Drop trait 的值离开作用域时，Rust会自动调用其 drop 方法。
以下是一个简单的示例，展示了如何实现 Drop trait：
struct CustomSmartPointer &#123;
    data: String,
&#125;

impl Drop for CustomSmartPointer &#123;
    fn drop(&amp;mut self) &#123;
        println!("Dropping CustomSmartPointer with data `&#123;&#125;`!", self.data);
    &#125;
&#125;

fn main() &#123;
    let c = CustomSmartPointer &#123; data: String::from("my stuff") &#125;;
    let d = CustomSmartPointer &#123; data: String::from("other stuff") &#125;;
    println!("CustomSmartPointers created.");
&#125;
在这个示例中，我们定义了一个 CustomSmartPointer 结构体，并为其实现了 Drop trait。当 c 和 d 离开作用域时，Rust会自动调用它们的 drop 方法，打印出相应的信息。
Deref Trait
Deref trait 用于重载解引用运算符（*），允许我们自定义指针类型的解引用行为。通过实现 Deref trait，我们可以让自定义的智能指针像普通指针一样使用解引用运算符。
Deref trait 定义了一个 deref 方法，该方法返回一个指向内部数据的引用。
以下是一个简单的示例，展示了如何实现 Deref trait：
use std::ops::Deref;

struct MyBox&lt;T>(T);

impl&lt;T> MyBox&lt;T> &#123;
    fn new(x: T) -> MyBox&lt;T> &#123;
        MyBox(x)
    &#125;
&#125;

impl&lt;T> Deref for MyBox&lt;T> &#123;
    type Target = T;

    fn deref(&amp;self) -> &amp;Self::Target &#123;
        &amp;self.0
    &#125;
&#125;

fn main() &#123;
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
&#125;
在这个示例中，我们定义了一个 MyBox 结构体，并为其实现了 Deref trait。通过实现 deref 方法，我们可以使用解引用运算符 * 来访问 MyBox 内部的数据。
练习
1. 创建一个大型数组并将其分配在堆上，然后测量和比较分配在堆和栈上的性能差异。
使用instant::now() ; 以及elapsed()
use std::time::Instant;

const ARRAY_SIZE: usize = 1000000;

fn main() &#123;
    // 测量栈上分配的时间
    let start_stack = Instant::now();
    let _stack_array: [i32; ARRAY_SIZE] = [0; ARRAY_SIZE];
    let stack_duration = start_stack.elapsed();

    // 测量堆上分配的时间
    let start_heap = Instant::now();
    let _heap_array: Box&lt;[i32]> = vec![0; ARRAY_SIZE].into_boxed_slice();
    let heap_duration = start_heap.elapsed();

    println!("Stack allocation time: &#123;:?&#125;", stack_duration);
    println!("Heap allocation time: &#123;:?&#125;", heap_duration);
&#125;
2. 创建一个包含1_000_000个元素的数据，分别将其分配在堆和栈上。使用std::time::Instant来测量分配和访问时间。
use std::time::Instant;

const ELEMENT_COUNT: usize = 1_000_000;

fn main() &#123;
    // 栈上分配
    let start_stack_alloc = Instant::now();
    let stack_data: [i32; ELEMENT_COUNT] = [0; ELEMENT_COUNT];
    let stack_alloc_time = start_stack_alloc.elapsed();

    let start_stack_access = Instant::now();
    for i in 0..ELEMENT_COUNT &#123;
        let _ = stack_data[i];
    &#125;
    let stack_access_time = start_stack_access.elapsed();

    // 堆上分配
    let start_heap_alloc = Instant::now();
    let heap_data: Box&lt;[i32]> = vec![0; ELEMENT_COUNT].into_boxed_slice();
    let heap_alloc_time = start_heap_alloc.elapsed();

    let start_heap_access = Instant::now();
    for i in 0..ELEMENT_COUNT &#123;
        let _ = heap_data[i];
    &#125;
    let heap_access_time = start_heap_access.elapsed();

    println!("Stack allocation time: &#123;:?&#125;", stack_alloc_time);
    println!("Stack access time: &#123;:?&#125;", stack_access_time);
    println!("Heap allocation time: &#123;:?&#125;", heap_alloc_time);
    println!("Heap access time: &#123;:?&#125;", heap_access_time);
&#125;
通过以上练习，我们可以更深入地了解 Box 指针在堆上分配内存的性能特点，以及与栈上分配的差异。
3. 实现一个简单的文件系统模拟
目标
实现一个简单的文件系统模拟，其中包含文件和文件夹的概念。文件夹可以包含文件和其他文件夹。使用 Box 来管理内存，并实现对文件系统的基本操作（如创建文件、创建文件夹、列出文件和文件夹）。
作业要求


定义 FileSystem trait 和 Node 枚举

FileSystem trait 包含 create_file、create_folder 和 list_contents 方法。
Node 枚举包含 File 和 Folder 变体。



实现 FolderNode 结构体

FolderNode 实现 FileSystem trait，包含 name 和 contents 字段。
使用 Box 管理 contents 中的子节点。



实现文件系统的基本操作

create_file 方法在文件夹中创建文件。
create_folder 方法在文件夹中创建子文件夹。
list_contents 方法列出文件夹的所有内容。



测试文件系统的操作

创建根文件夹并添加文件和文件夹。
创建子文件夹并添加文件。
列出文件夹的内容并输出文件系统结构。



提示

使用 Box 来管理 Folder 中的子节点。
使用递归方法来遍历和列出文件和文件夹的内容。
考虑使用 Vec 来存储文件夹的子节点。

/**
 * ---------------文件系统----------------------------
 */
// 节点枚举 用来区分文件夹还是文件，文件夹通过box包装来避免递归类型的大小歧义
// 定义 Node 枚举：包含文件（File）和文件夹（Folder）两种变体
#[derive(Debug)]
enum Node &#123;
    File(String),            // 文件：存储文件名
    Folder(Box&lt;FolderNode>), // 文件夹：存储 FolderNode 的 Box（避免递归结构的大小问题）
&#125;

// 定义 FileSystem trait：包含文件系统的核心操作
trait FileSystem &#123;
    fn create_file(&amp;mut self, name: String); // 在当前文件夹创建文件
    fn create_folder(&amp;mut self, name: String) -> &amp;mut Self; // 在当前文件夹创建子文件夹（返回子文件夹引用以便链式操作）
    fn list_contents(&amp;self, indent: &amp;str); // 列出当前文件夹内容（带缩进，方便展示结构）
&#125;

// 定义 FolderNode 结构体：表示文件夹节点
#[derive(Debug)]
struct FolderNode &#123;
    name: String,        // 文件夹名称
    contents: Vec&lt;Node>, // 存储子节点（文件或文件夹）
&#125;

// 为 FolderNode 实现 FileSystem trait
impl FileSystem for FolderNode &#123;
    // 1. 创建文件：向 contents 添加 File 节点
    fn create_file(&amp;mut self, name: String) &#123;
        self.contents.push(Node::File(name));
    &#125;

    // 2. 创建子文件夹：向 contents 添加 Folder 节点，并返回子文件夹的可变引用
    fn create_folder(&amp;mut self, name: String) -> &amp;mut Self &#123;
        // 新建子文件夹节点
        let new_folder = FolderNode &#123;
            name: name.clone(),
            contents: Vec::new(),
        &#125;;
        // 将子文件夹包装为 Box 并加入 contents
        self.contents.push(Node::Folder(Box::new(new_folder)));

        // 找到刚添加的子文件夹并返回其可变引用（通过 last_mut 确保是最后一个元素）
        match self.contents.last_mut() &#123;
            Some(Node::Folder(folder_box)) => &amp;mut **folder_box,
            _ => panic!("创建文件夹失败：逻辑错误"), // 理论上不会触发
        &#125;
    &#125;

    // 3. 列出内容：递归遍历子节点，带缩进展示结构
    fn list_contents(&amp;self, indent: &amp;str) &#123;
        // 打印当前文件夹名称
        println!("&#123;&#125;&#123;&#125;", indent, self.name);
        // 遍历子节点
        for node in &amp;self.contents &#123;
            match node &#123;
                Node::File(file_name) => println!("&#123;&#125;&#123;&#125;", indent, file_name), // 打印文件
                Node::Folder(folder) => folder.list_contents(&amp;format!("&#123;&#125;  ", indent)), // 递归打印子文件夹（增加缩进）
            &#125;
        &#125;
    &#125;
&#125;

// 测试代码：创建文件系统并执行操作
#[test]
fn test_file_system() &#123;
    // 1. 创建根文件夹
    let mut root = FolderNode &#123;
        name: "Root".to_string(),
        contents: Vec::new(),
    &#125;;

    // 2. 根文件夹操作：创建文件 + 子文件夹
    root.create_file("file1.txt".to_string()); // 根目录创建文件
    let mut sub1 = root.create_folder("sub1".to_string()); // 根目录创建子文件夹 sub1
    sub1.create_file("subfile1.txt".to_string()); // 在 sub1 中创建文件

    // 3. 子文件夹嵌套操作
    let mut sub2 = root.create_folder("sub2".to_string()); // 根目录创建子文件夹 sub2
    let mut subsub2 = sub2.create_folder("subsub2".to_string()); // 在 sub2 中创建子文件夹 subsub2
    subsub2.create_file("deepfile.txt".to_string()); // 在 subsub2 中创建文件

    // 4. 列出根文件夹内容（从空缩进开始）
    println!("文件系统结构：");
    root.list_contents("");
&#125;

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part2]_泛型</title>
    <url>/2025/07/29/Rust%E8%BF%9B%E9%98%B6-part2-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[Rust进阶[part2]_泛型
泛型概述
在定义函数时运用泛型，可将原本函数签名里明确指定参数和返回值类型的部分，用泛型来替代。这种方式能增强代码的适应性，为函数调用者赋予更多功能，还能避免代码重复。
fn add&lt;T>(a:T, b:T) -> T&#123;
  a + b
&#125;
不过，并非所有的T类型都能进行相加操作，此时会提示错误：
genertic_type.rs(5, 9): consider restricting type parameter 'T' with trait 'Add': ': std::ops::Add&lt;Output = T&gt;'
修正后的代码如下：
fn add&lt;T: std::ops::Add&lt;Output = T>>(a: T, b: T) -> T &#123;
    a + b
&#125;
使用场景
在函数定义中使用泛型
fn largest&lt;T: std::cmp::PartialOrd>(list: &amp;[T]) -> &amp;T &#123;
    let mut largest = &amp;list[0];
    for item in list &#123;
        if item > largest &#123;
            largest = item;
        &#125;
    &#125;
    largest
&#125;
在结构体中使用泛型
struct Point&lt;T> &#123;
    x: T,
    y: T,
&#125;

// 实例化泛型结构体
let integer = Point &#123; x: 5, y: 10 &#125;;
let float = Point &#123; x: 1.0, y: 4.0 &#125;;
在枚举里面使用泛型
enum Result&lt;T, E> &#123;
    Ok(T),
    Err(E),
&#125;

// 实例化泛型枚举
fn divide(numerator: f64, denominator: f64) -> Result&lt;f64, String> &#123;
    if denominator == 0.0 &#123;
        Err("Division by zero".to_string())
    &#125; else &#123;
        Ok(numerator / denominator)
    &#125;
&#125;
impl之后声明泛型T
泛型参数可以和结构体定义中声明的泛型参数不一样。
struct Point&lt;T, U> &#123;
    x: T,
    y: U,
&#125;

impl&lt;T, U> Point&lt;T, U> &#123;
    fn mixup&lt;V, W>(self, other: Point&lt;V, W>) -> Point&lt;T, W> &#123;
        Point &#123;
            x: self.x,
            y: other.y,
        &#125;
    &#125;
&#125;

// 示例用法
let p1 = Point &#123; x: 5, y: 10.4 &#125;;
let p2 = Point &#123; x: "Hello", y: 'c' &#125;;
let p3 = p1.mixup(p2);
const泛型
// 定义一个固定大小的数组类型
struct ArrayBuffer&lt;T, const N: usize> &#123;
    data: [T; N],
    len: usize,
&#125;

impl&lt;T, const N: usize> ArrayBuffer&lt;T, N>
where
    T: Default + Copy,
&#123;
    fn new() -> Self &#123;
        ArrayBuffer &#123;
            data: [Default::default(); N],
            len: 0,
        &#125;
    &#125;
&#125;


// 创建一个可以存储10个i32的缓冲区
let buffer: ArrayBuffer&lt;i32, 10> = ArrayBuffer::new();
where子句可以直接写在泛型参数后面，例如：
// 写法1：使用where子句
fn new_array_buffer&lt;T, const N: usize>() -> ArrayBuffer&lt;T, N>
where
    T: Default + Copy,
&#123; ... &#125;

// 写法2：直接在泛型参数后指定约束
fn new_array_buffer&lt;T: Default + Copy, const N: usize>() -> ArrayBuffer&lt;T, N> &#123; ... &#125;
泛型代码的性能
Rust通过在编译时对泛型代码进行单态化来保证效率。
当代码运行时，其执行效率和手写每个具体定义的重复代码一样。正是这个单态化过程，使得Rust泛型在运行时极为高效。
// 泛型代码
fn add&lt;T: std::ops::Add&lt;Output = T>>(a: T, b: T) -> T &#123;
    a + b
&#125;

// 单态化后的代码示例
fn add_i32(a: i32, b: i32) -> i32 &#123;
    a + b
&#125;

fn add_f64(a: f64, b: f64) -> f64 &#123;
    a + b
&#125;
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part10]_并发-概念、线程、通信、共享内存</title>
    <url>/2025/08/01/Rust%E8%BF%9B%E9%98%B6-part10-%E5%B9%B6%E5%8F%91-%E6%A6%82%E5%BF%B5%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[Rust进阶[part10]_并发
基本概述
在Rust中，通过std::thread::spawn函数可以创建新线程，该函数接收一个闭包作为参数，闭包中包含线程要执行的代码。
基础线程创建
子线程的生命周期依赖于主线程：当主线程结束时，无论子线程是否执行完毕，都会被强制终止。
use std::thread;
use std::time::Duration;

fn main() &#123;
    // 创建子线程
    thread::spawn(|| &#123;
        for i in 1..10 &#123;
            println!("spawn thread: &#123;&#125;", i);
            thread::sleep(Duration::from_millis(1)); // 模拟耗时操作
        &#125;
    &#125;);

    // 主线程逻辑
    for i in 1..5 &#123;
        println!("main thread: &#123;&#125;", i);
        thread::sleep(Duration::from_millis(1));
    &#125;
&#125;
输出结果（可能因调度顺序略有不同）：
main thread: 1
spawn thread: 1
main thread: 2
spawn thread: 2
main thread: 3
spawn thread: 3
main thread: 4
spawn thread: 4
spawn thread: 5  &#x2F;&#x2F; 主线程已结束，子线程可能被中断
等待线程完成：JoinHandle
通过thread::spawn返回的JoinHandle类型，可以让主线程等待子线程执行完毕。调用join方法会阻塞当前线程，直到子线程完成。
use std::thread;
use std::time::Duration;

fn main() &#123;
    // 获取子线程的JoinHandle
    let handle = thread::spawn(|| &#123;
        for i in 1..10 &#123;
            println!("spawn thread: &#123;&#125;", i);
            thread::sleep(Duration::from_millis(1));
        &#125;
    &#125;);

    // 主线程逻辑
    for i in 1..5 &#123;
        println!("main thread: &#123;&#125;", i);
        thread::sleep(Duration::from_millis(1));
    &#125;

    // 等待子线程完成（阻塞主线程）
    handle.join().unwrap(); // join返回Result，unwrap处理成功情况
&#125;
输出结果：主线程会等待子线程打印到9后再结束。
使用move闭包
move闭包用于将外部变量的所有权转移到子线程中，解决多线程中变量生命周期的问题（避免子线程访问已被释放的变量）。
示例：不使用move导致的错误
use std::thread;

fn main() &#123;
    let s = String::from("hello");
    // 错误：子线程可能比主线程生命周期长，s可能被提前释放
    thread::spawn(|| &#123;
        println!("&#123;&#125;", s); // 编译错误：`s` does not live long enough
    &#125;);
&#125;
使用move闭包解决
use std::thread;

fn main() &#123;
    let s = String::from("hello");
    // move闭包将s的所有权转移到子线程
    thread::spawn(move || &#123;
        println!("&#123;&#125;", s); // 正确：子线程拥有s的所有权
    &#125;).join().unwrap();
&#125;
多线程通信
Rust推荐通过消息传递实现安全并发，标准库提供的channel（通道）是实现这一机制的核心工具。
Channel（通道）基础
通道由发送端（Sender） 和接收端（Receiver） 组成，数据从发送端发送，接收端接收，实现线程间通信。

导入：use std::sync::mpsc;（mpsc：多生产者单消费者，支持多个发送端向一个接收端发送数据）
创建：let (tx, rx) = mpsc::channel();（返回包含发送端和接收端的元组）

基本使用示例
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() &#123;
    let (tx, rx) = mpsc::channel();

    // 子线程发送数据
    thread::spawn(move || &#123;
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];
        for val in vals &#123;
            tx.send(val).unwrap(); // 发送数据，失败时unwrap panic
            thread::sleep(Duration::from_millis(500)); // 模拟间隔发送
        &#125;
    &#125;);

    // 主线程接收数据
    for received in rx &#123; // 迭代接收，直到发送端全部关闭
        println!("Got: &#123;&#125;", received);
    &#125;
&#125;
输出结果：
Got: hi
Got: from
Got: the
Got: thread
发送端与接收端方法


发送端（Sender）：

send(T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt;：发送数据，成功返回Ok(())，失败（如接收端已关闭）返回Err。



接收端（Receiver）：

recv() -&gt; Result&lt;T, RecvError&gt;：阻塞当前线程，直到收到数据或发送端关闭（返回Err）。
try_recv() -&gt; Result&lt;T, TryRecvError&gt;：非阻塞，立即返回：

有数据：Ok(T)
无数据：Err(TryRecvError::Empty)
发送端关闭：Err(TryRecvError::Disconnected)





多生产者示例
通过Sender::clone可以创建多个发送端，实现多线程向同一接收端发送数据。
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() &#123;
    let (tx, rx) = mpsc::channel();
    let tx2 = tx.clone(); // 克隆发送端

    // 线程1发送数据
    thread::spawn(move || &#123;
        let vals = vec![
            String::from("thread1: hi"),
            String::from("thread1: hello"),
        ];
        for val in vals &#123;
            tx.send(val).unwrap();
            thread::sleep(Duration::from_millis(500));
        &#125;
    &#125;);

    // 线程2发送数据
    thread::spawn(move || &#123;
        let vals = vec![
            String::from("thread2: bye"),
            String::from("thread2: goodbye"),
        ];
        for val in vals &#123;
            tx2.send(val).unwrap();
            thread::sleep(Duration::from_millis(500));
        &#125;
    &#125;);

    // 接收数据
    for received in rx &#123;
        println!("Got: &#123;&#125;", received);
    &#125;
&#125;
练习
练习1——实现多线程文件处理器
任务描述
你需要编写一个多线程文件处理器，它从一个通道（channel）中接收文件路径，并在线程池中处理这些文件。文件处理的具体任务可以是读取文件内容并打印到控制台。你需要使用 Rust 的带缓冲区的 channel 来控制并发线程的数量，从而限制同时处理的文件数量。
具体要求
1.文件处理任务：定义一个函数process_file，该函数接受一个文件路径，读取文件内容，并将内容打印到控制台。
2.多线程控制：

创建一个带缓冲区的channel，用于在主线程和工作线程之间传递文件路径。
使用多线程来实现文件处理的并发性，限制线程的并发数量（例如，最多同时处理 4 个文件）。

3.主线程作为生产者：主线程负责向通道发送文件路径。假设我们有 10 个文件路径要处理。
4.工作线程作为消费者：创建多个工作线程，每个线程从通道中接收文件路径，并调用process_file函数来处理文件。
use crossbeam_channel::bounded;
use std::fs;
use std::path::Path;

// 实现多线程文件处理器,同时可以处理4个文件读取，说明有四个接受端 ，一个发送端
/* */
fn process_file(filename: &amp;str) &#123;
    match fs::read_to_string(filename) &#123;
        Ok(content) => &#123;
            println!("Processing file: &#123;&#125;", filename);
            println!("Content: &#123;&#125;", content);
        &#125;
        Err(error) => &#123;
            eprintln!("Error reading file &#123;&#125;: &#123;&#125;", filename, error);
        &#125;
    &#125;
&#125;

#[test]
fn test_thread_file_processor() &#123;
    let (tx, rx) = bounded(4);
    let num_threads = 4;
    let file_paths = vec![
        "file1.txt",
        "file2.txt",
        "file3.txt",
        "file4.txt",
        "file5.txt",
        "file6.txt",
        "file7.txt",
        "file8.txt",
        "file9.txt",
        "file10.txt",
    ];

    let mut handles = vec![];
    // 启动 4 个工作线程
    for i in 0..num_threads &#123;
        let rx: crossbeam_channel::Receiver&lt;String> = rx.clone();
        let handle: thread::JoinHandle&lt;()> = thread::spawn(move || &#123;
            for path in rx &#123;
                let content = fs::read_to_string(path).unwrap_or_else(|e| format!("Error: &#123;&#125;", e));
                println!("Worker &#123;&#125;: &#123;&#125;", i, content);
            &#125;
        &#125;);
        handles.push(handle);
    &#125;

    // 发送文件路径
    for path in file_paths &#123;
        tx.send(path.to_string()).unwrap();
    &#125;
  
    
    drop(tx);

    for h in handles &#123;
        h.join().unwrap()
    &#125;
&#125;


坑⚠️：
需要使用use crossbeam_channel::bounded; 才能满足接收者可以克隆，mpsc::channel()不能克隆接收者，只能克隆发送者
let (tx, rx) = bounded(4);
需要 drop(tx);来显式关闭发送端，使接收端退出 for path in rx 循环
for path in rx这是一个阻塞循环，只有在发送端关闭时才会退出

练习2——使用 Channel 实现程序的优雅停止
任务描述

任务描述
○ 在这道练习中，你需要编写一个多线程程序，该程序会创建多个工作线程，持续处理任务。在接收到停止信号时，所有工作线程应该优雅地停止工作，并确保所有未完成的任务都被处理完毕。
○ 你将使用 Rust 的 channel 来实现任务的调度和优雅停止机制。

具体要求

工作线程：
○ 创建一个工作线程池，工作线程从通道接收任务并处理。
○ 工作线程应能够响应停止信号，并在完成当前任务后优雅地退出。
任务结构：
○ 任务可以是简单的打印操作，模拟一些耗时工作，例如打印任务 ID 并暂停一段时间。
优雅停止：
○ 通过发送一个特殊的停止信号，通知所有工作线程停止接收新的任务，并在完成当前任务后退出。
○ 确保所有已接收的任务都被处理完毕。
主线程控制：
○ 主线程应当能够发送任务，也能够在适当的时候发送停止信号，触发工作线程的优雅停止。

答案：

优雅停止：工作线程处理完当前任务后退出，不中断正在执行的任务。
实现：通过特殊信号（如Option::None）通知线程停止，或关闭发送端触发接收端退出。

实现代码
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

// 任务类型：包含任务ID和模拟耗时
type Task = Option&lt;u32>; // None作为停止信号

// 处理任务
fn process_task(task_id: u32) &#123;
    println!("处理任务&#123;&#125;...", task_id);
    thread::sleep(Duration::from_secs(1)); // 模拟耗时1秒
    println!("任务&#123;&#125;处理完成", task_id);
&#125;

fn main() &#123;
    let (tx, rx) = bounded(4);
    let num_workers = 3;
    let mut handles = vec![];

    // 创建工作线程
    for i in 0..num_workers &#123;
        let rx = rx.clone();
        let handle = thread::spawn(move || &#123;
            println!("工作线程&#123;&#125;启动", i);
            // 循环接收任务，直到收到None（停止信号）
            while let Ok(task) = rx.recv() &#123;
                match task &#123;
                    Some(task_id) => process_task(task_id),
                    None => &#123;
                        println!("工作线程&#123;&#125;收到停止信号，退出", i);
                        break; // 退出循环，线程结束
                    &#125;
                &#125;
            &#125;
        &#125;);
        handles.push(handle);
    &#125;

    // 主线程发送任务
    for task_id in 1..=5 &#123;
        tx.send(Some(task_id)).unwrap();
    &#125;

    // 发送停止信号（每个线程一个）
    for _ in 0..num_workers &#123;
        tx.send(None).unwrap();
    &#125;

    // 等待所有工作线程退出
    for handle in handles &#123;
        handle.join().unwrap();
    &#125;
    println!("所有线程已优雅退出");
&#125;
✅ 总结



方案
支持克隆 Receiver
是否推荐
说明




mpsc::sync_channel
❌
❌
不支持克隆 Receiver


mpsc::channel
❌
✅
可克隆 Sender，适合多发送者单接收者


crossbeam-channel
✅
✅✅
支持克隆 Receiver，适合多消费者


Arc&lt;Mutex&lt;Receiver&gt;&gt;
❌
❌
不推荐，性能差，易出错


select! + bounded
✅
✅
适合多线程监听同一通道




📌 推荐方案
优先使用 crossbeam-channel 的 bounded 或 unbounded 通道，它不仅支持克隆 Receiver，还提供了更强大的功能，如 select!、try_recv、recv_timeout 等
共享内存实现并发
除了消息传递，还可以通过共享内存实现并发。Rust通过Mutex（互斥锁）和Arc（原子引用计数）保证共享内存的线程安全。
Mutex&lt;T&gt;（互斥锁）
Mutex确保同一时间只有一个线程能访问共享数据，通过“锁”机制实现：

访问数据前需调用lock()获取锁（返回MutexGuard，智能指针）。
MutexGuard离开作用域时自动释放锁，避免死锁。

基本使用
use std::sync::Mutex;

fn main() &#123;
    let m = Mutex::new(5); // 创建包含i32的Mutex

    &#123;
        let mut num = m.lock().unwrap(); // 获取锁，返回MutexGuard
        *num = 6; // 通过解引用修改数据
    &#125; // MutexGuard离开作用域，自动释放锁

    println!("m = &#123;:?&#125;", m.lock().unwrap()); // 输出：m = 6
&#125;
Arc&lt;T&gt;（原子引用计数）
Rc&lt;T&gt;不适合多线程（非线程安全），Arc&lt;T&gt;是线程安全版本的引用计数指针，通过原子操作保证计数的线程安全。常与Mutex配合，实现多线程共享数据。
多线程共享计数器示例
use std::sync::&#123;Arc, Mutex&#125;;
use std::thread;

fn main() &#123;
    let counter = Arc::new(Mutex::new(0)); // Arc包裹Mutex，实现多线程共享
    let mut handles = vec![];

    for _ in 0..10 &#123;
        let counter = Arc::clone(&amp;counter); // 克隆Arc，增加引用计数
        let handle = thread::spawn(move || &#123;
            let mut num = counter.lock().unwrap(); // 获取锁
            *num += 1; // 修改计数器
        &#125;);
        handles.push(handle);
    &#125;

    // 等待所有线程完成
    for handle in handles &#123;
        handle.join().unwrap();
    &#125;

    println!("Result: &#123;&#125;", *counter.lock().unwrap()); // 输出：Result: 10
&#125;
Send 和 Sync  trait
Rust通过这两个标记 trait 保证线程安全：

Send：标记类型可以安全地转移到另一个线程（所有权转移）。
Sync：标记类型可以安全地被多个线程共享（即&amp;T是Send的）。

默认实现：

基本类型（i32、bool等）和大多数标准库类型（String、Vec等）都实现了Send和Sync。
Rc&lt;T&gt;不实现Send和Sync（非线程安全）。
Arc&lt;T&gt;实现Send和Sync（线程安全）。
Mutex&lt;T&gt;当T是Send时，Mutex&lt;T&gt;实现Sync。

练习3——实现多线程任务调度器
任务描述
你需要编写一个简单的多线程任务调度器，它能够接收多个任务，并将这些任务分发到多个工作线程中执行。调度器使用 Channel 进行任务的分发和结果的收集。你需要使用 Rust 的Send和Sync特性来确保任务调度器在多线程环境中的安全性。
具体要求
定义一个Task结构体，表示需要执行的任务。任务包含一个唯一的id和一个用于执行的闭包。
调度器结构：
创建一个Scheduler结构体，包含一个任务队列和一个线程池。调度器应当使用channel来分发任务到不同的工作线程。
功能实现：
调度器应当具有以下功能：

添加任务：向调度器添加一个任务。
启动调度器：启动多个线程，开始从任务队列中获取任务并执行。
获取结果：在所有任务完成后，收集并打印每个任务的执行结果。

多线程安全：

通过使用Arc和Mutex确保任务队列在多个线程之间的安全访问。
确保任务的结果能够正确地在线程之间传递和收集。

任务分析

核心：用channel分发任务，用Arc+Mutex管理任务队列和结果收集。
结构：Scheduler包含任务发送端、结果接收端和工作线程句柄。

实现代码
use crossbeam_channel as channel;
use std::sync::Mutex;
use std::thread;
use std::time::Duration;

// ------------------实现多线程任务调度器------------------------
/**
 * 多线程任务调度器，能够接收多个任务，并将多个任务分配给多个线程执行。需要使用send和sync trait
 * 来确保任务调度器可以安全地被多个线程访问。
 */
use std::sync::Arc;
// 任务结构体：包含ID和执行闭包（返回结果）
struct Task &#123;
    id: u32,
    func: Box&lt;dyn FnOnce() -> String + Send + 'static>, // 闭包需实现Send
&#125;

// 调度器结构体
struct Scheduler &#123;
    task_tx: Option&lt;channel::Sender&lt;Task>>, // 任务发送端 (使用Option便于take)
    result_rx: Arc&lt;Mutex&lt;channel::Receiver&lt;String>>>, // 结果接收端（共享）
    workers: Option&lt;Vec&lt;thread::JoinHandle&lt;()>>>, // 工作线程句柄队列 (使用Option便于take)
&#125;

impl Scheduler &#123;
    // 创建新调度器
    fn new(num_workers: usize) -> Self &#123;
        let (task_tx, task_rx) = channel::unbounded();
        let (result_tx, result_rx) = channel::unbounded();
        let result_rx = Arc::new(Mutex::new(result_rx));
        let mut workers = vec![];

        // 创建工作线程
        for _ in 0..num_workers &#123;
            // 注意：crossbeam-channel的Receiver支持clone
            let task_rx_clone: channel::Receiver&lt;Task> = task_rx.clone();
            let result_tx: channel::Sender&lt;String> = result_tx.clone();

            let handle = thread::spawn(move || &#123;
                // 循环接收任务并执行
                while let Ok(task) = task_rx_clone.recv() &#123;
                    println!("执行任务&#123;&#125;", task.id);
                    let result = (task.func)(); // 执行任务
                    result_tx.send(result).unwrap(); // 发送结果
                &#125;
            &#125;);
            workers.push(handle);
        &#125;

        Scheduler &#123;
            task_tx: Some(task_tx),
            result_rx,
            workers: Some(workers),
        &#125;
    &#125;

    // 添加任务
    fn add_task(&amp;self, id: u32, func: Box&lt;dyn FnOnce() -> String + Send + 'static>) &#123;
        if let Some(ref tx) = self.task_tx &#123;
            tx.send(Task &#123; id, func &#125;).unwrap();
        &#125;
    &#125;

    // 等待所有任务完成并收集结果
    fn wait_and_collect_results(&amp;mut self) -> Vec&lt;String> &#123;
        // 关闭任务发送端，让工作线程接收完毕后退出
        self.task_tx.take(); // 使用take获取所有权并使原位置为None

        // 等待所有工作线程完成
        if let Some(workers) = self.workers.take() &#123;
            // 使用take获取所有权
            for handle in workers &#123;
                handle.join().unwrap();
            &#125;
        &#125;

        // 收集结果
        let mut results = vec![];
        let result_rx = self.result_rx.lock().unwrap();
        // 使用try_iter()来获取已有的结果，避免阻塞
        for result in result_rx.try_iter() &#123;
            results.push(result);
        &#125;
        results
    &#125;
&#125;

fn main() &#123;
    let mut scheduler = Scheduler::new(2); // 创建2个工作线程

    // 添加任务
    for i in 1..=5 &#123;
        scheduler.add_task(
            i,
            Box::new(move || &#123;
                thread::sleep(Duration::from_secs(1)); // 模拟耗时
                format!("任务&#123;&#125;执行完成", i)
            &#125;),
        );
    &#125;

    // 收集结果
    let results = scheduler.wait_and_collect_results();
    println!("所有任务结果：");
    for res in results &#123;
        println!("&#123;&#125;", res);
    &#125;
&#125;

总结
Rust通过所有权系统、Send/Sync trait、channel和Mutex/Arc等工具，在编译期保证并发安全，避免数据竞争。开发中应根据场景选择消息传递（channel）或共享内存（Mutex+Arc）模式，优先使用消息传递（更易保证安全）。
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part4]_智能指针2</title>
    <url>/2025/07/30/Rust%E8%BF%9B%E9%98%B6-part4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%882/</url>
    <content><![CDATA[Rust进阶[part4]_智能指针2
Rc&lt;T&gt;
Rc&lt;T&gt;（Reference Counted）是 Rust 标准库提供的单线程共享所有权智能指针，通过引用计数实现多所有权管理。以下是其核心特性与使用场景
核心特性


引用计数：


每个实例在堆上存储：


实际数据 T


引用计数器（记录活跃引用数量）


克隆时只增加计数器，不会深拷贝数据：
let a = Rc::new(vec![1,2,3]);
let b = a.clone(); // 计数器从1→2


最后一个引用离开作用域时释放内存




不可变共享：


所有者只能通过 .clone() 共享不可变引用


需配合RefCell&lt;T&gt;实现内部可变性：
let cell = Rc::new(RefCell::new(5));
*cell.borrow_mut() += 1;




使用场景
下面这个例子使用box可以实现链表的结构
enum list &#123;
    Cons(i32, Box&lt;list>),
    Nil,
&#125;
fn main() &#123;
    let list = list::Cons(1, Box::new(list::Cons(2, Box::new(list::Nil))));
    println!("&#123;:?&#125;", list);
&#125;
------
Cons(1, Cons(2, Nil))


Cons变体：表示链表节点
第一个参数i32：存储当前节点的数值
第二个参数Box：指向下一个节点的堆内存指针


Nil变体：表示链表终止节点（空节点）


如果需要共享引用，可以转换为Rc, 需要使用use std::rc::Rc;
use std::rc::Rc;

#[derive(Debug)]
enum list &#123;
    Cons(i32, Rc&lt;list>),
    Nil,
&#125;

fn main() &#123;
    let a = Rc::new(list::Cons(5, Rc::new(list::Nil)));
    let b = list::Cons(10, Rc::clone(&amp;a));
    let c = list::Cons(15, Rc::clone(&amp;a));

    // 打印验证
    match b &#123;
        list::Cons(val, ref next) => &#123;
            println!("当前值: &#123;&#125;", val);
            println!("下一个节点: &#123;:?&#125;", next);
        &#125;
        list::Nil => println!("空节点"),
    &#125;
&#125;
✅ 推荐使用场景：

共享子结构：如链表尾部共享、树结构的子节点
缓存实现：多个地方需要访问相同缓存数据
事件系统：多个监听者订阅同一事件源
配置共享：全局只读配置的分发

RefCell&lt;T&gt; 实现内部可变
RefCell&lt;T&gt; 是 实现&quot;内部可变性&quot;的智能指针，它本身不是可变引用，但可以通过其方法获取对内部数据的可变访问权限。与 Rc&lt;T&gt; 结合使用时，可以实现 多所有权下的共享可变状态。以下是详细解释：

内部可变性模式：

允许在不可变引用（&amp;self）下修改内部数据
通过运行时借用检查替代编译时检查
违反借用规则会触发 panic（而非编译错误）


关键方法：

borrow()：获取不可变借用（Ref&lt;T&gt;）
borrow_mut()：获取可变借用（RefMut&lt;T&gt;）
into_inner()：提取内部数据


与 Cell&lt;T&gt; 的区别：

Cell&lt;T&gt;：适用于复制类型（如 i32、bool），通过 get() 和 set() 直接操作值
RefCell&lt;T&gt;：适用于引用类型（如 Vec&lt;T&gt;、自定义结构体），通过借用获取引用



和Rc&lt;T&gt;组合使用
use std::rc::Rc;
use std::cell::RefCell;

let shared_data = Rc::new(RefCell::new(vec![1, 2, 3]));

// 克隆 Rc 获取共享所有权
let data1 = Rc::clone(&amp;shared_data);
let data2 = Rc::clone(&amp;shared_data);

// 通过 borrow_mut() 修改数据
data1.borrow_mut().push(4);
data2.borrow_mut().push(5);

// 最终结果：[1, 2, 3, 4, 5]
println!("&#123;:?&#125;", shared_data.borrow());
Weak&lt;T&gt;
Weak&lt;T&gt; 是 Rust 中用于打破 循环引用 的弱引用智能指针。它与 Rc&lt;T&gt; 配合使用，既能共享数据访问权，又不会增加引用计数，从而避免内存泄漏。
核心作用

打破循环引用

当两个 `Rc&lt;T&gt;` 相互引用时，会形成循环引用，导致引用计数永远不为 0，内存无法释放。`Weak&lt;T&gt;` 通过不增加引用计数，打破循环链。


延迟访问共享数据

Weak&lt;T&gt; 可以通过 .upgrade() 方法尝试获取 Option&lt;Rc&lt;T&gt;&gt;
如果数据已被释放，返回 None，避免悬空指针

实现缓存和观察者模式

缓存系统：避免缓存项因强引用无法回收
使用场景
双向链表循环引用导致无法释放内存
/**
 * 双向链表
 */
#[derive(Debug)]
struct Node &#123;
    value: i32,
    prev: Option&lt;Rc&lt;RefCell&lt;Node>>>,
    next: Option&lt;Rc&lt;RefCell&lt;Node>>>,
&#125;

#[test]
fn weak_reference() &#123;
    let a: Rc&lt;RefCell&lt;Node>> = Rc::new(RefCell::new(Node &#123;
        value: 1,
        prev: None,
        next: None,
    &#125;));
    let b: Rc&lt;RefCell&lt;Node>> = Rc::new(RefCell::new(Node &#123;
        value: 2,
        prev: Some(a.clone()),
        next: None,
    &#125;));
    a.borrow_mut().next = Some(b.clone());

    // 循环引用：a.next -> b，b.prev -> a
    // 无法释放内存！
&#125;

通过weak&lt;T&gt;解决
use std::rc::&#123;Rc, Weak&#125;;
use std::cell::RefCell;

#[derive(Debug)]
struct Node &#123;
    value: i32,
    prev: Option&lt;Weak&lt;RefCell&lt;Node>>>,
    next: Option&lt;Rc&lt;RefCell&lt;Node>>>,
&#125;

fn main() &#123;
    // 创建节点 A
    let a = Rc::new(RefCell::new(Node &#123;
        value: 1,
        prev: None,
        next: None,
    &#125;));

    // 创建节点 B
    let b = Rc::new(RefCell::new(Node &#123;
        value: 2,
        prev: Some(Rc::downgrade(&amp;a)), // 使用 Weak&lt;T>
        next: None,
    &#125;));

    // 设置 A 的 next
    a.borrow_mut().next = Some(b.clone());

    // 验证引用关系
    if let Some(next_node) = &amp;a.borrow().next &#123;
        println!("A.next.value = &#123;&#125;", next_node.borrow().value); // 输出 2
    &#125;

    if let Some(prev_weak) = &amp;b.borrow().prev &#123;
        if let Some(prev_strong) = prev_weak.upgrade() &#123;
            println!("B.prev.value = &#123;&#125;", prev_strong.borrow().value); // 输出 1
        &#125; else &#123;
            println!("B.prev 已释放");
        &#125;
    &#125;
&#125;
✅ 推荐使用场景

双向链表：将 prev 设为 Weak&lt;T&gt;
树结构：子节点到父节点的引用设为 Weak&lt;T&gt;
缓存系统：缓存项使用 Weak&lt;T&gt;，避免阻止数据释放
观察者模式：订阅者使用 Weak&lt;T&gt; 避免阻止发布者释放

练习
实现一个简单的社交网络系统，包含用户和朋友的关系。
要求：
用户结构：每个用户拥有一个名字和朋友列表。
添加朋友：支持在两个用户之间建立朋友关系。
展示朋友关系：能够展示每个用户的朋友列表。
循环引用：处理用户之间的双向引用，确保不产生循环引用。
/**
 * 实现一个简单的社交网络
 */
struct User &#123;
    username: String,
    friends: RefCell&lt;Vec&lt;Weak&lt;User>>>,
&#125;

impl User &#123;
    fn new(name: String) -> Rc&lt;User> &#123;
        Rc::new(User &#123;
            username: name,
            friends: RefCell::new(vec![]),
        &#125;)
    &#125;

    fn print_friends(&amp;self) &#123;
        for friend in self.friends.borrow().iter() &#123;
            println!(
                "&#123;&#125;'s friends list: &#123;&#125;",
                self.username,
                friend.upgrade().unwrap().username
            );
        &#125;
    &#125;
&#125;
fn add_friend(this: Rc&lt;User>, other: Rc&lt;User>) &#123;
    this.friends.borrow_mut().push(Rc::downgrade(&amp;other));
    other.friends.borrow_mut().push(Rc::downgrade(&amp;this));
&#125;
#[test]
fn test_social_network() &#123;
    let alice = User::new("Alice".to_string());
    let bob = User::new("Bob".to_string());
    add_friend(alice.clone(), bob.clone());
    alice.print_friends();
    bob.print_friends();
&#125;

最佳实践


优先选择

优先用 Box&lt;T&gt; 保持所有权清晰
确需共享时才使用 Rc&lt;T&gt;



组合使用

配合 RefCell&lt;T&gt; 实现&quot;内部可变性&quot;
配合 Weak&lt;T&gt; 避免循环引用



性能优化


避免频繁 .clone() 传递所有权


用 Rc::make_mut获取唯一可变引用：
let mut strong = Rc::new(10);
let weak = Rc::downgrade(&amp;strong);
let unique = Rc::make_mut(&amp;mut strong); // 若有其他引用会触发深拷贝
*unique += 1;




通过合理使用 Rc&lt;T&gt;，可以在单线程场景下安全高效地实现数据共享，但需要特别注意其局限性和潜在风险。
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part3]_生命周期</title>
    <url>/2025/07/29/Rust%E8%BF%9B%E9%98%B6-part3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[Rust进阶[part3]_生命周期
生命周期概述
在Rust中，生命周期是一种确保引用有效性的机制。Rust编译器通过生命周期注解来跟踪引用的作用域，防止出现悬空引用（dangling references）。
简单使用
下面是一个简单的生命周期注解示例：
fn longest&lt;'a>(x: &amp;'a str, y: &amp;'a str) -> &amp;'a str &#123;
    if x.len() > y.len() &#123;
        x
    &#125; else &#123;
        y
    &#125;
&#125;

fn main() &#123;
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(&amp;string1, string2);
    println!("The longest string is &#123;&#125;", result);
&#125;
在这个例子中，'a 是一个生命周期参数，它表示 x 和 y 引用的字符串切片必须至少和 'a 一样长。函数返回的引用也必须和 'a 一样长。
类别
fn
函数可以有生命周期参数，用于指定函数参数和返回值的生命周期关系。如上面的 longest 函数示例。
struct
结构体也可以包含引用类型的字段，这时需要为这些引用添加生命周期注解。
struct ImportantExcerpt&lt;'a> &#123;
    part: &amp;'a str,
&#125;

fn main() &#123;
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt &#123;
        part: first_sentence,
    &#125;;
&#125;
这里的 'a 表示 part 字段引用的字符串切片必须至少和 ImportantExcerpt 实例一样长。
enum
枚举同样可以包含引用类型的字段，需要添加生命周期注解。
enum MaybeString&lt;'a> &#123;
    Some(&amp;'a str),
    None,
&#125;

fn main() &#123;
    let s = String::from("hello");
    let maybe_str = MaybeString::Some(&amp;s);
&#125;
生命周期消除

rust编译器自动推理，无需手动重复添加


每个引用参数都有自己的生命周期
如果只有一个输入引用参数，那么它的生命周期会被赋予所有输出引用
如果有多个输入生命周期参数，但是其中一个是 &amp;self 或者 &amp;mut self ，那它的生命周期也会被赋予所有输出引用 ，比如结构体和枚举自己实现的方法中

示例
fn first_word(s: &amp;str) -> &amp;str &#123;
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() &#123;
        if item == b' ' &#123;
            return &amp;s[0..i];
        &#125;
    &#125;

    &amp;s[..]
&#125;
在这个函数中，虽然没有显式地添加生命周期注解，但编译器根据生命周期消除规则，自动为 s 和返回值添加了相同的生命周期。
特殊生命周期的标注
全局变量或者字符串字面量的生命周期在整个程序运行期间都有效，一般是使用 'static 来标注的生命周期。
示例
let s: &amp;'static str = "I have a static lifetime.";
这里的 s 是一个字符串字面量，它的生命周期是 'static，意味着它在整个程序运行期间都有效。
生命周期约束
生命周期注解可以用来约束多个引用之间的关系。
示例
fn longest_with_an_announcement&lt;'a, T>(x: &amp;'a str, y: &amp;'a str, ann: T) -> &amp;'a str
where
    T: std::fmt::Display,
&#123;
    println!("Announcement! &#123;&#125;", ann);
    if x.len() > y.len() &#123;
        x
    &#125; else &#123;
        y
    &#125;
&#125;

fn main() &#123;
    let string1 = String::from("abcd");
    let string2 = "xyz";
    let ann = "Let's find the longest string!";

    let result = longest_with_an_announcement(&amp;string1, string2, ann);
    println!("The longest string is &#123;&#125;", result);
&#125;
在这个例子中，'a 约束了 x 和 y 引用的字符串切片的生命周期，同时也约束了返回值的生命周期。
生命周期子类型和协变
生命周期可以有子类型关系，较短的生命周期可以被视为较长生命周期的子类型。这在协变（covariance）中尤为重要。
示例
fn main() &#123;
    let r;
    &#123;
        let x = 5;
        r = &amp;x;
    &#125; // x 在这里离开作用域，r 变成悬空引用

    println!("r: &#123;&#125;", r);
&#125;
在这个例子中，x 的生命周期比 r 短，x 的生命周期是 r 生命周期的子类型。当 x 离开作用域时，r 变成悬空引用，这段代码会编译错误。
练习
要求：修复一下原始代码的bug
原始代码
fn test_lifetime_multiple() &#123;
    fn insert_value&lt;'a, 'b>(my_vec: &amp;'a mut Vec&lt;&amp;'a i32>, value: &amp;'b i32) &#123;
        my_vec.push(value)
    &#125;
    let mut my_vec: Vec&lt;&amp;i32> = vec![];
    let val1 = 1;
    let val2 = 2;

    let a = &amp;mut my_vec;
    insert_value(a, &amp;val1);
    println!("a is &#123;:?&#125; ", a);
    let b = &amp;mut my_vec;
    insert_value(b, &amp;val2);
    println!("b is &#123;:?&#125;", b);
    println!("&#123;my_vec:?&#125;");
&#125;
修改后的代码
fn test_lifetime_multiple() &#123;
    fn insert_value&lt;'a, 'b>(my_vec: &amp;'a mut Vec&lt;&amp;'b i32>, value: &amp;'b i32) &#123;
        my_vec.push(value)
    &#125;
    let mut my_vec: Vec&lt;&amp;i32> = vec![];
    let val1 = 1;
    let val2 = 2;

    let a = &amp;mut my_vec;
    insert_value(a, &amp;val1);
    println!("a is &#123;:?&#125; ", a);
    let b = &amp;mut my_vec;
    insert_value(b, &amp;val2);
    println!("b is &#123;:?&#125;", b);
    println!("&#123;my_vec:?&#125;");
&#125;
解释
分离生命周期参数：
fn insert_value&lt;'a, 'b>(my_vec: &amp;'a mut Vec&lt;&amp;'b i32>, value: &amp;'b i32)

'a 是 my_vec 可变引用的生命周期
'b 是存储在 Vec 中的引用的生命周期

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part6]_宏</title>
    <url>/2025/07/31/Rust%E8%BF%9B%E9%98%B6-part6-%E5%AE%8F/</url>
    <content><![CDATA[Rust进阶[part6]_宏
macro 概述
宏是 Rust 中强大的代码生成工具，与函数不同，它在编译期展开并生成具体代码，能处理可变参数、实现动态逻辑，语法上以 ! 结尾（如 println! vec! panic!）。
常用宏简化了重复操作：println! 处理格式化输出，vec! 快速创建向量，cfg! 做条件编译判断。宏支持模式匹配和代码生成，比函数更灵活，但也因编译期处理，调试和学习门槛稍高。按功能可分为声明宏（基于模式匹配）和过程宏（更复杂的代码生成），是 Rust 元编程的核心能力。
一些之前常用的宏，例如 println!、vec! 等，它们简化了代码编写。
声明宏
声明宏允许你通过模式匹配来生成代码。例如，下面是一个简单的加法声明宏：
macro_rules! add &#123;
    ($a:expr, $b:expr) => &#123;
        $a + $b
    &#125;;
&#125;

fn main() &#123;
    let result = add!(1, 2);
    println!("Result: &#123;&#125;", result);
&#125;
格式
macro_rules! 宏名称 &#123;
    (模式1) => &#123; 代码1 &#125;;
    (模式2) => &#123; 代码2 &#125;;
    // ...
&#125;

模式：匹配调用宏时的输入参数。
元变量：用 $ 开头，捕获输入的片段（如表达式、标识符等）。
重复符号：*（零或多次）、+（至少一次），类似正则表达式。

过程宏
派生宏
派生宏可以为结构体、枚举等类型自动生成代码。例如，使用 #[derive(Debug)] 可以自动为结构体添加调试输出的能力：
#[derive(Debug)]
struct Person &#123;
    name: String,
    age: u8,
&#125;

fn main() &#123;
    let person = Person &#123;
        name: String::from("Alice"),
        age: 30,
    &#125;;
    println!("&#123;:?&#125;", person);
&#125;
属性宏
属性宏可以为函数、结构体等添加自定义属性。例如，自定义一个日志属性宏：
#[proc_macro_attribute]
pub fn log(_attr: TokenStream, item: TokenStream) -> TokenStream &#123;
    // 这里可以实现日志记录逻辑
    item
&#125;

#[log]
fn my_function() &#123;
    println!("Function called");
&#125;

fn main() &#123;
    my_function();
&#125;
函数宏
函数宏类似于普通函数，但在编译时展开。例如：
#[proc_macro]
pub fn greet(_item: TokenStream) -> TokenStream &#123;
    let code = "println!(\"Hello, world!\");";
    code.parse().unwrap()
&#125;

fn main() &#123;
    greet!();
&#125;
总结
宏是 Rust 中强大的代码生成工具，声明宏通过模式匹配生成代码，过程宏则提供了更灵活的代码生成方式，包括派生宏、属性宏和函数宏。
应用场景

减少重复代码： 通过宏生成重复的代码，提高代码的可维护性。
编译期计算：在编译器进行计算并生成代码，提高运行时性能。
DSL（领域特定语言）：使用宏定义领域特定语言，提高代码的表达力和可读性。

课后习题
实现一下宏
assert_eq!(repeat!("x", 3), "xxx");
    assert_eq!(sum!(1, 2, 3, 4, 5), 15);
    assert_eq!(max_value!(1, 8, 9), 9);
代码：
#[macro_export]
macro_rules! say_hello &#123;
    () => &#123;
        println!("hello!");
    &#125;;
    ($name:expr) => &#123;
        println!("hello &#123;&#125;!", $name);
    &#125;;
&#125;

#[macro_export]
macro_rules! repeat &#123;
    () => &#123;
        println!("repeat!");
    &#125;;
    ($s:expr, $n:expr) => &#123;
        std::string::String::from($s).repeat($n)
    &#125;;
&#125;

#[macro_export]
macro_rules! sum &#123;
    () => &#123;
        println!("sum!");
    &#125;;
    ($($x:expr),*) => &#123;
        &#123;
            let mut total = 0;
            $(total += $x;)*
            total
        &#125;
    &#125;;
&#125;

#[macro_export]
macro_rules! max_value &#123;
    () => &#123;
        println!("max_value!");
    &#125;;
    ($x:expr, $y:expr, $z:expr) => &#123;
        if $x > $y &#123;
            if $x > $z &#123; $x &#125; else &#123; $z &#125;
        &#125; else &#123;
            if $y > $z &#123; $y &#125; else &#123; $z &#125;
        &#125;
    &#125;;
&#125;

一些符号拆解：

$()：分组捕获元变量。
\*/+：重复匹配输入片段。
$(...)\*：在展开时代入重复的代码逻辑。

// sum! 宏展开逻辑
$(total += $x;)*  // 对每个捕获的表达式，生成一次累加语句
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part7]_闭包</title>
    <url>/2025/07/31/Rust%E8%BF%9B%E9%98%B6-part7-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[Rust进阶[part7]_闭包
闭包概述

闭包是一个可以捕获所在环境中的变量的匿名函数
在Rust中，闭包通过||符号定义，可以像普通函数一样调用，但和函数不同，闭包可以访问外部作用域的变量

特点

匿名性：没有函数名，通常作为表达式使用
捕获环境：能自动捕获定义所在作用域中的变量（无需显式声明）
类型推断：参数和返回值类型可由编译器自动推断，无需显式标注
灵活语法：语法简洁，可根据复杂度调整写法（单行可省略&#123;&#125;和return）
实现trait：编译器会为闭包自动实现Fn、FnMut或FnOnce trait，使其能作为参数传递

语法
基本语法：|参数列表| 代码块（返回值由最后一行表达式决定）
// 无参数闭包
let hello = || println!("Hello, closure!");
hello(); // 调用闭包

// 单参数闭包（省略类型标注）
let square = |x| x * x;
println!("&#123;&#125;", square(5)); // 输出：25

// 多参数闭包（显式标注类型，可选）
let add = |a: i32, b: i32| -> i32 &#123; a + b &#125;;
println!("&#123;&#125;", add(2, 3)); // 输出：5

// 多行闭包（需用&#123;&#125;包裹）
let complex_calc = |x: i32| &#123;
    let y = x * 2;
    y + 3 // 隐式返回
&#125;;
println!("&#123;&#125;", complex_calc(4)); // 输出：11
使用场景
函数的参数
闭包常作为参数传递给函数（如迭代器方法、异步任务等），实现灵活的逻辑注入
// 1. 结合迭代器使用
let numbers = vec![1, 2, 3, 4, 5];
let doubled: Vec&lt;i32> = numbers.iter().map(|x| x * 2).collect();
println!("&#123;:?&#125;", doubled); // 输出：[2, 4, 6, 8, 10]

// 2. 自定义接受闭包的函数
fn apply&lt;F>(f: F, value: i32) -> i32 
where 
    F: Fn(i32) -> i32  // 约束闭包类型
&#123;
    f(value)
&#125;

let result = apply(|x| x * 3 + 2, 5);
println!("&#123;&#125;", result); // 输出：17
捕获环境变量
可以捕获并使用其定义所在环境中的变量，捕获方式由编译器根据使用场景自动推断
// 1. 按引用捕获（&amp;T）：适用于只读访问
let message = String::from("Hello");
let print_msg = || println!("&#123;&#125;", message); // 捕获message的引用
print_msg(); // 输出：Hello
println!("&#123;&#125;", message); // 仍可使用message（未转移所有权）

// 2. 按可变引用捕获（&amp;mut T）：适用于修改变量
let mut count = 0;
let mut increment = || &#123;
    count += 1; // 修改捕获的变量
    println!("Count: &#123;&#125;", count);
&#125;;
increment(); // 输出：Count: 1
increment(); // 输出：Count: 2

// 3. 按值捕获（T）：适用于需要转移所有权的场景
let name = String::from("Alice");
let take_name = || &#123;
    println!("Name: &#123;&#125;", name); // 捕获name的所有权
&#125;;
take_name(); 
// println!("&#123;&#125;", name); // 错误：name的所有权已被闭包捕获
闭包原理


自动实现的函数类型：编译器会为每个闭包自动实现Fn、FnMut或FnOnce中的一个或多个trait：

FnOnce：闭包消耗捕获的变量（所有权转移），因此只能调用一次
FnMut：闭包通过可变引用修改捕获的变量，可多次调用
Fn：闭包通过不可变引用访问捕获的变量，可多次调用（实现Fn的闭包自动实现FnMut和FnOnce）



闭包的类型推断：

闭包的参数和返回值类型由编译器根据上下文自动推断
同一闭包的类型是唯一的（即使签名相同，不同闭包类型也不同）
若需存储闭包或作为返回值，需通过trait对象（如Box&lt;dyn Fn(...) -&gt; ...&gt;）实现



生命周期与闭包：

捕获引用的闭包，其生命周期受限于所捕获变量的生命周期
若闭包作为返回值，需确保返回的闭包不捕获已销毁的变量引用



move关键字
在参数列表前使用move关键字，可强制闭包取得它所使用的环境值的所有权（忽略默认的引用捕获）
// 基础示例：转移所有权
let x = vec![1, 2, 3];
let equal_to_x = move |y| y == x; // x的所有权被闭包捕获
// println!("&#123;:?&#125;", x); // 错误：x的所有权已转移
let y = vec![1, 2, 3];
assert!(equal_to_x(y));

// 多线程场景：确保闭包拥有变量所有权（避免生命周期问题）
use std::thread;

let s = String::from("thread message");
thread::spawn(move || &#123; // 必须用move转移s的所有权到子线程
    println!("&#123;&#125;", s);
&#125;).join().unwrap();
练习

实现一个闭包，计算两个数的乘积并加上一个外部定义的偏移量（如offset = 10）
使用闭包作为filter方法的参数，从整数列表中筛选出偶数
用move关键字创建一个闭包，在新线程中打印捕获的字符串
编写一个函数，接受两个闭包参数（一个计算平方，一个计算立方），并返回两个闭包结果的和

示例答案参考：
// 练习1
let offset = 10;
let calc = |a: i32, b: i32| a * b + offset;
println!("&#123;&#125;", calc(3, 4)); // 输出：22（3*4+10）

// 练习2
let numbers = vec![1, 2, 3, 4, 5, 6];
let evens: Vec&lt;_> = numbers.into_iter().filter(|x| x % 2 == 0).collect();
println!("&#123;:?&#125;", evens); // 输出：[2, 4, 6]

// 练习3
use std::thread;
let msg = String::from("hello from thread");
thread::spawn(move || &#123;
    println!("&#123;&#125;", msg);
&#125;).join().unwrap();

// 练习4
fn combine&lt;F1, F2>(f1: F1, f2: F2, x: i32) -> i32
where
    F1: Fn(i32) -> i32,
    F2: Fn(i32) -> i32,
&#123;
    f1(x) + f2(x)
&#125;
let square = |n| n * n;
let cube = |n| n * n * n;
println!("&#123;&#125;", combine(square, cube, 2)); // 输出：4 + 8 = 12]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part8]_迭代器</title>
    <url>/2025/07/31/Rust%E8%BF%9B%E9%98%B6-part8-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[Rust进阶[part8]_迭代器&amp;关联类型
概述
迭代器（Iterator）是 Rust 中处理序列元素的强大工具，它提供了一种统一的方式来遍历集合（如向量、数组、哈希表等）中的元素。迭代器的核心特性是惰性执行：除非主动调用消耗迭代器的方法，否则迭代器不会实际执行任何操作。这种特性使得迭代器可以高效地组合使用，而不会带来额外的性能开销。
在 Rust 中，迭代器由 Iterator trait 定义，所有实现了该 trait 的类型都可以被称为迭代器。迭代器不仅可以用于遍历现有集合，还可以用于生成序列（如斐波那契数列）、处理数据流等场景。
迭代器的实现
迭代器本质是实现了 Iterator trait 的类型。该 trait 的核心定义如下：
trait Iterator &#123;
    type Item;  // 关联类型：迭代器产生的元素类型
    fn next(&amp;mut self) -> Option&lt;Self::Item>;  // 核心方法：返回下一个元素（None表示结束）
&#125;
next 方法是迭代器的核心：

每次调用返回 Option&lt;Self::Item&gt;，其中 Some(value) 表示下一个元素，None 表示迭代结束
调用 next 会修改迭代器的内部状态（推进到下一个元素），因此需要 &amp;mut self

关联类型
上面 trait 中用到的 type Item; 是关联类型（Associated Type），它是在 trait 内部定义的类型占位符，用于表示 trait 中涉及的某个类型。实现该 trait 时，需要指定 Item 的具体类型。
和泛型的区别
关联类型与泛型都可以实现&quot;类型抽象&quot;，但适用场景不同：


关联类型：在 trait 中只声明一个类型占位符，实现 trait 时必须为该类型指定唯一具体类型（一个实现对应一个具体类型）。适合 trait 中某个类型逻辑上&quot;固定&quot;的场景（如迭代器的元素类型）。
// 迭代器只能产生一种类型的元素，用关联类型更合适
trait Iterator &#123;
    type Item;
    fn next(&amp;mut self) -> Option&lt;Self::Item>;
&#125;


泛型：在 trait 定义时声明类型参数，实现 trait 时可以为不同类型参数提供多个实现。适合需要为多种类型提供通用逻辑的场景。
// 泛型可以为不同T实现不同逻辑
trait Container&lt;T> &#123;
    fn get(&amp;self, index: usize) -> Option&lt;&amp;T>;
&#125;


简单迭代器
迭代器的基本使用示例：
fn iter_study() &#123;
    let v1 = vec![1, 2, 3];
    // 1. for循环遍历（最常用）
    let v1_iter = v1.iter();  // 获取迭代器（不可变引用）
    for var in v1_iter &#123;
        println!("&#123;&#125;", var);  // 输出：1 2 3
    &#125;

    // 2. 手动调用next方法
    let mut v1_iter2 = v1.iter();  // 需要mut，因为next会修改迭代器状态
    while let Some(var) = v1_iter2.next() &#123;
        println!("&#123;&#125;", var);  // 输出：1 2 3
    &#125;
&#125;
for 循环不需要 mut 而 while 循环需要的原因：
for 循环在内部会自动处理迭代器的可变性——它会将迭代器标记为 mutable，并在循环过程中隐式调用 next 方法。而手动调用 next 时，需要显式声明 mut，因为 next 方法接收 &amp;mut self，要求迭代器是可变的。
几个迭代的方法
集合类型（如 Vec）通常提供以下方法来获取不同类型的迭代器：
iter 方法
返回不可变引用迭代器（Iterator&lt;Item = &amp;T&gt;），迭代过程中借用集合元素（不获取所有权），集合本身可以在迭代后继续使用。
let v = vec![1, 2, 3];
let iter = v.iter();  // 迭代元素类型：&amp;i32
into_iter 方法
返回所有权迭代器（Iterator&lt;Item = T&gt;），迭代过程中会获取集合元素的所有权，迭代结束后集合本身无法再使用（已被消耗）。
let v = vec![1, 2, 3];
let iter = v.into_iter();  // 迭代元素类型：i32（v此后不可用）
iter_mut 方法
返回可变引用迭代器（Iterator&lt;Item = &amp;mut T&gt;），迭代过程中可以修改集合元素的值。
let mut v = vec![1, 2, 3];
let iter = v.iter_mut();  // 迭代元素类型：&amp;mut i32
for num in iter &#123;
    *num *= 2;  // 修改元素值
&#125;
println!("&#123;:?&#125;", v);  // 输出：[2, 4, 6]
消耗迭代器的方法
消耗型方法（Consuming Adaptors）会遍历迭代器并消耗它（调用后迭代器无法再使用），通常会产生一个最终结果。
next
最基础的消耗型方法，每次调用返回下一个元素，直到返回 None。
sum
计算迭代器中所有元素的总和，支持所有实现了 Sum trait 的类型（如数值类型）。
let v = vec![1, 2, 3, 4];
let total: i32 = v.iter().sum();  // sum会消耗迭代器
println!("&#123;&#125;", total);  // 输出：10
collect
将迭代器产生的元素收集到一个集合中（如 Vec、HashMap 等），需要显式指定目标集合类型。
let v = vec![1, 2, 3];
let doubled: Vec&lt;i32> = v.iter().map(|x| x * 2).collect();  // 收集到Vec
println!("&#123;:?&#125;", doubled);  // 输出：[2, 4, 6]
产生其他迭代器的方法
迭代器适配器（Iterator Adaptors）会对迭代器进行转换，产生一个新的迭代器（不立即执行，仍保持惰性）。
map
接收一个闭包作为参数，将迭代器中的每个元素转换为另一种类型，返回一个新的迭代器。
let v = vec![1, 2, 3];
let mapped = v.iter().map(|x| x * 10);  // 类型：Map&lt;Iter&lt;i32>, ...>（未执行）
// 用collect触发执行
let result: Vec&lt;i32> = mapped.collect();
println!("&#123;:?&#125;", result);  // 输出：[10, 20, 30]
filter
接收一个闭包作为 predicate（断言），该闭包返回 bool，新迭代器只包含满足断言的元素。
let v = vec![1, 2, 3, 4, 5];
let even_numbers: Vec&lt;&amp;i32> = v.iter().filter(|x| **x % 2 == 0).collect();
println!("&#123;:?&#125;", even_numbers);  // 输出：[2, 4]
练习：实现斐波那契数列迭代器
题目描述
实现一个自定义迭代器，用于生成斐波那契数列。该迭代器应支持无限生成斐波那契数，直到用户停止迭代。
任务要求

实现结构体 Fibonacci，并为它实现 Iterator trait。
在 next 方法中生成下一个斐波那契数。
编写测试函数，输出前10个斐波那契数。

实现代码

use std::iter::Iterator;

// 定义斐波那契迭代器结构体，存储当前和下一个斐波那契数
struct Fibonacci &#123;
    current: u64,
    next: u64,
&#125;

// 为Fibonacci实现Iterator trait
impl Iterator for Fibonacci &#123;
    type Item = u64;  // 迭代器产生u64类型的斐波那契数

    fn next(&amp;mut self) -> Option&lt;Self::Item> &#123;
        let current_val = self.current;  // 保存当前值作为返回结果
        // 更新下一组值（斐波那契规则：下一个数 = 当前数 + 前一个数）
        let new_next = self.current + self.next;
        self.current = self.next;
        self.next = new_next;
        Some(current_val)  // 始终返回Some（无限迭代）
    &#125;
&#125;

// 提供一个构造函数，初始化斐波那契迭代器（从0, 1开始）
impl Fibonacci &#123;
    fn new() -> Self &#123;
        Fibonacci &#123; current: 0, next: 1 &#125;
    &#125;
&#125;

// 测试函数：输出前10个斐波那契数
fn test_fibonacci() &#123;
    let fib_iter = Fibonacci::new();
    // take(10)限制只取前10个元素（迭代器适配器）
    for (i, num) in fib_iter.t  ake(10).enumerate() &#123;
        println!("第&#123;&#125;个斐波那契数：&#123;&#125;", i + 1, num);
    &#125;
&#125;

// 运行测试
fn main() &#123;
    test_fibonacci();
&#125;
输出结果
第1个斐波那契数：0
第2个斐波那契数：1
第3个斐波那契数：1
第4个斐波那契数：2
第5个斐波那契数：3
第6个斐波那契数：5
第7个斐波那契数：8
第8个斐波那契数：13
第9个斐波那契数：21
第10个斐波那契数：34
说明

结构体 Fibonacci 用 current 和 next 存储当前和下一个斐波那契数，初始化为 0 和 1（符合斐波那契数列的数学定义）。
next 方法通过更新 current 和 next 的值生成下一个数，始终返回 Some（实现无限迭代）。
使用 take(10) 适配器限制只获取前10个元素，避免无限循环。

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part9]_test测试</title>
    <url>/2025/07/31/Rust%E8%BF%9B%E9%98%B6-part9-test%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[Rust进阶[part9]_test测试
Unit Test（单元测试）
单元测试用于测试代码中的最小功能单元（如函数、方法），通常与被测试代码放在同一模块中，方便测试私有接口。
基本示例
创建src/lib.rs，编写公共函数及对应的单元测试：
pub fn add(left: usize, right: usize) -> usize &#123;
    left + right
&#125;

pub fn multiply(a: i32, b: i32) -> i32 &#123;
    a * b
&#125;

// 测试模块（通常命名为test，使用#[cfg(test)]标记仅在测试模式下编译）
#[cfg(test)]
mod tests &#123;
    // 引入父模块的函数（因测试模块是子模块，需显式引入）
    use super::*;

    // 测试add函数：正常情况
    #[test]
    fn test_add() &#123;
        assert_eq!(add(2, 3), 5); // 断言相等
        assert_ne!(add(10, 20), 25); // 断言不相等
    &#125;

    // 测试multiply函数：边界情况
    #[test]
    fn test_multiply() &#123;
        assert_eq!(multiply(0, 5), 0); // 乘以0
        assert_eq!(multiply(-3, 4), -12); // 负数相乘
    &#125;

    // 标记应该失败的测试（用于验证错误处理）
    #[test]
    #[should_panic(expected = "division by zero")] // 预期panic信息
    fn test_divide_by_zero() &#123;
        let _ = 1 / 0;
    &#125;

    // 忽略测试（暂时不执行）
    #[test]
    #[ignore = "尚未实现完整逻辑"]
    fn test_complex_calculation() &#123;
        // 待实现的测试逻辑
    &#125;
&#125;
代码解释：

#[cfg(test)]：标记测试模块，仅在运行cargo test时才编译，避免影响生产代码
#[test]：标记测试函数，cargo会自动识别并执行
断言宏：assert_eq!(a, b)（检查a等于b）、assert_ne!(a, b)（检查a不等于b）、assert!(condition)（检查条件为真）
#[should_panic]：标记测试预期会panic，若未panic则测试失败；可通过expected指定预期的panic信息
#[ignore]：标记测试暂时忽略，执行cargo test -- --ignored可单独运行忽略的测试

Integration Test（集成测试）
集成测试用于测试多个模块或组件协同工作的情况，通常放在独立的tests目录中，只能访问被测试代码的公共接口。
目录结构
在src同级创建tests文件夹（cargo会自动识别为集成测试目录）：
project&#x2F;
├── src&#x2F;
│   └── lib.rs
├── tests&#x2F;
│   ├── basic_test.rs  &#x2F;&#x2F; 集成测试文件1
│   └── advanced_test.rs  &#x2F;&#x2F; 集成测试文件2
└── Cargo.toml
示例代码
tests/basic_test.rs：
// 引入被测试的库（需在Cargo.toml中配置库名称）
use my_library::&#123;add, multiply&#125;;

#[test]
fn test_integration_add() &#123;
    assert_eq!(add(10, 20), 30);
&#125;

#[test]
fn test_integration_multiply() &#123;
    assert_eq!(multiply(3, 7), 21);
&#125;
配置说明
需在Cargo.toml中配置库信息，使集成测试能正确引入：
[lib]
name = "my_library"  # 库名称（集成测试中use的名称）
path = "src/lib.rs"  # 库文件路径
测试命令行



命令
作用




cargo test
运行所有测试（单元测试+集成测试+文档测试）


cargo test test_add
运行名称包含test_add的测试（模糊匹配）


cargo test tests::test_multiply
运行指定模块下的测试


cargo test --test basic_test
仅运行tests/basic_test.rs中的集成测试


cargo test -- --nocapture
运行测试并显示测试中的打印输出（默认捕获输出）


cargo test -- --ignored
仅运行被#[ignore]标记的测试


cargo test --release
在release模式下运行测试（性能更接近生产环境）



Doc Tests（文档测试）
文档测试是嵌入在代码文档中的测试，既能作为示例文档，又能被cargo执行，确保文档与代码行为一致。
基本用法
在函数的文档注释（///）中通过代码块编写测试：
/// 两数相加
/// 
/// # Examples
/// 
/// ```
/// use my_library::add;
/// 
/// assert_eq!(add(2, 3), 5);
/// assert_eq!(add(100, 200), 300);
/// ```
pub fn add(left: usize, right: usize) -> usize &#123;
    left + right
&#125;
执行文档测试
cargo test --doc  # 仅运行文档测试
注意事项

文档测试代码块必须是完整可执行的（需包含use引入）
可使用/// # fn main() &#123; ... &#125;包裹复杂示例（适用于需要主函数的场景）
若示例代码预期会 panic，可在代码块前加should_panic标记：/// # Examples
/// 
/// ```should_panic
/// use my_library::divide;
/// divide(1, 0);  // 预期panic
/// ```
pub fn divide(a: i32, b: i32) -> i32 &#123;
    if b == 0 &#123;
        panic!("division by zero");
    &#125;
    a / b
&#125;


Examples（示例代码）
examples目录用于存放可运行的示例代码，这些示例不仅是文档，还能通过cargo test验证其可执行性。
目录结构
project&#x2F;
├── src&#x2F;
│   └── lib.rs
└── examples&#x2F;
    ├── simple_usage.rs  # 简单示例
    └── advanced&#x2F;  # 多文件示例
        ├── main.rs
        └── helper.rs
示例代码
examples/simple_usage.rs：
use my_library::add;

fn main() &#123;
    let result = add(5, 7);
    println!("5 + 7 = &#123;&#125;", result);
&#125;
运行示例测试
cargo test --examples  # 运行所有示例（验证能否编译执行）
cargo run --example simple_usage  # 直接运行指定示例
标准工程目录规范详解
├── Cargo.lock  # 依赖版本锁定文件（自动生成，不要手动修改）  
├── Cargo.toml  # 项目配置文件（依赖、库信息等）  
├── src&#x2F;  
│   ├── lib.rs  # 库代码入口（被单元测试和集成测试引用）  
│   ├── main.rs  # 主程序入口（若项目是可执行程序）  
│   └── bin&#x2F;  # 多可执行文件目录（每个.rs文件对应一个可执行程序）  
│       ├── tool1.rs  
│       └── tool2.rs  
├── benches&#x2F;  # 基准测试目录（性能测试）  
│   ├── performance.rs  
│   └── heavy_operation.rs  
│       # 基准测试示例：  
│       # #[bench]  
│       # fn bench_add(b: &amp;mut Bencher) &#123;  
│       #     b.iter(|| add(1, 2));  
│       # &#125;  
├── examples&#x2F;  # 示例代码目录（见上文Examples部分）  
└── tests&#x2F;  # 集成测试目录（见上文Integration Test部分）  

src/bin：当项目需要多个可执行程序时使用，运行cargo run --bin tool1可执行对应程序
benches：基准测试使用#[bench]标记，通过cargo bench运行，用于评估代码性能
所有测试相关目录（tests、benches、examples）的代码都遵循&quot;仅在测试/运行时编译&quot;的原则，不影响生产环境代码体积

练习
创建并发布一个 Rust crate 到 crates.io，涵盖单元测试、集成测试、文档测试、examples 以及项目规范，甚至进阶的 GitHub Actions 自动发布。
首先，得理清楚整个流程的步骤，从初始化项目、编写代码、添加测试、配置文档，到发布和自动化。
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust进阶[part5]_trait</title>
    <url>/2025/07/30/Rust%E8%BF%9B%E9%98%B6-part5-trait/</url>
    <content><![CDATA[Rust进阶[part5]_trait
trait概述
在 Rust 中，trait 是一种定义共享行为的方式。它类似于其他语言中的接口，允许我们定义一组方法签名，然后让不同的类型去实现这些方法。通过 trait，我们可以实现多态性，即不同类型可以以统一的方式处理。
普通实现

使用 trait 关键字来声明一个特征
summary 是特征名
在大括号中定义了该特征的所有方法

// 定义一个 trait
trait Summary &#123;
    fn summarize(&amp;self) -> String;
&#125;

// 定义一个结构体
struct NewsArticle &#123;
    headline: String,
    location: String,
    author: String,
    content: String,
&#125;

// 为 NewsArticle 结构体实现 Summary trait
impl Summary for NewsArticle &#123;
    fn summarize(&amp;self) -> String &#123;
        format!("&#123;&#125;, by &#123;&#125; (&#123;&#125;)", self.headline, self.author, self.location)
    &#125;
&#125;

// 定义另一个结构体
struct Tweet &#123;
    username: String,
    content: String,
    reply: bool,
    retweet: bool,
&#125;

// 为 Tweet 结构体实现 Summary trait
impl Summary for Tweet &#123;
    fn summarize(&amp;self) -> String &#123;
        format!("&#123;&#125;: &#123;&#125;", self.username, self.content)
    &#125;
&#125;

fn main() &#123;
    let article = NewsArticle &#123;
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from("The Pittsburgh Penguins once again are the best \
                              hockey team in the NHL."),
    &#125;;

    let tweet = Tweet &#123;
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    &#125;;

    println!("Article summary: &#123;&#125;", article.summarize());
    println!("Tweet summary: &#123;&#125;", tweet.summarize());
&#125;
特征定义与实现的位置
孤儿规则
孤儿规则是 Rust 中的一个重要规则，它规定了特征的实现必须满足以下条件：要么特征在当前的 crate 中定义，要么类型在当前的 crate 中定义。这个规则确保了特征的实现是可预测的，避免了不同 crate 中对同一类型实现同一特征时可能出现的冲突。
例如，我们不能在自己的 crate 中为 Vec&lt;T&gt; 实现标准库中的 Display 特征，因为 Vec&lt;T&gt; 和 Display 都定义在标准库中。
带泛型的 trait
可以针对不同的泛型来实现
默认泛型类型参数

实现 trait 时不指定 Rhs 的具体类型，Rhs 的类型将是默认的 Self 类型，也就是在其上实现 Add 的类型

trait Add&lt;Rhs=Self> &#123;
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
&#125;

// 为 i32 实现 Add trait
impl Add for i32 &#123;
    type Output = i32;
    fn add(self, rhs: i32) -> i32 &#123;
        self + rhs
    &#125;
&#125;

fn main() &#123;
    let num1 = 5;
    let num2 = 3;
    let result = num1.add(num2);
    println!("The result of addition is: &#123;&#125;", result);
&#125;
关联类型
关联类型是 trait 定义中的类型占位符，并不定义它的具体类型是什么，在实现这个 trait 的时候才为这个关联类型赋予确定的类型。
trait Container &#123;
    type Item;

    fn contains(&amp;self, item: &amp;Self::Item) -> bool;
&#125;

struct IntContainer &#123;
    numbers: Vec&lt;i32>,
&#125;

impl Container for IntContainer &#123;
    type Item = i32;

    fn contains(&amp;self, item: &amp;i32) -> bool &#123;
        self.numbers.contains(item)
    &#125;
&#125;

fn main() &#123;
    let container = IntContainer &#123; numbers: vec![1, 2, 3] &#125;;
    println!("Container contains 2: &#123;&#125;", container.contains(&amp;2));
&#125;
特征作为函数参数
&amp;impl
使用 &amp;impl Trait 语法可以将实现了特定 trait 的类型作为参数传递给函数。
trait Summary &#123;
    fn summarize(&amp;self) -> String;
&#125;

struct NewsArticle &#123;
    headline: String,
&#125;

impl Summary for NewsArticle &#123;
    fn summarize(&amp;self) -> String &#123;
        format!("Headline: &#123;&#125;", self.headline)
    &#125;
&#125;

fn notify(item: &amp;impl Summary) &#123;
    println!("Breaking news! &#123;&#125;", item.summarize());
&#125;

fn main() &#123;
    let article = NewsArticle &#123;
        headline: String::from("New Rust feature released!"),
    &#125;;
    notify(&amp;article);
&#125;
trait bound语法
trait bound 语法允许我们在泛型函数中指定泛型类型必须实现的 trait。

fn notify&lt;T: Summary>(item: &amp;T) &#123;
    println!("Breaking news! &#123;&#125;", item.summarize());
&#125;
where 语法简化 trait bound
当泛型参数较多，并且每个参数都有多个 trait 约束时，使用 where 语法可以使代码更易读。


fn notify&lt;T>(item: &amp;T)
where
    T: Summary + Display,
&#123;
    println!("Breaking news! &#123;&#125;", item.summarize());
    item.display();
&#125;

trait作为泛型的类型
可以将 trait 作为泛型类型参数，这样函数就可以接受实现了该 trait 的任何类型。
trait Summary &#123;
    fn summarize(&amp;self) -> String;
&#125;

struct NewsArticle &#123;
    headline: String,
&#125;

impl Summary for NewsArticle &#123;
    fn summarize(&amp;self) -> String &#123;
        format!("Headline: &#123;&#125;", self.headline)
    &#125;
&#125;

fn print_summary&lt;T: Summary>(item: T) &#123;
    println!("Summary: &#123;&#125;", item.summarize());
&#125;

fn main() &#123;
    let article = NewsArticle &#123;
        headline: String::from("New Rust feature released!"),
    &#125;;
    print_summary(article);
&#125;
impl trait 语法 （返回值中返回trait）
如果需要动态返回不同的 trait 类型的话，需要使用 Box&lt;dyn xxx&gt; 语法来保证返回的内存大小一致，并且可以标注返回的哪种 trait。
trait Summary &#123;
    fn summarize(&amp;self) -> String;
&#125;

struct NewsArticle &#123;
    headline: String,
&#125;

impl Summary for NewsArticle &#123;
    fn summarize(&amp;self) -> String &#123;
        format!("Headline: &#123;&#125;", self.headline)
    &#125;
&#125;

fn returns_summarizable() -> Box&lt;dyn Summary> &#123;
    Box::new(NewsArticle &#123;
        headline: String::from("New Rust feature released!"),
    &#125;)
&#125;

fn main() &#123;
    let item = returns_summarizable();
    println!("Summary: &#123;&#125;", item.summarize());
&#125;
通过 derive 派生类型
例如 #[derive(Debug)] 是一种特征派生语法，这种被标记的对象会自动实现对应的默认特征代码，继承相应的功能。
#[derive(Debug)]
struct Rectangle &#123;
    width: u32,
    height: u32,
&#125;

fn main() &#123;
    let rect = Rectangle &#123; width: 30, height: 50 &#125;;
    println!("Rectangle: &#123;:?&#125;", rect);
&#125;
练习
练习 1
定义一个 Area trait，包含一个 area 方法，用于计算面积。然后为 Rectangle 结构体实现该 trait。
练习 2
创建一个函数，接受一个实现了 Area trait 的类型作为参数，并打印其面积。
练习 3
使用 derive 派生 Clone 和 Copy trait 到一个自定义类型上，并验证其功能。
以下是练习的参考答案：
// 练习 1
trait Area &#123;
    fn area(&amp;self) -> f64;
&#125;

struct Rectangle &#123;
    width: f64,
    height: f64,
&#125;

impl Area for Rectangle &#123;
    fn area(&amp;self) -> f64 &#123;
        self.width * self.height
    &#125;
&#125;

// 练习 2
fn print_area&lt;T: Area>(shape: T) &#123;
    println!("The area is: &#123;&#125;", shape.area());
&#125;

// 练习 3
#[derive(Clone, Copy, Debug)]
struct Point &#123;
    x: i32,
    y: i32,
&#125;

fn main() &#123;
    let rect = Rectangle &#123; width: 5.0, height: 3.0 &#125;;
    print_area(rect);

    let p1 = Point &#123; x: 1, y: 2 &#125;;
    let p2 = p1; // 复制操作
    println!("p1: &#123;:?&#125;, p2: &#123;:?&#125;", p1, p2);
&#125;
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part1]_SOL基础</title>
    <url>/2025/08/04/Solana-part1-SOL%E4%B8%AD%E7%9A%84Rust%E6%BA%90%E7%A0%81%E6%A6%82%E8%A7%88%EF%BC%8C%E4%BB%A5%E5%8F%8ARust%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[Solana[part1]_SOL基础
一、Solana概述
Solana是一个高性能的公链系统，核心特点体现在以下几个方面：

共识协议：采用独特的历史证明（POH）与权益证明（PoS）结合的共识机制，兼顾安全性与高效性。
高性能架构：通过优化数据传输、并行处理等技术，支持每秒数万笔交易（TPS），远超传统公链。
高并发处理：采用账户模型与事务隔离设计，实现多笔交易的并行验证与执行。
低延迟：得益于POH的时间戳机制，交易确认延迟可低至秒级。

1.1 核心模块

Runtime模块：作为Solana的运行时核心，负责管理所有账户的状态（包括余额、数据存储等），并调度智能合约的执行流程，确保交易按规则有序处理。
Programs模块：即Solana的智能合约层，包含多个核心程序：

Token Program：Solana生态中代币发行、转账、授权的基础程序，兼容SPL标准代币（类似以太坊的ERC-20）。
Stake Program：用于验证节点的质押管理，支持SOL代币质押、解除质押及收益分配等操作。



1.2 Rust在Solana中的应用
Rust是Solana智能合约开发的首选语言，核心原因包括：

内存安全性：Rust的所有权机制和借用检查器可避免空指针、缓冲区溢出等内存错误，确保智能合约在去中心化环境中稳定运行。
高性能：编译型语言特性使Rust代码执行效率接近C/C++，适配Solana高TPS的性能需求。
类型安全：强类型系统减少运行时错误，降低智能合约漏洞风险（如逻辑漏洞、重入攻击等）。
生态适配：Solana提供了完整的Rust开发工具链（如Anchor框架），简化合约编写、测试与部署流程。

二、SOL在区块链生态系统中的地位

高性能标杆：Solana以高TPS和低延迟成为去中心化应用（dAPP）的重要载体，尤其适合高频交易、游戏、DeFi等对性能敏感的场景。
生态扩展性：支持NFT、DeFi、Web3应用等多元场景，拥有大量开发者工具（如Phantom钱包、Solscan区块浏览器）和基础设施。
市场认可度：SOL作为其原生代币，是市值排名前列的加密资产，广泛用于支付手续费、质押验证节点及生态内价值流转。

三、SOL的历史、未来及发展

历史里程碑：

2017年由Anatoly Yakovenko创立，核心团队多来自高通、英特尔等科技公司。
2020年主网上线，凭借POH技术迅速获得关注。
2021-2022年生态爆发，NFT和DeFi项目快速增长，成为主流公链之一。


未来方向：

进一步优化共识机制，提升去中心化程度（如减少验证节点门槛）。
扩展跨链互操作性，支持与以太坊、Avalanche等公链的资产与数据交互。
降低开发门槛，吸引更多开发者参与生态建设。



四、SOL的架构和常见名词概念
4.1 常见概念

accounts（账户）：Solana中数据存储的基本单元，不仅包含钱包地址（如solfare、Backpack等钱包管理的账户），还存储智能合约数据、代币余额等信息。每个账户有唯一的公钥（address），需支付租约费用以维持存储。
合约（Programs）：即智能合约，由Rust编写并编译为字节码，部署后通过交易触发执行，修改账户状态。
验证器（Validator）：维护Solana网络的节点，负责验证交易、生成区块并参与共识，通过质押SOL获得出块权限和奖励。
区块浏览器：用于查询交易、账户、区块等信息的工具（如Solscan、Solana Explorer），支持主网、测试网（devnet/testnet）查询。
address（地址）：账户的唯一标识符，由公钥生成（通常为Base58编码的字符串），用于接收转账或标识合约。
transfer（转账）：通过交易将SOL或SPL代币从一个账户转移到另一个账户，需支付手续费（fee）。
dAPP（去中心化应用）：基于Solana公链开发的应用，如去中心化交易所（DEX）、NFT市场等，依赖智能合约实现逻辑。
fee（手续费）：用户发起交易时支付给验证节点的费用，取决于交易复杂度和网络拥堵程度。
block（区块）：验证节点打包交易的集合，包含多个交易及POH时间戳，确保交易顺序可追溯。
租约（rent）：Solana通过租约机制维持账户存储，账户余额高于阈值时可免租，否则会被回收。
签名（signature）：交易发起者用私钥对交易进行签名，证明交易合法性，验证节点通过公钥验证签名。
钱包（wallet）：管理账户私钥的工具，支持生成地址、签名交易、查询余额等功能（如Phantom、Solflare）。

4.2 8大核心技术

POH（历史证明）：Solana的创新时间戳机制，通过哈希链记录事件顺序，无需全节点同步即可确定交易先后，大幅提升共识效率。
Turbine（涡轮机）：数据传输协议，将区块数据分片并通过节点网络并行传输，解决大区块同步瓶颈。
Gulf Stream（湾流）：交易预执行机制，验证节点在收到交易前提前缓存并预执行，减少确认延迟。
Sealevel：并行交易处理引擎，支持多笔不冲突的交易同时执行（基于账户隔离），提升TPS。
Pipelining（流水线）：将交易处理拆分为“验证-执行-打包”等阶段，通过流水线并行处理，优化节点资源利用率。
Cloudbreak：存储优化技术，将历史数据压缩并分布式存储，降低全节点存储成本。
Reed-Solomon：数据冗余编码算法，通过纠错码确保数据在传输或存储中发生错误时可恢复，提升网络健壮性。
Archivers（归档节点）：专门存储历史区块数据的节点，减轻验证节点的存储压力，确保链上数据可追溯。

五、本地环境搭建
5.1 环境准备


安装依赖工具：

macOS：安装Xcode命令行工具

  xcode-select --install  # 安装工具链
xcode-select -p  # 验证安装（输出路径即成功）

Windows：通过WSL（Windows Subsystem for Linux）模拟Linux环境，再执行后续步骤。



安装Rust：
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh  # 下载安装脚本
source $HOME/.cargo/env  # 配置环境变量
rustc --version  # 验证安装


安装Solana CLI：
参考官方文档：https://solana.com/zh/docs/intro/installation#安装-solana-cli
sh -c "$(curl -sSfL https://release.solana.com/v1.18.4/install)"  # 安装指定版本
solana --version  # 验证安装


安装Anchor框架（智能合约开发工具）：
参考官方文档：https://solana.com/zh/docs/intro/installation#安装-anchor-cli
cargo install --git https://github.com/coral-xyz/anchor avm --locked --force  # 安装AVM（Anchor版本管理器）
avm install latest  # 安装最新版Anchor
avm use latest  # 启用最新版
配置环境变量（以zsh为例）：
echo 'export PATH="$HOME/.avm/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc  # 生效配置
anchor --version  # 验证安装


5.2 创建钱包
solana-keygen new  # 创建默认钱包（路径：~/.config/solana/id.json）
执行后输入密码（BIP39 Passphrase），完成后生成私钥文件（用于签名交易）和公钥（钱包地址）。
5.3 切换至Devnet（测试网）
Solana有主网（Mainnet）、测试网（Devnet）、开发网（Testnet），开发阶段建议使用Devnet：
solana config set -ud  # 切换至Devnet
solana config get  # 验证配置（RPC URL显示https://api.devnet.solana.com即为成功）
5.4 获取测试SOL（空投）
Devnet的SOL可通过空投获取，用于测试交易：
solana airdrop 5  # 向默认钱包空投5个SOL
若提示“rate limit reached”，可等待几分钟后重试，或指定其他钱包地址：
solana airdrop 5 &lt;钱包公钥>  # 向指定钱包空投
六、Solana CLI常见用法
6.1 创建多个钱包
# 创建钱包1（路径：~/wallets/wallet1.json）
solana-keygen new -o ~/wallets/wallet1.json

# 创建钱包2
solana-keygen new -o ~/wallets/wallet2.json

# 创建带密码的钱包3（--force强制覆盖同名文件，谨慎使用）
solana-keygen new -o ~/wallets/wallet3.json --force
6.2 领取空投至指定钱包
# 向wallet2空投0.5个SOL（先通过pubkey命令获取钱包公钥）
solana airdrop 0.5 $(solana-keygen pubkey ~/wallets/wallet2.json)
6.3 钱包间转账
# 从默认钱包向目标地址转账（示例）
solana transfer --from ~/.config/solana/id.json &lt;目标钱包公钥> 0.3  # 转账0.3 SOL
参数说明：--from指定转出钱包路径，最后一个数字为转账金额（SOL）。
6.4 查看账户余额
# 查看指定钱包余额
solana balance &lt;钱包公钥>
# 示例输出：0.9 SOL
6.5 查询交易记录
通过区块浏览器查询交易详情，例如Devnet的交易可访问：  https://solscan.io/tx/&lt;交易ID&gt;?cluster=devnet
（将&lt;交易ID&gt;替换为实际交易哈希，可通过solana transfer命令的输出获取）
https://solscan.io/tx/3pnyEXnDJcyCZo2VBzunRRveu1siXmAJmjpGrC4TdrkbAfvLGaioC7Amnum6YoorioBUVMxgQe3VcW3UGpoJskh6?cluster=devnet

]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part10]_Anchor实战：创建用户profile</title>
    <url>/2025/08/14/Solana-part10-anchor%E5%AE%9E%E6%88%981/</url>
    <content><![CDATA[Solana[part10]_Anchor实战：创建用户profile
一、项目架构概览
1.1 整体架构
anchor_social&#x2F;
├── programs&#x2F;               # Solana 智能合约源代码
│   └── anchor_social&#x2F;      # 核心合约模块
│       ├── src&#x2F;              # Rust 源代码
│       │   ├── lib.rs        # 程序入口和指令路由
│       │   ├── instructions&#x2F; # 指令处理逻辑
│       │   └── state&#x2F;        # 链上状态定义
│       └── Cargo.toml        # Rust 项目配置
├── app&#x2F;                    # 前端交互代码
│   ├── api&#x2F;                  # API 接口模块
│   │   ├── wallet.ts         # 钱包管理
│   │   └── profile.ts        # 用户资料接口
│   └── index.ts            # 主程序入口
├── tests&#x2F;                  # 测试模块
├── migrations&#x2F;             # 合约部署脚本
├── Anchor.toml             # Anchor 项目配置
├── package.json            # 前端依赖配置
└── tsconfig.json           # TypeScript 配置
1.2 技术栈

区块链平台: Solana
开发框架: Anchor v0.31.1
智能合约语言: Rust
前端交互: TypeScript
依赖管理:

前端: yarn
合约: Cargo



二、核心模块详解
2.1 智能合约模块 (programs/anchor_social)
2.1.1 程序入口 (lib.rs)
declare_id!("35vQtxXXv5rb99eiVrVVrwYMRYc7vscZvXas8zjEnnK5");

pub mod instructions;
pub mod state;
use instructions::*;

#[program]
pub mod anchor_social &#123;
    use super::*;

    pub fn create_profile(ctx: Context&lt;CreateProfile>, display_name: String) -> Result&lt;()> &#123;
        instructions::profile::create_profile(ctx, display_name)
    &#125;
&#125;

declare_id!: 定义程序地址
#[program]: Anchor 宏标记程序入口
指令路由: 将 create_profile 指令路由到 instructions 模块

2.1.2 指令处理 (instructions/profile.rs)
pub fn create_profile(ctx: Context&lt;CreateProfile>, display_name: String) -> Result&lt;()> &#123;
    ctx.accounts.profile.display_name = display_name;
    Ok(())
&#125;

#[derive(Accounts)]
pub struct CreateProfile&lt;'info> &#123;
    #[account(init, payer = user, space = 8 + Profile::INIT_SPACE, seeds = [Profile::SEED_PREFIX.as_bytes(), user.key().as_ref()], bump)]
    pub profile: Account&lt;'info, Profile>,
    #[account(mut)]
    pub user: Signer&lt;'info>,
    pub system_program: Program&lt;'info, System>,
&#125;

业务逻辑: 简单设置显示名称
账户约束:

init: 创建新账户
payer = user: 指定支付账户
seeds: PDA 计算种子
mut: 表示可变账户



2.1.3 状态定义 (state/profile.rs)
#[account]
#[derive(InitSpace)]
pub struct Profile &#123;
    #[max_len(20)]
    pub display_name: String,
&#125;
impl Profile &#123;
    pub const SEED_PREFIX: &amp;'static str = "profile";
&#125;

#[account]: 标记为链上账户结构
#[derive(InitSpace)]: 自动生成空间计算代码
#[max_len(20)]: 字符串长度限制

2.2 前端交互模块 (app/)
2.2.1 钱包管理 (api/wallet.ts)
// 默认钱包
export function useDefaultWallet() &#123;
    return anchor.Wallet.local();
&#125;

// 访客钱包
export function useVisitorWallet() &#123;
    const keypair = anchor.web3.Keypair.fromSecretKey(new Uint8Array([...]));
    return new anchor.Wallet(keypair);
&#125;

钱包类型:

local(): 使用本地环境变量钱包
Keypair: 通过私钥创建密钥对
Wallet: 包装签名功能


重要约束:

需要 payer 属性进行交易签名
必须处理异步签名操作



2.2.2 用户资料接口 (api/profile.ts)
export async function createProfile(wallet: anchor.Wallet, displayName: string) &#123;
    return await program.methods.createProfile(displayName).accounts(&#123;
        user: wallet.publicKey,
    &#125;)
    .signers([wallet.payer])  // 必须显式传递签名者
    .rpc();
&#125;

export async function getProfile(wallet: anchor.Wallet) &#123;
    const [profilePda,] = anchor.web3.PublicKey.findProgramAddressSync(
        [Buffer.from("profile"), wallet.publicKey.toBuffer()],
        program.programId,
    );
    return await program.account.profile.fetch(profilePda);
&#125;

交易构建:

accounts: 绑定账户参数
signers: 指定额外签名者
rpc(): 发送交易


PDA 计算:

使用种子生成确定性账户地址
保证账户地址一致性



2.2.3 主程序入口 (index.ts)
const defaultWallet = useDefaultWallet();
const visitorWallet = useVisitorWallet();

// 创建用户资料
async function createProfiles() &#123;
    try &#123;
        await createProfile(defaultWallet, "Bob");
        await createProfile(visitorWallet, "Alice");
    &#125; catch (error) &#123;
        console.error("创建资料失败:", error.message);
    &#125;
&#125;

// 获取用户资料
async function fetchProfiles() &#123;
    try &#123;
        console.log("默认钱包资料:", await getProfile(defaultWallet));
        console.log("访客钱包资料:", await getProfile(visitorWallet));
    &#125; catch (error) &#123;
        console.error("获取资料失败:", error.message);
    &#125;
&#125;

异步处理: 使用 try-catch 捕获异常
流程控制: 分离创建和查询操作
日志记录: 详细输出执行结果

三、关键实现细节
3.1 钱包签名机制
class NodeWallet &#123;
    constructor(payer) &#123;
        this.payer = payer;  // Keypair 实例
    &#125;

    async signTransaction(tx) &#123;
        if (isVersionedTransaction(tx)) &#123;
            tx.sign([this.payer]);  // 版本化交易
        &#125; else &#123;
            tx.partialSign(this.payer);  // 传统交易
        &#125;
        return tx;
    &#125;
&#125;

签名流程:

检测交易版本
根据版本选择签名方式
返回签名后的交易



3.2 PDA 账户生成
const [profilePda, bump] = PublicKey.findProgramAddressSync(
    [Buffer.from("profile"), wallet.publicKey.toBuffer()],
    program.programId
);

生成规则:

种子由常量和用户地址组成
使用程序ID作为程序标识
确保地址唯一性和可预测性



3.3 交易错误处理
try &#123;
    await createProfile(wallet, "Alice");
&#125; catch (error) &#123;
    console.log("错误详情:", &#123;
        message: error.message,
        logs: error.logs,  // 包含链上日志
        errorCode: error.errorCode
    &#125;);
&#125;

错误分析要点:

查看完整日志堆栈
检查链上返回码
验证账户状态



四、常见问题及解决方案
4.1 类型错误 (TS2345)
错误信息:
Argument of type &#39;Keypair&#39; is not assignable to parameter of type &#39;Wallet&#39;
解决方案:
// 错误方式
return Keypair.fromSecretKey(...)

// 正确方式
return new anchor.Wallet(Keypair.fromSecretKey(...))
4.2 账户不存在错误
错误信息:
Account does not exist or has no data
解决方案:

验证钱包地址:

solana address -k ~/.config/solana/t3.json

空投 SOL:

solana airdrop 1 &lt;WALLET_ADDRESS>

确认 PDA 计算正确性:

console.log("预期PDA:", profilePda.toBase58())
4.3 交易签名错误
错误信息:
Transfer: &#96;from&#96; must not carry data
解决方案:
// 确保正确传递签名者
.signers([wallet.payer])
五、开发最佳实践


模块化开发:

将指令和状态分离到不同文件
使用 pub(crate) 控制可见性



错误处理:

使用 anyhow 或 thiserror 简化错误处理
添加详细的日志记录



测试策略:

单元测试: 使用 anchor 的测试框架
集成测试: 使用本地网络测试完整流程
边界测试: 验证输入长度限制



安全性建议:

避免硬编码密钥
使用 Anchor 的账户约束
验证所有输入参数



]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part11]_Anchor实战：用户发帖&amp;点赞</title>
    <url>/2025/08/17/Solana-part11-Anchor%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E5%8F%91%E5%B8%96-%E7%82%B9%E8%B5%9E/</url>
    <content><![CDATA[Solana[part11]_Anchor实战：用户发帖&amp;点赞
发帖功能（createTweet）
1. 核心数据结构
发帖功能的核心数据结构为Tweet，定义在programs/anchor_social/src/state/tweet.rs中，用于存储帖子内容及点赞数：
// programs/anchor_social/src/state/tweet.rs
use anchor_lang::prelude::*;

#[account]
#[derive(InitSpace)]
pub struct Tweet &#123;
    #[max_len(50)]  // 限制帖子内容最大长度为50字符
    pub body: String,  // 帖子内容
    pub like_count: u64,  // 点赞数，初始为0
&#125;

impl Tweet &#123;
    pub const SEED_PREFIX: &amp;'static str = "tweet";  // PDA种子前缀

    // 初始化新帖子
    pub fn new(body: String) -> Self &#123;
        Self &#123;
            body,
            like_count: 0,
        &#125;
    &#125;
&#125;
2. 前端API实现（创建帖子）
前端通过app/api/tweet.ts中的createTweet函数发起创建帖子的交易，核心逻辑包括生成帖子PDA、调用链上程序：
// app/api/tweet.ts
import * as anchor from "@coral-xyz/anchor";
import &#123; program &#125; from "./wallet";

export async function createTweet(
    wallet: anchor.Wallet,
    body: string,
): Promise&lt;[anchor.web3.PublicKey, string]> &#123;
    // 1. 生成用户Profile的PDA（用于关联帖子所属用户）
    const [profilePda,] = anchor.web3.PublicKey.findProgramAddressSync(
        [Buffer.from("profile"), wallet.publicKey.toBuffer()],  // 种子："profile" + 用户公钥
        program.programId,
    );

    // 2. 获取用户Profile数据（需先创建Profile）
    const profile = await program.account.profile.fetch(profilePda);

    // 3. 生成帖子的PDA（唯一标识帖子）
    const [tweetPda] = anchor.web3.PublicKey.findProgramAddressSync(
        [
            Buffer.from("tweet"),  // 种子1：固定前缀"tweet"
            profilePda.toBuffer(),  // 种子2：用户Profile的PDA（关联用户）
            Buffer.from((profile.tweet_count + 1).toString())  // 种子3：用户的第N+1条帖子（确保唯一性）
        ],
        program.programId,
    );

    // 4. 调用链上程序创建帖子，返回帖子PDA和交易签名
    return [
        tweetPda,
        await program.methods.createTweet(body)
            .accounts(&#123;
                authority: wallet.publicKey,  // 交易发起者（帖子作者）
                tweet: tweetPda,  // 帖子账户（新建）
            &#125;)
            .rpc()  // 发送交易
    ];
&#125;
3. 后端程序逻辑（创建帖子）
链上程序逻辑定义在programs/anchor_social/src/instructions/tweet.rs中，负责初始化帖子账户、更新用户发帖数：
// programs/anchor_social/src/instructions/tweet.rs
use crate::state::profile::*;
use crate::state::tweet::*;
use anchor_lang::prelude::*;

// 处理创建帖子的核心逻辑
pub fn create_tweet(ctx: Context&lt;CreateTweet>, body: String) -> Result&lt;()> &#123;
    // 1. 更新用户Profile的发帖数（+1）
    let profile = &amp;mut ctx.accounts.profile;
    profile.tweet_count += 1;

    // 2. 初始化帖子数据
    let tweet = Tweet::new(body);
    // 将帖子数据写入账户（set_inner用于更新Anchor账户的内部数据）
    ctx.accounts.tweet.set_inner(tweet.clone());
    Ok(())
&#125;

// 定义创建帖子所需的账户结构
#[derive(Accounts)]
pub struct CreateTweet&lt;'info> &#123;
    // 帖子账户（新建）
    #[account(
        init,  // 初始化新账户
        payer = authority,  // 由authority支付账户创建费用
        space = 8 + Tweet::INIT_SPACE,  // 分配存储空间（8字节为Anchor账户前缀）
        seeds = [  // PDA种子（需与前端生成逻辑一致）
            Tweet::SEED_PREFIX.as_bytes(),  // "tweet"
            profile.key().as_ref(),  // 用户Profile的PDA
            (profile.tweet_count + 1).to_string().as_ref()  // 第N+1条帖子
        ],
        bump  // 自动计算PDA的bump值
    )]
    pub tweet: Account&lt;'info, Tweet>,

    // 用户Profile账户（需已存在，用于记录发帖数）
    #[account(mut, seeds = [Profile::SEED_PREFIX.as_bytes(), authority.key().as_ref()], bump)]
    pub profile: Account&lt;'info, Profile>,

    // 交易发起者（帖子作者，签名者）
    #[account(mut)]
    pub authority: Signer&lt;'info>,

    // Solana系统程序（用于创建新账户）
    pub system_program: Program&lt;'info, System>,
&#125;
4. 关键技术点解析

PDA（Program Derived Address）设计：帖子的PDA由&quot;tweet&quot; + 用户Profile的PDA + 帖子序号组成，确保每个用户的每条帖子有唯一标识，且可通过种子逆向推导。
状态更新依赖：创建帖子时必须先存在用户Profile（用于记录 tweet_count），否则会因无法获取Profile数据而失败。
存储空间分配：space = 8 + Tweet::INIT_SPACE中，8字节是Anchor账户的固定前缀（用于存储账户 discriminator），Tweet::INIT_SPACE由#[derive(InitSpace)]自动计算（包含body和like_count的空间）。

点赞功能（CreateLike）
1. 核心数据结构
点赞功能涉及两个核心数据结构：Like（存储点赞关系）和Tweet（记录点赞数）。Like定义在programs/anchor_social/src/state/like.rs中：
// programs/anchor_social/src/state/like.rs
use anchor_lang::prelude::*;

#[account]
#[derive(InitSpace)]
pub struct Like &#123;
    pub profile_pubkey: Pubkey,  // 点赞用户的公钥
    pub tweet_pubkey: Pubkey,  // 被点赞帖子的公钥
&#125;

impl Like &#123;
    pub const SEED_PREFIX: &amp;'static str = "like";  // PDA种子前缀

    // 初始化新点赞
    pub fn new(profile_pubkey: Pubkey, tweet_pubkey: Pubkey) -> Self &#123;
        Self &#123;
            profile_pubkey,
            tweet_pubkey,
        &#125;
    &#125;
&#125;
2. 前端API实现（创建点赞）
前端通过app/api/tweet.ts中的createLike函数发起点赞交易：
// app/api/tweet.ts
export async function createLike(
    wallet: anchor.Wallet,
    tweetPdas: anchor.web3.PublicKey  // 被点赞帖子的PDA
) &#123;
    // 调用链上程序创建点赞，返回交易签名
    return await program.methods.createLike()
        .accounts(&#123;
            tweet: tweetPdas,  // 被点赞的帖子账户
            authority: wallet.publicKey,  // 点赞用户
        &#125;)
        .signers([wallet.payer])  // 签名者（点赞用户）
        .rpc();
&#125;
3. 后端程序逻辑（创建点赞）
链上程序逻辑定义在programs/anchor_social/src/instructions/tweet.rs中，负责创建点赞记录、更新帖子点赞数：
// programs/anchor_social/src/instructions/tweet.rs
use crate::state::like::*;
use crate::state::tweet::*;
use anchor_lang::prelude::*;

// 处理创建点赞的核心逻辑
pub fn create_like(ctx: Context&lt;CreateLike>) -> Result&lt;()> &#123;
    // 1. 更新帖子的点赞数（+1）
    let tweet = &amp;mut ctx.accounts.tweet;
    tweet.like_count += 1;

    // 2. 初始化点赞记录（关联点赞用户和帖子）
    let like = Like::new(ctx.accounts.authority.key(), tweet.key());
    // 将点赞数据写入账户
    ctx.accounts.like.set_inner(like);
    Ok(())
&#125;

// 定义创建点赞所需的账户结构
#[derive(Accounts)]
pub struct CreateLike&lt;'info> &#123;
    // 点赞记录账户（新建）
    #[account(
        init,  // 初始化新账户
        payer = authority,  // 由点赞用户支付费用
        space = 8 + Like::INIT_SPACE,  // 分配存储空间
        seeds = [  // PDA种子（确保唯一：同一用户对同一帖子只能点赞一次）
            Like::SEED_PREFIX.as_bytes(),  // "like"
            profile.key().as_ref(),  // 点赞用户的Profile PDA
            tweet.key().as_ref()  // 被点赞帖子的PDA
        ],
        bump
    )]
    pub like: Account&lt;'info, Like>,

    // 被点赞的帖子账户（需已存在，更新点赞数）
    #[account(mut)]
    pub tweet: Account&lt;'info, Tweet>,

    // 点赞用户的Profile账户（验证用户身份）
    #[account(mut, seeds = [Profile::SEED_PREFIX.as_bytes(), authority.key().as_ref()], bump)]
    pub profile: Account&lt;'info, Profile>,

    // 点赞用户（签名者）
    #[account(mut)]
    pub authority: Signer&lt;'info>,

    // 系统程序（用于创建点赞账户）
    pub system_program: Program&lt;'info, System>,
&#125;
4. 关键技术点解析

点赞唯一性保障：点赞记录的PDA由&quot;like&quot; + 点赞用户Profile PDA + 帖子PDA组成，确保同一用户对同一帖子只能创建一条点赞记录（重复创建会因PDA已存在而失败）。
状态联动更新：点赞时同时更新两个状态：tweet.like_count（帖子的点赞数+1）和Like账户（存储点赞关系）。
依赖验证：点赞操作依赖三个前提：帖子账户已存在、点赞用户的Profile账户已存在，否则会因账户不存在而失败。

使用示例
以下是app/index.ts中发帖和点赞的调用示例，展示完整流程：
// app/index.ts
import &#123; useDefaultWallet, useVisitorWallet &#125; from "./api/wallet";
import &#123; createTweet, getTweet, createLike &#125; from "./api/tweet";

(async () => &#123;
    const defaultWallet = useDefaultWallet();  // 发帖用户钱包
    const visitorWallet = useVisitorWallet();  // 点赞用户钱包

    // 1. 创建帖子
    const [tweetPda, createTweetTx] = await createTweet(defaultWallet, "Hello, world!");
    console.log("帖子创建成功，PDA：", tweetPda.toBase58(), "交易签名：", createTweetTx);

    // 2. 获取帖子详情（验证创建结果）
    const tweet = await getTweet(defaultWallet, tweetPda);
    console.log("帖子初始信息：", tweet);  // like_count应为0

    // 3. 对帖子点赞
    const createLikeTx = await createLike(visitorWallet, tweetPda);
    console.log("点赞成功，交易签名：", createLikeTx);

    // 4. 再次获取帖子详情（验证点赞数更新）
    const updatedTweet = await getTweet(defaultWallet, tweetPda);
    console.log("点赞后帖子信息：", updatedTweet);  // like_count应为1
&#125;)();
总结
发帖和点赞功能通过Anchor框架实现了Solana区块链上的状态管理：

发帖功能通过PDA关联用户与帖子，确保唯一性并记录发帖数；
点赞功能通过PDA保障唯一点赞，并联动更新帖子的点赞数；
核心依赖Profile账户作为用户身份标识，所有操作均需验证账户存在性。

理解上述逻辑有助于掌握Solana上的PDA设计、账户交互及状态更新模式。
]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part12]_Anchor实战：spl token&amp;mint账户的创建</title>
    <url>/2025/08/18/Solana-part12-Anchor%E5%AE%9E%E6%88%98%EF%BC%9A/</url>
    <content><![CDATA[Solana[part12]_Anchor实战：spl token&amp;mint账户的创建
一、功能概述
createTokenMintAccount 是项目中用于创建代币铸造（Mint）账户及关联元数据账户的核心功能，基于 Solana 区块链和 Anchor 框架实现。其核心目标是：

通过 Anchor 指令初始化一个由 PDA（程序派生地址）控制的 SPL Token Mint 账户；
通过 CPI（跨程序调用）调用 Metaplex 元数据程序的 create_metadata_accounts_v3 方法，为 Mint 账户创建元数据（名称、符号、URI 等）。

二、token.rs 实现细节解析
1. 核心函数：create_token_mint_account
该函数是指令的入口，负责初始化 mint 账户并触发元数据账户的 CPI 调用，代码逻辑如下：
pub fn create_token_mint_account(ctx: Context&lt;CreateTokenMintAccount>) -> Result&lt;()> &#123;
    // 定义 PDA 签名种子（用于 CPI 调用时的签名验证）
    let signer_seeds: &amp;[&amp;[&amp;[u8]]] = &amp;[&amp;[b"mint_v3", &amp;[ctx.bumps.mint_account]]];
    // CPI 调用 Metaplex 的 create_metadata_accounts_v3 方法
    create_metadata_accounts_v3(
        CpiContext::new_with_signer(
            ctx.accounts.token_metadata_program.to_account_info(), // 元数据程序账户
            CreateMetadataAccountsV3 &#123;
                metadata: ctx.accounts.meta_account.to_account_info(), // 元数据账户
                mint: ctx.accounts.mint_account.to_account_info(), // mint 账户
                mint_authority: ctx.accounts.mint_account.to_account_info(), // mint 授权者（自身 PDA）
                update_authority: ctx.accounts.mint_account.to_account_info(), // 元数据更新授权者（自身 PDA）
                payer: ctx.accounts.authority.to_account_info(), // 支付者（外部签名者）
                system_program: ctx.accounts.system_program.to_account_info(), // 系统程序
                rent: ctx.accounts.rent.to_account_info(), // 租金系统变量
            &#125;,
            signer_seeds, // 传入 PDA 签名种子，确保 CPI 调用权限
        ),
        // 元数据内容（DataV2 结构）
        DataV2 &#123;
            name: "tokenchs".to_string(), // 代币名称
            symbol: "TKS".to_string(), // 代币符号
            uri: "https://example.com/tokenchs".to_string(), // 元数据 URI（通常指向JSON文件）
            seller_fee_basis_points: 0, // 卖家手续费（0表示无）
            creators: None, // 创作者信息（可选）
            collection: None, // 集合信息（可选）
            uses: None, // 用途限制（可选）
        &#125;,
        false, // 不创建主售市场
        true, // 允许第三方转让
        None, // 无集合授权
    )?;
    Ok(())
&#125;
关键逻辑说明：

PDA 签名种子：signer_seeds 使用 b&quot;mint_v3&quot; 和 mint_account 的 bump 值生成，用于证明当前程序对 mint_account 的控制权，确保 CPI 调用有权限操作元数据。
CPI 调用参数：通过 CreateMetadataAccountsV3 结构体指定元数据账户、mint 账户、授权者等关键账户，其中 mint_authority 和 update_authority 均设为 mint_account 自身（PDA），确保只有 mint 账户的控制程序（当前程序）可修改权限。
元数据内容：DataV2 结构体固定了代币 的名称、符号和 URI，实际场景中可改为动态参数传入。

2. 账户结构：CreateTokenMintAccount
该结构体定义了指令所需的所有账户及其约束条件，确保链上账户的安全性和正确性：
#[derive(Accounts)]
pub struct CreateTokenMintAccount&lt;'info> &#123;
    /// 元数据账户（存储代币 元数据）
    #[account(
        mut,
        seeds = [
            b"metadata", // 固定前缀
            token_metadata_program.key().as_ref(), // 元数据程序地址
            mint_account.key().as_ref(), // mint 账户地址
        ],
        bump, // 自动计算 bump 值
        seeds::program = token_metadata_program.key(), // 种子校验程序
    )]
    pub meta_account: UncheckedAccount&lt;'info>,

    /// Mint 账户（代币铸造账户）
    #[account(
        init_if_needed, // 若不存在则初始化
        payer = authority, // 由 authority 支付租金
        seeds = [b"mint_v3"], // 固定种子（用于生成 PDA）
        bump, // 自动计算 bump 值
        mint::decimals = 100, // 代币小数位为 100
        mint::authority = mint_account.key(), // 授权者为自身 PDA
    )]
    pub mint_account: Account&lt;'info, Mint>,

    /// 交易支付者（外部签名者）
    #[account(mut)]
    pub authority: Signer&lt;'info>,

    /// SPL Token 程序（用于处理代币逻辑）
    pub token_program: Program&lt;'info, Token>,

    /// 系统程序（用于创建账户）
    pub system_program: Program&lt;'info, System>,

    /// Metaplex 元数据程序（用于创建元数据）
    pub token_metadata_program: Program&lt;'info, Metadata>,

    /// 租金系统变量（用于计算账户存储费用）
    pub rent: Sysvar&lt;'info, Rent>,
&#125;
账户约束说明：

meta_account：通过 b&quot;metadata&quot; + 元数据程序地址 + mint 地址 生成种子，确保元数据账户与 mint 账户一一对应，符合 Metaplex 元数据账户的标准生成规则。
mint_account：使用 b&quot;mint_v3&quot; 作为种子生成 PDA，init_if_needed 确保重复调用时不会重复创建；mint::authority 设为自身，意味着只有通过该 PDA 签名（即当前程序）才能执行铸造 等操作，增强安全性。

三、前端测试调用逻辑（app/api/token.ts）
前端通过 createTokenMintAccount 函数触发链上指令，核心逻辑是生成 mint 账户的 PDA 并发送交易：
export async function createTokenMintAccount(wallet: anchor.Wallet) &#123;
    // 生成 mint 账户的 PDA（与链上种子 b"mint_v3" 对应）
    const [splTokenPda,] = anchor.web3.PublicKey.findProgramAddressSync(
        [Buffer.from("mint_v3"),],
        program.programId,
    );

    // 发送交易调用链上指令
    return [splTokenPda,
        await program.methods.createTokenMintAccount().accounts(&#123;
            // 需补充账户参数（当前为空，实际调用需传入以下账户）
            // authority: wallet.publicKey,
            // mintAccount: splTokenPda,
            // tokenMetadataProgram: METADATA_PROGRAM_ID,
            // ...其他必要账户
        &#125;).rpc()];
&#125;
注意事项：

前端需显式传入 accounts 参数，包括 authority、mint_account、token_metadata_program 等，否则会因账户缺失导致交易失败。
PDA 生成需与链上 mint_account 的种子（b&quot;mint_v3&quot;）保持一致，确保地址匹配。

四、测试注意事项与踩坑点
1. 环境配置（必做）
使用 create_metadata_accounts_v3 CPI 需确保本地测试环境加载 Metaplex 元数据程序：
# 下载元数据程序二进制文件
solana program dump -u m metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s metadata.so
# 启动本地测试网并加载程序
solana-test-validator -r --bpf-program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s metadata.so

若未加载，会出现 Program not found 错误，导致 CPI 调用失败。

2. PDA 签名与权限问题

问题：CPI 调用时出现 Signature verification failed，通常因 signer_seeds 与 mint_account 种子不匹配。
解决：确保链上 mint_account 的种子（b&quot;mint_v3&quot;）与 signer_seeds 完全一致，且 bump 值正确（通过 ctx.bumps.mint_account 获取）。

3. 账户参数缺失

问题：前端调用时未传入 token_metadata_program、system_program 等账户，导致交易因账户验证失败而回滚。
解决：补充完整账户参数，示例：await program.methods.createTokenMintAccount().accounts(&#123;
    authority: wallet.publicKey,
    mintAccount: splTokenPda,
    metaAccount: metaPda, // 需提前计算元数据账户 PDA
    tokenProgram: TOKEN_PROGRAM_ID,
    tokenMetadataProgram: METADATA_PROGRAM_ID,
    systemProgram: SystemProgram.programId,
    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
&#125;).rpc()


4. 元数据账户空间不足

问题：元数据字段（如 name、uri）过长导致账户空间不足，交易失败。
解决：限制 DataV2 字段长度（如 name 不超过 32 字节），或动态计算所需空间。

五、测试验证

导出metadata程序

solana program dump -u m metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s metadata.so

启动测试验证器

solana-test-validator -r --bpf-program metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s metadata.so

部署程序

anchor build &amp;&amp; anchor deploy

执行测试

 anchor run api 
 --------------
 ➜  anchor_social git:(main) ✗ anchor run api               
yarn run v1.22.18
warning ../package.json: No license field
$ /Users/tinachan/anchor_social/node_modules/.bin/ts-node app/index.ts
DuFS4L7YDYsEnXeyc13g5xTxKYdcpNRvXkbrsp7BmbAW tm2FqnqSAZ5KhT5499ozLUh38RZAZM1BPuSst7A97N4f1WSsE9hZFbvnzuEu569dwrnHiGarJRE5BiuRsQHn4jj

https://explorer.solana.com/ 查看账户详情



可以看到这里就创建了一个有metadata体的token
SPL-TOKEN 定义

Solana SPL Token 与其他区块链 Token 的核心区别
1. 技术架构：账户模型 vs 智能合约



维度
Solana SPL Token
ETH ERC20 / BSC BEP20




实现方式
复用 SPL Token Program 统一逻辑，无需部署合约
每个 Token 是独立 智能合约（如 ERC20 合约）


部署成本
仅需创建 Mint/Token 账户（链上数据存储）
需部署完整合约（消耗 Gas，代码存储占空间）


灵活性
依赖 SPL 标准扩展（如 Token 2022），但逻辑集中
可自定义合约逻辑（如分红、销毁规则），更灵活



2. 性能与执行效率

Solana 优势：
基于 并行处理（Tower BFT + 流水线），SPL Token 操作可并行执行，支持 10 万 + TPS（理论值）。
例：转账、铸币等操作通过 CPI 调用 Token Program，无需逐个验证合约逻辑。
ETH/BSC 限制：
交易串行处理（基于 Gas 竞价），ERC20 交易 TPS 仅 30-300，且复杂逻辑（如批量转账）会进一步降低效率。

3. 账户模型细节

SPL Token 的 “账户分离”：
用户的 Token 余额存储在 独立的 Token Account（需提前创建，关联 Mint），而非用户钱包本身。
例：用户 A 的 USDC 余额 → 一个 Token Account（地址：...，mint: USDC Mint，owner: A）。
ERC20 的 “合约内映射”：
余额直接记录在 ERC20 合约的 mapping(address =&gt; uint256) balances 中，用户钱包地址本身不存储 Token 数据。

4. 生态与标准扩展

SPL 的统一扩展：

元数据：通过 Token Metadata Program 统一管理（名称、URI、符号），与 NFT 标准（如 Metaplex）无缝兼容。
进阶标准：Token 2022（更灵活的权限控制）、NFT（基于 SPL Token 的变种）。


ERC20 的分散扩展：

元数据需额外协议（如 OpenSea 的 Metadata 标准），各扩展标准（ERC721、ERC1155）需独立开发，兼容性依赖开发者实现。



5. 跨程序调用（CPI） vs 合约调用

Solana CPI：
类似 “函数调用”，支持 嵌套跨程序调用（如 Token Metadata Program 调用 Token Program 获取 Mint 信息），逻辑更高效。
ETH 合约调用：
通过 call 指令调用其他合约，嵌套深度受限（避免栈溢出），复杂交互成本高。

总结
createTokenMintAccount 功能通过 Anchor 框架整合了 SPL Token 和 Metaplex 元数据程序，核心逻辑集中在 token.rs 中：

定义 PDA 控制的 mint 账户，确保权限安全；
通过 CPI 调用生成关联的元数据账户，固定代币元数据内容；
前端需正确生成 PDA 并传入完整账户参数才能触发交易。

测试时需重点关注环境配置、PDA 种子一致性和账户参数完整性，避免因链上程序依赖或权限问题导致失败。
]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part13]_Anchor实战：为用户Mint Spl TOKEN</title>
    <url>/2025/08/19/Solana-part13-Anchor%E5%AE%9E%E6%88%98%EF%BC%9A%E4%B8%BA%E7%94%A8%E6%88%B7Mint-Spl-TOKEN/</url>
    <content><![CDATA[Solana[part13]_Anchor实战：为用户Mint Spl TOKEN
该部分代码见：https://github.com/SoniaChan33/anchor_social/commit/5abd954500f2926d999ac644c18a97c91cde9fb6
createLike指令添加需要的account
/anchor_social/src/instructions/tweet.rs
#[derive(Accounts)]
pub struct CreateLike&lt;'info> &#123;
    #[account(
        mut,
        seeds = [b"mint_v3",],
        bump,
    )]
    pub mint_account: Account&lt;'info, Mint>,

    #[account(
        init_if_needed,
        payer = authority,
        associated_token::mint = mint_account,
        associated_token::authority = author_wallet,
    )]
    pub author_token_account: Account&lt;'info, TokenAccount>,

    /// CHECK : THIS IS AUTHOR WALLET
    pub author_wallet: AccountInfo&lt;'info>,

    #[account(
        init,
        payer = authority,
        space = 8 + Like::INIT_SPACE,
        seeds = [
            Like::SEED_PREFIX.as_bytes().as_ref(),
            profile.key().as_ref(),
            tweet.key().as_ref()
        ],
        bump
    )]
    pub like: Account&lt;'info, Like>,

    #[account(mut)]
    pub tweet: Account&lt;'info, Tweet>,


    #[account(mut, seeds = [Profile::SEED_PREFIX.as_bytes(), authority.key().as_ref()], bump)]
    pub profile: Account&lt;'info, Profile>,
    #[account(mut)]
    pub authority: Signer&lt;'info>,
    pub system_program: Program&lt;'info, System>,

    pub associated_token_program: Program&lt;'info, AssociatedToken>,

    pub token_program: Program&lt;'info, Token>, // 新增的Token程序字段
&#125;

tweet结构体修改
#[account]
#[derive(InitSpace)]
pub struct Tweet &#123;
    #[max_len(50)]
    pub body: String,

    pub like_count: u64,
    pub author: Pubkey,
&#125;
impl Tweet &#123;
    pub const SEED_PREFIX: &amp;'static str = "tweet";

    pub fn new(body: String, author: Pubkey) -> Self &#123;
        Self &#123;
            body,
            like_count: 0,
            author,
        &#125;
    &#125;
&#125;

添加author属性记录要mint to的author token account 地址
同时需要修改create_tweet函数的细节：
pub fn create_tweet(ctx: Context&lt;CreateTweet>, body: String) -> Result&lt;()> &#123;
    let profile = &amp;mut ctx.accounts.profile;
    profile.tweet_count += 1;
    let tweet = Tweet::new(body, ctx.accounts.tweet.key()); // 这里添加tweet的地址
    ctx.accounts.tweet.set_inner(tweet.clone());
    Ok(())
&#125;

修改createLike方法
pub fn create_like(ctx: Context&lt;CreateLike>) -> Result&lt;()> &#123;
    let tweet = &amp;mut ctx.accounts.tweet;
    tweet.like_count += 1;

    let like = Like::new(ctx.accounts.profile.key(), tweet.key());
    ctx.accounts.like.set_inner(like);
    // 打印mint_account的地址
    msg!("mint_account: &#123;&#125;", ctx.accounts.mint_account.key());
    msg!(
        "author_token_account: &#123;&#125;",
        ctx.accounts.author_token_account.key()
    );

    mint_to(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            MintTo &#123;
                mint: ctx.accounts.mint_account.to_account_info(),
                to: ctx.accounts.author_token_account.to_account_info(),
                authority: ctx.accounts.mint_account.to_account_info(),
            &#125;,
            &amp;[&amp;[b"mint_v3", &amp;[ctx.bumps.mint_account]]],
        ),
        100,
    )?;
    Ok(())
&#125;
关键参数解析：


CpiContext::new_with_signer：创建跨程序调用（CPI）上下文，因为铸造代币需要调用 Solana 的 Token 程序（token_program）。


MintTo
结构体：指定铸造相关的账户：

mint：代币的铸造账户（mint_account），负责生成新代币。
to：接收代币的账户（author_token_account，推文作者的代币账户）。
authority：铸造权限的拥有者（这里是mint_account自身，因为该账户的权限通过种子验证）。



签名种子&amp;[&amp;[b&quot;mint_v3&quot;, &amp;[ctx.bumps.mint_account]]]：用于验证mint_account的权限（该账户是通过b&quot;mint_v3&quot;种子和 bump 值创建的，因此需要用相同种子证明有权限铸造代币）。


最后一个参数100：指定铸造的代币数量（向作者账户铸造 100 个代币）。


api重新调用这部分代码
// 创建推文
const [pda, r3] = await createTweet(defaultWallet, "Hello, world!");

const r4 = await getTweet(defaultWallet, pda);
console.log("defaultWallet public key:", defaultWallet.publicKey);

console.log(r4);

// 创建点赞
const visitorPublicKey = visitorWallet.publicKey;
console.log("Visitor public key:", visitorPublicKey.toString());
const r5 = await createLike(visitorWallet, pda);
console.log("Like created:", r5);

const r6 = await getTweet(defaultWallet, pda);
console.log(r6);
结果校验
  anchor_social git:(main) anchor run api
yarn run v1.22.18
warning ../package.json: No license field
$ /Users/tinachan/anchor_social/node_modules/.bin/ts-node app/index.ts
defaultWallet public key: PublicKey [PublicKey(FcKkQZRxD5P6JwGv58vGRAcX3CkjbX8oqFiygz6ohceU)] &#123;
  _bn: &lt;BN: d91024e709f54d65b29c9328658d06a488414c4cabc36522130c330322428769>
&#125;
&#123;
  body: 'Hello, world!',
  likeCount: &lt;BN: 0>,
  author: PublicKey [PublicKey(BiQgNLwkejkdYyvbSSCjKhTsdK6tmn6YZiXhApX88L1q)] &#123;
    _bn: &lt;BN: 9f3074c28783b31efe51bdc42e5a0a6a8c2314d017da6a8ed713ccecd1aee164>
  &#125;
&#125;
Visitor public key: 7rQKPb1bPLS4xU93a43GYmBK7MfY3ChSTSVfA8fcxbRF
Like created: 59rjviQxEK68USP6VfPjqpciwKNcf98jTUpv7CBWEdFqNbAvh9FBTwH3RCcwviK8Wu92G3WACgwv6rafsWgitWDT
&#123;
  body: 'Hello, world!',
  likeCount: &lt;BN: 1>,
  author: PublicKey [PublicKey(BiQgNLwkejkdYyvbSSCjKhTsdK6tmn6YZiXhApX88L1q)] &#123;
    _bn: &lt;BN: 9f3074c28783b31efe51bdc42e5a0a6a8c2314d017da6a8ed713ccecd1aee164>
  &#125;
&#125;
✨  Done in 2.45s.
成功后查看author token account的账户

]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part15]_Solana质押-流动性质押</title>
    <url>/2025/08/20/Solana-part15-Solana%E8%B4%A8%E6%8A%BC-%E6%B5%81%E5%8A%A8%E6%80%A7%E8%B4%A8%E6%8A%BC/</url>
    <content><![CDATA[Solana[part15]_Solana质押-流动性质押
一、流动性质押核心概念与角色
1. 基本定义
流动性质押（Liquid Staking）是一种允许用户质押加密资产支持区块链网络安全，同时通过接收流动性代币（Liquid Staking Token, LST）保持资产流动性的机制。
在Solana生态中，用户质押SOL后会收到对应比例的LST（如mSOL、stSOL等），这些代币可在DeFi应用中自由使用（交易、借贷等），同时仍能获得质押奖励。
2. 工作原理
graph TD
    A[用户质押SOL] --&gt; B[流动性质押协议接收SOL]
    B --&gt; C[协议分配SOL给验证者节点]
    B --&gt; D[用户获得等额LST]
    D --&gt; E[LST在DeFi场景使用]
    C --&gt; F[产生质押奖励]
    F --&gt; G[LST价值随奖励增值]
    D --&gt; H[用户赎回LST为SOL]
    
3. 与原生质押的核心区别



特性
原生质押
流动性质押




资产流动性
低（解锁需2-3天）
高（LST可自由流通）


资金利用率
低（资金锁定）
高（LST可复用至其他场景）


收益模式
单一质押奖励
质押奖励+LST应用收益


操作复杂度
较低
中等（需了解LST生态）



4. 核心角色与职责



角色
核心职责




Manager
质押池创建者，负责配置规则（费率、权限）、管理验证者节点、维护质押池平衡


User
质押SOL/质押账户、获取LST、赎回资产，享受质押收益



二、环境准备（本地测试网）

前置操作：为后续Manager和User的实操搭建本地测试环境

1. 工具安装
# 安装Solana CLI和质押池工具
sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
cargo install spl-stake-pool-cli

# 克隆质押池代码（部署依赖）
git clone https://github.com/solana-labs/spl-stake-pool.git
cd spl-stake-pool &amp;&amp; cargo build-bpf
2. 启动本地测试网（加载质押池程序）
solana-test-validator \
  --ledger ./test-ledger \  # 数据存储路径
  --bpf-program STAKE11111111111111111111111111111111111111 ./target/deploy/spl_stake_pool.so \  # 加载质押池程序
  --reset  # 重置测试网状态（首次启动建议添加）
三、Manager操作：质押池全生命周期管理

流程：创建身份 → 初始化质押池 → 配置验证者 → 维护质押池

1. 生成Manager身份密钥
solana-keygen new --outfile pool-manager.json --no-passphrase
2. 创建质押池（初始化核心参数）
# 替换$USER_ADDR为后续用户主账户地址（见第四章步骤1）
spl-stake-pool create-pool \
  --manager pool-manager.json \          # Manager身份（签名权限）
  --fee-owner $USER_ADDR \              # 管理费接收地址
  --withdrawal-fee 0.01 \               # 提现手续费（1%）
  --management-fee 0.1 \                # 质押奖励管理费（10%）
  --stake-deposit-authority $USER_ADDR \# 允许用户存入质押账户的权限
  --withdrawal-authority $USER_ADDR \   # 允许用户提现的权限
  --no-lamports-check                   # 测试网跳过余额检查

输出关键信息：质押池地址（POOL_ADDR）、流动性代币Mint地址（TOKEN_MINT）

3. 配置流动性代币元数据（钱包显示）
spl-stake-pool create-token-metadata \
  $POOL_ADDR \           # 质押池地址
  "MyStakePoolToken" \   # 代币名称
  "MPT" \                # 代币符号（如mSOL）
  --manager pool-manager.json
4. 验证者节点管理
① 创建测试验证者投票账户（测试网专用）
solana-keygen new --outfile validator.json --no-passphrase
solana create-vote-account validator-vote.json validator.json 100
VALIDATOR_VOTE_ADDR=$(solana address -k validator-vote.json)  # 获取验证者投票地址
② 添加验证者到质押池
spl-stake-pool add-validator \
  $POOL_ADDR \
  $VALIDATOR_VOTE_ADDR \  # 验证者投票账户地址
  --manager pool-manager.json
③ 调整验证者质押分配


增加质押量（100 SOL）：
spl-stake-pool increase-validator-stake \
  $POOL_ADDR \
  $VALIDATOR_VOTE_ADDR \
  100 \
  --manager pool-manager.json


减少质押量（50 SOL）：
spl-stake-pool decrease-validator-stake \
  $POOL_ADDR \
  $VALIDATOR_VOTE_ADDR \
  50 \
  --manager pool-manager.json


5. 质押池维护（收益再平衡）
定时触发质押资金在验证者间的优化分配（向高收益节点倾斜）：
spl-stake-pool update \
  $POOL_ADDR \
  --manager pool-manager.json
四、User操作：质押与赎回全流程

流程：创建用户身份 → 质押SOL/质押账户 → 赎回SOL/质押账户

1. 准备User主账户
solana-keygen new --outfile user.json --no-passphrase
solana config set --keypair user.json  # 设为默认签名账户
USER_ADDR=$(solana address)  # 获取用户地址
solana airdrop 1000 $USER_ADDR  # 测试网空投SOL（用于质押）
2. 质押操作
① 直接质押SOL（自动创建质押账户）
适合普通用户，无需提前准备质押账户：
spl-stake-pool deposit-sol \
  $POOL_ADDR \  # 目标质押池地址
  50 \          # 质押50 SOL
  --source user.json  # 用户签名
② 质押已有质押账户（自定义质押策略）
适合机构用户或需灵活配置质押的场景：

先创建质押账户：solana create-stake-account stake-account.json 100  # 质押账户存入100 SOL

存入质押池：spl-stake-pool deposit-stake \
  $POOL_ADDR \
  stake-account.json \  # 已创建的质押账户
  --source user.json    # 用户签名


3. 赎回操作
① 直接赎回SOL（快速提现，依赖池内流动性）
适合紧急或小额提现：
spl-stake-pool withdraw-sol \
  $POOL_ADDR \
  20 \          # 赎回20 SOL
  --owner user.json  # 用户签名
② 赎回至新质押账户（大额赎回，需解锁期）


发起提现请求（创建新质押账户）：
spl-stake-pool request-withdrawal \
  $POOL_ADDR \
  30 \  # 赎回30 SOL对应的LST
  --owner user.json \
  --new-stake-account new-stake.json  # 新质押账户


测试网跳过解锁期（模拟时间流逝）：
solana advance-clock +1000  # 推进1000个slot（约10分钟）


完成提现并提取SOL到主账户：
spl-stake-pool complete-withdrawal \
  $POOL_ADDR \
  new-stake.json \
  --owner user.json

solana withdraw-stake new-stake.json $USER_ADDR 100%  # 从质押账户提取全部SOL


五、机制解析与操作对比
1. 流动性代币（LST）增值逻辑

初始比例为1:1（1 LST = 1 SOL），随质押奖励累积，1 LST对应的SOL数量会增长（如1:1.1）。
Manager收取的管理费（如10%）从用户奖励中扣除，直接影响LST增值速度。

2. User操作对比表



操作类型
特点
适用场景




deposit-sol
自动创建质押账户，操作简
普通用户小额质押


deposit-stake
需提前创建质押账户，灵活
机构用户/自定义策略


withdraw-sol
快速赎回，依赖池内流动性
紧急提现/小额赎回


withdraw-stake
需解锁期，金额无上限
大额赎回/长期质押后提现



3. Manager核心逻辑

验证者优化：通过add-validator和质押量调整，将资金分配给高收益、低风险验证者。
自动平衡：update操作触发资金重分配，确保收益最大化。
规则控制：可通过set-withdrawal-fee/set-management-fee动态调整费率。

六、常见问题与调试
1. Manager操作报错

Permission denied：检查--manager参数是否为pool-manager.json（需Manager签名）。
Validator not found：确认验证者投票账户地址正确，且已通过add-validator加入池。

2. User操作问题

质押后未收到LST：通过solana transaction-status &lt;TX_HASH&gt;查询交易状态，确认质押池是否有权限发行代币。
赎回失败：withdraw-sol失败可能因池内流动性不足，建议改用withdraw-stake。

3. 质押池update无效果

确保池内有可分配的质押资金，或验证者投票账户状态正常（可通过solana vote-account &lt;VOTE_ADDR&gt;检查）。

通过Manager对质押池的专业管理与User的灵活操作，流动性质押实现了“收益性”与“流动性”的平衡。本地测试网可反复演练上述流程，帮助理解其底层逻辑！
]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part14]_Solana质押-native stake</title>
    <url>/2025/08/20/Solana-part14-Solana%E8%B4%A8%E6%8A%BC-native-stake/</url>
    <content><![CDATA[Solana[part14]_Solana质押-native stake
什么是 Solana Native Staking？
Solana 的原生质押（Native Staking）是指将 SOL 代币质押给验证者，以支持 Solana 网络的安全运行并获得相应奖励的过程。通过质押，用户可以参与网络共识，同时获得年化收益（APY 通常在 4-8% 之间浮动）。
一、钱包操作方式
1. 准备工作

安装支持 Solana 质押的钱包（推荐：Phantom、Solflare、Ledger Live）
确保钱包中有足够的 SOL（至少需要覆盖质押金额 + 交易手续费）
了解 Solana 验证者的基本信息（可以在 Solana Validator Explorer 查看）

2. 使用 Phantom 钱包进行质押
步骤 1：打开 Phantom 钱包并连接到 Solana 主网
确保钱包网络已切换至 “Solana Mainnet Beta”
步骤 2：导航至质押页面

在钱包主页点击 “Stake” 或 “质押” 选项
点击 “Add Stake” 或 “添加质押” 按钮

步骤 3：选择验证者

可以通过搜索验证者的名称或地址查找
查看验证者的佣金比例、活跃度和历史表现
选择合适的验证者后点击 “Select” 或 “选择”

步骤 4：输入质押金额

输入要质押的 SOL 数量
确认交易手续费（通常自动计算）
点击 “Stake” 或 “质押” 按钮

步骤 5：确认交易

检查交易详情无误后确认
等待交易被网络确认（通常需要几秒钟到一分钟）

步骤 6：查看质押状态

在 “Stake” 页面可以查看所有质押头寸
包括质押金额、验证者信息、预计收益和解锁时间

3. 解除质押（Unstake）

在质押头寸旁点击 “Unstake” 或 “解除质押”
确认交易，等待网络确认
注意：解除质押后，资金有大约 2-3 天的解锁期，期间无法转移或再次质押

4. 领取奖励

大多数钱包会自动累积奖励
部分钱包需要手动点击 “Claim Rewards” 或 “领取奖励”
奖励会直接添加到你的可用余额中

二、CLI 操作方式
1. 准备工作
# 创建新钱包
solana-keygen new --outfile ~/.config/solana/my-wallet.json

# 导入现有钱包（如有私钥文件）
# solana-keygen recover -o ~/.config/solana/my-wallet.json

# 设置默认钱包
solana config set --keypair ~/.config/solana/my-wallet.json

# 查看钱包余额
solana balance
2. 进行质押
步骤 1：创建质押账户
# 创建一个质押账户，需要支付少量租金
solana create-stake-account ~/.config/solana/my-stake-account.json 10 SOL
# 注意：10 SOL 是质押的最小金额示例，实际可根据需要调整
步骤 2：查找验证者
# 获取验证者列表（前100名）
solana validators --output json-compact | jq '.validators[0:100] | map(&#123;votePubkey: .votePubkey, commission: .commission, activatedStake: .activatedStake&#125;)'

# 选择一个验证者的 vote account 地址（示例）
VALIDATOR_VOTE_ADDRESS="GdnSyH3YtwcxFvQrVVJMm1JhTS4QVX7MFsX56uJLUfiZ"
步骤 3：进行质押
# 将质押账户委托给验证者
solana delegate-stake ~/.config/solana/my-stake-account.json $VALIDATOR_VOTE_ADDRESS
步骤 4：查看质押状态
# 查看质押账户信息
solana stake-account ~/.config/solana/my-stake-account.json

# 查看所有质押账户
solana stakes
3. 增加质押金额
# 向现有质押账户添加更多 SOL
solana delegate-stake --increase ~/.config/solana/my-stake-account.json $VALIDATOR_VOTE_ADDRESS 5 SOL
# 这里的 5 SOL 是要增加的质押金额
4. 解除质押
# 解除质押（开始解锁过程）
solana deactivate-stake ~/.config/solana/my-stake-account.json

# 检查解锁状态（需要等待解锁期）
solana stake-account ~/.config/solana/my-stake-account.json
5. 提取质押资金
在解锁期结束后，可以提取资金：
# 提取质押的 SOL 到钱包
solana withdraw-stake ~/.config/solana/my-stake-account.json ~/.config/solana/my-wallet.json 100%
# 100% 表示提取全部金额，也可以指定具体数量如 5 SOL
6. 领取奖励
# 查看可领取的奖励
solana get-rewards ~/.config/solana/my-stake-account.json --output json

# 领取奖励到钱包
solana withdraw-stake --withdraw-from-rewards ~/.config/solana/my-stake-account.json ~/.config/solana/my-wallet.json 100%
三、注意事项


验证者选择：选择佣金合理、历史表现良好的验证者，避免选择过于集中的验证者以分散风险。


质押周期：质押没有固定期限，但解除质押有 2-3 天的解锁期。


奖励计算：奖励按 epoch（约 2 天）计算和发放，具体收益取决于网络整体质押率和验证者表现。


安全考虑：

不要将私钥分享给任何人
大额质押建议使用硬件钱包（如 Ledger）
定期检查验证者状态



费用问题：所有操作都需要支付少量交易费，确保钱包中有足够的 SOL 支付费用。


]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part2]_Solana开发入门</title>
    <url>/2025/08/05/Solana-part2-Solana%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[Solana[part2]_Solana开发入门
虚拟机
Solana的执行环境与其他区块链存在显著差异，其虚拟机架构是实现高吞吐量的核心基础之一：

EVM（Ethereum Virtual Machine）：以太坊等区块链采用的虚拟机，基于栈式架构，Solana不直接支持EVM，但可通过跨链桥或兼容层（如Neon EVM）实现EVM合约迁移。
WASM（WebAssembly）：通用二进制指令格式，Solana早期曾考虑采用，但最终选择了更轻量的方案。
Sealevel VM：Solana原生虚拟机，支持并行执行（区别于EVM的串行执行），是Solana高TPS（每秒交易数）的关键，可同时处理数千个独立合约调用。
BPF扩展指令集：Sealevel VM基于BPF（Berkeley Packet Filter）扩展，具有高效、安全、低资源占用的特点，适合区块链场景的沙箱执行环境。

项目搭建
1. Native Rust开发（原生开发方式）
直接使用Rust编写Solana合约，适合深入理解底层机制。
环境准备

安装Rust：curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
安装Solana CLI：sh -c &quot;$(curl -sSfL https://release.solana.com/v1.18.4/install)&quot;（版本号可按需更新）
配置网络：solana config set --url https://api.devnet.solana.com（使用devnet测试网）
获取测试网SOL（用于支付gas）：solana airdrop 1（每次最多1 SOL，不足可重复申请）

步骤详解


创建项目
cargo new --lib native-rust &amp;&amp; cd native-rust
cargo add solana-program  # 添加Solana合约核心依赖


修改编译配置
编辑Cargo.toml，指定输出为动态链接库（Solana合约要求）：
# 顶部添加（解决edition2024兼容问题）
cargo-features = ["edition2024"]

[package]
name = "native-rust"
version = "0.1.0"
edition = "2024"  # 需与cargo-features对应

[lib]
crate-type = ["cdylib", "lib"]  # 输出为动态链接库

[dependencies]
solana-program = "1.18.0"  # 建议指定明确版本


编写基础合约
编辑src/lib.rs，实现合约入口函数（Solana合约必须包含entrypoint!宏定义的入口）：
use solana_program::&#123;
    entrypoint,
    account_info::AccountInfo,
    entrypoint::ProgramResult,
    msg,  // 用于日志输出（链上可见）
    pubkey::Pubkey,
&#125;;

// 定义入口函数
entrypoint!(process_instruction);

/// 合约核心逻辑
/// 参数说明：
/// - program_id: 合约本身的公钥
/// - accounts: 本次交互涉及的账户列表
/// - instruction_data: 传入的指令数据（二进制）
fn process_instruction(
    program_id: &amp;Pubkey,
    accounts: &amp;[AccountInfo],
    instruction_data: &amp;[u8],
) -> ProgramResult &#123;
    // 链上日志（可通过solana logs查看）
    msg!("Hello Solana!");
    msg!("Program ID: &#123;&#125;", program_id);
    msg!("Accounts involved: &#123;:?&#125;", accounts.len());
    msg!("Instruction data length: &#123;&#125;", instruction_data.len());
    
    Ok(())  // 返回成功结果
&#125;


构建合约
使用Solana的BPF编译器编译（生成.so文件）：
cargo build-sbf  # 编译为Solana兼容的BPF格式
编译成功后，输出文件路径：target/sbpf-solana-solana/release/native_rust.so


部署与验证


部署到测试网：
solana program deploy target/sbpf-solana-solana/release/native_rust.so
部署成功后会返回Program Id: &lt;YOUR_PROGRAM_ID&gt;（记录此ID用于后续交互）。


验证部署：
solana program show &lt;YOUR_PROGRAM_ID>  # 查看合约状态




合约管理

升级合约（需提前配置升级权限）：solana program upgrade &lt;new_so_file> &lt;YOUR_PROGRAM_ID> --upgrade-authority &lt;AUTHORITY_KEYPAIR>

关闭合约（回收存储空间，需合约所有者权限）：solana program close &lt;YOUR_PROGRAM_ID>




常见问题

编译报错feature edition2024 is required：确保Cargo.toml顶部添加了cargo-features = [&quot;edition2024&quot;]。
部署失败Insufficient funds：通过solana airdrop 1获取更多测试网SOL。
日志无法查看：使用solana logs --url https://api.devnet.solana.com监听链上日志。

2. Playground（在线开发工具）
适合快速原型开发，无需本地环境配置，推荐新手入门使用。
操作步骤

访问在线IDE：Solana Playground
点击New Project → 选择Solana Program，自动生成基础框架。
编辑src/lib.rs（同Native方式的合约逻辑）。
连接钱包：点击左侧Build &amp; Deploy → Connect Wallet（推荐使用Phantom钱包，切换到devnet）。
构建部署：点击Build编译，成功后点击Deploy，等待部署完成（需支付少量gas）。
查看部署详情：部署成功后，左下角会显示Program ID，点击链接可在Solana Explorer中查看合约信息。

交互示例（客户端）
通过自动生成的client.ts（TypeScript）与合约交互：
import &#123; Connection, PublicKey, Transaction, SystemProgram &#125; from "@solana/web3.js";
import &#123; sendTransaction &#125; from "./utils/sendTransaction";

// 合约地址（替换为你的Program ID）
const PROGRAM_ID = new PublicKey("YOUR_PROGRAM_ID");

async function main() &#123;
  const connection = new Connection("https://api.devnet.solana.com");
  const payer = (await window.solana.connect()).publicKey;

  // 构建交易
  const transaction = new Transaction().add(&#123;
    programId: PROGRAM_ID,
    keys: [&#123; pubkey: payer, isSigner: true, isWritable: false &#125;],  // 传入 payer 账户
    data: Buffer.from([]),  // 空指令数据
  &#125;);

  // 发送交易
  const signature = await sendTransaction(transaction, connection);
  console.log("Transaction signature:", signature);
  console.log("View on Explorer: https://explorer.solana.com/tx/" + signature + "?cluster=devnet");
&#125;

main();
点击Run执行客户端代码，在控制台查看交易结果。
3. Anchor（开发框架）
Anchor是Solana生态最流行的开发框架，简化了合约编写、测试和部署流程，内置类型安全和序列化工具。
环境安装
# 安装Anchor CLI
cargo install --git https://github.com/coral-xyz/anchor anchor-cli --locked

# 验证安装
anchor --version  # 需显示0.29.0+版本

# 安装yarn
npm install -g yarn
或者
brew install yarn # 这个会默认系统配置
项目操作


创建项目
anchor init anchor-project &amp;&amp; cd anchor-project
项目结构：
anchor-project&#x2F;
├── programs&#x2F;          # 合约代码（Rust）
│   └── anchor_project&#x2F;
├── tests&#x2F;             # 测试代码（TypeScript）
├── migrations&#x2F;        # 部署脚本
├── Anchor.toml        # 项目配置（网络、合约地址等）
└── Cargo.toml         # 依赖管理


编写合约（以计数器为例）
编辑programs/anchor_project/src/lib.rs：
use anchor_lang::prelude::*;

// 声明程序ID（需与Anchor.toml中一致）
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod anchor_project &#123;
    use super::*;

    // 初始化计数器
    pub fn initialize(ctx: Context&lt;Initialize>) -> Result&lt;()> &#123;
        let counter = &amp;mut ctx.accounts.counter;
        counter.count = 0;  // 初始值为0
        msg!("Counter initialized! Current count: &#123;&#125;", counter.count);
        Ok(())
    &#125;

    // 增加计数
    pub fn increment(ctx: Context&lt;Increment>) -> Result&lt;()> &#123;
        let counter = &amp;mut ctx.accounts.counter;
        counter.count += 1;
        msg!("Count incremented! New count: &#123;&#125;", counter.count);
        Ok(())
    &#125;
&#125;

// 初始化时的账户约束
#[derive(Accounts)]
pub struct Initialize&lt;'info> &#123;
    // 计数器账户（需要存储数据，因此is_writable=true）
    #[account(init, payer = user, space = 8 + 8)]  // 8字节 discriminator + 8字节u64
    pub counter: Account&lt;'info, Counter>,
    // 支付者（签名者）
    #[account(mut)]
    pub user: Signer&lt;'info>,
    // 系统程序（用于创建账户）
    pub system_program: Program&lt;'info, System>,
&#125;

// 增加计数时的账户约束
#[derive(Accounts)]
pub struct Increment&lt;'info> &#123;
    #[account(mut)]  // 可写（需要修改count）
    pub counter: Account&lt;'info, Counter>,
&#125;

// 计数器数据结构
#[account]
pub struct Counter &#123;
    pub count: u64,
&#125;


配置网络
编辑Anchor.toml，指定部署网络：
[provider]
cluster = "devnet"  # 可选：localnet, testnet, mainnet-beta
wallet = "~/.config/solana/id.json"  # 本地钱包路径

[programs.devnet]
anchor_project = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"  # 程序ID（需与合约中一致）


测试合约
编辑tests/anchor_project.ts编写测试用例：
import * as anchor from "@coral-xyz/anchor";
import &#123; Program &#125; from "@coral-xyz/anchor";
import &#123; AnchorProject &#125; from "../target/types/anchor_project";
import &#123; expect &#125; from "chai";

describe("anchor-project", () => &#123;
  // 配置Anchor provider和program
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.AnchorProject as Program&lt;AnchorProject>;
  
  // 为每个测试生成一个新的账户密钥对
  let counterKeypair: anchor.web3.Keypair;

  beforeEach(() => &#123;
    counterKeypair = anchor.web3.Keypair.generate();
  &#125;);

  it("Initialize counter", async () => &#123;
    // 调用initialize方法
    const tx = await program.methods.initialize()
      .accounts(&#123;
        counter: counterKeypair.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      &#125;)
      .signers([counterKeypair])
      .rpc();
    
    console.log("Your transaction signature", tx);

    // 获取counter账户并验证初始值
    const counter = await program.account.counter.fetch(counterKeypair.publicKey);
    expect(counter.count.toNumber()).to.equal(0);
    console.log("Initial count:", counter.count.toString());
  &#125;);

  it("Increment counter", async () => &#123;
    // 首先初始化账户
    await program.methods.initialize()
      .accounts(&#123;
        counter: counterKeypair.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      &#125;)
      .signers([counterKeypair])
      .rpc();

    // 调用increment方法
    const tx = await program.methods.increment()
      .accounts(&#123; 
        counter: counterKeypair.publicKey 
      &#125;)
      .rpc();
    
    console.log("Your transaction signature", tx);

    // 获取counter账户并验证计数增加
    const counter = await program.account.counter.fetch(counterKeypair.publicKey);
    expect(counter.count.toNumber()).to.equal(1);
    console.log("After increment:", counter.count.toString());
  &#125;);

  it("Increment counter multiple times", async () => &#123;
    // 首先初始化账户
    await program.methods.initialize()
      .accounts(&#123;
        counter: counterKeypair.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      &#125;)
      .signers([counterKeypair])
      .rpc();

    // 多次调用increment方法
    await program.methods.increment()
      .accounts(&#123; 
        counter: counterKeypair.publicKey 
      &#125;)
      .rpc();

    await program.methods.increment()
      .accounts(&#123; 
        counter: counterKeypair.publicKey 
      &#125;)
      .rpc();

    await program.methods.increment()
      .accounts(&#123; 
        counter: counterKeypair.publicKey 
      &#125;)
      .rpc();

    // 获取counter账户并验证计数
    const counter = await program.account.counter.fetch(counterKeypair.publicKey);
    expect(counter.count.toNumber()).to.equal(3);
    console.log("After 3 increments:", counter.count.toString());
  &#125;);
&#125;);
运行测试：
anchor test  # 自动启动本地节点，运行测试后关闭
测试完成：
anchor-project
Your transaction signature 3DBSMCVTW65CDsuPLx4jB3CosozZSjQbCurXo2KcfMSkfr2nZRHz5XQuEzEXr56bf1qY2MVsoYuQsYePwAuLLY4F
Initial count: 0
 ✔ Initialize counter (592ms)
Your transaction signature 36wPyPxho2rGRiRxM2ihF2cvfKENbNFKzNEr3ida4mEVeiRSmnEMbKqeg7BuTWdiDeKzd7dktn5WjbpNv4mWhNnF
After increment: 1
 ✔ Increment counter (915ms)
After 3 increments: 3
 ✔ Increment counter multiple times (1905ms)
 3 passing (3s)


部署合约
anchor deploy  # 部署到Anchor.toml指定的网络
-------------
➜  anchor-project anchor deploy
Error: error sending request for url (http://127.0.0.1:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)

Caused by:
    0: error sending request for url (http://127.0.0.1:8899/): error trying to connect: tcp connect error: Connection refused (os error 61)
    1: error trying to connect: tcp connect error: Connection refused (os error 61)
    2: tcp connect error: Connection refused (os error 61)
    3: Connection refused (os error 61)
部署失败，发现没有切换 devnet
[provider]
cluster = "devnet"                  # 可选：localnet, testnet, mainnet-beta
wallet = "~/.config/solana/id.json" # 本地钱包路径
部署成功后，会返回Program Id: &lt;DEPLOYED_PROGRAM_ID&gt;，可在Solana Explorer中查看。
➜  anchor-project anchor deploy
Deploying cluster: https://api.devnet.solana.com
Upgrade authority: /Users/tinachan/.config/solana/id.json
Deploying program "anchor_project"...
Program path: /Users/tinachan/rust/anchor-project/target/deploy/anchor_project.so...
Program Id: HDvugLuzT7XtdaskGkYw9DJZqNLtDLeVXfMeET9bne9y

Signature: 4ArrCsQQu4zCU7455yeoo3L5LvTiWngXq3gMCHoA42Z25tSHgMrVKPiQd4yhSvu37n28cwWPysrDiMAMfA21BNfF

Deploy success



优势总结

自动处理账户序列化/反序列化（无需手动处理二进制数据）。
内置测试框架，支持TypeScript测试合约。
简化账户权限管理（通过#[derive(Accounts)]约束）。
自动生成客户端SDK（target/types/目录下），方便前端集成。

踩坑

程序ID不匹配问题：

Rust代码中的[declare_id!](javascript:void(0))与Anchor.toml中的程序ID不一致
我们将Rust代码中的程序ID从Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS更新为5vhtLSUBXoqe3a2Kxtx8tcNdTNTaXaSgFT7MGN1bWxz5，与Anchor.toml保持一致


测试环境配置问题：

将Anchor.toml中的[cluster](javascript:void(0))从devnet改为localnet，这样测试可以在本地运行而不需要连接到Devnet


断言比较问题：

Solana程序返回的数字是BN（BigNumber）类型，而我们之前直接与JavaScript数字比较
通过使用.toNumber()方法将BN类型转换为普通数字进行比较，解决了断言失败问题


依赖安装：

确保安装了chai依赖以支持测试断言 npm install chai



总结

Native Rust：适合深入理解Solana底层，灵活性高但开发效率低。
Playground：适合快速验证想法，无需配置环境，适合新手入门。
Anchor：生产环境首选，大幅提升开发效率，生态工具丰富。

]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part4]_Token解析&amp;创建</title>
    <url>/2025/08/06/Solana-part4-Token%E8%A7%A3%E6%9E%90-%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[Solana[part4]_Token解析&amp;创建
solana上的代币
代币是代表对各种资产所有权的数字资产。代币化使得财产权的数字化成为可能，是管理可替代和不可替代资产的基本组成部分

可替代代币代表同类型和同价值的可互换和可分割资产（例如 USDC）
不可替代代币（NFT）代表不可分隔资产的所有权（例如艺术品）

SPL(Solana Program Library)
SPL 是 Solana 生态的核心程序库，其中 Token Program 是创建和管理代币的基础协议，主要涉及以下核心概念：

Token Program：Solana 上的标准代币协议，定义了代币的创建、转账、铸币、销毁等核心逻辑
Mint Account：代币的&quot;铸造源&quot;，存储代币的元数据（如总供应量、小数位数、是否可铸币/冻结等），每个代币类型对应唯一的 Mint 账户
Token Account：用户持有特定代币的账户，关联到一个 Mint 账户和一个所有者钱包，用于实际存储代币余额
Associated Token Account (ATA)：与钱包地址绑定的标准代币账户，遵循固定地址推导规则（由钱包地址和 Mint 地址计算得出），方便用户管理不同代币

Token创建完整流程（基于spl-token-cli）
前置准备


安装工具
# 安装Solana命令行工具
sh -c "$(curl -sSfL https://release.solana.com/v1.18.4/install)"
# 安装SPL Token命令行工具（锁定版本确保兼容性）
cargo install spl-token-cli --version 2.0.0 --locked


初始化本地环境
# 启动本地Solana测试节点（默认端口8899）
solana-test-validator
# 新建终端，配置集群为本地节点
solana config set --url http://localhost:8899


创建测试钱包并获取空投（用于支付Gas费）
# 创建新钱包（生成密钥对文件）
solana-keygen new --outfile ~/my-wallet.json
# 配置默认钱包
solana config set --keypair ~/my-wallet.json
# 获取测试网空投（本地节点无需真实代币）
solana airdrop 10
# 验证余额
solana balance


核心步骤：创建并管理代币
1. 创建Mint账户（代币类型）
Mint账户是代币的&quot;根&quot;，决定代币的基本属性：
  # 创建默认可替代代币（可铸币、可冻结，小数位6）
➜  ~ spl-token create-token
Creating token 3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9 under program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA

Address:  3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9
Decimals:  9

Signature: 5RHsDWPbGkFs8Cuq5G8wRGwfKhgAYqAejLc5nGwLSoDSHxWNV3CmX6wpYy5yPjYWvPuZVqUwYXEMt9M3ByJTKzqM
---------------------------------------

 # 自定义参数示例：
 # 创建NFT（不可分割，小数位0，不可增发）
 spl-token create-token --decimals 0 --no-mint-authority --no-freeze-authority

 # 命令输出解析：
 # Creating token &lt;MINT_ADDRESS>
 # Signature: &lt;TRANSACTION_SIGNATURE>
 # 其中&lt;MINT_ADDRESS>是新代币的唯一标识，需记录
 
 ---------------------------------
 ## 查看mint account info
 ➜  ~ spl-token account-info --address 3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9

SPL Token Mint
  Address: 3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9
  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
  Supply: 0
  Decimals: 9
  Mint authority: FcKkQZRxD5P6JwGv58vGRAcX3CkjbX8oqFiygz6ohceU
  Freeze authority: (not set)
参数说明：

--decimals：代币小数位数（默认6，如USDC），NFT需设为0
--mint-authority：指定铸币权限账户（默认当前钱包），--no-mint-authority表示永久不可铸币
--freeze-authority：指定冻结权限账户（默认当前钱包），--no-freeze-authority表示永久不可冻结

2. 创建Token Account（代币持有账户）
用户需要关联Mint账户的Token Account才能接收代币，推荐使用ATA（自动关联钱包）：
  # 创建与当前钱包关联的ATA（自动推导地址）
 spl-token create-account &lt;MINT_ADDRESS>
 --------------------
 ➜  ~ spl-token create-account 3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9
Creating account 7i8smGYKco3hicJThL8WYrMaGKpceeKkZRekqR4aWKFJ

Signature: 5AiPVz8Kjc9RYEtMGQAgx8Mdgy8cNiAwnprAHK14JYyciNJr1ufmPu3AQAwXbr5w1hRV1tTbiDDfEQz66yKkvxVy
----------------------

 # 手动指定所有者创建Token Account（非ATA）
 spl-token create-account &lt;MINT_ADDRESS> &lt;OWNER_WALLET_ADDRESS>
 
 ---------------------
➜  ~ spl-token create-account 3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9 /Users/tinachan/.config/solana/t2.json
Creating account 2tQibfGH1UX4PEA1dNWJ8zvnpSbKRBr5a5eVhaRxF6EX

Signature: 4dvu4YNxgfbEAyGiBxYxDqGHdsEgamZ8MMEE8uNBdoGJWZg3UM4eGk3v4BsEMQADut7VeYx32Ng7p4r4zWL6CMaK
 ---------------------

 # 命令输出解析：
 # Creating account &lt;TOKEN_ACCOUNT_ADDRESS>
 # Signature: &lt;TRANSACTION_SIGNATURE>
 # &lt;TOKEN_ACCOUNT_ADDRESS>为新创建的代币持有账户地址
代码中第一个创建的就是ATA，默认关联的token account； 第二个用私钥创建的是非ATA的token account ，两者区别：

地址生成方式不同


ATA（自动关联代币账户）：
地址是通过固定算法推导出来的，公式为：
ATA地址 = 基于钱包地址 + Mint地址 + 代币程序ID 推导的唯一地址
这种推导规则是 Solana 的官方标准，确保一个钱包（所有者）对一个 Mint 只能有唯一对应的 ATA。
例如：你的钱包地址为A，Mint 地址为M，那么对应的 ATA 地址是唯一确定的，任何人用A和M推导都会得到同一个地址。
非 ATA Token Account（手动指定所有者）：
地址是随机生成的，不遵循上述推导规则。每次执行create-account &lt;MINT&gt; &lt;OWNER&gt;命令，都会生成一个全新的随机地址，即使所有者和 Mint 相同，也会得到不同的地址。


与所有者的关联性不同


ATA：
强制与「创建时的钱包地址」绑定，即 ATA 的所有者（owner）就是该钱包地址，且无法修改。
一个钱包对一个 Mint 只能有1 个 ATA（因为地址唯一），这是钱包管理代币的「默认账户」。
非 ATA Token Account：
所有者可以是任意地址（可以是你的钱包、其他用户的钱包，甚至是智能合约地址），且允许一个所有者对一个 Mint 创建多个非 ATA 账户（因为地址随机）。
例如：你可以用自己的钱包作为所有者，为同一个 Mint 创建 10 个不同的非 ATA 账户，分别持有不同数量的代币。


钱包与 DApp 兼容性不同


ATA：
遵循 Solana 官方标准，所有主流钱包（如 Phantom、Solflare）和 DApp 都会自动识别并显示 ATA 中的代币，无需手动添加地址。
例如：你在 Phantom 钱包中看到的某代币余额，实际就是你钱包对应的 ATA 中的余额。
非 ATA Token Account：
不被钱包自动识别，需要用户手动添加账户地址才能在钱包中显示余额。
大多数 DApp 也不会默认与非 ATA 交互，需要手动指定账户地址才能进行转账、交易等操作。


使用场景不同


ATA：
适合普通用户日常使用，用于接收、存储和管理代币，因为兼容性好、管理简单（一个 Mint 对应一个账户，不易混乱）。
例如：别人向你转账某代币时，只需提供你的钱包地址，对方会自动向你的 ATA 转账（因为 ATA 地址可推导）。
非 ATA Token Account：
适合特殊场景，例如：

智能合约需要控制代币（将所有者设为合约地址）；
需将同一 Mint 的代币拆分到多个账户管理（如分账、隔离资金）；
临时账户（用完即弃）等。



总结来说，ATA 是「标准化、自动关联、易管理」的代币账户，适合大多数日常场景；非 ATA 是「灵活、自定义、需手动管理」的账户，适合特殊需求。实际开发或使用中，优先推荐使用 ATA，除非有明确的特殊场景需要非 ATA。
3. 铸币（增加代币供应量）
只有Mint账户的mint-authority有权限铸币：
  # 向指定Token Account铸币100单位（注意小数位，实际金额=数量*10^decimals）
 spl-token mint &lt;MINT_ADDRESS> 100 &lt;TOKEN_ACCOUNT_ADDRESS>

 # 示例：向当前钱包的ATA铸币1000（假设decimals=6，实际为1000 * 10^6 最小单位）
 spl-token mint &lt;MINT_ADDRESS> 1000
 
 --------
 ➜  ~ spl-token mint 3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9 100
Minting 100 tokens
  Token: 3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9
  Recipient: 7i8smGYKco3hicJThL8WYrMaGKpceeKkZRekqR4aWKFJ

Signature: USQP7cDcCip1ePdgKDxEXobBm8ohtaVwDRmGFt2BmDyi3tRQMrxtbvMkXbrUcdkoSNuQ2X9k6u1NNbztHeYY97Y

 --------

 # 验证铸币结果
 spl-token balance &lt;MINT_ADDRESS>
  --------
 ➜  ~ spl-token balance 3F14kaMXjdC1mFx5LRdD19amiMneKhgJsmMzGQUJjTt9
100
 --------
4. 代币转账
 # 从当前钱包的ATA向目标钱包的ATA转账50单位
spl-token transfer &lt;MINT_ADDRESS> 50 &lt;RECIPIENT_WALLET_ADDRESS> --fund-recipient

# 参数说明：
# --fund-recipient：自动为接收者创建ATA（若不存在）并支付创建费用
5. 销毁代币（减少供应量）
代币持有者可销毁自己持有的代币：
 # 销毁当前钱包ATA中的20单位代币
spl-token burn &lt;TOKEN_ACCOUNT_ADDRESS> 20
6. 查看代币信息
 # 查看Mint账户详情（总供应量、权限等）
spl-token mint-info &lt;MINT_ADDRESS>

# 查看Token Account详情（余额、所有者等）
spl-token account-info &lt;TOKEN_ACCOUNT_ADDRESS>
关键注意事项

权限管理：Mint账户的铸币/冻结权限默认归创建者，可通过spl-token authorize转移或撤销
NFT特殊处理：必须设置--decimals 0，且通常只铸币1个单位（spl-token mint &lt;MINT&gt; 1）
主网操作：切换集群为https://api.mainnet-beta.solana.com时，需使用真实SOL支付Gas费
地址记录：Mint地址是代币的唯一标识，需妥善保存（可通过solana address -k &lt;MINT_KEYPAIR_FILE&gt;查询）

通过以上步骤，即可完成从代币创建到转账销毁的全流程操作。实际开发中，可通过Solana Rust SDK或Web3.js调用Token Program的指令实现相同功能。
]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part5]_SPLToken合约简单实现</title>
    <url>/2025/08/07/Solana-part5-SPLToken%E5%90%88%E7%BA%A6%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[Solana[part5]_SPLToken合约简单实现
实现Token项目


创建一个token项目


token 项目依赖：
[dependencies]
borsh = "1.5.7"
solana-program = "2.3.0"
spl-associated-token-account = &#123; version = "7.0.0", features = [
    "no-entrypoint",
] &#125;
spl-token = &#123; version = "8.0.0", features = ["no-entrypoint"] &#125;

[lib]
crate-type = ["cdylib", "lib"]



编写合约,具体代码见: https://github.com/SoniaChan33/token


起本地环境：➜  ~ solana-test-validator


打开log
➜  ~ solana logs


编译合约：
➜  token git:(master) ✗ cargo build-sbf


部署合约, 获取programID
➜  token git:(master) ✗ solana program deploy target/deploy/token.so
Program Id: 5DPHC1PjRftRHJLKD4WSSXt83h1AChJy2pHXUqGdKD9X

Signature: 29PquhXv5Jw9c8p6k3jGK9UoLATg5rUpk3Mx8BBiJK8vxNEcLru4t7xYn6EdxXVeivUP7urczzoQY3KSvgGbEdhR


核心文件
具体实现文档见仓库readme文档：https://github.com/SoniaChan33/token?tab=readme-ov-file#spl-token合约项目实现文档
processor.rs：核心业务逻辑，处理指令
state.rs：定义账户的状态和扩展字段
instruction.rs：定义各种代币操作的指令
oerror.rs：定义了程序可能抛出的错误
olib.rs：程序入口点，汇总各个模块。

实现调用方Cli


创建项目


编写：具体代码见：https://github.com/SoniaChan33/solana-cli


测试结果：
running 1 test
test test_fn ... ok

successes:

---- test_fn stdout ----
Mint Account: 54b3u3wmAzM7LdPpERfa3iZGjkbafaD5FQ3aXV8iRaQk
Transaction result: zaWCinW8Kmjh6sQ3jRPcrntZ5yFWhuQM6GwWuGBJxCPPRJUiEcVRC1hKtaw1TSGZ5QB3nnEqBPieG3HzCvuEv5A
Token created successfully with mint account: 54b3u3wmAzM7LdPpERfa3iZGjkbafaD5FQ3aXV8iRaQk


successes:
    test_fn


]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part3]_solana账户&amp;简单的交互</title>
    <url>/2025/08/06/Solana-part3-solana%E8%B4%A6%E6%88%B7-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[Solana[part3]_solana账户&amp;简单的交互
solana 账户

数据账户，用来存储数据

系统所有账户
程序派生账户（PDA）


程序账户，用来存储可执行程序（智能合约），其数据字段为程序的字节码，executable 标志为 true
原生账户，指 Solana 上的原生程序，例如：system（系统程序，处理账户创建、转账等基础操作），stake（质押程序），以及 vote（投票程序）

账户结构体
Account
Account 结构体主要用于客户端（如 RPC 调用）获取账户的完整数据，包含账户的所有核心属性。
代码示例：
use solana_sdk::account::Account;

// 账户结构体定义（简化版）
pub struct Account &#123;
    // 账户中的lamports数量（Sol的最小单位）
    pub lamports: u64,
    // 账户存储的二进制数据
    pub data: Vec&lt;u8>,
    // 账户所有者的公钥（通常是程序的公钥）
    pub owner: Pubkey,
    // 标识该账户是否为可执行程序（程序账户为true，数据账户为false）
    pub executable: bool,
    // 下一次需要支付租金的 epoch
    pub rent_epoch: Epoch,
&#125;
Account Info
AccountInfo 是智能合约程序中用于访问账户的结构体，包含更多与程序执行相关的元数据（如签名状态、可写性），通常通过参数传递给程序入口函数。
代码示例：
use solana_program::account_info::AccountInfo;

// 账户信息结构体（简化版）
pub struct AccountInfo&lt;'a> &#123;
    // 账户的公钥
    pub key: &amp;'a Pubkey,
    // 标识该账户是否为交易签名者
    pub is_signer: bool,
    // 标识该账户在本次交易中是否可写
    pub is_writable: bool,
    // 账户中lamports的可变引用
    pub lamports: Rc&lt;RefCell&lt;&amp;'a mut u64>>,
    // 账户数据的可变引用
    pub data: Rc&lt;RefCell&lt;&amp;'a mut [u8]>>,
    // 账户所有者的公钥
    pub owner: &amp;'a Pubkey,
    // 标识该账户是否为可执行程序
    pub executable: bool,
    // 租金相关的epoch信息
    pub rent_epoch: Epoch,
&#125;
对比



特性
Account（客户端）
AccountInfo（程序内）




使用场景
客户端查询账户数据（如 RPC 返回）
智能合约中操作账户（函数参数）


核心数据
包含账户完整静态数据
包含数据的可变引用及操作权限标记


签名 / 可写标记
无（客户端无需关心交易执行时的权限）
有（is_signer/is_writable，用于程序验证）


数据访问方式
不可变（客户端只读）
可变引用（程序可修改数据）



要点

账户是用来存放数据的基本单元，所有链上数据均存储在账户中
每个账户都有一个独一无二的地址（公钥），由 32 字节组成
每个账户大小不能超过 10MB，且大小是静态的（创建后无法动态扩容，需提前规划）
账户数据存储需要付租金：如果账户余额低于租金阈值，会被系统回收；若存入足够 lamports（约 2 年租金），可成为rent-exempt（免租金）状态
默认的账户所有者是系统程序（11111111111111111111111111111111），只有所有者程序有权修改账户数据

程序派生账户（PDA）
相关文档：https://solana.com/zh/docs/core/pda
程序派生账户（PDA）是由智能合约程序通过特定算法生成的特殊账户，无对应私钥，仅由生成它的程序控制。
注意事项

不能直接签名交易
PDA 没有私钥，无法像普通账户那样签名交易，只能由其关联的程序控制操作（确保安全性）。
地址碰撞的可能性
理论上，相同程序 ID 和种子可能生成相同 PDA 地址（概率极低）。需通过唯一种子（如用户公钥 + 时间戳）避免碰撞。
种子长度限制
种子组合的总长度不能超过 32 字节，超过时需哈希处理（如用sha256压缩）。
生成成本
PDA 通过find_program_address函数生成（内部调用sha256哈希），频繁生成会增加链上计算成本。
单一程序访问
仅生成 PDA 的程序可修改其数据，跨程序共享需特殊设计（如权限委托）。
存储限制
作为数据账户时，大小受 10MB 限制，超大数据需拆分到多个 PDA。

应用场景

用户状态管理：存储用户在 DApp 中的资产、等级等数据
去中心化金融 (DeFi) 协议：存储流动性池、借贷记录等
NFT 元数据存储：关联 NFT 的属性、创作者信息等
DAO 投票系统：记录提案、投票结果等
时间锁合约：存储待执行的定时交易
多签钱包：存储签名阈值、授权列表等
去中心化身份验证：存储用户身份凭证

生成 PDA 的代码示例
use solana_program::&#123;program_pack::Pack, pubkey::Pubkey&#125;;

// 生成PDA
fn create_pda(program_id: &amp;Pubkey, seeds: &amp;[&amp;[u8]]) -> (Pubkey, u8) &#123;
    // 生成PDA地址和bump（用于确保地址不在Ed25519曲线内）
    Pubkey::find_program_address(seeds, program_id)
&#125;

// 示例：用用户公钥和"profile"作为种子生成PDA
let user_pubkey = Pubkey::from_str("...").unwrap();
let seeds = &amp;[b"profile", user_pubkey.as_ref()];
let (pda_address, bump) = create_pda(&amp;program_id, seeds);
println!("PDA地址: &#123;&#125;", pda_address);
println!("Bump值: &#123;&#125;", bump);
Rust库

solana_client：客户端库，用于与 Solana RPC 节点交互（查询余额、发送交易等）
solana_sdk：核心 SDK，定义账户、交易、签名等基础结构
solana_program：智能合约开发库，包含程序开发所需的账户操作、指令处理等工具

实战


启动本地环境 solana-test-validator
➜  ~ solana-test-validator
Ledger location: test-ledger
Log: test-ledger/validator.log
⠁ Initializing...                                                               Waiting for fees to stabilize 1...
Identity: GmyJV396jL2hnhcooyMs9U8UeWrBSadDYGbLrd8PvAL6
Genesis Hash: ATymZxWB3G7W8Qyjp7AVBLVN2ZLk1ssiWsTNsehNFczA
Version: 2.2.21
Shred Version: 31032
Gossip Address: 127.0.0.1:1024
TPU Address: 127.0.0.1:1027
JSON RPC URL: http://127.0.0.1:8899
WebSocket PubSub URL: ws://127.0.0.1:8900
⠒ 03:14:40 | Processed Slot: 21992 | Confirmed Slot: 21992 | Finalized Slot: 219



配置本地环境
# 查看当前配置
solana config get

# 切换到本地测试网
solana config set --url http://127.0.0.1:8899

# 确认配置生效
solana config get
# 输出应显示RPC URL为本地地址


创建本地账户
# 生成新账户（保存到文件）
solana-keygen new --outfile my-wallet.json

# 查看账户公钥
solana address --keypair my-wallet.json


给账户空投 SOL
# 向账户空投1 SOL（1 SOL = 1e9 lamports）
solana airdrop 1 &lt;你的账户公钥> --url http://127.0.0.1:8899

# 检查余额
solana balance &lt;你的账户公钥>


使用sdk


获取账户信息
 use solana_client::rpc_client::RpcClient;
use solana_sdk::&#123;pubkey::Pubkey, signature&#125;;
use std::str::FromStr;
fn main() &#123;
    // 创建solana连接
    let rpc_url = "http://127.0.0.1:8899";
    let client = RpcClient::new(rpc_url);

    // 指定你要查询的余额账户公钥
    // 接收空投账户
    let account_pubkey = Pubkey::from_str("FcKkQZRxD5P6JwGv58vGRAcX3CkjbX8oqFiygz6ohceU").unwrap();

    // 获取账户余额
    match client.get_balance(&amp;account_pubkey) &#123;
        Ok(balance) => &#123;
            println!("账户余额为: &#123;&#125;", balance);
        &#125;
        Err(err) => &#123;
            eprintln!("获取账户余额时出错: &#123;&#125;", err);
        &#125;
    &#125;
&#125;


空投sol
   use solana_client::rpc_client::RpcClient;
   use solana_sdk::&#123;pubkey::Pubkey, signature&#125;;
   use std::str::FromStr;
   fn main() &#123;
       // 创建solana连接
       let rpc_url = "http://127.0.0.1:8899";
       let client = RpcClient::new(rpc_url);
   
       // 指定你要查询的余额账户公钥
       // 接收空投账户
       let account_pubkey = Pubkey::from_str("FcKkQZRxD5P6JwGv58vGRAcX3CkjbX8oqFiygz6ohceU").unwrap();
   
       // 定义空投数量
       let amount = 1 * 1_000_000_000;
   
       match client.request_airdrop(&amp;account_pubkey, amount) &#123;
           Ok(signature) => &#123;
               println!("空投成功，签名为: &#123;&#125;", signature);
           &#125;
           Err(err) => &#123;
               eprintln!("空投时出错: &#123;&#125;", err);
           &#125;
       &#125;
   
       // 获取账户余额
       match client.get_balance(&amp;account_pubkey) &#123;
           Ok(balance) => &#123;
               println!("账户余额为: &#123;&#125;", balance);
           &#125;
           Err(err) => &#123;
               eprintln!("获取账户余额时出错: &#123;&#125;", err);
           &#125;
       &#125;
   &#125;
   ----------------
   空投成功，签名为: 36wYSruZNjLDiBvxG2XGNJDEDi2fmSZs9ViwYMAhEPJdpoTJMtdg5gvgRCC4VpXuDogC8YuDywCLE1ffcCDCVVnQ
   账户余额为: 500000000000000000


转移sol
   use solana_client::rpc_client::RpcClient;
   use solana_sdk::signature::Signer;
   use solana_sdk::signature::read_keypair_file;
   use solana_sdk::system_instruction::transfer;
   use solana_sdk::transaction;
   use solana_sdk::&#123;pubkey::Pubkey, signature&#125;;
   use std::str::FromStr;
   fn main() &#123;
       // 创建solana连接s
       let rpc_url = "http://127.0.0.1:8899";
       let client = RpcClient::new(rpc_url);
   
   
       // 设置接收方
       let receive = Pubkey::from_str("6qkpaXM6Q9z9rsJQ4qpHV8soGmw2uVTFdJ8KvHR32GDe").unwrap();
   
       // 设置发送方，需要通过签名获取
       let sender = read_keypair_file("/Users/tinachan/.config/solana/id.json")
           .expect("failed to read keypair file");
   
       // 定义空投数量 最小单位是lamports
       let amount = 1 * 1_000_000_000;
   
       // 创建转账的指令
       let transfer = transfer(&amp;sender.pubkey(), &amp;receive, amount);
   
       // 创建交易
       let recent_blockhash = client.get_latest_blockhash().unwrap();
       let transaction = transaction::Transaction::new_signed_with_payer(
           &amp;[transfer],
           Some(&amp;sender.pubkey()),
           &amp;[&amp;sender],
           recent_blockhash,
       );
       let result = client.send_and_confirm_transaction(&amp;transaction);
       match result &#123;
           Ok(signature) => &#123;
               println!("交易成功，签名为: &#123;&#125;", signature);
           &#125;
           Err(err) => &#123;
               eprintln!("交易时出错: &#123;&#125;", err);
           &#125;
       &#125;
       
   &#125;
   ----------------
   交易成功，签名为: 5yPGuuN7hbVqv1wTvsSryYG6rfaW6FNWTyih2PpwpSPxywjZ6LLMBGxdTjo59ZDdt8DfPShiq4KU4KXXvPBbevLc


总结：（代补充）
​


通过JsonRpc获取账户信息 https://solana.com/zh/docs/rpc/http/getaccountinfo


查看官网文档，挑选getaccountinfo来玩玩
curl https://api.devnet.solana.com -s -X \
  POST -H "Content-Type: application/json" -d ' 
  &#123;
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getAccountInfo",
    "params": [
      "vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg",
      &#123;
        "commitment": "finalized",
        "encoding": "base58"
      &#125;
    ]
  &#125;
'


替换自己的账户pubkey以及本地运行链接
➜  sol git:(master) ✗ curl http://127.0.0.1:8899 -s -X \
  POST -H "Content-Type: application/json" -d '
  &#123;
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getAccountInfo",
    "params": [
      "6qkpaXM6Q9z9rsJQ4qpHV8soGmw2uVTFdJ8KvHR32GDe",
      &#123;
        "commitment": "finalized",
        "encoding": "base58"
      &#125;
    ]
  &#125;
'
&#123;"jsonrpc":"2.0","result":&#123;"context":&#123;"apiVersion":"2.2.21","slot":33045&#125;,"value":&#123;"data":["","base58"],"executable":false,"lamports":1000000000,"owner":"11111111111111111111111111111111","rentEpoch":18446744073709551615,"space":0&#125;&#125;,"id":1&#125;




]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part6]_社交项目1-合约部分文档</title>
    <url>/2025/08/08/Solana-part6-%E7%A4%BE%E4%BA%A4%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[Solana[part6]_社交项目1-合约部分

社交项目地址链接
🔗 合约地址：https://github.com/SoniaChan33/sol-friend
🔗 客户端地址： https://github.com/SoniaChan33/solana-friend-cli

一、项目概述
本项目是基于Solana区块链的去中心化社交应用合约，使用Rust语言开发。合约支持用户账户初始化、关注/取消关注其他用户、发布内容、查询粉丝列表及查询帖子等核心社交功能。通过Solana的Program Derived Address (PDA)机制管理用户数据，使用Borsh进行数据序列化/反序列化，确保链上数据的高效存储与读取。
二、核心模块与数据结构
1. 指令定义（instruction.rs）
定义了合约支持的所有操作指令，通过SocialInstruction枚举实现，包含以下指令：



指令名
功能描述
参数说明




InitializeUser
初始化用户账户（ profile 或 post 类型）
seed_type: 账户类型（“profile” 或 “post”）


FollowUser
关注指定用户
user_to_follow: 被关注用户的Pubkey


UnfollowUser
取消关注指定用户
user_to_unfollow: 被取消关注用户的Pubkey


QueryFollowers
查询当前用户的粉丝列表
无参数


PostContent
发布内容
content: 帖子内容字符串


QueryPosts
查询用户的帖子信息
无参数



2. 状态数据结构（state.rs）
定义了链上存储的数据结构及操作方法，核心结构如下：
（1）UserProfile
存储用户的粉丝列表信息：
pub struct UserProfile &#123;
    pub data_len: u16,       // 粉丝数量（与followers.len()一致，用于快速计算存储空间）
    pub followers: Vec&lt;Pubkey>, // 粉丝的Pubkey列表
&#125;
核心方法：

new()：初始化空的用户资料
follow(&amp;mut self, user: Pubkey)：添加粉丝（去重）
unfollow(&amp;mut self, user_to_follow: Pubkey)：移除粉丝（更新数量）

（2）UserPost
记录用户发布的帖子数量：
pub struct UserPost &#123;
    pub post_count: u16, // 帖子总数
&#125;
核心方法：

new()：初始化帖子计数器（初始为0）
add_post(&amp;mut self)：发布新帖子时递增计数器
get_count(&amp;self)：获取当前帖子总数

（3）Post
存储单条帖子的具体内容：
pub struct Post &#123;
    pub content: String,  // 帖子内容
    pub timestamp: u64,   // 发布时间戳（基于Solana网络时钟）
&#125;
核心方法：

new(content: String, timestamp: u64)：创建新帖子实例

三、指令处理逻辑（processor.rs）
Processor结构体实现了所有指令的具体处理逻辑，核心流程如下：
1. initialize_user：初始化用户账户

功能：创建用户的PDA账户（分为profile和post两种类型），用于存储用户资料或帖子计数器。
流程：

解析账户信息（用户账户、PDA账户、系统程序）；
基于用户Pubkey和seed_type（“profile&quot;或&quot;post”）生成PDA地址，验证传入的PDA账户是否匹配；
计算账户所需存储空间（profile账户根据最大粉丝数计算，post账户固定大小）；
调用系统程序创建PDA账户（预存足够租金以豁免租金）；
初始化对应的数据结构（UserProfile或UserPost）并序列化到PDA账户中。



2. follow_user：关注用户

功能：将被关注用户的Pubkey添加到当前用户的UserProfile粉丝列表中。
流程：

解析PDA账户（存储当前用户的UserProfile）；
读取data_len计算当前粉丝列表的存储空间，反序列化UserProfile；
调用follow方法添加粉丝（自动去重）；
将更新后的UserProfile重新序列化并写入PDA账户。



3. unfollow_user：取消关注用户

功能：从当前用户的UserProfile粉丝列表中移除指定用户的Pubkey。
流程：

解析PDA账户（存储当前用户的UserProfile）；
反序列化UserProfile；
调用unfollow方法移除粉丝（更新data_len）；
将更新后的UserProfile重新序列化并写入PDA账户。



4. query_followers：查询粉丝列表

功能：读取当前用户的UserProfile并输出粉丝列表。
流程：

解析PDA账户（存储当前用户的UserProfile）；
反序列化UserProfile并通过msg!打印粉丝列表。



5. post_content：发布内容

功能：创建新的帖子PDA账户，存储帖子内容和时间戳，并更新用户的帖子计数器。
流程：

解析账户信息（用户账户、帖子计数器PDA、新帖子PDA、系统程序）；
读取当前用户的UserPost，递增post_count并重新序列化；
基于用户Pubkey、&quot;post&quot;种子和最新post_count生成新帖子的PDA地址；
计算帖子所需存储空间（基于Post结构体大小），创建新帖子PDA账户；
将帖子内容和当前时间戳（通过Solana时钟获取）序列化到新帖子PDA中。



6. query_post：查询帖子信息

功能：读取用户的帖子计数器和指定帖子的内容。
流程：

解析账户信息（帖子计数器PDA、目标帖子PDA）；
分别反序列化UserPost和Post，通过msg!打印帖子数量和内容。




四、遇到的坑
1. 关于Rust借用规则（follow_user中的作用域）
&#123;
    let data = &amp;pda_account.data.borrow(); // 不可变引用
    // ... 读取data计算size
&#125; // data的生命周期结束，不可变引用释放
原因：Rust的借用规则禁止同一作用域内同时存在不可变引用和可变引用。此处用作用域限制data（不可变引用）的生命周期，确保后续调用try_borrow_mut_data()（获取可变引用）时不会触发借用冲突。
2. 数组切片的使用（follow_user中的&amp;data[..U16_SIZE]）
let len: &amp;[u8] = &amp;data[..U16_SIZE]; // U16_SIZE=2
原因：UserProfile的data_len是u16类型（占2字节），存储在账户数据的前2字节。通过数组切片提取前2字节，再转换为u16，用于计算粉丝列表的总存储空间（data_len即粉丝数量）。
3. 序列化的必要性（修改数据后重新序列化）
user_profile.serialize(&amp;mut *pda_account.try_borrow_mut_data()?)?;
原因：链上账户存储的是字节数据，user_profile是内存中的结构体实例。当结构体被修改（如添加粉丝）后，必须通过serialize将内存中的最新状态转换为字节流，写入账户数据区域，否则修改不会被持久化到链上。
4. PDA地址计算（post_content中的种子）
Pubkey::find_program_address(&amp;[user_account.key.as_ref(), "post".as_bytes(), &amp;[count as u8]], program_id)
原因：PDA（程序派生地址）需通过“种子+程序ID”生成，确保唯一性。此处使用：

用户Pubkey（区分不同用户）；
&quot;post&quot;字符串（标识帖子类型）；
帖子计数器count（区分同一用户的不同帖子）；
三者组合作为种子，确保每个帖子的PDA地址唯一。

5. unwrap()与?的区别

unwrap()：当Result为Ok时返回值，为Err时直接触发程序恐慌（panic），适合确定不会出错的场景（如已知序列化Post必然成功）。
?：当Result为Err时将错误返回给调用者，由上层处理，适合需要传播错误的场景（如账户解析失败）。

6. create_account指令参数
system_instruction::create_account(
    user_account.key,    // 资金来源（创建者）
    &amp;pda,                // 新账户地址（PDA）
    lamports,            // 初始Lamports（需覆盖租金）
    space as u64,        // 账户存储空间
    program_id           // 账户所有者（当前合约）
)
原因：创建Solana账户必须指定：资金来源（支付租金）、账户地址、存储空间（决定租金金额）、所有者（只有所有者程序可修改账户数据）。
7. invoke_signed中的signer_seeds
&amp;[&amp;[user_account.key.as_ref(), "post".as_bytes(), &amp;[count as u8], &amp;[bump_seed]]]
原因：PDA本身不是私钥控制的账户，无法直接签名。signer_seeds用于证明“当前合约有权限操作该PDA”——通过种子重新计算PDA地址，验证与目标地址一致，从而获得临时签名权限，确保账户创建的安全性。
8. mod语句调用注意
在 Rust 中，mod 语句用于告诉编译器包含某个模块的源文件。只有在模块被声明为 pub mod xxx; 后，其他文件（如 processor.rs）才能通过 use crate::xxx::… 访问其内容。
原因如下：
state.rs 只是物理存在于 src 目录下，只有在 lib.rs 里用 pub mod state; 声明后，state 模块才会被编译进 crate 并对外可见。
如果不在 lib.rs 里声明，crate::state 这个路径在其他文件里就找不到。
processor.rs 只是使用 state，但模块的“引入”必须在 crate 的根（即 lib.rs）声明。
五、程序入口（lib.rs）
定义了Solana程序的入口点process_instruction，将指令处理逻辑委托给Processor::process_instruction，符合Solana程序的标准入口规范。
六、总结
本合约通过PDA管理用户数据，结合Borsh序列化和Solana系统指令，实现了去中心化社交应用的核心功能。关键设计点包括：用PDA确保数据所有权、通过计数器和种子生成唯一帖子地址、严格遵循Rust内存安全规则处理账户数据。
]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part7]_社交项目2-客户端文档</title>
    <url>/2025/08/11/Solana-part7-%E7%A4%BE%E4%BA%A4%E9%A1%B9%E7%9B%AE2%E2%80%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[Solana[part7]_社交项目2—客户端文档

社交项目地址链接
🔗 合约地址：https://github.com/SoniaChan33/sol-friend
🔗 客户端地址： https://github.com/SoniaChan33/solana-friend-cli

一、概述
本文档介绍基于Solana区块链的社交应用客户端代码的核心功能、数据结构及使用方法。该客户端通过RPC与Solana网络交互，实现用户资料管理、关注/取消关注、内容发布与查询等社交功能，依赖链上程序处理核心业务逻辑。
二、依赖说明
客户端代码依赖以下Rust crate：

solana-client：提供Solana RPC客户端功能，用于与节点交互
solana-sdk：Solana核心SDK，包含账户、交易、签名等基础类型
borsh：用于链上数据的序列化/反序列化（Solana生态常用）
std::str::FromStr：用于Pubkey字符串解析

三、核心数据结构
1. 账户数据结构
用于在链上存储用户相关数据，需实现BorshDeserialize和BorshSerialize以支持链上传输。
UserProfile

功能：存储用户的关注者列表信息
字段：

data_len: u16：关注者数量（与followers长度一致）
followers: Vec&lt;Pubkey&gt;：关注当前用户的用户公钥列表


方法：

new()：创建空的用户资料实例
follow(&amp;mut self, user: Pubkey)：添加新关注者（去重处理）



UserPost

功能：记录用户的发帖数量
字段：

post_count: u16：用户发布的内容总数



Post

功能：存储单条帖子内容
字段：

content: String：帖子文本内容
timestamp: u64：发帖时间戳（通常为区块时间）



2. 客户端核心结构
SocialClient

功能：封装与Solana链上社交程序交互的所有方法
字段：

rpc_client: RpcClient：Solana RPC客户端实例
program_id: Pubkey：链上社交程序的公钥


构造方法：pub fn new(rpc_url: &amp;str, program_id: Pubkey) -> Self

参数：rpc_url（Solana节点RPC地址）、program_id（链上程序公钥）
返回：SocialClient实例



3. 指令枚举 SocialInstruction
定义客户端向链上程序发送的指令类型，需实现BorshDeserialize和BorshSerialize：

InitializeUser &#123; seed_type: String &#125;：初始化用户账户（资料/帖子账户）
FollowUser &#123; user_to_follow: Pubkey &#125;：关注指定用户
UnfollowUser &#123; user_to_unfollow: Pubkey &#125;：取消关注指定用户
QueryFollowers：查询当前用户的关注者列表
PostContent &#123; content: String &#125;：发布新内容
QueryPosts：查询指定帖子内容

四、核心功能说明
1. PDA生成（get_pda函数）

功能：基于程序ID和种子（seed）生成Program Derived Address（PDA），用于唯一标识链上账户
参数：program_id（程序公钥）、seed（种子数组，用于区分不同账户）
种子作用：通过不同种子生成唯一PDA，避免账户地址冲突（例如：USER_PROFILE_SEED用于用户资料账户，USER_POST_SEED用于帖子相关账户）
代码：fn get_pda(program_id: &amp;Pubkey, seed: &amp;[&amp;[u8]]) -> Pubkey &#123;
    let (pda, _bump) = Pubkey::find_program_address(seed, &amp;program_id);
    pda
&#125;


2. 账户初始化（initialize_user）

功能：创建用户的PDA账户（支持资料账户或帖子账户，通过seed_type区分）
参数：

user_keypair: &amp;Keypair：用户签名密钥对（交易 payer）
seed_type: &amp;str：种子类型（USER_PROFILE_SEED或USER_POST_SEED）


流程：

基于用户公钥和seed_type生成PDA
构建InitializeUser指令，包含用户账户、PDA账户和系统程序（用于创建账户）
发送交易并确认


返回：Result&lt;(), Box&lt;dyn Error&gt;&gt;（成功/错误信息）

3. 关注/取消关注
follow_user

功能：让当前用户关注指定用户
参数：

user_keypair: &amp;Keypair：当前用户密钥对
follow_user: Pubkey：被关注用户的公钥


流程：生成用户资料PDA，发送FollowUser指令更新关注者列表

unfollow_user

功能：让当前用户取消关注指定用户
参数：

user_keypair: &amp;Keypair：当前用户密钥对
unfollow_user: Pubkey：被取消关注用户的公钥


流程：生成用户资料PDA，发送UnfollowUser指令从关注者列表移除

4. 关注者查询（query_followers）

功能：查询当前用户的关注者列表
参数：user_keypair: &amp;Keypair（当前用户密钥对）
流程：生成用户资料PDA，发送QueryFollowers指令，由链上程序返回关注者数据

5. 内容发布与查询
post_content

功能：发布新帖子
参数：

user_keypair: &amp;Keypair：发布者密钥对
content: String：帖子内容
id: u64：帖子唯一ID（用于生成帖子PDA）


流程：

生成用户帖子主PDA（记录发帖数量）和当前帖子PDA（存储内容）
发送PostContent指令，包含内容和时间戳
链上程序更新UserPost的post_count并存储Post数据



query_posts

功能：查询指定ID的帖子内容
参数：

user_keypair: &amp;Keypair：用户密钥对
id: u64：帖子ID


流程：生成用户帖子主PDA和目标帖子PDA，发送QueryPosts指令查询内容

6. 交易发送（send_instruction）

功能：通用交易发送工具，封装交易签名、发送和确认逻辑
参数：

payer: &amp;Keypair：交易付费者密钥对
instruction: Vec&lt;Instruction&gt;：待执行的指令列表


流程：

获取最新区块哈希（用于交易有效性）
生成并签名交易
发送交易并等待确认，返回签名信息



五、使用示例
以下示例展示客户端核心功能的调用流程（参考main函数）：
// 1. 初始化客户端
let program_id = Pubkey::from_str("9ti8R5H2Ru5553wi419aj2h5cZJbbJEk6zr8insVphJe")?; // 链上程序公钥
let user_keypair = read_keypair_file("/Users/tinachan/.config/solana/id.json")?; // 加载用户密钥对
let client = SocialClient::new("http://127.0.0.1:8899", program_id); // 连接本地测试网

// 2. 初始化用户资料账户
client.initialize_user(&amp;user_keypair, USER_PROFILE_SEED)?;

// 3. 关注指定用户
let follow_user = Pubkey::from_str("2tQibfGH1UX4PEA1dNWJ8zvnpSbKRBr5a5eVhaRxF6EX")?;
client.follow_user(&amp;user_keypair, follow_user)?;

// 4. 查询关注者列表
client.query_followers(&amp;user_keypair)?;

// 5. 取消关注
client.unfollow_user(&amp;user_keypair, follow_user)?;

// 6. 初始化帖子账户
client.initialize_user(&amp;user_keypair, USER_POST_SEED)?;

// 7. 发布帖子
client.post_content(&amp;user_keypair, "Hello, world!".into(), 1)?;

// 8. 查询帖子
client.query_posts(&amp;user_keypair, 1)?;
六、注意事项

序列化必要性：所有链上数据（如UserProfile、SocialInstruction）需通过borsh序列化，因为Solana链上程序仅能处理二进制数据，且borsh是Solana生态的标准序列化方式。
PDA唯一性：种子（seed）需确保唯一，避免不同类型账户地址冲突（例如用户资料和帖子账户需使用不同种子）。
错误处理：所有方法返回Result类型，需处理可能的错误（如RPC连接失败、交易确认超时、账户未初始化等）。
测试环境：示例中使用本地测试网（http://127.0.0.1:8899），正式环境需切换为Solana主网或devnet RPC地址。

]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part8]_Solana 生态中的协议与标准库</title>
    <url>/2025/08/12/Solana-part8-Solana-%E7%94%9F%E6%80%81%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[Solana[part8]_Solana 生态中的协议与标准库
一、协议基础：定义与生态差异
1.1 区块链协议的本质
区块链协议是定义网络交互规则、数据结构和业务逻辑的规范，是智能合约和应用的“底层规则集”。例如：

代币协议规定资产的发行（Mint）、转移（Transfer）、销毁（Burn） 逻辑；
Swap协议定义两种资产的兑换规则（如价格算法、流动性池交互）。
类比互联网：如同HTTP协议规定网页传输规则，区块链协议定义“价值与逻辑”的传输标准。

1.2 不同公链协议的核心差异
以 以太坊（ERC标准） 和 Solana（SPL标准） 对比：



维度
以太坊（ERC）
Solana（SPL）




底层架构
账户模型（EOA+合约账户），单线程执行
账户模型（可执行+数据账户，关联账户），并行执行（Sealevel）


开发语言
Solidity
Rust


性能导向
通用性优先（牺牲部分效率）
高性能优先（高TPS、低延迟）


协议设计
灵活（如ERC-721A优化NFT批量Mint）
高效（如SPL-Token支持并行转移）



二、Solana核心协议解析（SPL体系）
Solana的协议多通过 Solana Program Library（SPL，标准程序库） 实现，以下是核心协议拆解：
2.1 代币协议：SPL-Token &amp; 扩展
（1）SPL-Token（基础版）

功能：发行可替代代币（Fungible Token），支持 Mint（增发）、Transfer（转移）、Burn（销毁）、Approval（授权）等操作。
账户模型：

Mint账户：记录代币总供应量、小数位、发行方等核心信息；
代币账户：用户持有代币的载体（默认不创建，需通过关联账户机制生成）。


类比：类似以太坊ERC-20，但借助Solana并行处理，批量转移效率更高。

（2）SPL-Associated Token Account（ATA，关联账户）

作用：为 用户主账户 + 代币Mint地址 自动生成唯一关联代币账户，统一管理该代币的余额。
优势：避免用户手动创建多个代币账户（如以太坊需为每个ERC-20代币单独授权），简化资产管理。

（3）SPL-Token 2022（增强版）

新增特性：可选的冻结（Freeze）和锁定（Locking）机制：

冻结：管理员（如项目方）可冻结特定ATA的代币转移，用于合规管控（如防止黑钱交易）或项目治理；
锁定：设定代币解锁条件（如 时间锁：团队代币分阶段解锁；逻辑锁：满足某条件才允许转移），适配私募、vesting计划等场景。



2.2 交互协议：从Memo到Governance
（1）Memo（交易备注）

功能：在Solana交易中附加文本信息（如“订单ID#123”、“NFT购买”），虽不影响交易逻辑，但可作为链上审计或交互记录。
应用：DEX交易记录订单信息、NFT市场记录购买备注。

（2）Name Service（域名服务，如SNS）

功能：将复杂的Solana地址（如 8X...yz）映射为易记域名（如 user.sol），方便转账和社交展示。
类比：类似以太坊ENS（.eth），但Solana的SNS更轻量，结合链上存储实现。

（3）Swap协议（如Serum的SPL Swap）

机制：实现两种代币的兑换，支持 订单簿模式（如Serum）或 AMM模式（自动做市商，如Raydium）。
核心：通过SPL-Token的Transfer接口，结合价格算法（如恒定乘积公式），实现去中心化交易。

（4）Staking（质押协议）

流程：用户将代币质押给验证者或质押池，获取质押收益（如SOL代币质押获得通胀奖励）。
协议逻辑：涉及 委托（Delegate）、解绑（Unstake，含解锁期）、收益分发，保障Solana网络的PoS共识安全。

（5）Governance（治理协议，如Realms）

功能：社区投票决定协议升级、资金分配等，通常结合“治理代币”（如$SRM用于Serum治理）。
流程：提案创建 → 代币加权投票 → 通过CPI调用执行程序（如转移社区金库资金）。

（6）Flash Loans（闪电贷）

原理：在同一原子交易中，用户可无抵押借出资产，前提是“借出→使用→偿还”全流程完成（否则交易回滚）。
应用：套利（跨交易所价格差）、临时资金利用，依赖Solana高TPS和低延迟实现高效操作。

三、Solana标准库（SPL）的核心价值：模块化与CPI
3.1 模块化开发：站在巨人肩膀上

SPL定位：Solana官方维护的标准程序库，提供经过审计、高性能的基础模块（如token、swap、治理）。
开发者收益：

无需从头开发代币系统，直接调用 SPL-Token 接口；
开发DEX时，复用 SPL-Swap 的兑换逻辑，节省时间和安全成本。


案例：NFT平台可复用SPL-Token（手续费代币）和Metaplex NFT标准（基于SPL开发，管理NFT元数据）。

3.2 跨程序调用（CPI）：程序间的“协作魔法”

定义：Solana允许一个智能合约（程序）调用另一个程序的指令，所有操作在同一原子交易中执行（要么全成，要么全败）。
应用场景：

DEX交易：Swap程序调用SPL-Token的Transfer指令，完成代币兑换；
借贷协议：借贷程序调用SPL-Token转移抵押品，同时调用价格预言机程序获取资产价格；
治理执行：Governance程序通过CPI调用SPL-Token转移社区金库资金。


优势：实现复杂业务逻辑（如“质押+借贷+Swap”组合操作），同时通过原子性避免中间状态风险。

四、总结：协议与标准库的生态意义

协议是规则基石：定义资产、交互、治理的标准，让不同应用互操作（如不同DEX都用SPL-Swap，用户资产通用）。
SPL是开发加速器：模块化设计和CPI机制，降低开发门槛，促进生态繁荣（如大量项目基于SPL快速迭代）。
对比与展望：与以太坊ERC体系相比，Solana的SPL更注重性能和并行；随着SPL-Token 2022等升级，在合规、复杂资产管理上会更灵活。

附录：关键术语速查表



术语
解释




SPL
Solana Program Library（Solana标准程序库）


ATA
Associated Token Account（关联代币账户）


CPI
Cross Program Invocation（跨程序调用）


Mint Account
代币发行账户（记录总供应量、小数位等）


Vesting
代币锁定计划（如团队代币分阶段解锁）



]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Solana[part9]_Anchor入门&amp;账户的概念和用法</title>
    <url>/2025/08/13/Solana-part9-Anchor%E5%85%A5%E9%97%A8-%E8%B4%A6%E6%88%B7%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%94%A8%E6%B3%95-1/</url>
    <content><![CDATA[Solana[part9]_Anchor入门&amp;账户的概念和用法
一、Anchor框架概述
Anchor是Solana区块链生态中用于简化智能合约开发的核心框架，其核心优势在于将复杂的账户验证逻辑与业务逻辑分离，通过声明式语法降低开发门槛。Anchor提供了以下核心功能：

账户验证：通过#[account]宏定义账户结构，自动验证账户状态
指令分离：将交易逻辑拆分为独立的指令处理函数
PDA管理：内置对Program Derived Addresses（PDA）的支持
错误处理：自定义错误类型及友好的错误提示

安装与配置
# 安装Anchor CLI
cargo install --git https://github.com/coral-xyz/anchor anchor-cli --locked

# 初始化项目
anchor init my_project
cd my_project
二、PDA（Program Derived Address）核心概念
PDA是Solana中一种特殊的账户地址，其生成基于特定的种子（seeds）和程序ID（Program ID）。与普通账户的区别在于：

无私钥控制：PDA地址无法通过私钥签名，只能由关联程序操作
确定性生成：相同种子和程序ID生成的PDA地址唯一
安全存储：用于存储程序专属数据，防止外部篡改

PDA生成公式
use anchor_lang::prelude::*;

fn derive_pda(seeds: &amp;[&amp;[u8]], program_id: &amp;Pubkey) -> (Pubkey, u8) &#123;
    Pubkey::find_program_address(seeds, program_id)
&#125;
三、Anchor中使用PDA的典型场景

哈希表结构：通过种子组合实现键值对存储
权限控制：作为程序专属签名者
状态隔离：不同业务逻辑使用独立PDA账户

示例：创建PDA账户
use anchor_lang::solana_program::system_program;

#[derive(Accounts)]
pub struct CreatePdaAccount&lt;'info> &#123;
    #[account(mut)]
    pub user: Signer&lt;'info>,
    #[account(
        init,
        seeds = [b"user_stats", user.key().as_ref()],
        bump,
        payer = user,
        space = 8 + std::mem::size_of::&lt;UserStats>(),
        program = my_program::ID
    )]
    pub user_stats: Account&lt;'info, UserStats>,
    pub system_program: Program&lt;'info, System>,
&#125;

#[derive(Default, AnchorSerialize, AnchorDeserialize)]
pub struct UserStats &#123;
    pub level: u16,
    pub name: String,
&#125;
四、PDA账户操作详解

初始化账户
通过init约束自动创建PDA账户并分配存储空间：

#[derive(Accounts)]
pub struct InitPda&lt;'info> &#123;
    #[account(mut)]
    pub authority: Signer&lt;'info>,
    #[account(
        init,
        seeds = [b"pda", authority.key().as_ref()],
        bump,
        payer = authority,
        space = 8 + 32,
        program = my_program::ID
    )]
    pub pda_account: Account&lt;'info, PdaData>,
    pub system_program: Program&lt;'info, System>,
&#125;

重新分配空间
使用realloc约束动态调整账户存储：

#[derive(Accounts)]
pub struct ReallocPda&lt;'info> &#123;
    #[account(
        mut,
        realloc,
        realloc::payer = authority,
        realloc::zero = false,
    )]
    pub pda_account: Account&lt;'info, PdaData>,
    #[account(mut)]
    pub authority: Signer&lt;'info>,
    pub system_program: Program&lt;'info, System>,
&#125;

关闭账户
通过close约束释放账户资源：

#[derive(Accounts)]
pub struct ClosePda&lt;'info> &#123;
    #[account(
        mut,
        close = authority,
    )]
    pub pda_account: Account&lt;'info, PdaData>,
    #[account(mut)]
    pub authority: Signer&lt;'info>,
&#125;
五、PDA安全最佳实践

种子设计原则


避免使用可变参数作为主种子
关键业务使用复合种子（如[b&quot;order&quot;, order_id.as_ref(), user.key().as_ref()]）
敏感操作添加时间戳或随机数种子


Bump值管理


使用canonical bump（默认255）简化开发
复杂场景可自定义bump值验证
通过Pubkey::find_program_address预计算地址


权限控制


限制PDA操作权限到特定指令
使用#[access_control]宏实现细粒度访问控制

六、典型应用案例

跨链资产托管

// 生成托管PDA地址
let (escrow_pda, _) = Pubkey::find_program_address(
    &amp;[b"escrow", token_mint.as_ref(), buyer.as_ref(), seller.as_ref()],
    program_id,
);

// 托管资金转移
transfer(
    CpiContext::new(
        token_program.to_account_info(),
        Transfer &#123;
            from: user_wallet.to_account_info(),
            to: escrow_pda.to_account_info(),
            authority: user_wallet.to_account_info(),
        &#125;,
    ),
    amount,
);

可验证随机数生成

// 生成随机数PDA
let (random_pda, _) = Pubkey::find_program_address(
    &amp;[b"random", user.key().as_ref(), blockhash.as_ref()],
    program_id,
);

// 存储随机数结果
random_pda_account.value = calculate_hash(random_seed);
七、开发工具链支持

Anchor IDL生成

anchor idl generate

客户端SDK集成

import &#123; Program, web3 &#125; from '@project-serum/anchor';
import &#123; MyProgram &#125; from '../target/types/my_program';

const program = new Program&lt;MyProgram>(
    idl,
    new web3.PublicKey('PROGRAM_ID'),
    provider
);

// 计算PDA地址
const [pdaAddress, bump] = await web3.PublicKey.findProgramAddress(
    [Buffer.from('user_stats'), user.publicKey.toBuffer()],
    program.programId
);
八、常见问题与解决方案

PDA地址不匹配


检查种子顺序及编码格式
确认程序ID是否正确
使用solana address -k ~/.config/solana/id.json验证地址生成


账户空间不足


预计算所需存储空间（8字节系统开销 + 数据结构大小）
使用realloc动态调整空间
避免频繁创建销毁账户


签名权限问题


确保PDA操作指令包含正确的授权账户
检查#[account]宏中的signer约束
使用invoke_signed进行PDA签名模拟

九、延伸学习资源

官方文档


Anchor Book
Solana PDA指南


实战项目


Anchor示例仓库
Solana Cookbook PDA章节


社区支持


Solana Stack Exchange
Anchor Discord频道

]]></content>
      <categories>
        <category>Solana</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Solana</tag>
      </tags>
  </entry>
  <entry>
    <title>Twikoo评论系统的Cloudflare部署方案</title>
    <url>/2025/06/17/Twikoo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%9A%84Cloudflare%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[Twikoo评论系统的Cloudflare部署方案
Twikoo是一款简洁、安全且免费的静态网站评论系统，在提升网站互动性方面表现出色。通常，Twikoo可部署在诸如腾讯云开发环境、Vercel等平台，但借助Cloudflare进行部署，能极大改善冷启动延迟问题，实现快速加载，为用户带来更流畅的评论体验，同时利用Cloudflare强大的全球网络提升访问速度。以下为详细的Cloudflare部署Twikoo评论系统的步骤与要点。
一、前期准备
在开始部署前，需提前准备好相关工具与资源：

Cloudflare账户：若尚未注册，前往Cloudflare官网完成注册流程。
Node.js环境：确保本地开发环境安装了Node.js，可通过Node.js官网下载并安装对应系统的最新版本，安装完成后，在命令行输入node -v验证是否安装成功及查看版本号。
文本编辑器：推荐使用Visual Studio Code、Sublime Text等，方便进行代码编辑与配置文件修改。

二、安装依赖包

首先，创建一个新的项目目录，用于存放Twikoo相关代码与配置文件，在命令行中进入该目录，执行以下命令安装项目依赖：

npm install

由于Cloudflare Workers的免费套餐对捆绑包大小有严格的1MiB限制，部分与Cloudflare Workers的Node.js兼容性存在问题的包即便安装了也无法使用，为控制捆绑包大小，需手动删除这些包，在命令行中依次执行：

echo "" > node_modules/jsdom/lib/api.js
echo "" > node_modules/tencentcloud-sdk-nodejs/tencentcloud/index.js
echo "" > node_modules/nodemailer/lib/nodemailer.js
上述命令会清空jsdom、tencentcloud-sdk-nodejs、nodemailer这三个包中特定文件的内容，使其不占用捆绑包空间，同时规避兼容性问题。
三、登录Cloudflare账户
通过Wrangler工具登录Cloudflare账户，Wrangler是Cloudflare提供的用于管理Workers、D1数据库等资源的命令行工具，执行以下命令进行登录：
npx wrangler login
运行该命令后，系统会自动打开浏览器，跳转到Cloudflare的授权页面，按照提示完成授权操作，授权成功后，Wrangler便与你的Cloudflare账户建立连接，后续可通过它对Cloudflare资源进行操作。
四、创建Cloudflare D1数据库并设置架构

使用Wrangler创建名为twikoo的D1数据库，在命令行执行：

npx wrangler d1 create twikoo
执行此命令后，终端会输出数据库的相关信息，其中database_name和database_id这两行信息至关重要，需将其复制下来，用于后续配置。

&#123;
  "d1_databases": [
    &#123;
      "binding": "DB",
      "database_name": "twikoo",
      "database_id": "56def18d-b46a-42c8-bc99-0214e58f9a54"
    &#125;
  ]
&#125;

打开项目目录下的wrangler.toml文件（若不存在，可手动创建），将刚刚复制的database_name和database_id粘贴进去，替换原有的对应值，使项目与创建的D1数据库建立关联。
为D1数据库设置架构，Twikoo项目中包含定义数据库表结构和初始数据的schema.sql文件，执行以下命令，将该架构应用到Cloudflare D1数据库：

npx wrangler d1 execute twikoo --remote --file=./schema.sql
此命令会远程连接到之前创建的twikoo数据库，并依据schema.sql文件的内容创建相应的表结构及可能的初始数据，确保数据库满足Twikoo评论系统的存储需求。

五、创建Cloudflare R2存储
Cloudflare R2可用于存储Twikoo评论系统相关的文件，如上传的图片等（尽管当前部署方案中对R2的使用存在一定限制，但创建步骤仍需完成），通过以下命令创建名为twikoo的R2存储桶：
npx wrangler r2 bucket create twikoo
创建完成后，找到wrangler.toml文件中r2_public_url字段，将其值更新为新创建的R2存储桶的域名，确保项目能正确访问R2存储资源。
[vars]
R2_PUBLIC_URL = “https://twikoo.soniachen.com”

六、部署Cloudflare Worker
完成上述配置后，即可将Twikoo评论系统部署到Cloudflare Workers，执行以下命令进行部署：
npx wrangler deploy --minify
--minify参数用于对代码进行压缩，以进一步减小捆绑包大小，提升部署效率与性能。部署过程可能需要一些时间，完成后，命令行中会输出类似https://twikoo-cloudflare.&lt;your username&gt;.workers.dev的访问地址。若部署成功，在浏览器中访问该地址，应能看到类似于&#123;&quot;code&quot;: 100, &quot;message&quot;: &quot;twikoo云函数运行正常，请参考https://twikoo.js.org/frontend.html完成前端的配置&quot;, &quot;version&quot;: &quot;1.6.33&quot;&#125;的提示信息，这表明Twikoo的后端服务已在Cloudflare上成功部署。
七、前端配置

在博客或网站的前端代码中，找到需要添加评论功能的页面。若使用Twikoo官方提供的前端初始化代码，需将其中的envId字段值设置为第六步中得到的Cloudflare Worker访问地址（包含https://前缀）。例如：

twikoo.init(&#123;
    envId: "https://twikoo-cloudflare.&lt;your username>.workers.dev",
    el: "#tcomment",
    // region: 'ap-guangzhou', // 环境地域，默认为ap-shanghai，如果您的环境地域不是上海，需传此参数
    // path: 'window.location.pathname', // 用于区分不同文章的自定义js路径，如果您的文章路径不是location.pathname，需传此参数
    // lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表https://github.com/imaegoo/twikoo/blob/dev/src/js/utils/i18n/index.js
    // onCommentLoaded: function () &#123;
    //     console.log("评论加载或评论成功");
    // &#125;
&#125;);

确保前端页面包含用于显示评论区的HTML元素，其id需与上述代码中el字段指定的值一致（如&lt;div id=&quot;tcomment&quot;&gt;&lt;/div&gt;），这样Twikoo前端脚本才能正确渲染评论区。


八、配置邮件通知（可选）
Twikoo支持在有新评论时发送邮件通知管理员，由于nodemailer包的兼容性问题，在Cloudflare Workers环境中，无法直接通过SMTP集成发送邮件，而是通过SendGrid的HTTPS API实现邮件通知功能，具体步骤如下：

注册一个可用的SendGrid账户（SendGrid提供免费套餐，每天可发送多达100封邮件）或Mailchannels账户（每月免费3000封邮件），并在账户设置中创建一个API Key，用于后续验证身份。
在Twikoo的配置中设置相关邮件参数，找到配置文件中与邮件通知相关的部分，设置以下字段：

sender_email: "发件人邮箱地址", // 需在SendGrid中进行验证
sender_name: "显示的发件人名称",
smtp_service: "sendgrid",
smtp_user: "提供任意非空值",
smtp_pass: "之前创建的SendGrid API Key",
此外，还可根据需求设置其他配置值，以自定义通知邮件的外观和内容。完成设置后，在配置页面点击“发送测试邮件”按钮，检查邮件通知功能是否正常工作，同时需确保邮件提供商不会将收到的通知邮件归类为垃圾邮件。
九、常见问题及解决方法

捆绑包大小超限：若在部署时遇到捆绑包大小超过Cloudflare Workers免费套餐1MiB限制的问题，除了前文提到的删除特定包文件内容外，还可检查项目中是否引入了不必要的大型依赖，精简代码，减少不必要的资源加载。
数据库连接问题：若出现无法连接到Cloudflare D1数据库的情况，首先确认wrangler.toml文件中database_name和database_id是否填写正确，其次检查网络连接是否正常，确保能访问Cloudflare的服务。
前端评论区无法显示：前端评论区无法正常显示时，检查浏览器控制台是否有报错信息，可能是envId配置错误、前端脚本加载失败或HTML元素id不匹配等原因导致，根据具体错误提示进行排查修复。

通过以上详细的Cloudflare部署方案，可将Twikoo评论系统高效地集成到网站中，利用Cloudflare的优质服务提升评论系统的性能与稳定性，为网站访客打造良好的互动交流环境。
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>CloudFlare</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3 Day1—BlockChain Basic 1</title>
    <url>/2025/06/17/WEB3%20Day1%20%E2%80%94%E2%80%94%20BlockChain%20Basic%201/</url>
    <content><![CDATA[WEB3 Day1—BlockChain Basic 1
转型方向
从 Java 开发转型至智能合约开发。
学习资源
学习视频
推荐 patrick collins 【Cyfrin】的教学视频 。
同时，Cyfrin Updraft 官网提供了文字笔记和视频课程。不过，某些翻译插件的双语字幕不支持该网站，因此我选择在 YouTube 上观看完整视频，并且将两者结合起来学习。
翻译插件推荐
这里推荐一款翻译插件——沉浸式翻译
创建自己的钱包
安装 MetaMask 插件
首先，进入 MetaMask 官网，将其作为 Chrome 浏览器插件添加到浏览器中。
创建钱包
创建自己的钱包后，会得到三个关键信息：私钥（private key）、助记词（Mnemonic Key）和公钥地址（public Address）。其中，私钥和助记词极其重要，务必安全保存！因为拥有私钥就可以直接访问你的钱包账户，所以千万不能有侥幸心理。建议将助记词记录在纸上，而不是存储在电脑里，如果能记在大脑中（如使用记忆宫殿的方法）则是最安全的。三者的重要性排序为：【Mnemonic &gt; Private Key &gt; public Address】。
相关图示如下：


模拟交易
创建虚拟测试网络
登录 Tenderly 测试网站（https://tenderly.co/?mtm_campaign=partner&amp;mtm_kwd=cyfrin ），通过该链接注册并创建账户是免费的。在网站左侧点击“virtual TestNets”，创建虚拟测试网络。

网络设置
进行简单设置，无特定要求。设置完成后，会创建一个模拟区块链，接下来可以将其添加到 MetaMask 中。

手动添加网络问题处理
在连接后，可能会遇到 MetaMask 中未显示创建的虚拟网络的问题，此时需要手动添加。注意，原系统默认的 chainId（11155111）无法修改，因此需要重新创建一个链，并在创建时在“custom”处修改自己的 ID。

有其他开发者也遇到了同样的问题，可参考：https://github.com/Cyfrin/foundry-full-course-cu/discussions/4066?sort=old
注资操作
完成上述步骤后，进行注资。

查看注资结果
注资完成后，等待几分钟，就可以在自定义虚拟网络中看到资金到账啦，仿佛瞬间“暴富”（当然这只是模拟）。

账户间转账
在模拟网络中，从一个账户向另一个账户转账非常简单，直接进行发送操作即可。


另外，Tenderly 与 Cypher 有合作，账户可以续期。

区块链数据结构
可以通过 BlockChain Demo 网站（https://andersbrownworth.com/blockchain/block ）来帮助理解区块链的底层数据结构。
交易费用相关概念
交易费用（Transaction Fee）
交易费用是支付给区块生产者处理交易的奖励金额，通常通过以太币或者 Gwei 支付。
燃气价格（Gas Price）
同样以以太币或者 Gwei 来定义，燃气价格是交易中指定的每单位燃气（Gas）的成本。价格越高，交易被打包进区块的机会就越大，它用于设定交易中每单位燃气的成本。
燃气（Gas）
不要将燃气与燃气价格混淆。燃气指的是执行交易所需要的工作量，而燃气价格则是每单位工作量的成本。
交易费用的计算公式为：
Transaction fee =  gasPrice * gasUsed
简单来说，当大量用户进行交易时，特定区块的空间竞争会变得激烈，此时提高燃气价格可以在拥堵时限制交易，并优先处理部分交易。
]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3 Day2—BlockChain Basic 2 + Solidity基础[part1]</title>
    <url>/2025/06/17/WEB3%20Day2%20%E2%80%94%E2%80%94%20BlockChain%20Basic%202+Solidity%E5%9F%BA%E7%A1%80%5Bpart1%5D/</url>
    <content><![CDATA[WEB3 Day2—BlockChain Basic 2 + Solidity基础[part1]
Layer1
​	blockChain的base layer，例如bitcoin、BNB chain、Solana,and Avalanche.
Layer2
构建在L1区块链外部但是也与之连接的任何应用application。有各种类型，比如for example ChainLink(去中心化预言机网络) ，以及像The Graph(事件索引网络)。
好的，我将为你优化这段区块链技术描述，提升专业性和清晰度：
Rollup 技术：以太坊Layer2扩容的核心方案
Rollup是Layer2（L2）扩容的主流解决方案，其核心原理是将多笔链下交易打包为一个聚合交易，仅将交易摘要（而非完整数据）提交至以太坊主链（Layer1），大幅提升交易吞吐量并降低Gas费用。根据验证机制不同，Rollup可分为两类：
1. Optimistic Rollups（乐观汇总）

工作机制：默认所有链下交易均为有效，运营商（Operator）定期向主链提交状态根（State Root）和交易哈希。若其他参与者发现欺诈交易，可在挑战期（通常7天）内提交欺诈证明（Fraud Proof）进行质疑。
安全性：依赖经济惩罚机制（押金锁定）和链上验证合约，若运营商被证明欺诈，将损失押金并回滚状态。
代表项目：Arbitrum、Optimism、Base。

2. Zero-Knowledge Rollups（零知识汇总）

工作机制：通过零知识证明（ZK Proof）技术生成有效性证明（Validity Proof），证明交易批次的合法性。验证者只需检查证明，无需重放所有交易。
核心优势：

即时确定性：无需挑战期，交易确认后不可逆转。
更高安全性：数学证明保证状态正确性，无需依赖信任假设。
更低Gas成本：数据压缩率可达1000:1，验证成本显著低于Optimistic方案。


代表项目：zkSync、StarkNet、Polygon zkEVM。

3. 见证（Witness）与零知识证明

见证（Witness）：是证明者（Prover）生成的一组中间值，用于证明输入数据满足特定数学关系（如哈希函数、椭圆曲线方程）。在ZK Rollups中，Witness包含交易数据、状态转换逻辑等信息，但不泄露具体内容。
验证流程：

证明者收集交易并生成状态转换。
基于Witness生成零知识证明（如SNARK或STARK）。
验证者（Verifier）通过智能合约检查证明，确认输出状态与预期一致。


技术特性：

简洁性：证明大小通常仅几十KB，验证时间极短（毫秒级）。
非交互性：单个证明可独立验证，无需与证明者交互。



对比与应用场景



特性
Optimistic Rollups
ZK Rollups




验证机制
欺诈证明（默认有效，需挑战）
有效性证明（数学证明）


最终确认时间
7天挑战期后
几秒至几分钟（证明生成后）


兼容性
完全兼容EVM（支持所有Solidity合约）
部分兼容（需适配ZK-EVM）


适用场景
DeFi协议、复杂智能合约
NFT铸造、高频交易、隐私保护



Rollup技术通过链下计算+链上验证的模式，将以太坊的理论TPS从15提升至2000+，Gas成本降低90%以上。Optimistic方案侧重兼容性，ZK方案侧重安全性与效率，两者共同推动区块链应用进入规模化阶段。随着ZK-EVM（如zkSync 2.0）的成熟，未来大多数应用可能转向零知识Rollup架构。
RollUp stage (Rollup 发展阶段)
Stage 0
在这个初始的阶段，RollUp的治理主要由运营方和安全委员会掌控，确保关键决策并且有可信的团体去专门监督（中心化的），此阶段的用户拥有退出机制，可以在七天内离开rollup，但是通常需要实体和运营方的操作进行结合。
Stage 1
中心化的治理演化为智能合约管理，当然安全委员会同时发挥作用。
证明系统完全开始运作，支持去中心化的有效证明。
退出机制也得到改进，用户可独立退出而无需运营方协调。
Stage 2
通过完全由智能合约管理的治理机制实现完全去中心化。
无需运营方和安全委员会干预。
证明系统是无许可的，退出机制也完全去中心化。
ZKSync Risk Analysis[风险分析]
https://l2beat.com/scaling/summary  L2Beat摘要中可以查看各Rollup所处的stage
Risks那一列的饼图可以体现当前阶段的一些风险，例如ZkSync Era专属页面中：



Data Availability: refers to the ability to reconstruct the L2 state from L1 data, ensuring that anyone can verify and rebuild the L2 state if necessary.
能够从L1的数据中重建L2状态


State Validation: involves verifying the legitimacy of a set of bundled transactions. For ZK Sync, this is done using zero-knowledge proofs through an algorithm known as PLONK (Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge).
涉及验证一组打包交易的合法性。


Sequencer Failure: describes the ability to process transactions even if the sequencer is down. In ZK Sync, transactions can still be submitted to L1, though not necessarily enforced immediately.
排序器故障，描述了即使排序器宕机还能够处理交易的能力，这里黄色区块表示，在ZKsync中，交易仍然可以提交到L1，但不一定能够强制执行。

排序器：是负责对打包的用户交易进行排序的操作方（运营商）
The sequencer is the operator responsible for ordering user transactions and often batching them before committing them to Layer 1.



Proposer Failure: describes the ability to process transactions even if the proposer is down. In this case, ZK Sync will halt all withdrawals and transactions executions.
提议者宕机但是可以处理交易的能力。在Zksync中回暂停所有的提款和交易执行。


Exit Window: In the current ZK Sync stage, there is no window for exit during unwanted upgrades.
红色区块表示Zksync在非预期的升级时不存在退出窗口期。


First Transaction On ZKSync
chainList 官网搜索ZKsync sepolia
https://chainlist.org/?search=zksync+sepolia&amp;testnets=true

进行connect


在zkSync官网的block explorer 中，可搜索到自己的账户，查看交易详情
如何获取测试网络的基金？

📒 NOTE
Network Fauncets

这里可以通过brige桥接源链和目标链来进行，也有两种方式，一种是lock和unlock 另一种是烧毁和铸造；
可能会有安全问题，但是基于ZkSync使用过程的经验来说，是比较安全的。

了解原理之后，我们在推荐的fauncet里获取我们的fund

这里我recive失败了，重新找了其他funsets ，可以用回tenderly试试看
Solidity 基础[part1]
Remix IDE

函数
无返回体函数示例：
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19; // chose our solidity version 

contract SimpleStorage &#123;
    uint256 public myFavoriteNumber; // 初始值就是0 而且是internal 也就是内部不可见的

    function store(uint256 favoriteNumber) public &#123;
        myFavoriteNumber = favoriteNumber;
    &#125;

&#125;
有返回体示例：
function recive() public view returns (uint256) &#123;
       return myFavoriteNumber;
   &#125;
数组
// 数组
uint256[] public myFavoriteNumbers;


Person public newPerson = Person(1, 'jack');

Person public myPerson;


function setPerson(string memory name, uint256 person_number) public &#123;
    myPersonArray.push(Person(person_number,name));
&#125;

结构
// 结构
    struct Person &#123;
        uint256 personNumber;
        string name;
    &#125;

数组加结构
// 数组加结构
 Person[] public myPersonArray;
可见性
函数和变量有四种可见性修饰符：

public：可从合约内部和外部合约访问
private：仅限当前合约内部访问。不会隐藏值，仅限制其访问权限。
external：仅适用于外部的合约访问。⚠️
internal： 当前合约和派生的合约可以访问。

如果没有指定，默认是internal
view 、pure
函数操作权限修饰符
1. view 关键字


功能：使用view关键字修饰的函数，承诺不会对区块链的状态进行修改。


可执行操作

能够读取区块链上的数据（也就是状态变量）。
可以访问 msg.sender、block.number 等全局变量。
支持调用其他同样被标记为view或者pure的函数。



不可执行操作：禁止对状态变量进行写入操作。


示例：


contract ViewExample &#123;
    uint public balance;

    // 此函数仅读取状态变量，不会对其进行修改
    function getBalance() public view returns (uint) &#123;
        return balance;
    &#125;
&#125;
2. pure 关键字


功能：被pure关键字修饰的函数，既不会读取也不会修改区块链的状态。


可执行操作

可以使用函数内部定义的局部变量。
能够操作传入函数的参数。
支持进行数学运算。
可以调用其他pure函数。



不可执行操作

禁止访问状态变量。
不允许调用非view或pure的函数。



示例：


contract PureExample &#123;
    // 该函数不依赖任何状态变量，仅对输入参数进行计算
    function add(uint a, uint b) public pure returns (uint) &#123;
        return a + b;
    &#125;
&#125;
3. 关键区别



特性
view 函数
pure 函数




能否读取状态变量
可以
不可以


能否修改状态变量
不可以
不可以


是否消耗 Gas（外部调用时）
不消耗
不消耗


是否消耗 Gas（内部调用时）
消耗
消耗




⚠️ 一般调用这两个关键字都不会消耗gas费， 但是如果是内部调用，例如下面这个例子, store里面调用recive就会导致gas费产生。

function store(uint256 favoriteNumber) public &#123;// 存储
       myFavoriteNumber = favoriteNumber;
       recive(favoriteNumber);
   &#125;

 function recive() public view returns (uint256) &#123;
     return myFavoriteNumber;
 &#125;
完整代码：
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19; // stating our version 

contract SimpleStorage &#123;
    uint256 public myFavoriteNumber; // 初始值就是0 而且是internal 也就是内部不可见的



    // 数组
    uint256[] public myFavoriteNumbers;

    // 结构
    struct Person &#123;
        uint256 personNumber;
        string name;
    &#125;

    Person public newPerson = Person(1, 'jack');

    Person public myPerson;

    Person[] public myPersonArray;

    function setPerson(string memory name, uint256 person_number) public &#123;
        myPerson = Person(person_number, name);
        myPersonArray.push(myPerson);
    &#125;

    function store(uint256 favoriteNumber) public &#123;// 存储
        myFavoriteNumber = favoriteNumber;
    &#125;

    // view 可读不可写 pure 不可读不可写
    function recive() public view returns (uint256) &#123;
        return myFavoriteNumber;
    &#125;



&#125;
]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3 Day4—Solidity基础[part3]</title>
    <url>/2025/07/01/WEB3%20Day4%20%E2%80%94%20Solidity%E5%9F%BA%E7%A1%80%5Bpart3%5D/</url>
    <content><![CDATA[WEB3 Day4—Solidity基础[part3]
智能合约部署 Smart Contracts Deploying
Sepolia TestNet deploying
我们可以通过进入部署选项卡，从本地虚拟环境（Remix VM）切换到注入的提供者 - MetaMask 来开始部署过程。这一操作将允许Remix发送请求并与您的MetaMask账户进行交互。

随后系统会提示你去选择一个账号。 在你成功连接到remix之后，你会看到账号已经成功链接到并且正在使用sepolia网络的信息。

注意，需要你的测试网络里面必须有足够的 sepolia ETH，如果没有需要从水龙头获取，免费的水龙头我这边会集中收集一次，后续可点击这篇文章：【TODO 挖个坑】；
暂时可以去这里faucet， 但是还是需要主账户里面要有ether。
随后，MetaMask就会要求你在测试网站上签署发送：

交易执行之后，合约地址会将交易详情一同显示在已部署的合约列表下面。这就是Eherscan上部署交易的显示方式。

合约交互 Contract interaction
合约部署完成以后，我们可以与之交互并更新区块链。例如，如果想存储一个数字，可以通过点击store按钮实现；MetaMask会要求再次确认交易。然后更行您设置的数字。这些交易都可以通过部署地址在etherscan上面查询查看。
Zksync部署
由于以太坊主网合约部署成本比较高昂，所以RollUp和Layer2网络等扩容解决方案更佳，需要掌握部署在Zksync的流程。
首先需要Zksync的测试网基金以及zkSync的跨链桥
可参照之前的笔记 WEB3 Day2 —— BlockChain Basic 2
然后步骤和上面主网的测试网络部署相似，只不过需要跨链

连接钱包
需要将Sepolia ETH跨链到zkSync，Zksync Bridge地址

连接钱包，保证网络在sepolia
从sepolia测试网发送eth到zksync




​	


有测试基金以后，需要将remixIDE 下载zksync的插件



⚠️ zkSync部署版本要求 ‘0.8.24’，并且合约*.sol文件必须放在一个contracts文件夹中，不然Zksyn插件的deploy标签页可能会显示空白


编译——&gt;连接钱包——&gt; 部署



合约之间如何相互部署以及交互
通过import进行导入另一个合约
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.18;

import "./SimpleStorage.sol";

contract StorageFacotory &#123;

    SimpleStorage public simpleStorage;


    function createSimpleStorageContract() public  &#123;
        simpleStorage = new SimpleStorage();
    &#125;
&#125;
如果导入文件有多个合约，一般import最好声明具体的名称，可以不用导入该文件的所有合约
import &#123;SimpleStorage, SimpleStorage2&#125; from "./SimpleStorage.sol";
调用另外一个合约的ABI[application binary interface]
可以创造一个SimpleStorage的数组来存储所有创建的simpleStorage的地址，然后通过地址去调用特定的simplestorage的函数

pragma solidity ^0.8.19;

import &#123;SimpleStorage&#125; from "./SimpleStorage.sol";
contract StorageFacotory &#123;

    SimpleStorage[] public listOfSimpleStorage;


    // 创建需要的SimpleStorage
    function createSimpleStorageContract() public  &#123;
        SimpleStorage simpleStorage = new SimpleStorage();
        listOfSimpleStorage.push(simpleStorage);
    &#125;

    // 调用simpleStorage的store函数
    function sfStore(uint256 _index, uint256 myFavoriteNumber) public&#123;
        listOfSimpleStorage[_index].store(myFavoriteNumber);
    &#125;

    // 调用simpleStorage里面的recive函数
    function sfRecive(uint256 _index) public view returns (uint256) &#123;
        return listOfSimpleStorage[_index].recive();
    &#125;

&#125;

继承和重写
创建继承自 SimpleStorage.sol 的新合约 AddFiveStorage.sol，并通过重写函数实现功能扩展。
SimpleStorage.sol代码

virtual 表示原函数可以被继承

function store(uint256 favoriteNumber) public virtual  &#123;// 存储
     myFavoriteNumber = favoriteNumber;
 &#125;
AddFiveStorage.sol代码
// SPDX-License-Identifier:MIT

pragma solidity ^0.8.18;

import &#123;SimpleStorage&#125; from "./SimpleStorage.sol";

contract AddFiveStorage is SimpleStorage &#123;


    // 需要override关键字 原函数需要加上virtual函数
   function store(uint256 favoriteNumber) public override &#123;// 存储
        myFavoriteNumber = favoriteNumber + 5;
    &#125;
&#125;

is 表示继承
override 关键字表示重写

]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3-Day5—Solidity基础[part4]</title>
    <url>/2025/07/01/WEB3-Day5%E2%80%94Solidity%E5%9F%BA%E7%A1%80-part4/</url>
    <content><![CDATA[WEB3-Day5—Solidity基础[part4]
通过函数发送ETH
新建合约 FundMe.sol，在本合约中会通过fund()函数向智能合约转移以太币。该函数将要求最低数量的ETH确保交易正常。
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract FundMe&#123;


    function fund() public &#123;
        
    &#125;
&#125;
我们还需要一个Withdraw函数，这样合约的owner(拥有者)可以提取不同的funder 发送的资金。
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract FundMe&#123;


    function fund() public &#123;
        
    &#125;

    function withDraw() public &#123;
        
    &#125;
&#125;
当交易被发送到区块链时，交易数据中始终包含一个value字段。该字段表示该交易中转账的原生加密货币数量。
要使fund函数可以接受ether，必须将其声明为payable。同时在remix界面中部署了可以看到，这个关键字会使函数显示为红色，表示它可以接受加密货币。
function fund() public payable &#123;
        
    &#125;
msy.value 属性
在solidity中，交易的数值可以通过这个属性进行访问，是全局对象msg的一部分，表示当前交易中传输的Wei的数量。【Wei是ETH的最小单位】
function fund() public payable &#123;
    
    msg.value;
&#125;
交易字段
以太坊上发送的每笔交易都包含一些必要字段，这些字段包括：

Nonce：这是发送地址的交易计数器。它确保交易按顺序执行，并防止重播攻击。
Gas Price：这是发送者愿意支付的 gas 单价，以太坊网络会根据 gas price 和 gas limit 来计算手续费。
Gas Limit：这是交易执行所需的最大 gas 数量。它决定了交易的复杂程度和成本。
To：这是接收以太币或者调用智能合约的目标地址。
Value：这是发送的以太币数量。
Data：这是可选字段，用于向智能合约发送数据。
v、r、s：这些字段用于交易的签名验证，确保交易的安全性和完整性。

在转账的时候，我们可以填充其中一些字段，例如，gas limit中填充的21,000，data是空的，然后to是我们想要将交易发送到的地址，在函数调用的交易中，仍然可以以这种方式填写to，我们可以调用一个函数，并同时进行转账。
Value
每当我们在任何一个兼容EVM的区块链上创建一笔交易时，这个value的值，代表我们将通过这笔交易发送多少ETH，当我们在不同账户间转移ETH时，实际上就是在value中填充不同的ETH数量。

撤销交易[Reverting Transactions]
我们可以使用requires关键字作为检查器，强制要求函数接收至少value个完整的以太币, 不满足就会回滚。
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract FundMe&#123;


    function fund() public payable &#123;
        require(msg.value > 1 ether, "Didn't send enough ETH"); //if the condition is false, revert with the error message    &#125;
    &#125;
    function withDraw() public &#123;
        
    &#125;
&#125;
msg.value &gt; 1 ether等同于 msg.value &gt; 1e18

👀❗提示
1 Ether = 1e9 Gwei = 1e18 Wei
Gwei是Gas费用的单位。

在线转换单位的工具 ：Ethconverter
回滚操作会撤销之前的所有操作，并将剩余gas费返还给交易者，我们在fund函数中添加一些逻辑：
myvalue  += 2;
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract FundMe&#123;


    uint256 public  myvalue = 1;
    function fund() public payable &#123;
        myvalue  += 2;
        require(msg.value > 1 ether, "Didn't send enough ETH"); //if the condition is false, revert with the error message    &#125;
    &#125;

    function withDraw() public &#123;

    &#125;
&#125;
部署合约，点击fund函数，报错信息成功返回：


⚠️ 回滚以后交易消耗的gas费不会返回的

]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3 Day3-Solidity基础[part2]</title>
    <url>/2025/06/26/WEB3%20Day3%20%E2%80%94%E2%80%94%20Solidity%E5%9F%BA%E7%A1%80%5Bpart2%5D/</url>
    <content><![CDATA[WEB3 Day3 — Solidity基础[part2]
存储位置
solidity里面有六种存储位置。

Calldata
Memory
Storage
Stack
Code
Logs

calldata和memory是函数执行期间变量的临时存储位置，calldata只读，用于不可修改的函数输入。
相比之下，memory允许读写访问，使变量能在函数内部被修改。
要修改calldata变量，必须先讲它们加载到memory中。
Calldata
只读的， 比storage更经济，主要用于输入。
下面函数中_name 用calldata关键字，就会收到错误提示，因为不可修改。

Memory
可读可修改，大多数的变量默认自动使用memory，但是字符串不能默认，需要明确指定memory或者calldata
string memory variableName = "someValue";
下面会讲到为什么会这么特殊
storage
存储在storage的变量在区块链上是持久化的，其值在函数调用和交易之间保持不变。
比如下面这个变量 favoriteNumber ，声明在函数外部，会被隐式转换为存储变量。
contract MyContract &#123;
    uint256 favoriteNumber; // this is a storage variable
&#125;;

⚠️ 同理，在函数内部也不能使用storage，因为函数中的变量都是临时存在。

字符串和基本类型的特殊存储
在Solidity中，string是字节数据，arrays of bytes，在上文中提过需要指定确切的存储位置；
另一方面，uint256基本类型有内置机制，用于规定它们的存储、访问和操作方式及位置。
所以，在函数给uint256指定关键字就会报错

mapping类型
遍历过于消耗资源，所以我们使用mapping结构
mapping (string => uint256) public nameToFavoriteNumber;
🧑‍💻 Test yourself

📕 How does the Solidity compiler handle primitive types and strings in terms of memory management?
📕 Why can’t the storage keyword be used for variables inside a function?
🧑‍💻 Write a smart contract that uses storage, memory and calldata keywords for its variables.

]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3-Day6—Solidity基础[part5]</title>
    <url>/2025/07/03/WEB3-Day6%E2%80%94Solidity%E5%9F%BA%E7%A1%80-part5/</url>
    <content><![CDATA[WEB3-Day6—Solidity基础[part5]

继续完善fundMe合约 的 fund() 和 withDraw()

转换ETH为USD
如果我们的最小交易值需要用美元为单位，我们该如何和msg.value进行比较？
新建一个变量：
uint256 public  minimumUsd = 5 * 1e18;  // 补全精度
新建两个函数：
// Function to get the price of Ethereum in USD
function getPrice() public &#123;&#125;
// Function to convert a value based on the price
function getConversionRate() public &#123;&#125;

getPrice():获取真实世界中以太坊当前的美元市场价格
getConversionRate()：根据当前输入价格进行计算和转换

去中心化预言机
以太坊等资产的美元价格无法仅通过区块链技术获取，而是由金融市场决定。为了获取正确的价格信息，必须在链下数据与链上数据之间建立连接，这一需求由去中心化预言机网络实现。
区块链存在这一局限性，是因为其确定性本质——它确保所有节点达成唯一共识。若尝试将外部数据引入区块链，将破坏这种共识，导致所谓的智能合约连接性问题或预言机问题。
若想让智能合约有效替代传统协议，它们必须具备与现实世界数据交互的能力。
依赖中心化预言机传输数据是不足的，因为这会重新引入潜在的单点故障风险。中心化数据源会削弱区块链功能所必需的信任前提。因此，中心化节点无法满足外部数据或计算需求。Chainlink通过提供去中心化预言机网络，解决了这些中心化挑战。
ChainLink数据源
Chainlink Data Feed documentation 提供如何与数据源合约交互的文档

AggregatorV3Interface：是一个数据源地址作为输入的合约。保持ETH/USD价格实时更新。
合约中的latestRoundData 函数返回最新的以太坊价格。
为了使用合约，我们需要它的地址和ABI。该地址可在Chainlink文档中的 Price Feed Contract Addresses部分找到。我们将使用ETH/USD。
首先导入该合约，可以通过github地址导入
import &#123;AggregatorV3Interface&#125; from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

在chainLink找到ETH/USD地址，调用latestRoundData函数获取answer，不用的参数可以用,相隔，因为返回的answer是int类型需要转换uint
完善getPrice() :
function getPrice() public  view returns(uint256) &#123;
        AggregatorV3Interface addressToBeFetched = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
        (, int256 answer,,,) = addressToBeFetched.latestRoundData(); // ( ,,,, , )  取出地址，值，错误码等
        return uint256(answer * 1e18);
    &#125;
msg.value 是一个具有 18 位小数精度的 uint256 值。
answer 是一个具有 8 位小数精度的 int256 值（基于 USD 的交易对使用 8 位小数，而基于 ETH 的交易对使用 18 位小数）。
这意味着从我们的latestRoundData函数返回的价格与msg.value不直接兼容。为了匹配小数位数，我们将价格乘以1e10.

⚠️ 始终先乘后除保持精度避免截断错误。

完善getConversionRate():
function getConversionRate(uint256 ethAmmout) public view returns(uint256) &#123;
      uint256 ethPrice = getPrice();
      return (ethPrice*ethAmmout)/1e18;
  &#125;

uint256 ethAmountInUsd = (ethPrice * ethAmount)
得到的结果精度为 1e18 * 1e18 = 1e36。为了将 ethAmountInUsd 的精度恢复到 1e18，我们需要将结果除以 1e18。

更改fund()：
require(getConversionRate(msg.value) >= MINIMUM_USD, "You need to spend more ETH!");
部署合约，调用getPrice函数获取当前以太坊价格。还可以向该合约发送资金，如果ETH金额低于5美元就一会报错。
完整代码：
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import &#123;AggregatorV3Interface&#125; from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

contract FundMe&#123;
    uint256 public  minimumUsd = 5 * 1e18; // 补全精度
    
    function fund() public payable &#123;
        require(getConversionRate(msg.value) > minimumUsd, "Didn't send enough ETH"); //if the condition is false, revert with the error message    &#125;
    &#125;

    function withDraw() public &#123;

    &#125;

    // 获取当前的eth对应实际世界的美元价格
    function getPrice() public view returns(uint256) &#123;
        AggregatorV3Interface addressToBeFetched = AggregatorV3Interface(0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43);
        (, int256 answer,,,) = addressToBeFetched.latestRoundData(); // ( ,,,, , )  取出地址，值，错误码等
        return uint256(answer * 1e18);
    &#125;

    function getConversionRate(uint256 ethAmmout) public view returns(uint256) &#123;
        uint256 ethPrice = getPrice();
        return (ethPrice*ethAmmout)/1e18;
    &#125;

&#125;
追踪资金
为了追踪向合约发送资金的地址，我们可以创建一个名为funders的地址array记录：
address[] public funders;
fund()函数中添加以下逻辑，每当有人向合约发送钱时，我们将使用push函数将他们的地址添加到数组中：
funders.push(msg.sender);
库[Libraries]
当某个功能具有通用性的时候，我们可以创建一个library库来高效管理重复代码。
getPrice()函数和getConversionRate()这些方法可以被任何使用价格预言机的合约多次复用。
在Solidity示例网站 Solidity by example上可以找到优秀的库示例。Solidity的库与合约类似，但不允许声明任何状态变量，也不能接收ETH。

📢 库中所有的函数都必须声明为internal，必须独立部署以后再链接到主合约。

创建新文件PriceConverter.sol，将两个函数的逻辑剪切到这边，注意声明internal
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import &#123;AggregatorV3Interface&#125; from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

library PriceConverter &#123;
    function getPrice() internal view returns (uint256) &#123;
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
        (, int256 answer, , , ) = priceFeed.latestRoundData();
        return uint256(answer * 10000000000);
    &#125;

    function getConversionRate(uint256 ethAmount) internal view returns (uint256) &#123;
        uint256 ethPrice = getPrice();
        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;
        return ethAmountInUsd;
    &#125;
&#125;
主合约FundMe修改为：

import库
using PriceConvertor for uint256 ：表示所有uint256类型可以调用该library的函数
msg.value.getConversionRate() 直接调用

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import &#123;PriceConvertor&#125; from "./PriceConvertor.sol";

contract FundMe&#123;

    // 表示所有uint256类型可以调用该library的函数
    using PriceConvertor for uint256;

    address[] public funders; 

    mapping(address funderAddress => uint256 funderAmount) public funderAmountMap;

    uint256 public  minimumUsd = 5 * 1e18;
    
    function fund() public payable &#123;
        require(msg.value.getConversionRate() > minimumUsd, "Didn't send enough ETH"); //if the condition is false, revert with the error message    &#125;
    
    		//记录追踪资金
        funders.push(msg.sender);
        funderAmountMap[msg.sender] += msg.value;
    &#125;

    function withDraw() public &#123;

    &#125;

&#125;
solidity 0.8后变更
safeMath 作为0.8版本之前广泛被使用的库，曾是智能合约中的标配功能，为什么如今不再使用了呢？
可以调整到编译器版本为0.6.0 ，新建一个合约SafeMathTester
// SafeMathTester.sol
pragma solidity ^0.6.0;

contract SafeMathTester &#123;
    uint8 public bigNumber = 255;

    function add() public &#123;
        bigNumber = bigNumber + 1;
    &#125;
&#125;
编译调用该函数，发现bigNumber值会被重置为0，这是因为0.8版本之前，有符号或者无符号的整数都是未检查的，意味着如果他们超过变量类型能够容纳的最大值，就会重置为下限值。
而safeMath会提供一个机制，达到最大限制时回滚交易，避免错误计算和漏洞。
function add(uint a, uint b) public pure returns (uint) &#123;
    uint c = a + b;
    require(c >= a, "SafeMath: addition overflow");
    return c;
&#125;
0.8.0以后，solidity已经实现自动化溢出下溢检查，在新版本部署SafeMathTester 将会报错而不是重置为0；
同时，也引入unchecked结构来提高代码的gas效率：
uint8 public bigNumber = 255;

function add() public &#123;
    unchecked &#123;
        bigNumber = bigNumber + 1;
    &#125;
&#125;
被unchecked包裹的代码块将忽略溢出和下溢检查，如果超出限制，就会重置到0。
从合约发送ETH
接下来进行资金的提取
重置资金
募集资金了以后，合约中已经存储了所有募集的资金，所以在资金提取这一步，我们可以先清空追踪资金的数组和集合，这里需要用到循环：
首先将map置空，再将数组置空
function withDraw() public &#123;

    //  Reset the funder records
    for (uint256 funderIndex = 0; funderIndex &lt; funders.length; funderIndex ++) &#123;
        address funder = funders[funderIndex];
        funderAmountMap[funder] = 0;
    &#125;
    // reset the array
    funders = new address[](0);
&#125;

构造函数
目前，任何人都可以调用提款函数并将所有资金从合约中提走。为了解决这个问题，我们需要将提款函数限制为仅合约所有者可以调用。
解决办法就是构造函数：
constructor() &#123;&#125;
构造函数会在合约部署期间自动调用，与部署合约的交易在同一笔交易中执行。
在函数里，我们将状态变量所有者初始化为合约部署者的地址（msg.sender）。
address public owner;
constructor() &#123;
    owner = msg.sender;
&#125;
更新withDraw函数：
function withdraw() public &#123;
    require(msg.sender == owner, "must be owner");
    // rest of the function here
&#125;
限制只有合约拥有者才可以进行提取。
modify优化
Solidity 中的修饰器（Modifier）是一种强大的合约元编程工具，用于在执行函数前 / 后注入额外逻辑（如权限检查、状态验证等）。合理使用修饰器不仅能提高代码复用性，还能显著优化合约性能与安全性。
上述的权限检查可以单独拆出来作为modify函数
modifier onlyOwner &#123;
        require(msg.sender == owner,"Must be the Owner!");
        _;
    &#125;
原函数添加onlyOwner：
function withdraw() public onlyOwner &#123;
   
&#125;
转账
Transfer
是以太币转帐至接收地址的最简单方式
payable(msg.sender).transfer(amount);
// the current contract sends the Ether amount to the msg.sender
然而，transfer有一个显著的限制。它只能使用最多2300个gas，并且它会回滚任何超出这个限制的交易，正如《Solidity实例教程》 Solidity by Example所示。

🧐 为什么需要payable关键字？
必须将接收者地址转换为可支付地址，以便它能够接收以太币。可以通过将msg.sender用可payable关键字包裹来实现。

Send
bool success = payable(msg.sender).send(address(this).balance);
require(success, "Send failed");
与transfer类似，send也有2300的gas限制。如果达到gas限制，它不会撤销交易，但会返回一个布尔值（true或false）以指示交易的成功或失败。处理失败是开发者的责任，如果send返回false，触发撤销条件是一种良好的实践。
Call
call函数非常灵活和强大。它可以用来调用任何函数，而不需要它的ABI。它没有gas限制，并且像send一样，它返回一个布尔值，而不是像transfer那样回滚。
(bool success, ) = payable(msg.sender).call&#123;value: address(this).balance&#125;("");
require(success, "Call failed");
call函数返回两个变量(bool success, )：一个表示成功或失败的布尔值，以及一个存储返回数据的字节对象（如果有）。

❗call是发送和接收以太坊或其他区块链原生代币的推荐方式。

完整代码
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import &#123;PriceConvertor&#125; from "./PriceConvertor.sol";

contract FundMe&#123;

    address public owner;

    constructor () &#123;
        owner = msg.sender;
    &#125;

    // 表示所有uint256类型可以调用该library的函数
    using PriceConvertor for uint256;

    address[] public funders; 

    mapping(address funderAddress => uint256 funderAmount) public funderAmountMap;

    uint256 public  minimumUsd = 5 * 1e18;
    
    function fund() public payable &#123;
        require(msg.value.getConversionRate() > minimumUsd, "Didn't send enough ETH"); //if the condition is false, revert with the error message    &#125;
    
        funders.push(msg.sender);
        funderAmountMap[msg.sender] += msg.value;
    &#125;

    function withDraw() public onlyOwner&#123;

        //  Reset the funder records
        for (uint256 funderIndex = 0; funderIndex &lt; funders.length; funderIndex ++) &#123;
            address funder = funders[funderIndex];
            funderAmountMap[funder] = 0;
        &#125;
        // reset the array
        funders = new address[](0);

        // send money to msg.sender[three ways]
        // transfer
            // payable(msg.sender).transfer(amount); // the current contract sends the Ether amount to the msg.sender
        // send
            // bool success = payable(msg.sender).send(address(this).balance); require(success, "Send failed");
        // call
        (bool success, ) = payable(msg.sender).call&#123;value: address(this).balance&#125;("");
        require(success, "Call failed");
    &#125;

    // 任何由onlyOwner修饰都会先执行这部分代码，“_;”代表被修饰的函数的代码，放在require之前就是先执行完函数代码再执行modifier代码块中内容
    modifier onlyOwner &#123;
        require(msg.sender == owner,"Must be the Owner!");
        _;
    &#125;
&#125;
]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3-Day8—Foundry框架[part1]</title>
    <url>/2025/07/06/WEB3-Day8%E2%80%94Foundry%E6%A1%86%E6%9E%B6-part1/</url>
    <content><![CDATA[WEB3-Day8—Foundry框架[part1]
简介
Foundry Fundamentals
Foundry 是一个相对较新但发展迅猛的智能合约开发框架，以高效性和模块化设计著称。关于这个强大工具的最佳简介可查阅 《Foundry 官方手册》：
Foundry 可管理项目依赖、编译工程、运行测试、部署合约，并支持通过命令行及 Solidity 脚本与区块链交互。
请务必收藏 《Foundry 官方手册》—— 它是最全面的资源，可解答您的所有疑问，在学习过程中会持续提供帮助。
Foundry 的核心优势包括：

借助 Rust 进行编译，相比 Hardhat 或 Brownie 等框架，构建速度显著提升；
完全基于 Solidity 开发，无需学习其他编程语言；
文档体系极为完善。

推荐代码编辑器：Visual Studio Code
在本课程中，我们将使用 Visual Studio Code 完成智能合约的 编写、测试、部署 及 交互。这款轻量级代码编辑器功能强大，支持 Windows、macOS 和 Linux 系统，其丰富的扩展生态系统使其成为智能合约开发的首选工具之一。
安装Foundry
curl -L https://foundry.paradigm.xyz | bash
source /Users/tinachan/.zshenv
foundryup
创建文件夹和初始化
创建文件夹
mkdir foundry-f23  
cd foundry-f23  
现在输入以下命令：
mkdir foundry-simple-storage-f23  
cd foundry-simple-storage-f23  
技巧：输入目标路径的前几个字母后按 Tab 键可快速补全 cd 命令——Tab 键能自动补全大部分命令/路径。
若输入 code .，将打开新的 VS Code 实例，并默认以 foundry-simple-storage-f23 为工作路径。
可通过左侧边栏查看该文件夹内容。尝试执行以下命令：
touch randomFile.txt  
这将创建一个 randomFile.txt 文件。
若需删除该文件，输入：
rm randomFile.txt  
终端在移动/打开/创建目录/文件、切换路径及运行程序方面非常便捷。若想提升操作效率，推荐阅读 此教程。
创建新项目
创建新Foundry项目 的方式是执行 forge init 命令，这将在当前工作目录生成一个新的Foundry项目。
若希望Foundry在新文件夹中创建项目，输入：forge init 新文件夹名称。
注意：forge init 默认要求目标文件夹为空。若文件夹非空，需执行 forge init --force .。
若遇到Git配置相关错误，需先配置用户名和邮箱：
git config --global user.email "你的邮箱@提供商.com"  
git config --global user.name "你的用户名"  
完成后，文件夹结构应如下所示：

各文件夹含义说明：


lib：存放所有依赖项，例如：

forge-std（用于测试和脚本的forge库）
openzeppelin-contracts（经过大量实践验证的智能合约库）
其他按需安装的依赖



scripts：存放所有脚本文件


src：存放所有智能合约源文件


test：存放所有测试文件


foundry.toml：Foundry的配置参数文件


后续将详细介绍这些文件夹和文件。
现在请右键点击 src 文件夹，选择 New File 并命名为 SimpleStorage.sol。将 此链接 中的代码复制到该文件中。
最后一步：请删除 Counter.s.sol、Counter.sol 和 Counter.t.sol。这些是Foundry创建新项目时默认提供的基础智能合约文件。
VSCode插件
刚开始编写代码时，界面可能只是一片单调、缺乏格式的白色文本。
通过安装 Solidity 扩展可轻松解决这个问题。在扩展选项卡（按 CTRL/CMD + SHIFT + X）中，以下几个 Solidity 扩展值得关注：

Solidity by Juan Blanco —— 最常用的 Solidity 扩展。
Solidity by Nomic Foundation —— Patrick 最推荐的 Solidity 扩展，本课程将使用此扩展演示。
Solidity Visual Developer —— 另一款热门选择。

注意：若安装扩展后代码仍无高亮，可按以下步骤解决：
按下 Command + Shift + P（macOS）或 Control + Shift + P（Windows）打开命令面板，输入“Settings”并选择 “Preferences: Open User Settings (JSON)”。
若文件为空，添加以下设置：
&#123;
  "editor.defaultFormatter": "NomicFoundation.hardhat"
&#125;

若使用 Solidity Visual Developer，设置为：
&quot;editor.defaultFormatter&quot;: &quot;tintinweb.solidity-visual-auditor&quot;
若使用 Solidity by Juan Blanco，设置为：
&quot;editor.defaultFormatter&quot;: &quot;JuanBlanco.solidity&quot;

其他实用扩展
上一课提到的 foundry.toml 配置文件也有对应的格式化扩展，推荐安装 Even Better TOML，提升 TOML 文件的可读性。
另一款必备扩展是 Inline Bookmarks，其功能如下：
该插件支持在代码中添加书签，适用于文档评审、安全审计、日志分析及记录开发笔记和待办事项。书签会随文件保存，可轻松与他人共享。
默认预设的触发标签/关键词如下：

@todo（蓝色）：常规待办事项标记
@note（蓝色）：常规注释
@remind（蓝色）：提醒事项
@follow-up（蓝色）：待跟进事项
@audit（红色）：潜在问题标记
@audit-info（蓝色）：待后续处理的信息标记
@audit-ok（绿色）：标记某行代码无问题（即使看似有问题）
@audit-issue（紫色）：标记已记录问题的代码位置

提示：这些标签的颜色可完全自定义！它们在开发尤其是项目审计中非常实用，更多细节可查阅 官方文档。
编译合约
复制之前Solidity基础课程中的 SimpleStorage.sol合约
然后打开新终端。输入 forge build 或 forge compile 来编译项目中的智能合约。

部署合约
Anvil
部署智能合约有多种方式和平台。使用Foundry框架开发时，最简单且现成的部署环境是Anvil。
Anvil是Foundry自带的本地测试网络节点，可用于从前端测试合约或通过RPC交互。在终端输入anvil即可运行：

此时会生成10个测试地址，每个地址预存10_000 ETH及对应的私钥。该测试节点默认监听127.0.0.1:8545，此地址将作为部署合约时的RPC_URL参数（后续会详细说明）。更多Anvil相关信息可查阅 官方文档。
如需关闭Anvil，按Ctrl/CMD + C即可。本课程将全程使用Anvil部署和测试合约，在此之前先了解一个中间步骤。
Ganache
Ganache通常指糕点酱，由等量奶油和碎巧克力加热制成，先温热奶油再浇在巧克力上。
等等，这里说的不是糕点酱！另一个Ganache：
Ganache是用于快速开发以太坊和Filecoin分布式应用的个人区块链，可在整个开发生命周期中使用，支持在安全且确定的环境中开发、部署和测试dApp。
请从 此处 下载Ganache。
使用Windows WSL的用户请阅读 此文档——在该环境中配置Ganache并非易事，且后续不会使用，因此配置失败无需担心。
点击Quickstart Ethereum，即可生成全新区块链，包含带余额的地址和私钥。
配置MetaMask
若需部署到自定义网络（如本地节点），需使用MetaMask——这是一款流行的加密货币钱包和浏览器扩展，支持与以太坊区块链及其生态交互。尚未安装者可从 此处 下载。
配置步骤如下：

打开MetaMask，点击三点图标并选择Expand View；
进入Settings→Networks，查看网络列表及详情，重点关注RPC URL；
RPC URL本质上是发送交易时调用API的端点，每次执行区块链交易都会向该地址发送API请求。

添加自定义区块链网络的步骤：

点击Add a Network，滚动至列表底部；
选择Add a Network manually，输入本地网络信息：

网络名称：Localhost
新RPC URL：Ganache为http://127.0.0.1:7545，Anvil为http://127.0.0.1:8545（需确保添加http://，具体URL以Ganache界面或Anvil终端显示为准）
链ID：Ganache通常为5777（或1337），Anvil为31337（具体ID以工具显示为准）
货币符号：ETH
区块浏览器URL：留空（本地区块链无区块浏览器，关闭VS Code/Ganache后数据通常会丢失）



配置完本地网络后，需将Ganache或Anvil中的账户导入MetaMask，步骤如下 点击查看详情：

点击钱包顶部的账户选择器，点击Add account or hardware wallet；
选择Import account，粘贴Ganache/Anvil的私钥并点击Import。

重要提示：此账户仅限本地测试使用，切勿在主网或其他真实区块链中使用，所有人均可访问该账户！
接下来将进一步讲解在MetaMask中添加新网络的细节。
命令行部署
forge create SimpleStorage --interactive

脚本部署
通过脚本部署智能合约特别实用，因为它提供了一致且可重复的可靠部署方式，其特性还能增强对部署流程和代码本身的测试。
你可能喜欢命令行方式，但脚本会丰富整个部署流程，带来无可比拟的功能扩展和易用性。
Foundry基于Solidity开发，这意味着我们的部署脚本也将使用Solidity编写。必须明确区分作为合约语言的Solidity和作为脚本语言的Solidity——Foundry还整合了扩展功能，让Solidity的应用超出智能合约范畴。现在开始创建部署简单存储合约的脚本。
在Foundry中，脚本存放在script文件夹下

创建新文件DeploySimpleStorage.s.sol

.s.sol是Foundry脚本的命名规范，后续编写测试时会使用.t.sol后缀。
更多脚本最佳实践可查阅 此处。



编写Solidity部署脚本


初始代码框架：
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

contract DeploySimpleStorage &#123;
&#125;

前两行分别声明许可证和Solidity版本。



导入依赖并继承Script：
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

import &#123;Script&#125; from "forge-std/Script.sol";
import &#123;SimpleStorage&#125; from "../src/SimpleStorage.sol";

contract DeploySimpleStorage is Script &#123;
&#125;

注：forge-std（Forge标准库）包含预写的Solidity合约，用于简化和增强Foundry中的脚本与测试。



添加run主函数：
// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;

import &#123;Script&#125; from "forge-std/Script.sol";
import &#123;SimpleStorage&#125; from "../src/SimpleStorage.sol";

contract DeploySimpleStorage is Script &#123;
    function run() external returns (SimpleStorage) &#123;
        vm.startBroadcast();

        SimpleStorage simpleStorage = new SimpleStorage();

        vm.stopBroadcast();
        return simpleStorage;
    &#125;
&#125;

vm是Foundry的“作弊码”（cheat codes），仅在Foundry环境中生效：

vm.startBroadcast()标记发送到RPC URL的交易开始；
vm.stopBroadcast()标记交易结束；


new SimpleStorage()通过Solidity的new关键字创建合约实例。



执行部署脚本


停止正在运行的Anvil（按CTRL(CMD) + C），运行：
forge script script/DeploySimpleStorage.s.sol

若遇“文件中Solidity版本不兼容”错误，确保SimpleStorage.sol和部署脚本均使用pragma solidity 0.8.19;。



典型输出：
[⠆] Compiling...
[⠔] Compiling 2 files with 0.8.19
[⠒] Solc 0.8.19 finished in 1.08s
Compiler run successful!
Script ran successfully.
Gas used: 338569

== Return ==
0: contract SimpleStorage 0x90193C961A926261B756D1E5bb255e67ff9498A1

关键问题：未指定RPC URL时，Foundry会自动启动并终止Anvil实例完成部署。



指定RPC URL模拟部署：
# 先启动Anvil
anvil
# 新开终端执行
forge script script/DeploySimpleStorage.s.sol --rpc-url http://127.0.0.1:8545

输出中的SIMULATION COMPLETE表示这是模拟部署，生成的broadcast文件夹记录脚本运行信息。



广播部署（添加私钥）：
forge script script/DeploySimpleStorage.s.sol --rpc-url http://127.0.0.1:8545 --broadcast --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

Anvil终端将显示成功部署的交易信息：Transaction: 0x73eb9fb4ef7b159e03c50d669c42e2ec4eeaa9358bea0a710cb07168e5192570
Contract created: 0x5fbdb2315678afecb367f032d93f642f64180aa3
Gas used: 357088




]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>Foundry</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1:用Git+CloudFlare+PicGo+Typora+Hexo搭建个人博客全流程</title>
    <url>/2025/06/17/%E4%BB%8E0%E5%88%B01-%E7%94%A8Git-CloudFlare-PicGo-Typora-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[从 0 到 1：用 Git、CloudFlare、PicGo、Typora、Hexo 搭建个人博客全流程
一、前言
22年，我用 Hexo + Next 主题搭起第一个个人博客。三年后，随着图床需求升级、对博客风格有了新想法，我决定重构 —— 替换图床工具、更换主题，用 Git、CloudFlare、PicGo、Typora 配合 Hexo 重新搭建。这篇文章复盘从旧版迭代到全新上线的全过程，既是对自己折腾经历的记录，也希望给想优化博客的朋友一份实操参考。
二、环境准备与工具选型
（一）核心工具简介

Git：分布式版本控制系统，负责博客代码的版本管理与远程仓库同步，让博客部署、内容更新更高效。
CloudFlare：提供 CDN 加速、DNS 解析、安全防护等功能，让博客访问更快、更稳定，还能隐藏真实服务器 IP 。
PicGo：图床上传工具，写博客时本地图片能一键上传到图床，解决文章中图片存储与引用问题。
Typora：简洁高效的 Markdown 编辑器，实时预览、语法简洁，专注内容创作。
Hexo：静态博客生成框架，基于 Node.js，支持 Markdown 写作，能快速生成美观博客站点，部署灵活。

（二）环境安装

Git 安装：
官网（https://git-scm.com/ ）下载对应系统版本，安装后通过 git --version 验证，看到版本号即成功。
配置用户信息：git config --global user.name "你的用户名"
git config --global user.email "你的邮箱"

Node.js 与 Hexo 安装（Hexo 依赖 Node.js ）：
Node.js 官网（https://nodejs.org/ ）下载 LTS 版本，安装后用 node -v、npm -v 验证。
全局安装 Hexo：npm install -g hexo-cli
验证 Hexo 安装：hexo -v 显示版本信息则成功。
Typora 安装：官网（https://typora.io/ ）下载对应系统版本，按提示安装即可，简洁直观。
PicGo 安装：官网（https://picgo.github.io/PicGo-Doc/ ）或应用商店下载，支持多平台，安装后配置图床（如 GitHub 图床、七牛云等，我用 GitHub 图床时需配置仓库、Token 等 ）。

三、Hexo 初始化与博客基础搭建
（一）初始化 Hexo 项目

创建博客目录（如 my-blog ），进入目录：mkdir my-blog &amp;&amp; cd my-blog

初始化 Hexo：hexo init
npm install
执行后，目录会生成 Hexo 基础文件结构，包含 _config.yml（配置文件 ）、source（存放文章、资源 ）、themes（主题目录 ）等。

（二）主题选择与配置

主题下载：Hexo 官网（https://hexo.io/themes/ ）选心仪主题，比如我用的 anzhiyu 主题，克隆到 themes 目录：git clone https://github.com/Anzhiyu/hexo-theme-anzhiyu.git themes/anzhiyu

主题配置：复制主题目录下的 _config.yml 到博客根目录，重命名为 _config.anzhiyu.yml ，修改基础配置（如站点标题、描述、头像、导航菜单等 ），让博客符合需求。

（三）本地预览博客
执行以下命令，启动本地服务器：
hexo clean &amp;&amp; hexo g &amp;&amp; hexo s

hexo clean：清理之前生成的静态文件。
hexo g（hexo generate ）：生成静态博客文件到 public 目录。
hexo s（hexo server ）：启动本地服务器，浏览器访问 http://localhost:4000 ，就能看到初始博客页面。

四、内容创作与管理（Typora + PicGo [S3插件] + CloudFlareR2存储桶 ）
一、Cloudflare R2 存储桶创建与基础配置
（一）登录 Cloudflare 控制台

访问 Cloudflare Dashboard 并登录账户（若无账户需先注册）。
点击左侧菜单中的 R2 选项（若未显示，点击“更多产品”查找）。

（二）创建存储桶


点击 创建存储桶 按钮，进入创建流程：

存储桶名称：自定义（如 blog-images），需全局唯一（建议包含个人标识）。
区域：选择 自动（Auto）以获得最佳分布，或手动指定区域（如 亚洲 - 新加坡）。
访问控制：勾选 公开访问（Public access），允许匿名读取图片（若仅个人使用可跳过）。
加密：默认启用服务器端加密（SSE），无需修改。



点击 创建存储桶，等待约 10 秒完成创建。


（三）获取 API 访问凭证


进入 存储桶详情页 → 权限 标签页：

点击 创建访问密钥 按钮（若提示需要创建密钥对，点击“创建”）。
记录生成的 Access Key ID 和 Secret Access Key（仅显示一次，需立即保存到安全位置）。



复制存储桶端点（Endpoint）：

存储桶详情页 → 概述 标签页，找到 外部访问 中的端点地址（格式为 https://&lt;账户ID&gt;.r2.cloudflarestorage.com）。



二、PicGo 配置 S3 插件对接 R2
（一）安装 S3 插件

打开 PicGo 软件 → 插件管理 → 搜索 s3 并安装 PicGo-S3-Plugin（若已安装可跳过）。

（二）配置插件参数


进入 PicGo 图床设置 → 选择 S3 插件：

Bucket：填写创建的存储桶名称（如 blog-images）。
Region：填 auto（R2 不区分传统区域）。
Access Key ID：粘贴 Cloudflare 生成的 Access Key。
Secret Access Key：粘贴对应的 Secret Key。
Endpoint：粘贴存储桶端点（如 https://abc123.r2.cloudflarestorage.com）。
Path：自定义图片存储路径前缀（如 blog/，可留空）。
Custom Domain：填写自定义域名（如 img.soniachen.com，后续配置）。
SSL：勾选（启用 HTTPS 访问）。



点击 设为默认图床，并点击 确定 保存配置。


（三）测试上传

在 PicGo 主界面点击 上传图片，选择本地图片：

若上传成功，下方会显示图片 URL（如 https://img.soniachen.com/blog/test.jpg）。



三、绑定自定义域名（CDN 加速）
（一）添加域名到 Cloudflare

登录 Cloudflare 控制台 → 域名 → 添加域名：

输入自定义域名（如 img.soniachen.com），点击 继续。
等待 Cloudflare 扫描 DNS 记录（约 1 - 5 分钟）。



（二）配置 DNS 解析

在域名管理界面 → DNS 标签页：

添加一条 CNAME 记录：

名称：填 @ 或 img（根据域名结构）。
目标：填存储桶端点（如 abc123.r2.cloudflarestorage.com）。
代理状态：选择 DNS Only（仅解析，不启用 CDN）或 Proxied（启用 CDN 加速）。





（三）配置 R2 自定义域名

回到 R2 存储桶 → 域名 标签页：

点击 添加自定义域名，输入已添加到 Cloudflare 的域名（如 img.soniachen.com）。
Cloudflare 会自动生成 SSL 证书（等待约 10 分钟生效）。



四、Hexo 集成 R2 图床（可选）
（一）安装 Hexo 插件

在 Hexo 项目根目录执行：npm install hexo-s3-image --save


（二）配置插件

修改 _config.yml 添加以下配置：s3_image:
  bucket: blog-images          # 存储桶名称
  region: auto                 # 区域
  accessKeyId: your-access-key # 替换为实际 Access Key
  secretAccessKey: your-secret-key # 替换为实际 Secret Key
  endpoint: https://abc123.r2.cloudflarestorage.com # 端点
  path: blog/                  # 存储路径
  customUrl: https://img.soniachen.com # 自定义域名
  public: true                 # 公开访问


（三）使用方式

在 Markdown 中插入图片时，直接使用本地路径：![示例图片](/img/test.jpg)

Hexo 生成时会自动上传图片到 R2，并替换为在线链接。

五、常见问题与解决方案
（一）403 Forbidden 错误

原因：存储桶未启用公开访问或访问密钥错误。
解决：

存储桶 → 权限 → 确保 公开访问 已启用。
重新核对 Access Key 和 Secret Key 是否正确。



（二）图片链接返回 404

原因：域名解析错误或路径配置错误。
解决：

检查 DNS 解析是否生效（可通过 ping img.soniachen.com 验证）。
确认 PicGo 中 Custom Domain 与 Cloudflare 域名一致。



（三）上传失败（网络错误）

原因：Endpoint 填写错误或网络阻断。
解决：

存储桶详情页复制端点，确保无多余字符（如末尾空格）。
尝试更换网络环境（如关闭 VPN）。



六、进阶优化：缓存与安全
（一）设置缓存策略

Cloudflare 域名 → 规则 → 页面规则：

添加规则 https://img.soniachen.com/*，设置 缓存级别 为 缓存所有，TTL 为 1 天（根据需求调整）。



（二）启用防盗链

存储桶 → 权限 → 添加 Origin Access：

配置允许访问的域名（如 soniachen.com），拒绝其他域名盗用图片。



/opt/homebrew/bin/node /opt/homebrew/bin/picgo upload

五、博客部署（Git + GitHub Pages + CloudFlare ）
（一）GitHub 仓库准备

GitHub 新建仓库，命名规则：若为用户/组织页，仓库名填 你的GitHub用户名.github.io（如 soniachan33.github.io ）；若为项目页，仓库名自定义（后续需配置路径 ）。
仓库创建后，复制仓库的 Git 地址（SSH 或 HTTPS 形式 ）。

（二）Hexo 部署配置
修改博客根目录 _config.yml 的 deploy 配置：
deploy:
  type: git
  repo: git@github.com:你的GitHub用户名/你的仓库名.git  # 替换为实际仓库地址
  branch: main  # 部署分支，GitHub Pages 常用 main 或 gh-pages
安装 hexo-deployer-git 插件：
npm install hexo-deployer-git --save
（三）部署到 GitHub Pages
执行部署命令：
hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
Hexo 会把生成的静态文件（public 目录内容 ）推送到 GitHub 仓库对应分支，稍等片刻，访问 https://你的GitHub用户名.github.io（或项目页地址 ），能看到线上博客。
（四）CloudFlare 加速与配置

添加站点：CloudFlare 官网（https://www.cloudflare.com/ ）注册登录，添加站点（输入博客域名，若用 GitHub Pages 默认域名可跳过，若自定义域名需提前备案、解析 ）。
DNS 解析设置：添加 DNS 记录，将域名解析到 GitHub Pages 对应的 IP（或直接解析到 你的GitHub用户名.github.io  ），让 CloudFlare 接管 DNS 解析。
CDN 与安全配置：开启 CDN 加速，优化缓存、压缩等设置；启用安全防护（如 DDoS 防护、防火墙规则 ），提升博客访问速度与安全性。
自定义域名（可选）：若用自定义域名（如 soniachen.com  ），在 GitHub Pages 仓库设置中填自定义域名，同时在 CloudFlare 配置域名解析、SSL 证书（推荐开启 Full 或 Strict 模式 ），确保 HTTPS 访问正常。

六、博客优化与维护
（一）SEO 优化

站点地图（Sitemap ）：安装 hexo-generator-sitemap 插件，生成站点地图：npm install hexo-generator-sitemap --save
修改 _config.yml 配置：sitemap:
  path: sitemap.xml
部署后，通过 https://你的域名/sitemap.xml 访问，提交给百度、必应、谷歌等搜索引擎，助力收录。
Meta 标签与关键词：在主题配置或文章 Front-matter 中，设置标题、描述、关键词，让搜索引擎更好理解内容，提升搜索排名。

（二）持续更新与备份

内容更新：用 Typora 写新文章，存到 source/_posts 目录，执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署，持续输出优质内容。
版本备份：借助 Git，定期提交代码到 GitHub 仓库，记录博客配置、文章修改历史，方便回退与协同。

七、遇到的问题与解决（结合之前的疑问）
（一）GitHub Pages 部署后 404

原因：部署分支与 GitHub Pages 设置不一致、root 配置错误、CNAME 文件丢失等。
解决：确保 _config.yml 中 deploy 分支正确，用户页 root 设为 / ；在 Hexo 项目 source 目录添加 CNAME 文件（填自定义域名 ），重新部署。

（二）CloudFlare 部署后域名配置清空

原因：Hexo 部署覆盖 GitHub Pages 分支内容，CNAME 文件未同步。
解决：在 Hexo 项目 source 目录添加 CNAME 文件，内容填自定义域名，部署时同步到 GitHub 仓库，CloudFlare 配置就会保留。

（三）必应收录验证问题

方法：通过 XML 文件（下载 BingSiteAuth.xml 放 Hexo source 目录，部署后验证 ）、HTML Meta 标记（添加到博客首页 &lt;head&gt;  ）、DNS CNAME 记录（域名解析后台添加 ）完成验证，提交站点地图，让博客在必应搜索可见。

八、总结
从工具安装、Hexo 初始化，到内容创作、部署上线，再到用 CloudFlare 加速、优化 SEO ，整个流程虽有波折，但一步步搭建出专属博客，成就感满满。这五个工具相互配合，让博客从本地走向公网，成为展示自我的窗口。未来，继续用它们更新内容、优化体验，让博客持续生长～
附录：关键命令与配置汇总，方便速查：

Hexo 常用命令：hexo clean、hexo g、hexo s、hexo d 。
Git 配置与部署：git config、hexo-deployer-git 插件配置。
CloudFlare 核心操作：DNS 解析、CDN 加速、SSL 配置。
PicGo + Typora 图床写作：Typora 上传图片设置、PicGo 图床配置。

希望这篇复盘能帮到想搭建博客的你，一起用技术记录生活、分享世界～
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>CloudFlare</tag>
        <tag>Git</tag>
        <tag>Typora</tag>
        <tag>PicGo</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB3-Day7—Solidity基础[part6]</title>
    <url>/2025/07/04/WEB3-Day7%E2%80%94Solidity%E5%9F%BA%E7%A1%80-part6/</url>
    <content><![CDATA[WEB3-Day7—Solidity基础[part6]
变量优化
优化仅设置一次的变量的燃气消耗（gas usage）
变量 owner 和 minimumUSD 仅设置一次且永不改变：owner 在合约创建时赋值，minimumUSD 在合约初始化时设定。
评估 FundMe 合约
我们可以通过部署合约并在终端中观察交易来评估创建合约所需的燃气量。在原始合约配置中，我们消耗了近 859,000 单位燃气。
常量（Constant）
为减少燃气消耗，我们可以使用 constant 和 immutable 关键字。这些关键字确保变量值保持不变。更多信息可参考 Solidity 文档。
对于仅赋值一次且永不改变的变量，我们可以应用这些关键字。
对于编译时已知的值，使用 constant 关键字。它会避免变量占用存储槽位，从而使读取更便宜、更快速。
使用 constant 关键字可节省约 19,000 单位燃气，这接近在两个账户之间发送 ETH 的成本。

📝 注意：
constant 变量的命名约定为全大写并以下划线分隔（例如 MINIMUM_USD）。


⚠️ 警告：
将当前 ETH 燃气成本转换为美元时可见，当 ETH 价格为 3000 美元时，将 MINIMUM_USD 定义为常量需花费 9 美元，比其公开变量（public）的等效实现多近 1 美元。

不可变（Immutable）
constant 变量适用于编译时已知的值，而 immutable 适用于部署时设置且不再改变的变量。immutable 变量的命名约定是在变量名前添加前缀 i_（例如 i_owner）。
将 owner 设为 immutable 变量后，观察到其燃气节省效果与 constant 关键字类似。

💡 提示：
在学习的早期阶段，不必过于关注燃气优化。先保证合约能够完整写出来先。

自定义错误
需求检查（Require）
提升燃气效率的一种方式是优化 require 语句。当前，require 语句强制我们存储字符串 'sender is not an owner'，该字符串中的每个字符都会单独存储，导致管理逻辑复杂且成本高昂。
自定义错误（Custom Errors）
自 Solidity 0.8.4 版本引入的自定义错误可用于 revert 语句中。这些错误需在代码顶部声明，并在 if 语句中使用。相较于之前的错误消息字符串，调用更轻量的错误代码可降低燃气成本。
我们可以先创建一个自定义错误：
error NotOwner();
然后用 if 语句替换 require 函数，并通过 revert 调用新创建的错误：
if (msg.sender != i_owner) &#123;
    revert NotOwner();
&#125;
通过实现自定义错误，我们既能降低燃气消耗，又能简化智能合约中的错误处理。
结论
本节课中，我们学习了如何通过使用自定义错误替代传统含字符串的 require 语句，进一步优化 Solidity 合约的燃气效率。
receive和fallback函数
receive和fallback是特殊函数，当用户直接向合约发送以太币或调用不存在的函数时会触发。这些函数不返回任何值，且必须声明为external。
为了说明这一点，我们创建一个简单的合约：
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract FallbackExample &#123;
    uint256 public result;

    receive() external payable &#123;
        result = 1;
    &#125;

    fallback() external payable &#123;
        result = 2;
    &#125;
&#125;
在这个合约中，result初始化为0。当以太币发送到合约时，receive函数会被触发，将result设为1。如果交易包含数据但指定的函数不存在，则会触发fallback函数，将result设为2。
如需全面解释，请参考SolidityByExample。
发送以太币的逻辑流程
向合约发送以太币
        |
        ↓
    msg.data为空吗？
      &#x2F;        \
     是          否
    &#x2F;            \
  receive()存在？   fallback()
    &#x2F;      \
   是        否
  &#x2F;          \
receive()     fallback()
向fundMe合约发送以太币
当用户直接向fundMe合约发送以太币而不调用fund函数时，可以使用receive函数将交易重定向到fund函数：
receive() external payable &#123;
    fund();
&#125;

fallback() external payable &#123;
    fund();
&#125;
要测试此功能，可使用MetaMask向fundMe合约发送一些Sepolia测试网以太币。此时并未直接调用fund函数，但receive函数会触发它。确认交易后，检查funders数组，会发现其已更新，表明receive函数成功调用了fund函数。
这种方法确保所有交易按预期处理。尽管直接调用fund函数消耗的Gas更少，但此方法能确保用户的贡献被正确确认和记录。
]]></content>
      <categories>
        <category>Web3</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>算法高频题总结</title>
    <url>/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[高频题
三数之和
两数之和为基础

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

// 1 先将数组排序
  // 2 从后往前遍历最后一个数 找对应的二元组：二元组 + arr[i] = 0
  // 2.1 保证不重复
  // 2.2 找出前面部分满足条件的二元组
  // 2.3 遍历将arr[i]添加在后面
  public static List&lt;List&lt;Integer>> threeSum(int[] nums) &#123;
      // 1
      Arrays.sort(nums);
      int N = nums.length;
      List&lt;List&lt;Integer>> ans = new ArrayList&lt;>();
      // 2
      for (int i = N - 1; i > 1; i--) &#123; // 三元组最后一个数，是arr[i]   之前....二元组 + arr[i]
          // 2.1
          if (i == N - 1 || nums[i] != nums[i + 1]) &#123;
              // 2.2
              List&lt;List&lt;Integer>> nexts = twoSum(nums, i - 1, -nums[i]);
              // 2.3
              for (List&lt;Integer> cur : nexts) &#123;
                  cur.add(nums[i]);
                  ans.add(cur);
              &#125;
          &#125;
      &#125;
      return ans;
  &#125;

  // nums[0...end]这个范围上，有多少个不同二元组，相加==target，全返回
  // &#123;-1,5&#125;     K = 4
  // &#123;1, 3&#125;
  // 1 两个指针
  // 2 两数相加大于目标值就右缩;小于就左缩;等于就添加在结果集里面（先加左再加右）
  public static List&lt;List&lt;Integer>> twoSum(int[] nums, int end, int target) &#123;
      int L = 0;
      int R = end;
      List&lt;List&lt;Integer>> ans = new ArrayList&lt;>();
      while (L &lt; R) &#123;
          if (nums[L] + nums[R] > target) &#123;
              R--;
          &#125; else if (nums[L] + nums[R] &lt; target) &#123;
              L++;
          &#125; else &#123; // nums[L] + nums[R] == target
              if (L == 0 || nums[L - 1] != nums[L]) &#123;
                  List&lt;Integer> cur = new ArrayList&lt;>();
                  cur.add(nums[L]);
                  cur.add(nums[R]);
                  ans.add(cur);
              &#125;
              L++;
          &#125;
      &#125;
      return ans;
  &#125;
两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。

1 使用hashmap 结构 map.put(nums[i], i)
2 遍历一遍 如果查询到map里面有与解 就返回i和mapget的value
3 最后如果没有找到就返回new int[0]
class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
        HashMap&lt;Integer, Integer> map = new HashMap&lt;>();
        for(int i = 0; i &lt; nums.length; i ++)&#123;
            if(map.containsKey(target - nums[i]))&#123;
                return new int[]&#123;i, map.get(target - nums[i])&#125;;
            &#125;
            map.put(nums[i], i);
        &#125;
        return new int[0];
    &#125;
&#125;
搜索旋转排序数组（面试）
使用二分查找

整数数组nums按升序排列，数组中的值互不相同。
arr，原本是有序数组，旋转过，而且左部分长度不知道.(以某一个下标为轴旋转 例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。)
题目需要在arr里面找到target

思路：

L = M = R 是最差的情况 不知道断点
L != M == R/ L == M != R/ L != M != R 只要三个数不全部一样就可以进行二分


public int search(int[] nums, int target) &#123;
		int N = nums.length;
		int L = 0;
		int R = N - 1;
		while (L &lt;= R) &#123;
			int M = (L + R) / 2;
			if (nums[M] == target) &#123;
				return M;
			&#125;
			// nums[M] != target
			// 1 左 中 右 相等 -- 》不能二分
			if (nums[L] == nums[M] &amp;&amp; nums[M] == nums[R]) &#123;
				// 左中一直相等 L ++
				while (L != M &amp;&amp; nums[L] == nums[M]) &#123;
					L++;
				&#125;
				// 1.1 左中直到重合都相等
				if (L == M) &#123;
					L = M + 1;
					continue;// 回到循环开始重新来
				&#125;
				// 1.2 或者是 到不相等地方 继续2

			&#125;
			// 2 左中右不都相等 --> 代表可以二分
			if (nums[L] != nums[M]) &#123; // 2.1 [L] != [M] ?= [R]
				if (nums[L] &lt; nums[M]) &#123;// 2.1.1 L &lt; M 左边一定有序
					if (nums[L] &lt;= target &amp;&amp; target &lt; nums[M]) &#123;
						R = M - 1;
					&#125; else &#123;
						L = M + 1;
					&#125;
				&#125; else &#123; // 2.1.2 L > M 左边一定有断点 右边有序
					if (nums[M] &lt; target &amp;&amp; target &lt;= nums[R]) &#123;
						L = M + 1;
					&#125; else &#123;
						R = M - 1;
					&#125;
				&#125;
			&#125; else &#123;// 2.2 [L] ?= [M] != [R]
				if (nums[M] &lt; nums[R]) &#123;// 2.2.1 M &lt; R
					if (nums[M] &lt; target &amp;&amp; target &lt;= nums[R]) &#123;
						L = M + 1;
					&#125; else &#123;
						R = M - 1;
					&#125;
				&#125; else &#123; // 2.1.2 M > R
					if (nums[L] &lt;= target &amp;&amp; target &lt; nums[M]) &#123;
						R = M - 1;
					&#125; else &#123;
						L = M + 1;
					&#125;
				&#125;
			&#125;

		&#125;
		return -1;
	&#125;
合并两个有序数组

给你两个有序数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。进行合并。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

public void merge(int[] nums1, int m, int[] nums2, int n) &#123;
        int index = nums1.length;
       while(m > 0 &amp;&amp; n > 0) &#123; // 相等的时候先拷贝长数组的  尽可能让空间早释放
            if(nums1[m - 1] >= nums2[n -1])&#123;
                nums1[--index] = nums1[--m];
            &#125; else &#123;
                nums1[--index] = nums2[--n];
            &#125;
        &#125;   
        while(n > 0) &#123;// m都被填完 就把nums2剩下的n填进nums1
            nums1[--index] = nums2[--n];
        &#125;
    &#125;
螺旋矩阵

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。


public List&lt;Integer> spiralOrder(int[][] matrix) &#123;
	List&lt;Integer> order = new ArrayList&lt;>();
	if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
		return order;
	&#125;
	int left = 0;
	int top = 0;
	// 易错点一：注意right和bottom别写反了。
	int right = matrix[0].length - 1;
	int bottom = matrix.length - 1;
	while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;
		// 上层：从左到右，行不变，列变。
		for (int i = left; i &lt;= right; i++) &#123;
			order.add(matrix[top][i]);
		&#125;
		// 右层：从上到下，行变，列不变。
		for (int i = top + 1; i &lt;= bottom; i++) &#123;
			order.add(matrix[i][right]);
		&#125;
		// 易错点二：注意针对行列不相等时，下面两个循环要满足right > left &amp;&amp; bottom > top条件 ⚠️
		if (right > left &amp;&amp; bottom > top) &#123;
			// 下层：从右向左，行不变，列变。
			for (int i = right - 1; i >= left; i--) &#123;
				order.add(matrix[bottom][i]);
			&#125;
			// 左层：从下到上，行变，列不变。
			// 易错点三：此处只需要 i>top, i不能=top
			for (int i = bottom - 1; i > top; i--) &#123;
				order.add(matrix[i][left]);
			&#125;
		&#125;

		left++;
		top++;
		right--;
		bottom--;
	&#125;
	return order;
&#125;
字符串相加

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。
你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

public String addStrings2(String num1, String num2) &#123;
	int i = num1.length() - 1, j = num2.length() - 1, add = 0;
	StringBuffer ans = new StringBuffer();
	while (i >= 0 || j >= 0 || add != 0) &#123;
		int x = i >= 0 ? num1.charAt(i) - '0' : 0;
		int y = j >= 0 ? num2.charAt(j) - '0' : 0;
		int result = x + y + add;
		ans.append(result % 10);
		add = result / 10;
		i--;
		j--;
	&#125;
	// 计算完以后的答案需要翻转过来
	ans.reverse();
	return ans.toString();
&#125;
二分查找
public int search(int[] nums, int target) &#123;
        int L = 0;
        int R = nums.length - 1;
        while(L &lt; R)&#123; // ⚠️ 没有相等
            int mid = (L + R) >> 1;
            if(target &lt; nums[mid])&#123;
                R = mid - 1;
            &#125; else if(target > nums[mid])&#123;
                L = mid + 1;
            &#125; else&#123;
                return mid;
            &#125; 
        &#125;
        return (nums[L] == target) ? L : -1;
    &#125;
在排序数组中找到元素第一个和最后一个位置
/**
 * 在排序数组中查找元素的第一个和最后一个位置
 * @author chs
 *
 */
public class Fre_044_FindFirstAndLastPositionOfElementInSortedArray &#123;
	// 借助二分 《找到数组中比它小的最右的数 (lessMostRight
	// 如果该位置右边!=target说明数组没有这个数
	// 如果是 那么左边界找到 右边界就是《找到比ta+1小的最右的数》 (lessMostRight
	public static int[] searchRange(int[] nums, int target) &#123;
		if (nums == null || nums.length == 0) &#123;
			return new int[] &#123; -1, -1 &#125;;
		&#125;
		int L = lessMostRight(nums, target) + 1;
		if (L == nums.length || nums[L] != target) &#123;
			return new int[] &#123; -1, -1 &#125;;
		&#125;
		return new int[] &#123; L, lessMostRight(nums, target + 1) &#125;;
	&#125;

	// 利用二分 
	// 1 一个指针 M
	// 2 ans存放结果
	// 3 arr[M] 小于就去右边找 大于就去左边找
	public static int lessMostRight(int[] arr, int num) &#123;
		int L = 0;
		int R = arr.length - 1;
		// 1
		int M = 0;
		// 2 
		int ans = -1;
		// 3
		while (L &lt;= R) &#123;
			M = L + ((R - L) >> 1);
			if (arr[M] &lt; num) &#123;
				ans = M;
				L = M + 1;
			&#125; else &#123;
				R = M - 1;
			&#125;
		&#125;
		return ans;
	&#125;
&#125;

字符串转化整数
注意有很多特殊情况

1.需要删除无用的前导空格
2.检查下一个字符为正还是负
3.只读一开始是数字的部分


4.超出范围的数字返回边界

1. 主函数myAtoi():
     1 除去空格和后面非数字的部分( 前后都要判空)【removeHeadZero()】
     2 判断该部分是否是有效数字【isValid()】
     3 转为负数形式（转回不会溢出，负数范围大些） posi(标志正负)
     4 res是最负的情况 (用了负数就只用可以装下，如果用整数转，最小就没法装)
2. removeHeadZero():
     1 是否有符号
     2 s标志第一个不是零的位置
     3 e标志数字部分后面的非数字部分的开头
     4 返回截取的带符号整数部分
3. isVaild():    判断带符号整数部分是否有效
     1 开头在remove部分没有判断，只要开头不是数字和符号都返回无效
     2 只有符号也无效
     3 夹杂着非数字字符也无效
public class Fre_072_StringToInteger &#123;
  public int myAtoi(String s) &#123;
        // 1 除去空格和后面不是数字的部分
        if(s == null || s.equals(""))&#123;// ⚠️
            return 0;
        &#125;
        s = removeHeadZero(s.trim());
        if(s == null || s.equals(""))&#123;
            return 0;
        &#125;

        // 2 判断这部分是不是有效数字
        char[] str = s.toCharArray();
        if(!isValid(str))&#123;
            return 0;
        &#125;

        // 3 转为负数形式 为了防止溢出 posi(标志正负) ⚠️不要搞反了
        boolean posi = str[0] == '-' ? false : true;
        // 后面会有*10的操作 需要先判断会不会溢出
        int minq = Integer.MIN_VALUE / 10;
        int minp = Integer.MIN_VALUE % 10;
        int res = 0;
        int cur = 0;
        for(int i = (str[0] == '-' || str[0] == '+') ? 1 : 0; i &lt; str.length; i++)&#123;
            cur = '0' - str[i]; // 转为负数
            // 在乘十之前判断是否会溢出
            if(res &lt; minq || (res == minq &amp;&amp; cur &lt; minp))&#123;
                	return posi ? Integer.MAX_VALUE : Integer.MIN_VALUE; 
            &#125;
            res = res * 10 + cur;

        &#125;

        // 4 res是最负情况（也就是本来是最大的+1）
        if(posi &amp;&amp; (res == Integer.MIN_VALUE))&#123;
            return Integer.MAX_VALUE; // 返回边界
        &#125;

        return posi ? -res : res;
    &#125;

    public static String removeHeadZero(String s)&#123;
        // 1 是否有符号
        boolean r = (s.startsWith("+") || s.startsWith("-")); // ⚠️ 不能用charat

        // 2 标志第一个不是零的位置
        int start = r ? 1 : 0;
        for(; start&lt; s.length(); start++)&#123;
            if(s.charAt(start) != '0')&#123;
                break;
            &#125;
        &#125;

        // 3 找到数字部分后面的非数组部分开头 倒着遍历
        int e = -1;
        for(int i = s.length() - 1; i >= (r ? 1 : 0); i--)&#123;
            if(s.charAt(i) &lt; '0'  || s.charAt(i) > '9') &#123;
                e = i;
            &#125;
        &#125;

        // 4 返回截取的带符号的整数部分
        return (r ? String.valueOf(s.charAt(0)): "") + s.substring(start, e == -1 ? s.length() : e);
    &#125;

    // 判断是否是有效的数字
    public static boolean isValid(char[] str) &#123;
        // 1 如果开头不是数组
        if(str[0] != '-' &amp;&amp; str[0] != '+' &amp;&amp; (str[0] &lt; '0' || str[0] > '9'))&#123;
            return false;
        &#125;
        // 2 只有符号也无效
        if((str[0] == '-' || str[0] == '+') &amp;&amp; str.length == 1)&#123;
            return false;
        &#125;
        // 3 夹杂着非数字字符 无效
        for(int i = 1; i &lt; str.length; i++)&#123;
            if(str[i] &lt;'0' || str[i] > '9')&#123;
                return false;
            &#125;
        &#125;
        return true;

    &#125;

	&#125;
下一个排列

给你一个整数数组 nums ，找出 nums 的字典序中的下一个排列。
例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
必须 原地 修改，只允许使用额外常数空间。

public void nextPermutation(int[] nums) &#123;
       int i = nums.length - 2;
       // 1 倒着找升序对 [ i , i+ 1]
       while(i >= 0 &amp;&amp; nums[i] >= nums[i + 1]) &#123;
           i--;
       &#125;
       // 2 从end -> i+1 倒着找比i大的数
       if(i >= 0)&#123;
           int j = nums.length - 1;
           while(nums[i] >= nums[j])&#123;
               j--;
           &#125;
           swap(nums, i, j);
       &#125;
       // 3 将数组i+1以后的反转
       // 因为有两种情况：1） i&lt; 0 说明本身就是字典序最大，直接翻转 2）[i+1, end]是降序需要翻转
       reverse(nums, i + 1);
   &#125;
   public static void reverse(int[] nums, int i)&#123;
       int left = i;
       int right =  nums.length - 1;
       while(left &lt; right)&#123;
           swap(nums, left, right);
           left++;
           right--;
       &#125;
   &#125;

   public static void swap(int[] nums, int i, int j)&#123;
       int tmp = nums[i];
       nums[i] = nums[j];
       nums[j] = tmp;
   &#125;
合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。


s 和 e 记录上一个区间的边界
然后复用interval数组来存储，最后复制数组size部分

class Solution &#123;
    public int[][] merge(int[][] intervals) &#123;
        	if (intervals.length == 0) &#123;
			return new int[0][0];
		&#125;
    // 先按照区间的左边界来排序
		Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
		int s = intervals[0][0];
		int e = intervals[0][1];// 
		int size = 0;
    // 然后复用interval数组来存储，最后复制数组size部分
		for (int i = 1; i &lt; intervals.length; i++) &#123;
			if (intervals[i][0] > e) &#123;// 如果当前左边界大于e 说明没有覆盖 
				intervals[size][0] = s;// 可以更新size部分的s和e 然后size++
				intervals[size++][1] = e;
				s = intervals[i][0];
				e = intervals[i][1];// s e 更新为当前的左右边界
			&#125; else &#123;
				e = Math.max(e, intervals[i][1]); // 如果当前左边界小于或者等于 说明两个区间可以覆盖 先将e更新为这两个区间的最大右区间
			&#125;
		&#125;
		intervals[size][0] = s; // 最后还有一次size处的更新
		intervals[size++][1] = e;
		return Arrays.copyOf(intervals, size);
    &#125;
&#125;
x的平方根
==二分查找==

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

1. 使用 二分 &lt;&#x3D;就更新ans和L 到右边就更新R
2. 注意数据类型时long主要是为了两个整型相乘不会溢出
// x一定非负，输入可以保证
    public static int mySqrt(int x) &#123;
        if (x == 0) &#123;
            return 0;
        &#125;
        if (x &lt; 3) &#123;
            return 1;
        &#125;
        // x >= 3
        long ans = 1;
        long L = 1;
        long R = x;
        long M = 0;
        while (L &lt;= R) &#123;
            M = (L + R) / 2;
            // 因为两个整数相乘可能会溢出
            if (M * M &lt;= x) &#123;
                ans = M;
                L = M + 1;
            &#125; else &#123;
                R = M - 1;
            &#125;
        &#125;
        return (int) ans;
    &#125;
扩展：求出小数点后k位 其实思路与一样 只是换成double类型并且需要转换数格式
缺失的正数

给你一个未排序的整数数组，请你找出没有出现的最小的正整数 时间复杂度o(n)

除了打标记以外，我们还可以使用置换的方法，将给定的数组「恢复」成下面的形式：
如果数组中包含 x∈[1,N]x \in [1, N]x∈[1,N]，那么恢复后，数组的第 x−1x - 1x−1 个元素为 xxx。

在恢复后，数组应当有 [1, 2, …, N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以题目中的示例二 [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 2。
public int firstMissingPositive(int[] nums) &#123;
        int n = nums.length;
        for (int i = 0; i &lt; n; ++i) &#123;
            while (nums[i] > 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) &#123; 
              // ⚠️交换的条件---nums[i]∈[1,N] 且 nums[i]和本来应该在的位置的值nums[nums[i]-1]不相等
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            &#125;
        &#125;
        for (int i = 0; i &lt; n; ++i) &#123;
            if (nums[i] != i + 1) &#123;
                return i + 1;
            &#125;
        &#125;
        return n + 1;
    &#125;
用rand7()生成rand10()

用一个不等概率返回0和1的函数, 怎么加工一个函数0和1等概率返回

public int rand10() &#123;
       int ans= 0;
       do&#123;
           ans = f2();
       &#125;while(ans >9);
       return ans + 1 ;
   &#125;
   public int f() &#123;
       int ans= 0;
       do&#123;
           ans = rand7();
       &#125;while(ans == 4);
       return ans &lt; 4? 0:1;
   &#125;

   // 0000~1111 0~15
   public int f2() &#123;
       return (f() &lt;&lt; 3) + (f() &lt;&lt; 2) + (f() &lt;&lt; 1 )+ f();
   &#125;
找到两个有序数组的中位数(⚠️)/两个有序数组第k小
public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;
        //这里就主要处理 两个为空 一个为空 全不为空的三个情况
        int size = nums1.length + nums2.length;
        boolean e = (size &amp; 1) == 0;
        if(nums1.length == 0 &amp;&amp; nums2.length == 0) &#123;
            return 0;
        &#125;else if(nums1.length == 0)&#123;
            if(!e)&#123;
                return nums2[size/ 2];                   
            &#125;else&#123;
                return (double)(nums2[ size / 2- 1] + nums2[size / 2 ])/2;
            &#125;
        &#125;else if(nums2.length == 0)&#123;
            if(!e)&#123;
                return nums1[size/ 2];
            &#125;else&#123;
                return (double)(nums1[size / 2 - 1] + nums1[size / 2])/2;
            &#125;
        &#125;else&#123;
            if(!e)&#123;
                return findKthNum(nums1, nums2, size / 2 + 1);
            &#125;else&#123;
                return (double)(findKthNum(nums1, nums2, size/2)+findKthNum(nums1, nums2, size/2 +1))/2D;
            &#125;
        &#125;

    //原型
    public static int getUpMedian(int[] arr1, int s1,int e1,int[] arr2, int s2, int e2)&#123;
        int mid1 = 0;
        int mid2 = 0;
        while(s1 &lt; e1)&#123;
            //mid
            mid1 = (e1 + s1) >> 1;
            mid2 = (e2 + s2) >> 1;
            if(arr1[mid1] == arr2[mid2] ) return arr1[mid1];
            //奇数
            if(((e1 - s1 + 1) &amp; 1) == 1)&#123;
                if(arr1[mid1] &lt; arr2[mid2])&#123;
                    if(arr1[mid1] >= arr2[mid2 - 1]) return arr1[mid1];
                    s1 = mid1 + 1;
                    e2 = mid2 - 1;
                &#125;else&#123;
                    if(arr2[mid2] >= arr1[mid1 - 1]) return arr2[mid2];
                    s2 = mid2 + 1;
                    e1 = mid1 - 1;
                &#125;
            &#125;
            //偶数
            else&#123;
                if(arr1[mid1] > arr2[mid2])&#123;
                    e1 = mid1;
                    s2 = mid2 + 1;
                &#125;else&#123;
                    e2 = mid2;
                    s1 = mid1 + 1;
                &#125;
            &#125;
        &#125;
        //最后跳出循环 都只剩一个数
        return Math.min(arr1[s1], arr2[s2]);
    &#125;



    //处理长度不同 返回Kth的情况
    public static int findKthNum(int[] arr1, int[] arr2, int k)&#123;
        int[] longs = arr1.length >= arr2.length ? arr1 : arr2;
        int[] shorts = arr1.length &lt; arr2.length ? arr1 : arr2;
        int l = longs.length;
        int s = shorts.length;
        //1
        if(k &lt;= s)&#123;
            return getUpMedian(longs, 0, k - 1, shorts, 0, k - 1);
        &#125;
        //2
        if(k > l)&#123;
            if(longs[k - s - 1] >= shorts[s - 1])&#123;
                return longs[k - s -1];
            &#125;
            if(shorts[k - l - 1] >= longs[l - 1])&#123;
                return shorts[k - l - 1];
            &#125;
            return getUpMedian(longs, k - s, l - 1, shorts, k - l, s - 1);
        &#125;
        //3
        if(longs[k - s - 1] >= shorts[s - 1])&#123;
            return longs[k - s - 1];
        &#125;
        return getUpMedian(longs, k - s, k - 1,shorts, 0 ,s - 1);
    &#125;


翻转字符串中的单词

给你一个字符串 s ，逐个翻转字符串中的所有 单词 。
单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。
说明：
输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。
示例 1：
输入：s = “the sky is blue”
输出：“blue is sky the”
示例 2：
输入：s = &quot;  hello world  &quot;
输出：“world hello”
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。

思路:

去除多余的空白：
(1去掉字符串开头的空白字符
(2去掉字符串末尾的空白字符
(3将字符串间多余的空白字符去除
翻转字符串：
翻转每一个单词：
(1 遍历sb 使用start 和 end来抓单词
(2 翻转单词
(3 更新start，去找下一个单词

// 1 去除多余的空白
    // 2 翻转字符串
    // 3 翻转每一个单词
    public String reverseWords(String s) &#123;
        // 1
        StringBuilder sb = trimSpaces(s);

        // 2
        reverse(sb, 0, sb.length() - 1);

        // 3
        reverseEachWord(sb);

        return sb.toString();
    &#125;

    // 1 去掉字符串开头的空白字符
    // 2 去掉字符串末尾的空白字符
    // 3 将字符串间多余的空白字符去除
    public StringBuilder trimSpaces(String s) &#123;
        int left = 0, right = s.length() - 1;
        // 1 
        while (left &lt;= right &amp;&amp; s.charAt(left) == ' ') &#123;
            ++left;
        &#125;

        // 2
        while (left &lt;= right &amp;&amp; s.charAt(right) == ' ') &#123;
            --right;
        &#125;

        // 3
        StringBuilder sb = new StringBuilder();
        while (left &lt;= right) &#123;
            char c = s.charAt(left);

            if (c != ' ') &#123;
                sb.append(c);
            &#125; else if (sb.charAt(sb.length() - 1) != ' ') &#123;
                sb.append(c);
            &#125;

            ++left;
        &#125;
        return sb;
    &#125;

    // 翻转任意字符
    public void reverse(StringBuilder sb, int left, int right) &#123;
        while (left &lt; right) &#123;
            char tmp = sb.charAt(left);
            sb.setCharAt(left++, sb.charAt(right));
            sb.setCharAt(right--, tmp);
        &#125;
    &#125;


    public void reverseEachWord(StringBuilder sb) &#123;
        int n = sb.length();
        int start = 0, end = 0;

        // 1 遍历sb 使用start 和 end来抓单词
        // 2 翻转单词
        // 3 更新start，去找下一个单词
        while (start &lt; n) &#123;
            // 1
            while (end &lt; n &amp;&amp; sb.charAt(end) != ' ') &#123;
                ++end;
            &#125;
            // 2
            reverse(sb, start, end - 1);
            // 3
            start = end + 1;
            ++end;
        &#125;
    &#125;
字符串相乘

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。
示例 1:
输入: num1 = “2”, num2 = “3”
输出: “6”
示例 2:
输入: num1 = “123”, num2 = “456”
输出: “56088”

public String multiply(String num1, String num2) &#123;
        if (num1.equals("0") || num2.equals("0")) &#123;
            return "0";
        &#125;
        int m = num1.length(), n = num2.length();
        int[] ansArr = new int[m + n];
        for (int i = m - 1; i >= 0; i--) &#123;
            int x = num1.charAt(i) - '0';
            for (int j = n - 1; j >= 0; j--) &#123;
                int y = num2.charAt(j) - '0';
                ansArr[i + j + 1] += x * y;
            &#125;
        &#125;
        for (int i = m + n - 1; i > 0; i--) &#123;
            ansArr[i - 1] += ansArr[i] /10;
            ansArr[i] %= 10;
        &#125;
        int index = ansArr[0] == 0 ? 1 : 0;
        StringBuffer ans = new StringBuffer();
        while (index &lt; m + n) &#123;
            ans.append(ansArr[index]);
            index++;
        &#125;
        return ans.toString();
    &#125;
删除数组中的重复项
任何删除重复的都可以用快慢指针
/**
 * 删除有序数组中的重复项
 * @author chs
 * 任何删除重复的都可以用快慢指针
 */
public class Fre_017_RemoveDuplicatesFromSortedArray &#123;
	public static int removeDuplicates(int[] nums) &#123;
		if (nums == null) &#123;
			return 0;
		&#125;
		
		if (nums.length &lt; 2) &#123;
			return nums.length;
		&#125;
		int done = 0;
		for (int i = 1; i &lt; nums.length; i++) &#123;
			if (nums[i] != nums[done]) &#123;
				nums[++done] = nums[i];
			&#125;
		&#125;
		return done + 1;
	&#125;
&#125;
去除重复字母
贪心➕单调栈？

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。
示例 1：
输入：s = “bcabc”
输出：“abc”
示例 2：
输入：s = “cbacdcbc”
输出：“acdb”

public String removeDuplicateLetters(String s) &#123;
       boolean[] vis = new boolean[26];
       int[] num = new int[26];
       for (int i = 0; i &lt; s.length(); i++) &#123;
           num[s.charAt(i) - 'a']++;
       &#125;

       StringBuffer sb = new StringBuffer();
       for (int i = 0; i &lt; s.length(); i++) &#123;
           char ch = s.charAt(i);
           if (!vis[ch - 'a']) &#123;
               while (sb.length() > 0 &amp;&amp; sb.charAt(sb.length() - 1) > ch) &#123;
                   if (num[sb.charAt(sb.length() - 1) - 'a'] > 0) &#123;
                       vis[sb.charAt(sb.length() - 1) - 'a'] = false;
                       sb.deleteCharAt(sb.length() - 1);
                   &#125; else &#123;
                       break;
                   &#125;
               &#125;
               vis[ch - 'a'] = true;
               sb.append(ch);
           &#125;
           num[ch - 'a'] -= 1;
       &#125;
       return sb.toString();
   &#125;
单词搜索

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。


public void rotate(int[][] matrix) &#123;
        int a = 0;
        int b = 0;
        int c = matrix.length - 1;
        int d = matrix[0].length - 1;
        while(a &lt; c) &#123;
            rotateEdge(matrix, a++, b++, c--, d--);
        &#125;
    &#125;

    public static void rotateEdge(int[][] m, int a, int b, int c, int d) &#123;
        int tmp = 0;
        for (int i = 0; i &lt; d - b; i++) &#123;
            tmp = m[a][b + i];
            m[a][b + i] = m[c - i][b];
            m[c - i][b] = m[c][d - i];
            m[c][d - i] = m[a + i][d];
            m[a + i][d] = tmp;
        &#125;
    &#125;
多数元素

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
是一个超级水王问题
1遍历 使用 candidate和HP 来一次删除两个不同的数
2到最后 HP 不为0 则说明可能有水王 是当前的candidate
3再遍历一次找candi 如果 HP&gt; n&#x2F;2 说明就是水王 


public int majorityElement(int[] nums) &#123;

        if(nums == null) &#123;
            return -1;
        &#125;
        int n = nums.length;
        int candi = 0;
        int HP = 0;
        for(int i  = 0; i &lt; n; i++) &#123;
            if(HP == 0) &#123;
                candi = nums[i];
                HP++;
            &#125;else if( nums[i] != candi) &#123;
                HP--;
            &#125;else &#123;
                HP++;
            &#125;
        &#125;
        if(HP == 0) &#123;
            return -1;
        &#125;
        HP = 0;
        for(int i = 0; i &lt; n ; i++) &#123;
            if(nums[i] == candi) &#123;
                HP++;
            &#125;
        &#125;
        if(HP > n / 2) &#123;
            return candi;
        &#125; else &#123;
            return -1;
        &#125;
    &#125;
&#125;
1 链表
1 反转链表
public ListNode reverseList(ListNode head) &#123;
      ListNode pre = null;
      ListNode cur = head;
      while(cur != null) &#123;
          ListNode next = cur.next;
          cur.next = pre;
          pre = cur;
          cur = next;
      &#125;
      return pre;// ！返回的是pre
  &#125;
反转链表二

就是反转链表中间一截

// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
// 第 3 步：切断出一个子链表（截取链表）先标记再切断
// 第 4 步：[同反转链表](##1 反转链表##)，反转链表的子区间
// 第 5 步：接回到原来的链表中
public ListNode reverseBetween(ListNode head, int left, int right) &#123;
        //1 需要一个虚拟头
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;

        //2 先找到反转部分的left前面pre
        ListNode pre = dummyNode;
        for(int i = 0; i &lt; left - 1;i++) &#123;
            pre = pre.next;
        &#125;

        //2 从pre再走right - left + 1步 来到right节点
        ListNode rNode = pre;
        for(int i = 0; i &lt; right - left + 1;i++) &#123;
            rNode = rNode.next;
        &#125;

        //3 切断这部分的链表
        ListNode lNode = pre.next;
        ListNode end = rNode.next;
        pre.next = null;
        rNode.next = null;

        //4 反转区间内的链表
        reverseLinkedList(lNode);

        //5 接回去
        pre.next = rNode;// ⚠️接回去的时候已经是反过来了
        lNode.next = end;
        return dummyNode.next;
    &#125;

    private void reverseLinkedList(ListNode head) &#123;
        ListNode pre = null;
        ListNode cur = head;

        while (cur != null) &#123;
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        &#125;
    &#125;

2 LRU缓存机制

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
函数 get 和 put 必0须以 O(1) 的平均时间复杂度运行。

			
1) 总的缓存结构 和方法调用
构造方法
private MyCache&lt;Integer, Integer> cache;
	public Fre_278_LRUCache(int capacity)&#123;
		cache = new MyCache&lt;>(capacity);
	&#125;
	
1 get()
public int get(int key) &#123;
		Integer ans = cache.get(key);
		return ans == null ? -1 : ans;
	&#125;
2 put()
public void put(int key, int value) &#123;
		cache.set(key, value);
	&#125;
2）MyCache
构造方法
public static class MyCache&lt;K, V> &#123;
	private HashMap&lt;K, Node&lt;K, V>> keyNodeMap;
	private NodeDoubleLinkedList&lt;K, V> nodeList;
	private final int capacity;
	
	public MyCache(int cap) &#123;
		keyNodeMap = new HashMap&lt;K, Node&lt;K, V>>();
		nodeList = new NodeDoubleLinkedList&lt;K, V>();
		capacity = cap;
	&#125;
1 V get(K key) 通过key返回value 需要将node放到尾部
public V get(K key) &#123;
		if(keyNodeMap.containsKey(key)) &#123;
			Node&lt;K, V> res = keyNodeMap.get(key);
			nodeList.moveNodeToTail(res);
			return res.value;
		&#125;
		return null;
	&#125;
2  void set(K key, V value) 更新与新增：放到尾部，超出内存就删除最长时间没有操作的
public void set(K key, V value) &#123;
		if (keyNodeMap.containsKey(key)) &#123;
			Node&lt;K, V> node = keyNodeMap.get(key);
			node.value = value;
			nodeList.moveNodeToTail(node);
		&#125; else &#123;
			Node&lt;K, V> newNode = new Node&lt;K, V>(key, value);
			keyNodeMap.put(key, newNode);
			nodeList.addNode(newNode);
			if (keyNodeMap.size() == capacity + 1) &#123;
				removeMostUnusedCache();
			&#125;
		&#125;
	&#125;
3 void removeMostUnusedCache() 删去最长时间没有操作的缓存 ；在两个结构里面都删除
private void removeMostUnusedCache() &#123;
			Node&lt;K, V> removeNode = nodeList.removeHead();
			keyNodeMap.remove(removeNode.key);
		&#125;
3) 双向链表结构
基于LRU机制的双向链表结构
private Node&lt;K, V&gt; head;
private Node&lt;K, V&gt; tail;
构造方法：将头尾置为空
public NodeDoubleLinkedList()&#123;
	head &#x3D; null;
	tail &#x3D; null;
&#125;
1 addNode() : 来新节点，挂到尾巴上
public void addNode(Node&lt;K, V> newNode)&#123;
			if(newNode == null) &#123;
				return;
			&#125;
			if(head ==  null) &#123;
				head = newNode;
				tail = newNode;
			&#125; else &#123;
				tail.next = newNode;
				newNode.last = tail;
				tail = newNode;
			&#125;
		&#125;
2 moveToTail() : （修改过的节点，要保证node在表中）更新到尾部
public void moveNodeToTail(Node&lt;K, V> node) &#123;
		 
		&#125;
3 removeHead() : 将头节点移走，返回新的头节点
public static class NodeDoubleLinkedList&lt;K, V> &#123;
	
	public Node&lt;K, V> removeHead() &#123;
		if (head == null) &#123;
			return null;
		&#125;
		Node&lt;K, V> res = head;
		if (head == tail) &#123;
			head = null;
			tail = null;
		&#125; else &#123;
			head = res.next;
			res.next = null;
			head.last = null;
		&#125;
		return res;
	&#125;
&#125;
3 K个一组翻转链表
1 先将第一组k凑齐 并且反转
2 再记录上一组的结尾节点
3 循环（当结尾.next != null)
(1)更新start   (2)更新end 注意判空！！
（3） 反转 ：end 变头
(4） 上一组结尾连接到现在的开头end (5)更新lastEnd

public ListNode reverseKGroup(ListNode head, int k) &#123;
       // 1
       ListNode start = head;
       ListNode end = getKEnd(start, k);
       if (end == null) &#123;
           return head;
       &#125;
       head = end;
       reverse(start, end);
       // 2
       ListNode lastEnd = start;
       // 3
       while (lastEnd.next != null) &#123;
           // 1)
           start = lastEnd.next;
           // 2)
           end = getKEnd(start, k);
           if (end == null) &#123;// ⚠️(注意判空！！！)
               return head;
           &#125;
           // 3)
           reverse(start, end);
           // 4)
           lastEnd.next = end;
           // 5)
           lastEnd = start;
       &#125;
       return head;
   &#125;

   private ListNode getKEnd(ListNode start, int k) &#123;
       while (--k != 0 &amp;&amp; start != null) &#123;
           start = start.next;
       &#125;
       return start;
   &#125;

   // 反转 
   // 1 end 往后移
   // 2 三个指针进行反转
   // 3 start反转后是结尾要连接到end
   private void reverse(ListNode start, ListNode end) &#123;
       // TODO Auto-generated method stub
       end = end.next;//⚠️(注意要移动end指针)
       ListNode pre = null;
       ListNode cur = start;
       ListNode next = null;
       while (cur != end) &#123;
           next = cur.next;
           cur.next = pre;
           pre = cur;
           cur = next;
       &#125;
       start.next = end;
   &#125;
4 合并两个有序链表

先抓小头head
cur2抓大头 cur1 = head.next pre = head
比较 c1 c2 谁小pre的next就指向谁 并且cur pre 后移

public static ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
        if(l1 == null || l2 ==null)&#123;
            return l1 == null ? l2 : l1;
        &#125;
        //抓大头
        ListNode head = l1.val &lt;= l2.val ? l1 : l2;
        ListNode cur1 = head.next;
        //抓小头
        ListNode cur2 = head == l1 ? l2 : l1;
        ListNode pre = head;
        while(cur1 != null &amp;&amp; cur2 != null)&#123;
            if(cur1.val &lt;= cur2.val)&#123;
                pre.next = cur1;
                cur1 = cur1.next;
            &#125;else&#123;
                pre.next = cur2;
                cur2 = cur2.next;
            &#125;
            pre = pre.next;
        &#125;
        pre.next = cur1 != null ? cur1 :cur2;
        return head;
&#125;
合并k个链表

给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。


public class LianBiao_MergeMoreList &#123;

  //对数器 ⚠️
	public static class ListNodeComparator implements Comparator&lt;ListNode> &#123;
		@Override
		public int compare(ListNode arg0, ListNode arg1) &#123;
			// TODO Auto-generated method stub
			return arg0.val - arg1.val;
		&#125;
	&#125;
  
	public ListNode mergeKLists(ListNode[] lists) &#123;
		if (lists == null) &#123;
			return null;
		&#125;
		// 1 定义一个对数器的小根堆
		PriorityQueue&lt;ListNode> heap = new PriorityQueue&lt;>(
				new ListNodeComparator());

   
		// 2 将每一条的head放在堆中
		for (int i = 0; i &lt; lists.length; i++) &#123;
			if (lists[i] != null) &#123;// !!! 
				heap.add(lists[i]);
			&#125;
		&#125;
    if(heap.isEmpty())&#123; // ⚠️
            return null;
    &#125;
		// 3 抓出head 将该条后面一个节点放入堆
		ListNode head = heap.poll();
		if (head.next != null) &#123;// !!!
			heap.add(head.next);
		&#125;
		ListNode pre = head;// 指针

		// 4 重复弹出连接结果表 再见弹出的下一个放入堆中
		while (!heap.isEmpty()) &#123;
			ListNode cur = heap.poll();
			pre.next = cur;
			pre = cur;
			if (cur.next != null) &#123;// !!!
				heap.add(cur.next);
			&#125;
		&#125;

		return head;

	&#125;
&#125;

5 相交链表
需要分有环和无环两种情况 [如何辨别有无环](##6 环形链表##)
无环链表相交


给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。


需要两个指针；
先用n记录两个链表长度大小以便分清楚谁长谁短，n长度差记得取绝对值；
长的走n步到和短的一样长的起点；
两个指针一起走到相等的地方 就是交点 返回；

public static ListNode getNoLoop(ListNode headA, ListNode headB) &#123;
	  if(headA == null || headB == null)&#123;
	      return null;
	  &#125;
	  ListNode cur1 = headA;
	  ListNode cur2 = headB;
	  int n = 0;
	  while(cur1 != null)&#123;
		  n++;
		  cur1 = cur1.next;
	  &#125;
	  while(cur2 != null)&#123;
		  n--;
		  cur2 = cur2.next;
	  &#125;
	   if(cur1 != cur2)&#123;
		  return null;
	  &#125;
	  cur1 = n > 0 ? headA : headB;//cur1指向长的头
	  cur2 = (cur1 == headA) ? headB : headA;//cur2指向短头
	  //将两个链表长度差取绝对值
	  n = Math.abs(n);
	  
	  //将指向长链表的指针cur1往下移动n,到达和短链表cur2指针与相交点相同距离的位置
	  while(n != 0)&#123;
		  n--;
		  cur1 = cur1.next;
	  &#125;
	  //两个指针向下 相遇点便是相交点
	  while(cur1 != cur2)&#123;
		  cur1 = cur1.next;
		  cur2 = cur2.next;
	  &#125;
	  return cur1;
         
  &#125;	
有环链表相交
有环的链表比较复杂 有三种情况
1 两个入环节点相同 即相交在入环前 (loop1 =loop2)
2 两个相交在环内相交 有两个相交点
3 两个不相交

public static ListNode bothLoop(ListNode headA,ListNode loop1,ListNode headB, ListNode loop2)&#123;
		ListNode cur1 = null;
		ListNode cur2 = null;
		if(loop1 == loop2)&#123;//2 
			//方法与两个无环链表方法一样只不过把loop1/2看作结尾
			cur1 = headA;
			cur2 = headB;
			int n = 0;
			while(cur1 != loop1)&#123;
				  n++;
				  cur1 = cur1.next;
			  &#125;
			  while(cur2 != loop2)&#123;
				  n--;
				  cur2 = cur2.next;
			  &#125;
			  if(cur1 != cur2)&#123;
				  return null;
			  &#125;
			  cur1 = n > 0 ? headA : headB;
			  cur2 = (cur1 == headA) ? headB : headA;
			  n = Math.abs(n);
			  while(n != 0)&#123;
				  n--;
				  cur1 = cur1.next;
			  &#125;
			  while(cur1 != cur2)&#123;
				  cur1 = cur1.next;
				  cur2 = cur2.next;
			  &#125;
			  return cur1;
		&#125;else&#123;
			//loop1往后移动 如果在遇到自己之前遇到了loop2就是情况3
			cur1 = loop1.next;
			while(cur1 != loop1)&#123;
				if(cur1 == loop2)&#123;
					return loop1;//3
					&#125;
				&#125;
				return null;//1
			&#125;
&#125;
6 环形链表

返回入环节点，没有环就返回null；

1.先将从头节点快慢指针开始往后，如果两个指针相遇那一定有环，期间如果快指针到null，可以直接判断无环。
2.如果要找到入环节点，就将fast指针指向head，slow不动，然后让两个指针都只移动一步，最后一定会在入环处相遇。
public static ListNode hasCycle(ListNode head) &#123;
        if(head == null || head.next == null || head.next.next == null)&#123;
            return null;
        &#125;
        ListNode slow = head.next;
        ListNode fast = head.next.next;
        while(slow != fast)&#123;
            if(fast.next ==  null || fast.next.next == null)&#123;
                return null;
            &#125;
            fast = fast.next.next;
            slow = slow.next;
        &#125;
        fast = head;
        while(slow != fast)&#123;
            fast = fast.next;
            slow = slow.next;
        &#125;
        return slow;
    &#125;
7 重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：
L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。


找到原表的中点

快慢指针从head开走
fast.next == null || fast.next.next = null 返回慢指针


将右半端反转：[反转链表](##1 反转链表##)
将左右端合并

public void reorderList(ListNode head) &#123;
		 public void reorderList(ListNode head) &#123;
        if(head == null) &#123; // ⚠️判空
            return;
        &#125;
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next =null; // ⚠️分离
        l2 = reverse(l2);
        mergeList(l1, l2);
    &#125;

    public ListNode middleNode(ListNode head) &#123;
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next != null &amp;&amp; fast.next.next != null) &#123;
            fast = fast.next.next;
            slow = slow.next;
        &#125;
        return slow;
    &#125;

    public ListNode reverse(ListNode head) &#123;
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null) &#123;
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        &#125;
        return pre; // ⚠️返回的是pre
    &#125;

    // 合并过程就是使用两个指针来标志两个的下一个
    public void mergeList(ListNode l1, ListNode l2) &#123;
        ListNode l1_next;
        ListNode l2_next;
        while(l1 != null &amp;&amp; l2 != null) &#123;
            l1_next = l1.next;
            l2_next = l2.next;

            l1.next = l2;
            l1 = l1_next;

            l2.next = l1;
            l2 = l2_next;
        &#125;
    &#125;
	&#125;
8 删除链表重复节点
设置虚拟节点
往后遍历  （条件：cur的下一个和下下个都是空）
2.1如果当前两个节点值相等就将当前cur.next的值保存在x;
​	循环（第一个节点后面的节点是否有重复的）cur.next指向不等于该x值的节点
​    2.2 不相等就直接next
public ListNode deleteDuplicates(ListNode head) &#123;
		 if(head == null) &#123;
            return head;
        &#125;
        ListNode dummy = new ListNode(0, head);

        ListNode cur = dummy;
        while(cur.next != null &amp;&amp; cur.next.next != null)&#123; // 当前节点下一个和下下个不为空
            if(cur.next.val == cur.next.next.val)&#123; // 两个节点相等
                int x = cur.next.val; 
                while(cur.next != null &amp;&amp; cur.next.val == x)&#123; // 遍历第一个节点后面的节点是否有重复的 
                    cur.next = cur.next.next;// 有就直接讲指针指向下下个
                &#125;
            &#125; else &#123; // 两个节点不相等 指针后移
                cur = cur.next;
            &#125;
        &#125;
        return dummy.next;
&#125;
9 排序链表

就是给链表排序

public static ListNode sortList(ListNode head) &#123;
		// 1 遍历一遍链表的长度
		int N = 0;
		ListNode cur = head;
		while (cur != null) &#123;
			N++;
			cur = cur.next;
		&#125;
		// 2 len是每次分组节点数 一直乘二
		ListNode h = head;
		ListNode teamFirst = head;
		ListNode pre = null;
		for (int len = 1; len &lt; N; len &lt;&lt;= 1) &#123;
			while (teamFirst != null) &#123;
				// 3 F就是将五个参数处理返回方便利用
				// 左组从哪到哪   ls le
				// 右组从哪到哪   rs re
				// 左 右  next
				ListNode[] f1 = f(teamFirst, len);
				// ls...le  rs...re -> merge去
				// 整体的头、整体的尾
				ListNode[] f2 = merge(f1[0], f1[1], f1[2], f1[3]);
				if (h == teamFirst) &#123;
					h = f2[0];
					pre = f2[1];
				&#125; else &#123;
					pre.next = f2[0];
					pre = f2[1];
				&#125;
				teamFirst = f1[4];// next
			&#125;
			teamFirst = h;
			pre = null;
		&#125;
		return h;
	&#125;

	public static ListNode[] f(ListNode teamFirst, int len) &#123;
		// 返回五个参数
		ListNode ls = teamFirst;
		ListNode le = teamFirst;
		ListNode rs = null;
		ListNode re = null;
		ListNode next = null;
		int pass = 0;
		while (teamFirst != null) &#123;
			pass++;
			if (pass &lt;= len) &#123;
				le = teamFirst;
			&#125;
			if (pass == len + 1) &#123;
				rs = teamFirst;
			&#125;
			if (pass > len) &#123;
				re = teamFirst;
			&#125;
			if (pass == (len &lt;&lt; 1)) &#123;
				break;
			&#125;
			teamFirst = teamFirst.next;
		&#125;
		// 左边结尾断开
		le.next = null;
		// 记录右边结尾的next并断开结尾断开 
		if (re != null) &#123;
			next = re.next;
			re.next = null;
		&#125;
		return new ListNode[] &#123; ls, le, rs, re, next &#125;;
	&#125;

	public static ListNode[] merge(ListNode ls, ListNode le, ListNode rs, ListNode re) &#123;
		if (rs == null) &#123;
			return new ListNode[] &#123; ls, le &#125;;
		&#125;
		ListNode head = null;
		ListNode pre = null;
		ListNode cur = null;
		ListNode tail = null;
		while (ls != le.next &amp;&amp; rs != re.next) &#123;
			if (ls.val &lt;= rs.val) &#123;
				cur = ls;
				ls = ls.next;
			&#125; else &#123;
				cur = rs;
				rs = rs.next;
			&#125;
			if (pre == null) &#123;
				head = cur;
				pre = cur;
			&#125; else &#123;
				pre.next = cur;
				pre = cur;
			&#125;
		&#125;
		if (ls != le.next) &#123;
			while (ls != le.next) &#123;
				pre.next = ls;
				pre = ls;
				tail = ls;
				ls = ls.next;
			&#125;
		&#125; else &#123;
			while (rs != re.next) &#123;
				pre.next = rs;
				pre = rs;
				tail = rs;
				rs = rs.next;
			&#125;
		&#125;
		return new ListNode[] &#123; head, tail &#125;;
	&#125;

10 两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;
		//两个链表分长短
		//分为三个阶段 ：1 长短都还有节点 2 短没有节点 长有节点 3 长也走到没节点
		ListNode l = listLength(l1) > listLength(l2) ? l1 : l2;
		ListNode s = (l == l1) ? l2 : l1;
		ListNode curl = l;
		ListNode curs = s;
		
		int carry = 0;
		int curNum = 0;
		ListNode last = curl;
		
		
		//1 
		while(curs != null)&#123;
			curNum = curs.val + curl.val + carry;
			carry = curNum / 10;
			curl.val = curNum % 10;
			last = curl;//last一直在抓住最后一个节点
			curl = curl.next;
			curs = curs.next;
		&#125;
		
		//2 
		while(curl != null)&#123;
			curNum =  curl.val + carry;
			carry = curNum / 10;
			curl.val = curNum % 10;
			last = curl;//last一直在抓住最后一个节点
			curl = curl.next;
		&#125;
		
		//3 到
		if(carry != 0)&#123;
			last.next = new ListNode(1);
		&#125;
		return l;
	&#125;
	
	
	
	public static int listLength(ListNode l)&#123;
		int length = 0;
		while(l != null)&#123;
			length++;
			l = l.next;
		&#125;
		return length;
	&#125;
11 链表中倒数第k个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

public class Fre_070_removeNthFromEnd &#123;
 public ListNode getKthFromEnd(ListNode head, int k) &#123;
        ListNode slow = head;
        ListNode fast = head;
        while(k - 1 != 0)&#123;
            fast = fast.next;
            k--;
        &#125;

        while(fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next;
        &#125;
        return slow;
    &#125;
12 删除链表倒数第k个节点
public ListNode removeNthFromEnd(ListNode head, int n) &#123;
       ListNode dummy = new ListNode(-1);
       dummy.next = head;
  			// 1 用两个指针截出n+1长度
       ListNode slow = dummy;
       ListNode fast = head;
       for(;n>0;n--)&#123;
           fast=fast.next;
       &#125;
  			// 2 两个指针一直往后直到fast到结尾
       while(fast != null)&#123;
           fast = fast.next;
           slow = slow.next;
       &#125;
  			// 3 slow在目标的前面一位 直接将next指针指向下下位 
       slow.next = slow.next.next;
       return dummy.next;// 使用虚拟节点以防删除的是头节点
   &#125;
13 回文链表
需要convert 和 然后判断对称 然后再convert恢复回去
public boolean isPalindrome(ListNode head) &#123;
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null &amp;&amp; fast.next.next != null)&#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        // 1 现在slow就走到了中间（偶数是上中）
        // 2 将后半部分convert
        ListNode l1 = null; //pre
        ListNode l2 = slow.next;
        ListNode l3 = null;
        while(l2 != null)&#123;
            l3 = l2.next;
            l2.next = l1;
            l1 = l2;
            l2 = l3;
        &#125;

        // 3 后面部分已经翻转 现在对比两部分是否对称
        boolean ans = true;
        l2 = head;
        l3 = l1;
        while(l3 != null)&#123;
            if(l2.val != l3.val)&#123; // ⚠️比较val
                ans = false;
                break;
            &#125;
            l2 = l2.next;
            l3 = l3.next;
        &#125;

        // 4 把后半部分又恢复原样
        l2 = null;// pre
        l3 = null;// next
        while(l1 != null)&#123;
            l3 = l1.next;
            l1.next = l2;
            l2 = l1;
            l1 = l3;
        &#125;
        slow.next = l2;

        return ans;
    &#125;
14 删除排序链表中的重复元素

给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

删除重复元素 留下一个
直接快慢指针
public ListNode deleteDuplicates(ListNode head) &#123;
       if(head == null)&#123;
           return null;
       &#125;
       ListNode ans = head;
       ListNode left = head;
       ListNode right = head.next;

       while( right != null) &#123;
           ListNode next = right.next;
           if(left.val == right.val) &#123;
               left.next = next;
               right.next = null;
           &#125; else&#123;
               left =  right;
           &#125;

           right = next;
       &#125;
       return ans;
   &#125;


15 复制带有随机指针的链表
/*
 * 深度复制带有rand的链表
 */
public class LiaoBiao_copyListWithRandom &#123;
	public static class Node &#123;
		public int value;
		public Node next;
		public Node rand;

		public Node(int data) &#123;
			value = data;
		&#125;
	&#125;
	
	/*
	 * 最优解：人工构造关系
	 * 1 每一个节点后面加一个克隆节点
	 * 2 遍历关系 （同时复制rand
	 * 3 遍历分离（同时复制next
	 */
    public static Node copyListWithRandom(Node head)&#123;
    	if(head == null)&#123; return null; &#125;
    	Node cur = head;
    	Node next = null;
    	// 1
    	while(cur != null)&#123;
    		next = cur.next;
    		cur.next = new Node(cur.value);
    		cur.next.next = next;
    		cur = next;
    	&#125;
    	
    	cur = head;
    	Node curCopy = null;
    	// 2
    	while(cur != null)&#123;
    		next = cur.next.next;
    		curCopy = cur.next;
    		curCopy.rand = cur.rand != null ? cur.rand.next : null;
    		cur = next;
    	&#125;
    	
    	cur = head;
    	Node res = head.next;
    	// 3
    	while(cur != null)&#123;
    		next = cur.next.next;
    		curCopy = cur.next;
    		curCopy.next = cur.next != null ? cur.next.next : null;
    		cur = next;
    	&#125;
    	return res;
	&#125;
	
    /**
     * 使用hashMap一一对应关系
     * 1 遍历第一遍一一对应
     * 2 遍历第二遍复制关系
     * @param head
     * @return
     */
	public static Node copyListWithRandom2(Node head)&#123;
		HashMap&lt;Node, Node> map = new HashMap&lt;>();
		Node cur = head;
		// 1 
		while(cur != null)&#123;
			map.put(cur, new Node(cur.value));
			cur = cur.next;
		&#125;
		
		cur = head;
		// 2
		while(cur != null)&#123;
			map.get(cur).next = map.get(cur.next);
			map.get(cur).rand = map.get(cur.rand);
			cur = cur.next;
		&#125;
		
		return map.get(head);
		
	&#125;
&#125;

2 动态规划
具体步骤 可以参考[零钱兑换](###2 返回凑齐的所有方法数)
基础问题 背包问题
/**
 * 传入货物的重量和价值 不能超过bag背包容量，返回最大价值
 * 
 * @author chs
 *
 */
public class DP2_knapsack &#123;
	/**
	 * 暴力递归
	 */
	public static int maxValue(int[] w, int[] v, int bag) &#123;
		if (w == null || v == null || w.length == 0) &#123;
			return 0;
		&#125;
		return process(w, v, 0, bag);
	&#125;

	public static int process(int[] w, int[] v, int i, int rest) &#123;
		if (rest &lt; 0) &#123;
			return -1;
		&#125;
		if (i == w.length) &#123;
			return 0;
		&#125;
		// 加上i
		int p1 = process(w, v, i + 1, rest - w[i]);
		// 没加
		int p2 = process(w, v, i + 1, rest);

		if (p1 != -1) &#123;
			p1 += v[i];
		&#125;
		return Math.max(p1, p2);
	&#125;
   
	/**
	 * 动态规划版
	 */
	public static int dp(int[] w, int[] v, int bag) &#123;
		if (w == null || v == null || w.length != v.length || w.length == 0) &#123;
			return 0;
		&#125;
		int N = w.length;
		int[][] dp = new int[N + 1][bag + 1];
		for(int i = N - 1; i >= 0; i --)&#123;
			for(int j = 0; j &lt;= bag; j ++)&#123;
				int ans = 0;
				if(j - w[i] >= 0)&#123;
					ans = dp[i + 1][j - w[i]] + v[i];
				&#125;else&#123;
					ans = dp[i + 1][j];
				&#125;
				dp[i][j] = Math.max(dp[i+1][j], ans);
			&#125;
		&#125;
		return dp[0][bag];

	&#125;
	
	
1. 最大子数组和
用贪心
只需要一个pre反复更新记录以i为底的最大累加和，然后max存最大的
//用两个变量存
	public static int maxSubArray4(int[] nums)&#123;
		if (nums.length == 0 || nums == null) &#123;
			return 0;
		&#125;
        int max = nums[0];
        int pre = 0;
		for(int i = 0; i &lt; nums.length; i++)&#123;
			pre = Math.max(pre + nums[i], nums[i]);
			max = Math.max(pre, max);
        &#125;
		return max;
	&#125;
如果需要返回该子数组
int res = nums[0], l = 0, r = 0;
for (int i = 0; i &lt; nums.size(); i++) &#123;
	if (nums[i - 1] &lt; 0) &#123;
		l = i;
	&#125;
	nums[i] += max(0, nums[i - 1]);
	if (res &lt; nums[i]) &#123;
		r = i;
		res = nums[i];
	&#125;
&#125;
2. 买卖股票的最佳时机 maxProfit
(1) 从头至尾买一次一股 返回最大利润:
遍历一遍 min标记， max最大利润更新 就是找到最低点和最高点
class Solution &#123;
    public int maxProfit(int prices[]) &#123;
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i &lt; prices.length; i++) &#123;
            if (prices[i] &lt; minprice) &#123;
                minprice = prices[i];
            &#125; else if (prices[i] - minprice > maxprofit) &#123;
                maxprofit = prices[i] - minprice;
            &#125;
        &#125;
        return maxprofit;
    &#125;
&#125;
(2) 买一股但是可以买无限次
遍历累加所有的爬坡
// 一股随便买
	// 相当于在每次爬坡前后买卖 将所有爬坡累加就行
	public static int maxProfit2(int[] prices) &#123;
		if (prices == null || prices.length == 0) &#123;
			return 0;
		&#125;
		int ans = 0;
		for(int i = 1; i &lt; prices.length; i++)&#123;
			ans += prices[i] - prices[i - 1] >= 0 ? prices[i] - prices[i - 1] : 0;
		&#125;
		return ans;
	&#125;
3. 最长回文子串
(1) 动态规划O(N^2)


/**
    * 自己改动态规划
    * @param s
    * @return
    */
   public String longestPalindrome33(String s) &#123;
       if (s.length() &lt; 2) &#123;
           return s;
       &#125;
       char[] str = s.toCharArray();
       int N = str.length;
       boolean[][] dp = new boolean[N][N];
       for(int i = 0; i &lt; N; i++) &#123;
           dp[i][i] = true;
       &#125;
       //边填dp 边抓最长和该最长开始节点
       int max = 1;
       int index = 0;

      //按对角线遍历 
      // 最外循环不是dp的坐标
      // i代表了n - len 每个循环行是不变的 
      // j是横坐标L
       for(int i = N - 1; i > 0; i--)&#123;
           for(int L = 0; L &lt; i; L++)&#123;
               int R = L + N - i;
               if(str[L] == str[R])&#123;
                   if(R - L &lt; 3)&#123;
                       dp[L][R] = true;
                   &#125;else&#123;
                       dp[L][R] = dp[L + 1][R - 1];
                   &#125;
               &#125;
               if(dp[L][R] &amp;&amp; R - L + 1 > max)&#123;
                   max = R - L + 1;
                   index = L;	
               &#125;
           &#125;
       &#125;
       return s.substring(index, index + max);
   &#125;
(2) Manacher!
面试讲一讲
假设字符串str长度为N，想返回最长回文子串的长度
时间复杂度O(N)
Manacher算法核心
1）理解回文半径数组
2）理解所有中心的回文最右边界R，和取得R时的中心点C
3）理解 L…(i’)…C…(i)…R 的结构，以及根据i’回文长度进行的状况划分
4）每一种情况划分，都可以加速求解i回文半径的过程
最长回文子串就是我知道可以进行。
最长回文子序列
子序列就是三种情况 L+1 ~R 和 L ~ R-1 和 L +1 ~ R - 1
public int longestPalindromeSubseq(String s) &#123;
      public int longestPalindromeSubseq(String s) &#123;
       if(s.length() == 0 || s == "")&#123;
           return 0;
       &#125;

       char[] str = s.toCharArray();
       int N = str.length;
       int[][] dp = new int[N][N];

       for(int i = 0; i &lt; N; i++)&#123;
           dp[i][i] = 1;
       &#125;
       //对角线遍历
       for(int i = N - 1; i >= 0; i--)&#123;
         for(int L = 0; L &lt; i; L++)&#123;
           int R = L + N - i;
           dp[L][R] = Math.max(dp[L + 1][R],dp[L][R - 1]);
           if(str[L] == str[R])&#123;
             dp[L][R] = Math.max(dp[L + 1][R - 1] + 2, dp[L][R]);
           &#125;
				&#125;
       &#125;
       return dp[0][N - 1];
      &#125;
   
4. 最长递增子序列
DP版  O(n^2)
public int lengthOfLIS(int[] nums) &#123;
      if (nums.length == 0) &#123; 
          return 0;
      &#125;
      int[] dp = new int[nums.length];
      dp[0] = 1;
      int maxans = 1;
      for (int i = 1; i &lt; nums.length; i++) &#123;
          dp[i] = 1;
          for (int j = 0; j &lt; i; j++) &#123;
              if (nums[i] > nums[j]) &#123;
                  dp[i] = Math.max(dp[i], dp[j] + 1);
              &#125;
          &#125;
          maxans = Math.max(maxans, dp[i]);
      &#125;
      return maxans;
  &#125;
二分查找+贪心  O(nlogn)
维护一个end数组存储


end[i] 代表  i+1 长度下子序列的最后下标


len = 递增子序列的长 度 - 1（end数组的下标 ）


设当前已求出的最长上升子序列的长度为 len（初始时为1），从前往后遍历数组nums，在遍历到 nums[i] 时：

如果 nums[i] &gt;[len] ，则[++len] = nums[i]；
否则，在end数组中[0 ~ len-1]二分查找，找到第一个比 nums[i] 小的数 end[k] ，并更新 end[k+1]=nums[i]。

代码
public static int lengthOfLIS(int[] nums) &#123;
	if (nums.length == 0 || nums == null) &#123;
		return 0;
	&#125;

	// end[i]存储 第i+1长度下子序列的最后下标
	int[] end = new int[nums.length];
	end[0] = nums[0];//!!!
	// end数组的下标 = 递增子序列的长度 - 1
	int len = 0;

	// 二分查找的下标

	for (int i = 1; i &lt; nums.length; i++) &#123;
		//
		if (nums[i] > end[len]) &#123;
			end[++len] = nums[i];
		&#125; else &#123;// 在end里面二分查找 &lt; num[i] 的数
			int L = 0;
			int R = len - 1;
			int pos = 0;//因为如果没有比他小的 说明都比他大 就更新的是end[0]
			while (L &lt;= R) &#123;
				int mid = (R + L) >> 1;
				if(end[mid] &lt; nums[i])&#123;
					pos = mid + 1;//抓住当前小于numi的数的后面一位 后面会更新
					L = mid + 1;
				&#125;else&#123;
					R = mid - 1;
				&#125;
			&#125;
			end[pos] = nums[i];//更新
		&#125;
	&#125;
	return len + 1;
&#125;

5. 接雨水

左右两个指针 left right
左右两个变量存储左右最大的值
每次更新左右任意一边靠着lmax或者rmax的指针的雨水大小
相当于是把每一下标积的水累加。

相当于是从左右两边来进行更新 哪边的max最大就比较那一边的L/R与max大小 累加并且更新最大值
最后返回累加和
public int trap(int[] arr) &#123;
	int ans = 0;
	int L = 1;
	int R = arr.length - 2;
	int leftMax = arr[0];
	int rightMax = arr[arr.length - 1];z
	while(L &lt;= R) &#123; // ！！！！ &lt;=
		if(leftMax &lt;= rightMax) &#123;
			ans += Math.max(0, leftMax - arr[L]);
			leftMax = Math.max(leftMax, arr[L++]);
		&#125;else &#123;
			ans += Math.max(0, rightMax - arr[R]);
			rightMax = Math.max(rightMax, arr[R--]);
		&#125;
	&#125;
	
	return ans;
&#125;
6. 最长上升子序列
设当前已求出的最长上升子序列的长度为 len（初始时为1），从前往后遍历数组nums，在遍历到 nums[i] 时：

如果 nums[i] d[len] ，则直接加入到 ddd 数组末尾，并更新 len= len+1；
否则，在 d数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k+1]=nums[i].

/**
	 * 这道题要用 二分查找和贪心
	 * 暴力递归XXX不用了老子 
	 * @param nums
	 * @return
	 */
	public static int lengthOfLIS(int[] nums) &#123;
		if (nums.length == 0 || nums == null) &#123;
			return 0;
		&#125;

		// end[i]存储 第i+1长度下子序列的最后下标
		int[] end = new int[nums.length];
		end[0] = nums[0];
		// end数组的下标 = 递增子序列的长度 - 1
		int len = 0;

		// 二分查找的下标
		for (int i = 1; i &lt; nums.length; i++) &#123;
			//
			if (nums[i] > end[len]) &#123;
				end[++len] = nums[i];
			&#125; else &#123;// 在end里面二分查找 &lt; num[i] 的数
				int L = 0;
				int R = len - 1;
				int pos = 0;//因为如果没有比他小的 说明都比他大 就更新的是end[0]
				while (L &lt;= R) &#123;
					int mid = (R + L) >> 1;
					if(end[mid] &lt; nums[i])&#123;
						pos = mid + 1;//抓住当前小于numi的数的后面一位 后面会更新
						L = mid + 1;
					&#125;else&#123;
						R = mid - 1;
					&#125;
				&#125;
				end[pos] = nums[i];//更新
			&#125;
		&#125;
		return len + 1;
	&#125;

7. 爬楼梯
递归 笔试
状态转移方程 f(n) = f(n - 1) + f(n - 2); ----&gt; 可以看出就是斐波拉契数列
用三个常量所以空间复杂度为O(1)
class Solution &#123;
    public int climbStairs(int n) &#123;
        int p = 0, q = 0, r = 1;
        for (int i = 1; i &lt;= n; ++i) &#123;
            p = q; 
            q = r; 
            r = p + q;
        &#125;
        return r;
    &#125;+
&#125;

矩阵快速幂 o(logn)

public class Code4_ClimbStairs &#123;
	public static int climbStairs(int n) &#123;
		if (n == 0) &#123;
			return 0;
		&#125;
		// [ 1 ,1 ]
		// [ 1, 0 ]
		int[][] base = &#123; &#123; 1, 1 &#125;, &#123; 1, 0 &#125; &#125;;
		int[][] res = matrixPower(base, n);
		return res[0][0]; 
    // 如果是斐波拉契数列 就要从1 1 2 3 5 
    // 返回的就是res[0][0]+res[0][1]
	&#125;

  /*
  快速幂 方法就是将指数循环 每次循环内矩阵平方 然后指数右移一位
  */
	public static int[][] matrixPower(int[][] m, int p) &#123;
    // res初始化为单位1
		int[][] res = &#123;&#123;1, 0 &#125;, &#123;0,1&#125;&#125;;
    // m ---> 一次方
		int[][] tmp = m;
		for (; p != 0; p >>= 1) &#123;
			if ((p &amp; 1) != 0) &#123; // ！！！先乘一次方 注意是不等于0 
				res = muliMatrix(res, tmp);
			&#125;
			tmp = muliMatrix(tmp, tmp);
		&#125;
		return res;
	&#125;
	public static int[][] muliMatrix(int[][] m1, int[][] m2) &#123;
		int[][] res = new int[m1.length][m2[0].length];
		for (int i = 0; i &lt; m1.length; i++) &#123;
			for (int j = 0; j &lt; m2[0].length; j++) &#123;
				for (int k = 0; k &lt; m2.length; k++) &#123;
					res[i][j] += m1[i][k] * m2[k][j]; // k = m1的列 = m2的行
				&#125;
			&#125;
		&#125;
		return res;
	&#125;
主要就是注意快速幂里面要先进行 一次方的判断
8. 编辑距离(dp3)
DP 样本对应模型：往往用最后的位置来判断可能性
给两个单词，返回第一个单词转换为第二个单词最少的操作数， 有增删改三种操作
（扩展：可以增加a d c分别代表增删改的代价）
根据最后一个位置有四种可能
public class DP3_EditDistance &#123;
		public int minDistance(String word1, String word2) &#123;
      	if(word1 == null || word2 == null) &#123;
          return 0;
        &#125;
       char[] str1 = word1.toCharArray();
        char[] str2 = word2.toCharArray();
        int N = str1.length; 
        int M = str2.length;
        int[][] dp = new int[N+1][M+1];
        // 1 处理边界：其中有字符串是空的情况 全是增加操作
        for(int i = 0; i &lt;= N; i++) &#123;
            dp[i][0] = i;
        &#125; 
        for(int i = 0; i &lt;= M; i++) &#123;
            dp[0][i] = i;
        &#125;

        // 2 普通情况 从最后位置比较word1该如何处理
        for(int i = 1; i &lt;= N; i++) &#123;
            for(int j = 1; j &lt;= M; j++) &#123;
                // 2.1 最后一个位置修改或者保留
                if(str1[i- 1] == str2[j - 1]) &#123;// ！！！ 注意
                    dp[i][j] = dp[i - 1][j - 1];
                &#125; else &#123;
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                &#125;
                // 2.2 最后一个位置删除
                dp[i][j] = Math.min(dp[i- 1][j] + 1, dp[i][j]);
                // 2.3 最后一个位置增加 
                dp[i][j] = Math.min(dp[i][j - 1] + 1, dp[i][j]);
            &#125;
        &#125;
        return dp[N][M];
&#125;
⚠️ 因为有为0的情况 所以总的就是[0, N] 所以循环范围需要是[0,N]  并且str下标 对应 dp下标减一

9. 最长公共子序列(dp3)

⚠️填边界的时候先将dp[0][0]填了 防止 i - 1 越界
public int longestCommonSubsequence(String text1, String text2) &#123;
        if(text1 == null || text2 == null) &#123;
            return 0;
        &#125;
        char[] str1 = text1.toCharArray();
        char[] str2 = text2.toCharArray();
        int[][] dp = new int[str1.length][str2.length];
        // 1 填完第一行和第一列
        dp[0][0] = str1[0] == str2[0] ? 1 : 0; // !!!
        for(int i = 1; i &lt; str2.length; i++) &#123;
           dp[0][i] = str1[0] == str2[i] ? 1 : dp[0][i - 1];
        &#125; 
        for(int i = 1; i &lt; str1.length; i++) &#123;
           dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];

        &#125;

        // 2 按每行没列填
        for(int i = 1; i &lt; str1.length; i++) &#123;
            for(int j = 1; j &lt; str2.length; j++) &#123;
              // 1 不看当前的情况 比较[i - 1]和[j ]或者[ i]和[j - 1]
                int p1 = dp[i - 1][j];
                int p2 = dp[i][j - 1];
              // 2 将这个位置的情况纳入 比较 [i]和 [j]
                int p3 = str1[i] == str2[j] ? dp[i - 1][j - 1] + 1 : dp[i - 1][j - 1];
                dp[i][j] = Math.max(p1, Math.max(p2, p3));
            &#125;
        &#125;
        return dp[str1.length - 1][str2.length - 1];


    &#125;
10 最小路径和

m ✖️n 的网格 从左下角走到右下角 怎么走路径最短

⚠️[1, 1] 开始填表
public int minPathSum2(int[][] grid) &#123;
        if (grid == null || grid.length == 0) &#123;
            return 0;
        &#125;

        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];

        for (int i = 1; i &lt; m; i++) &#123; // !!! 注意别写反了
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        &#125;
        for (int j = 1; j &lt; n; j++) &#123;
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        &#125;
        for (int i = 1; i &lt; m; i++) &#123;
            for (int j = 1; j &lt; n; j++) &#123;
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            &#125;
        &#125;
        return dp[m - 1][n - 1];
    &#125;

扩展
记录路径也可以开一个字典，应该知道了每个 [i,j] 上一个来源坐标 last， path[(i,j)] = (lasti,lastj)，最后用一个死循环输出所有path，当 (i,j) == (0,0 ) 时候退出 然后最后进行一个死循环 就可以将循环打出来了
不同路径

m ✖️n 的网格 从左下角走到右下角 有多少种走法 （方法数）

public int uniquePaths(int m, int n) &#123;
        int[][] dp = new int[m][n];

        for(int i = 0; i &lt; m; i++) &#123;
            dp[i][0] = 1;

        &#125;
        for(int i = 0; i &lt; n; i++) &#123;
            dp[0][i] = 1;

        &#125;

        for(int i = 1; i &lt; m; i++) &#123;
            for(int j = 1; j &lt; n; j++) &#123;
                dp[i][j] = dp[i - 1][j]+ dp[i][j - 1];
            &#125;
        &#125;
        return dp[m-1][n-1];
    &#125;
11  最长公共子数组(最长重复子数组)

注意的还是边界； 应为需要最开始的状态来依赖 所以要不选择dp外围加一圈 要不就是dp内围循环从1开始


public int findLength(int[] A, int[] B) &#123;
		int n = A.length, m = B.length;
		int[][] dp = new int[n + 1][m + 1];
		int ans = 0;
		for (int i = n - 1; i >= 0; i--) &#123;
			for (int j = m - 1; j >= 0; j--) &#123;
				dp[i][j] = A[i] == B[j] ? dp[i + 1][j + 1] + 1 : 0;
				ans = Math.max(ans, dp[i][j]);
			&#125;
		&#125;
		return ans;
	&#125;

public int findLength(int[] nums1, int[] nums2) &#123;
       int[][] dp = new int[nums1.length+1][nums2.length+1];
       int ans = 0;
       for(int i = 1; i &lt;= nums1.length;i++) &#123;
           for(int j = 1; j &lt;= nums2.length; j++) &#123;
               dp[i][j] = nums1[i-1] == nums2[j-1] ? dp[i - 1][j - 1] + 1 : 0; //！！！
               ans = Math.max(dp[i][j], ans);
           &#125;
       &#125;
       return ans;
   &#125;
12 零钱兑换问题 &lt;完全背包&gt;(dp4) 难
关于背包问题 吃透背包所有问题
从左向右的尝试模型

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

1 返回需要最少的硬币个数

计算并返回可以凑成总金额所需的 最少硬币个数 。
每个硬币都可以说使用无限次。

动态规划
public int coinChange(int[] arr, int aim) &#123;
        if (aim == 0) &#123;
			return 0;
		&#125;
		int N = arr.length;
		int[][] dp = new int[N + 1][aim + 1];
		dp[N][0] = 0;
		for (int j = 1; j &lt;= aim; j++) &#123;
			dp[N][j] = Integer.MAX_VALUE;
		&#125;
		for (int index = N - 1; index >= 0; index--) &#123;
			for (int rest = 0; rest &lt;= aim; rest++) &#123;
				dp[index][rest] = dp[index + 1][rest];// 下边
				if (rest - arr[index] >= 0 
						&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;
          // 最小值 相当于（ 左边+1）与（下边 ）进行比较
					dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + 1);
				&#125;
			&#125;
		&#125;
		return dp[0][aim] == Integer.MAX_VALUE ? -1 : dp[0][aim];// 无解情况返回-1
    &#125;
2 返回凑齐的所有方法数

返回硬币或者货币可以凑齐钱的所有方法数

暴力递归的尝试

public static int coinsWay(int[] arr, int aim) &#123;
		if (arr == null || arr.length == 0 || aim &lt; 0) &#123;
			return 0;
		&#125;
		return process(arr, 0, aim);
	&#125;

	// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？
	public static int process(int[] arr, int index, int rest) &#123;
		if (index == arr.length) &#123; // 没钱了
			return rest == 0 ? 1 : 0;
		&#125;
		int ways = 0;
		for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123; 
			ways += process(arr, index + 1, rest - (zhang * arr[index]));
		&#125;
		return ways;
	&#125;


说明是有重复解的,所以可以进一步进行记忆化搜索
记忆化搜索
就是用一个结构存储f(i, rest)结果 后面就不会重复解

如果该题没有枚举行为那么傻缓存的方法和严格表结构（动态规划）的方法就是一样的。
严格的表结构： 就是在记忆化搜索的基础上，进一步梳理了依赖关系，从简单位置算出复杂位置，严格规定好了计算顺序
有枚举行为：需要搞出严格的表结构进行继续优化。
动态规划
第一版dp:有枚举行为，和上面记忆化搜索的方法是等效的
public static int dp1(int[] arr, int aim) &#123;
		if (arr == null || arr.length == 0 || aim &lt; 0) &#123;
			return 0;
		&#125;
		int N = arr.length;
		int[][] dp = new int[N + 1][aim + 1];
		dp[N][0] = 1;
		for (int index = N - 1; index >= 0; index--) &#123;
			for (int rest = 0; rest &lt;= aim; rest++) &#123;
				int ways = 0;
				for (int zhang = 0; zhang * arr[index] &lt;= rest; zhang++) &#123;
					ways += dp[index + 1][rest - (zhang * arr[index])];
				&#125;
				dp[index][rest] = ways;
			&#125;
		&#125;
		return dp[0][aim];
	&#125;
第二版：将枚举行为的规律找出来，利用严格的表结构


public int coinChange(int[] coins, int amount) &#123;
		if (coins == null || coins.length == 0 || amount &lt; 0) &#123;
			return 0;
		&#125;
		int N = coins.length;
		int[][] dp = new int[N + 1][amount + 1];
		dp[N][0] = 1;
		for (int index = N - 1; index >= 0; index--) &#123;
			for (int rest = 0; rest &lt;= amount; rest++) &#123;
				dp[index][rest] = dp[index + 1][rest];
				if (rest - coins[index] >= 0) &#123;
					dp[index][rest] += dp[index][rest - coins[index]];
				&#125;
			&#125;
		&#125;
		return dp[0][amount];
	&#125;
	
3 最终代码
零钱兑换1
public int coinChange(int[] arr, int aim) &#123;
        if (aim == 0) &#123;
			return 0;
		&#125;
		int N = arr.length;
		int[][] dp = new int[N + 1][aim + 1];
		dp[N][0] = 0;
		for (int j = 1; j &lt;= aim; j++) &#123;
			dp[N][j] = Integer.MAX_VALUE;
		&#125;
		for (int index = N - 1; index >= 0; index--) &#123;
			for (int rest = 0; rest &lt;= aim; rest++) &#123;
				dp[index][rest] = dp[index + 1][rest];
				if (rest - arr[index] >= 0 
						&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;
          // 最小值判断
					dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + 1);
				&#125;
			&#125;
		&#125;
		return dp[0][aim] == Integer.MAX_VALUE ? -1 : dp[0][aim];// 无解情况返回-1
    &#125;

/*
* 一维 难理解
*/
public int coinChange(int[] coins, int amount) &#123;
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i &lt;= amount; i++) &#123;
            for (int j = 0; j &lt; coins.length; j++) &#123;
                if (coins[j] &lt;= i) &#123;
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                &#125;
            &#125;
        &#125;
        return dp[amount] > amount ? -1 : dp[amount];

    &#125;
零钱兑换2
public int coinChange(int[] coins, int amount) &#123;
		if (coins == null || coins.length == 0 || amount &lt; 0) &#123;
			return 0;
		&#125;
		int N = coins.length;
		int[][] dp = new int[N + 1][amount + 1];
		dp[N][0] = 1;
		for (int index = N - 1; index >= 0; index--) &#123;
			for (int rest = 0; rest &lt;= amount; rest++) &#123;
				dp[index][rest] = dp[index + 1][rest];
				if (rest - coins[index] >= 0) &#123;
					dp[index][rest] += dp[index][rest - coins[index]];
				&#125;
			&#125;
		&#125;
		return dp[0][amount];
	&#125;
/*
* 一维 不是很好理解怕写错
*/
public int change(int amount, int[] coins) &#123;
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) &#123;
            for (int i = coin; i &lt;= amount; i++) &#123;
                dp[i] += dp[i - coin];
            &#125;
        &#125;
        return dp[amount];
    &#125;
13 最长有效括号

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

思路：
    是子串类型，看以i结尾
1 如果当前是‘）’ 就找可以和他配对的最前左括号pre下标
   pre = i - dp[i - 1] - 1; 
           （dp[i - 1] 前一个已经配好对的长度 
2 如果pre是左括号(注意pre>= 0 防止越界) 
     更新dp[i] == 2 + dp [i - 1]+ (pre > 0? dp [pre - 1] : 0);
public int longestValidParentheses(String s) &#123;
        if(s == null || s.length()== 0) &#123;
            return 0;
        &#125;
        char[] str= s.toCharArray();
        int[] dp = new int[s.length()];
        int max = 0;
        for(int i = 1; i &lt; str.length; i++) &#123;
            if( str[i] == ')') &#123; 
                int pre = i - dp[i - 1] - 1;
                if( pre >= 0 &amp;&amp; str[pre] == '(' ) &#123; // !! pre >= 0在前 pre 
                    dp[i] = 2 + dp[i - 1] + (pre > 0? dp[pre - 1] : 0);  //!!! pre -1 
                &#125;
            &#125;
            max = Math.max(dp[i], max);

        &#125;
        return max;
    &#125;
14 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
链接：https://leetcode-cn.com/problems/house-robber

public int rob(int[] nums) &#123;
       if (nums == null || nums.length == 0) &#123;
           return 0;
       &#125;
       if (nums.length == 1) &#123; // ！！！ 
           return nums[0];
       &#125;
       int n = nums.length;
       int[] dp = new int[n];
       dp[0] = nums[0];
       dp[1] = Math.max(dp[0], nums[1]); // ！！!注意要将[0][1] 先填 i从2开始
       for(int i = 2; i &lt; n; i++) &#123;
           int p1 = nums[i];
           int p2 = dp[i - 1];
           int p3 = nums[i] + dp[i - 2];
           dp[i] = Math.max(p1, Math.max(p2, p3));
       &#125;
       return dp[n - 1];
   &#125;
打家劫舍Ⅱ

这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。

是滚动数组，可以分成两个数组来判断[0]-[N-2] 和 [1]-[N-1]
public int rob(int[] nums) &#123;
        if (nums == null || nums.length == 0) &#123;
        return 0;
    &#125;
    if (nums.length == 1) &#123;
        return nums[0];
    &#125;
    if (nums.length == 2) &#123;
        return Math.max(nums[0], nums[1]);
    &#125;
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for(int i = 2; i &lt; nums.length-1; i++) &#123;
            int p1 = nums[i];
            int p2 = dp[i - 1];
            int p3 = dp[i - 2] + nums[i];
            dp[i] = Math.max(p1, Math.max(p2, p3));
        &#125;
        int ans1 = dp[nums.length - 2];

        dp[1] = nums[1];
        dp[2] = Math.max(nums[1], nums[2]);
        for(int i = 3; i &lt; nums.length; i++) &#123;
            int p1 = nums[i];
            int p2 = dp[i - 1];
            int p3 = dp[i - 2] + nums[i];
            dp[i] = Math.max(p1, Math.max(p2, p3));
        &#125;
        int ans2 = dp[nums.length - 1];
        return Math.max(ans1, ans2);
        
    &#125;

15 矩阵的递增路径

给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。


public static int longestIncreasingPath(int[][] matrix) &#123;
	int ans = 0;
	int N = matrix.length;
	int M = matrix[0].length;
	int[][] dp = new int[N][M];
	for (int i = 0; i &lt; N; i++) &#123;
		for (int j = 0; j &lt; M; j++) &#123;
			ans = Math.max(ans, process1(matrix, i, j, dp));
		&#125;
	&#125;
	return ans;
&#125;
private static int process1(int[][] m, int i, int j,int[][] dp) &#123;
	if(dp[i][j] != 0)&#123;//存了数就不用再算了
		return dp[i][j];
	&#125;
	// 上下左右四个方向
	int up = i > 0 &amp;&amp; m[i][j] &lt; m[i - 1][j] ? process1(m, i - 1, j, dp) : 0;
	int down = i &lt; (m.length - 1) &amp;&amp; m[i][j] &lt; m[i + 1][j] ? process1(m,
			i + 1, j, dp) : 0;
	int left = j > 0 &amp;&amp; m[i][j] &lt; m[i][j - 1] ? process1(m, i, j - 1,dp) : 0;
	int right = j &lt; (m[0].length - 1) &amp;&amp; m[i][j] &lt; m[i][j + 1] ? process1(
			m, i, j + 1, dp) : 0;
	int ans = Math.max(Math.max(up, down), Math.max(left, right)) + 1;
	dp[i][j] = ans;
	return ans;
&#125;
16 机器人walk
/*
 * 机器人在n长度的数组中，位置在M，要走k步到p，有多少种方法
 */
public class DP_RobortWalk &#123;
	/* 1
	 * 暴力递归尝试
	 * 每次走一步： 1. rest - 1 ；2. 位置cur更新
	 */
	public static int way1(int N, int M, int K, int P)&#123;
		if (N &lt; 2 || M &lt; 1 || M > N || P &lt; 1 || P > N || K &lt; 1) &#123;
			return -1;
		&#125;
		return process1(N, M, K, P);
	&#125; 
	
	// 1 当剩下0步 ：到了aim 返回1;没到 返回0
	// 2 两个边界条件
	// 3 返回递归结果
	public static int process1(int n, int cur, int rest, int aim)&#123;
		// 1 
		if(rest == 0 )&#123;// base case
			return cur == aim ? 1 : 0;
		&#125;
		// 2
		if(cur == 1)&#123;
			return process1(n, 2, rest - 1, aim);
		&#125;
		if(cur == n)&#123;
			return process1(n, n - 1, rest - 1, aim);
		&#125;
		// 3
		return process1(n, cur - 1, rest - 1, aim) +  process1(n, cur + 1, rest - 1, aim);
	&#125;

	
	/*
	 * DP:直接使用矩阵来替代递归的过程
	 */
	public static int way3(int N,int M, int K, int P)&#123;
		if (N &lt; 2 || M &lt; 1 || M > N || P &lt; 1 || P > N || K &lt; 1) &#123;
			return -1;
		&#125;
		int[][] dp = new int[N + 1][K + 1];
		// 1
		dp[P][0] = 1;//base case 
		for (int rest = 1; rest &lt;= K; rest++) &#123;
			// 2
			dp[1][rest] = dp[2][rest - 1];
			dp[N][rest] = dp[N - 1][rest - 1];
			// 3
			for (int cur = 2; cur &lt; N; cur++) &#123;
				dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
			&#125;
			
		&#125;
		return dp[M][K];
	&#125;
	
	public static void main(String[] args) &#123;
		System.out.println(way1(4, 2, 3, 3));
		System.out.println(way3(4, 2, 3, 3));
	&#125;
&#125;

17 纸牌博弈
/* 纸牌博弈问题
 * 两个会预判的人 从左右选卡片 返回胜利的人的分数
 */
public class DP1_TwoSmartManPeekCard &#123;

	
    public static int win1(int[] arr)&#123;
        if(arr==null||arr.length==0)&#123;
            return 0;
        &#125;
        return Math.max(f(arr,0,arr.length-1), s(arr,0,arr.length-1)) ;
    &#125;
    // f() 在i~j范围 先拿
    public static int f(int[] arr,int i,int j)&#123;
        //纸牌被聪明人先拿，获得的分数
        if(i==j)&#123;
            return arr[i];
        &#125;
        //拿走一张（i或者j）后，聪明人成了后拿的人，在两种决策中选最优
        return Math.max(arr[i]+s(arr,i+1,j),arr[j]+s(arr,i,j-1));
    &#125;

    // g() 在i~j范围 后拿
    public static int s(int[] arr,int i,int j)&#123;
        //纸牌被聪明人后拿，获得的分数
        if(i==j)&#123;
            return 0;
        &#125;
        //对方拿走一张（i或者j）后，聪明人成了先拿的人，对方也是聪明人，会留下最差的情况
        return Math.min(f(arr,i+1,j),f(arr,i,j-1));
    &#125;

    /*
     * DP
     */
    public static int win2(int[] arr)&#123;
    	int N = arr.length;
		int[][] fmap = new int[N][N];
		int[][] gmap = new int[N][N];
		
		
		//先处理L == R （gmap在初始化就是0，不用管
		for(int i = 0; i &lt;= N - 1; i++)&#123;
			fmap[i][i] = arr[i];
		&#125;
		//按着对角线来一步步求！！！
		for (int startCol = 1; startCol &lt; N; startCol++) &#123;
			int L = 0;
			int R = startCol;
			while (R &lt; N) &#123;
				fmap[L][R] = Math.max(arr[L] + gmap[L + 1][R], arr[R] + gmap[L][R - 1]);
				gmap[L][R] = Math.min(fmap[L + 1][R], fmap[L][R - 1]);
				L++;
				R++;
			&#125;
		&#125;
		return Math.max(fmap[0][N - 1], gmap[0][N-1]);
    &#125;
&#125;

3 排序
-快速排序-
1.0 partition

partition 以arr[R] 为界分为 &lt;=arr[R]   arr[R]    &gt;arr[R] 三个部分
每次可以找到一个位置的数

public static int partition(int[] arr, int L, int R) &#123;
    if (L > R) &#123;
        return -1;
    &#125;
    if (L == R) &#123;
        return L;
    &#125;
    int lessEqual = L - 1;
    int index = L;
    while (index &lt; R) &#123;
        if (arr[index] &lt;= arr[R]) &#123;
            swap(arr, index, ++lessEqual);
        &#125;
        index++;
    &#125;
    swap(arr, ++lessEqual, R);
    return lessEqual;
&#125;

public static void quickSort1(int[] arr) &#123;
    if (arr == null || arr.length &lt; 2) &#123;
        return;
    &#125;
    process1(arr, 0, arr.length - 1);
&#125;

public static void process1(int[] arr, int L, int R) &#123;
    if (L >= R) &#123;
        return;
    &#125;
    // L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    >arr[R]  ]
    int M = partition(arr, L, R);
    process1(arr, L, M - 1);
    process1(arr, M + 1, R);
&#125;
2.0 荷兰国旗

在[l, r]上以arr[R]为界 将数组分为&lt; = &gt; 三个部分
每次可以找到中间等等于那部分的数

public static int[] netherlandsFlag(int[] arr, int L, int R) &#123;
  if(L > R) &#123;return new int[]&#123;-1, -1&#125;;&#125;
  if(L == R) &#123;return new int[]&#123;L, R&#125;;&#125;
  int less = L - 1;
  int index = L;
  int more = R;
 	while(index &lt; more) &#123; // !!! index &lt; more
    if(arr[index] == arr[R]) &#123;// 1 == 情况 index++
      index++;
    &#125; else if(arr[index] &lt; arr[R]) &#123; // 2 &lt; 情况 交换index和less的右边 然后index++
      swap(arr, index, ++less);
      index++;
    &#125; else&#123; // 3 > 情况 交换index和more左边  不用index++！
      swap(arr, index, --more);
    &#125;
  &#125;
  swap(arr, R, more);
  return new int[]&#123;	less+1, more&#125;; // ！！！
&#125;
随机快排

在荷兰国旗基础上 将数组的arr[R]进行随机交换 然后递归将数组所有部分都排完
最终期望求出来的复杂度就是O(logN*N)

public static void quickSort(int[] arr) &#123;
  if(arr == null || arr.length == 0) &#123;
    return;
  &#125;
  process(arr, 0, arr.length - 1);
&#125;

public static void proces(int[] arr, int L, int R) &#123;
  if(L > R) &#123;return;&#125;
  // 随机交换
  int random = L + Math.random() * (R - L + 1);
  swap(arr, R, random);
  int[] area = netherlandsFlag(arr, L, R);
  process(arr, L, area[0] - 1);
  process(arr, area[1] + 1, R);
&#125;

递归版本

迭代，自己压栈，把任务做了然后再放出来
最开始做一次递归里做的 然后在迭代过程中再做递归里做的

// 定义任务
public static class Op&#123;
  public int L;
  public int R;
  public Op(int left, int right) &#123;
    L = left;
    R = right;
  &#125;
&#125;

// 压栈：开始是从[0,N - 1]
public static void quickSort2(int[] arr) &#123;
  if(...) &#123;return;&#125;
  int N = arr.length;
  // 随机交换 分界
  int random = (int)(Math.random() * N);
  swap(arr, N - 1, random);
  int[] area = netherlandsFlag(arr, 0, N - 1);
  
  Stack&lt;Op> stack = new Stack&lt;>();
  stack.push(new Op(0, area[0]-1));
  stack.push(new Op(area[1]+1, N - 1));
  
  while(!stack.isEmpty()) &#123;
    Op op = stack.pop();
    if(op.L &lt; op.R) &#123;
      // 随机交换和分界
      random = op.L + (int)(Math.random() * (op.R - op.L + 1));
      swap(arr, op.R, random);
      area = netherlandsFlag(arr, op.L, op.R);
      
      stack.push(new Op(op.L, area[0]-1));
  		stack.push(new Op(area[1]+1, op.R));
      
    &#125;
  &#125;
    
&#125;
&lt;随机快排的时间复杂度分析&gt;
1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差
2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N
4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！
时间复杂度O(N logN)，额外空间复杂度O(logN)都是这么来的。*
!!! ==找到数组中的第k个最大元素==
⚠️是k大还是k小
改写快速排序
时间复杂度O(N)
1 原先数组不能改变 复制一个新数组
2 随机选一个数来分区
3 分区: 返回两个边界 partition
4 如果分区中间=部分包含k 就找到了
没有就根据k与边界大小比较大小去其中一部分去找
public int findKthLargest(int[] array, int k) &#123;
       // 1 原来的数组不好更改
       int[] arr = copyArray(array);
       return process2(arr, 0, arr.length - 1, arr.length - k);// k 小的话就 k - 1
   &#125;   
   // 2 partition分区返回两个边界 分区中间等于部分包含k 就是找到了
   public static int process2(int[] arr, int L, int R, int index) &#123;
       if(L == R) &#123;
           return arr[L];
       &#125;
       int random = L + (int)(Math.random() * (R - L + 1));
       int[] area = partition(arr, L, R, arr[random]);
       
     	
       if(index >= area[0] &amp;&amp; index &lt;= area[1]) &#123;
           return arr[index];
       &#125; else if(index &lt; area[0]) &#123;// 没有找到就到另外两个部分继续找
           return process2(arr, L, area[0] - 1, index);
       &#125; else &#123;
           return process2(arr, area[1] + 1, R, index);
       &#125;
   &#125;
注意这里的partition

因为是使用num来分区 所以边界注意⚠️对比快排用arr[R]来分区

public static int[] partition(int[] arr, int L , int R, int num) &#123;
    int less = L - 1;
    int more = R + 1; //！！
    int index = L;
    while(index &lt; more) &#123;
        if(arr[index] &lt; num) &#123;
            swap(arr, index, ++less);
            index++;
        &#125;else if(arr[index] > num) &#123;
            swap(arr, index, --more);
        &#125;else&#123;
            index++;
        &#125;
    &#125;
  // 快排还需要交换more和R
    return new int[]&#123;less + 1, more - 1&#125;; //！！！ 返回的右边界是more - 1 快排是more
&#125;

BFPRT(面试聊)
俗称&quot;中位数之中位数算法&quot;。依靠一种精心设计的 pivot 选取方法，该算法从理论上保证了最坏情形下的线性时间复杂度，打败了平均线性、最坏 O(n^2) 复杂度的传统算法

bfprt算法


改进部分就是将快排中随机选数的过程改为五个一组 分组组中排好序


找出每一段的中位数 组成m[]


找到m的中位数返回


medianOfMedian():
// 1 arr[L…R] 五个数一组
// 2 每个小组内部排序，找到中位数领出来，组成m
// 3 m[]中，找到中位数 反调bfprt



public static int process(int[] arr, int L, int R, int index)&#123;
    if(L == R)&#123;
        return arr[L];
    &#125;
    // 改进部分：随机部分改成一个方法
    int r = medianOfMedian(arr, L ,R);
  
    int[] range = partition(arr, L, R, r);

    if(index >= range[0] &amp;&amp; index &lt;= range[1])&#123;
        return arr[index];
    &#125; else if (index &lt; range[0])&#123;
        return process(arr, L , range[0] - 1, index);
    &#125; else &#123;
        return process(arr, range[1] + 1, R, index);
    &#125;
&#125;

// 1 arr[L...R] 五个数一组 
// 2 每个小组内部排序，找到中位数领出来，组成m 
// 3 m[]中，找到中位数 反调bfprt
private static int medianOfMedian(int[] arr, int L, int R) &#123;
    int size = R - L + 1;
    // 1
    int offset = size % 5 == 0 ? 0 : 1;
    int[] m = new int[size/5 + offset];
    // 2
    for(int i = 0; i &lt; m.length - 1; i++)&#123;
        int first = L + i * 5;
        m[i] = sortAndMedian(arr, first, Math.min(R, first + 4));
    &#125;
    // 3
    return process(m, 0, m.length - 1, m.length / 2);
&#125;

public static int sortAndMedian(int[] arr, int L, int R) &#123;
    // SORT
    for (int i = L + 1; i &lt;= R; i++) &#123;
        for (int j = i - 1; j >= L &amp;&amp; arr[j] > arr[j + 1]; j--) &#123;
            swap(arr, j, j + 1);
        &#125;
    &#125;
    // MEDIAN
    return arr[(L + R) / 2];
&#125;
-堆排序-
/**
     * 1 从下至上让整个数组变为大根堆 并将堆顶(max)与结尾交换 再去重新调整
     * 2 遍历调整 直到heapSize = 0
     * @param arr
     */
public static void heapSort(int[] arr) &#123;
        if (arr.length &lt; 2 || arr == null) &#123;
            return;
        &#125;
        int heapSize = arr.length;

        // 1
        for (int i = arr.length - 1; i >= 0; i--) &#123;
            heapify(arr, i, arr.length);
        &#125;
        swap(arr, 0, --heapSize);

        // 2
        while(heapSize > 0)&#123;
            heapify(arr, 0, heapSize);
            swap(arr, 0, --heapSize);
        &#125;
    &#125;

    // 从下到上将整个数组变为大根堆结构
    private static void heapify(int[] arr, int i, int heapSize) &#123;
        //先找到左孩子 如果有孩子 将最大的找到并与根比较 谁大放在上面
        int left = 2 * i + 1;
        while(left &lt; heapSize)&#123;
            int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] > arr[left] ? left + 1 : left;
            largest = arr[largest] > arr[i] ? largest : i;
            if(largest == i)&#123;
                break;
            &#125;
            swap(arr, largest, i);
            i = largest;
            left = 432 * i + 1;
        &#125;

    &#125;

    private static void swap(int[] arr, int largest, int i) &#123;
        // TODO Auto-generated method stub
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
    &#125;


-归并排序-

1）整体是递归，左边排好序+右边排好序+merge让整体有序
2）让其整体有序的过程里用了排外序方法
3）利用master公式来求解时间复杂度
4）当然可以用非递归实现

递归版本
// 递归方法实现
public static void mergeSort1(int[] arr) &#123;
    if (arr == null || arr.length &lt; 2) &#123;
        return;
    &#125;
    process(arr, 0, arr.length - 1);
&#125;

// arr[L...R]范围上，变成有序的
// L...R    N    T(N) = 2*T(N/2) + O(N)  ->
public static void process(int[] arr, int L, int R) &#123;
    if (L == R) &#123; // base case
        return;
    &#125;
    int mid = L + ((R - L) >> 1);
    process(arr, L, mid);
    process(arr, mid + 1, R);
    merge(arr, L, mid, R);
&#125;

public static void merge(int[] arr, int L, int M, int R) &#123;
    int[] help = new int[R - L + 1];
    int i = 0;
    int p1 = L;
    int p2 = M + 1;
    while (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;
        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];
    &#125;
    // 要么p1越界了，要么p2越界了
    while (p1 &lt;= M) &#123;
        help[i++] = arr[p1++];
    &#125;
    while (p2 &lt;= R) &#123;
        help[i++] = arr[p2++];
    &#125;
    for (i = 0; i &lt; help.length; i++) &#123;
        arr[L + i] = help[i];
    &#125;
&#125;
非递归版本
流程就在于折腾  步长 这个概念
步长 = 1 开始, 步长的变化一定是2的某次方
最后一组: 凑不齐左组就不管了, 右组有多少算多少
步长一旦超过总长度, 说明搞完了, 停止就行了
public static void mergeSort3(int[] arr) &#123;
    if (arr == null || arr.length &lt; 2) &#123;
        return;
    &#125;
    int N = arr.length;
    int step = 1;
    while (step &lt; N) &#123;
        int L = 0;
        while (L &lt; N) &#123;
            int M = 0;
            if ( N - L >= step) &#123;
                M = L + step - 1;
            &#125; else &#123;
                M = N - 1;
            &#125;
            if (M == N -1) break;

            int R = 0;
            if (N -1 - M >= step) &#123;
                R = M + step;
            &#125; else &#123;
                R = N - 1;
            &#125;
            merge(arr, L, M, R);
            if (R == N - 1) &#123;
                break;
            &#125; else &#123;
                L = R + 1;
            &#125;
        &#125;
        if (step > N / 2) &#123;
            break;
        &#125;
        step &lt;&lt;= 1;
    &#125;
&#125;
注意最后一组左组: L + step - 1 可能越界
从右往左合并就不用考虑越界问题了
if (step &gt; N &#x2F; 2) &#123;
    break;
&#125;
此处不用等号的原因:
如果17个数, 最后一个调整是步长为16的时候的调整:
前16个数做左组, 后一个数做右组
而 N/2 是向下取整的, 17/2 =8 , 所以 mergeSize &gt;= N / 2,
在等于的时候就停止的话, 最后一个步长是8, 不会有最后一个步长为16的时候, 导致你出错了
优化后的最终版本
// 非递归方法实现
public static void mergeSort2(int[] arr) &#123;
    if (arr == null || arr.length &lt; 2) &#123;
        return;
    &#125;
    int N = arr.length;
    int mergeSize = 1;// 当前有序的，左组长度
    // 一组是2倍的mergeSize
    while (mergeSize &lt; N) &#123; // log N
        int L = 0;
        // 0.... 
        while (L &lt; N) &#123;
            // L...M  左组（mergeSize）
            int M = L + mergeSize - 1;
            if (M >= N) &#123; // 当前组凑不齐,只有左边, 肯定有序
                break;    // 预防越界风险
            &#125;
            //  L...M   M+1...R(mergeSize)
            // 有可能最后一组右组数目不够
            int R = Math.min(M + mergeSize, N - 1);
            merge(arr, L, M, R);
            L = R + 1; // 下一次左组
        &#125;
        // 防止溢出, INT_MAX
        if (mergeSize > N / 2) &#123;
            break;
        &#125;
        mergeSize &lt;&lt;= 1;
    &#125;
&#125;
复杂度
一共执行次数  log2Nlog_2Nlog2​N, merge 一次的复杂度 O(N)
总的复杂度: O(N∗logN)O(N*logN)O(N∗logN)
-前缀树-
1）单个字符串中，字符从前到后的加到一棵多叉树上
2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）
3）所有样本都这样添加，如果没有路就新建，如有路就复用
4）沿途节点的pass值增加1，每个字符串结束时来-到的节点end值增加1
可以完成前缀相关的查询
例子
设计一种结构。用户可以：
1）void insert(String str)            添加某个字符串，可以重复添加，每次算1个
2）int search(String str)             查询某个字符串在结构中还有几个
3) void delete(String str)           删掉某个字符串，可以重复删除，每次算1个
4）int prefixNumber(String str)       查询有多少个字符串，是以str做前缀的
前缀树的实现方式
public static class Node &#123;
        public int pass;// 经过几次
        public int end;// 作为end几次
        public Node[] nexts; // 后面的数组

        public Node()&#123;
            pass = 0;
            end = 0;
            nexts = new Node[26];// 一条最长就26 所以这个方式不适合很多类型的节点
        &#125;

    &#125;

    public static class Trie1&#123;
        private Node root;// 头节点

        // 构造方法
        public Trie1()&#123;
            root = new Node();
        &#125;

        /*
         * insert()
         */
        // 1 先抓住头节点  pass ++ 
        // 2 从左向右遍历字符，next[path]== null则新建节点 pass++
        // 3 最后end++
        public void insert(String word)&#123;
            if(word == null)&#123;
                return;
            &#125;
            char[] str = word.toCharArray();
            Node node = root;
            node.pass++;
            int path = 0;

            for(int i = 0; i &lt; str.length; i++)&#123;
                path = str[i] - 'a';
                if(node.nexts[path] == null)&#123;
                    node.nexts[path] = new Node();
                &#125;
                node = node.nexts[path];
                node.pass++;
            &#125;
            node.end++;
        &#125;

        /*
         * search():查找word出现了几次
         */
        public int search(String word)&#123;
            if(word ==  null)&#123;
                return 0;
            &#125;
            char[] str = word.toCharArray();
            Node node = root;
            int path = 0;
            for(int i = 0; i &lt; str.length; i++)&#123;
                path = str[i] - 'a';
                if(node.nexts[path] == null)&#123;
                    return 0;
                &#125;
                node = node.nexts[path];
            &#125;
            return node.end;
        &#125;

        /*
         * delete() 内存泄漏问题jvm可以解决的
         */
        // 1 先search是否存在
        // 2 遍历经过要把pass-- 且当pass==0时将next[path]置空，后面的节点JVM自动会清除
        // 3 end --
        public void delete(String word)&#123;
            if(this.search(word) != 0)&#123;
                char[] str = word.toCharArray();
                Node node = root;
                node.pass--;
                int path = 0;
                for(int i = 0; i &lt; str.length; i++)&#123;
                    path = str[i] - 'a';
                    if(--node.nexts[path].pass == 0)&#123;
                        node.nexts[path] = null;
                        return;
                    &#125;
                    node = node.nexts[path];
                &#125;
                node.end--;

            &#125;
        &#125;

        /*
         * prefixNode:有几个是以pre作为前缀的字符
         * 
         */
        //和search步骤差不多 最后return的是pass
        public int prefixNode(String pre)&#123;
            Node node = root;
            int path = 0;
            char[] str = pre.toCharArray();
            for(int i = 0; i &lt; str.length;i++)&#123;
                path = str[i] - 'a';
                if(node.nexts[path] == null)&#123;
                    return 0;
                &#125;
                node = node.nexts[path];
            &#125;
            return node.pass;
        &#125;

    &#125;
-（桶排序）不基于比较的-
桶排序思想下的排序：计数排序 &amp; 基数排序
1)桶排序思想下的排序都是不基于比较的排序
2)时间复杂度为O(N)，额外空间负载度O(M)
3)应用范围有限，需要样本的数据状况满足桶的划分
计数排序和基数排序
题目3: 计数排序
计数排序要求，样本是整数，且范围比较窄
// only for 0~200 value
public static void countSort(int[] arr) &#123;
    if (arr == null || arr.length &lt; 2) &#123;
        return;
    &#125;
    int max = Integer.MIN_VALUE;
    for (int i = 0; i &lt; arr.length; i++) &#123;
        max = Math.max(max, arr[i]);
    &#125;
    int[] bucket = new int[max + 1];
    for (int i = 0; i &lt; arr.length; i++) &#123;
        bucket[arr[i]]++;
    &#125;
    int i = 0;
    for (int j = 0; j &lt; bucket.length; j++) &#123;
        while (bucket[j]-- > 0) &#123;
            arr[i++] = j;
        &#125;
    &#125;
&#125;
题目4: 基数排序代码
一般来讲，基数排序要求，样本是10进制的正整数
// only for no-negative value
public static void radixSort(int[] arr) &#123;
    if (arr == null || arr.length &lt; 2) &#123;
        return;
    &#125;
    radixSort(arr, 0, arr.length - 1, maxbits(arr));
&#125;

public static int maxbits(int[] arr) &#123;
    int max = Integer.MIN_VALUE;
    for (int i = 0; i &lt; arr.length; i++) &#123;
        max = Math.max(max, arr[i]);
    &#125;
    int res = 0;
    while (max != 0) &#123;
        res++;
        max /= 10;
    &#125;
    return res;
&#125;

// arr[l..r]排序  ,  digit
// l..r    3 56 17 100    3
public static void radixSort(int[] arr, int L, int R, int digit) &#123;
    final int radix = 10;
    int i = 0, j = 0;
    // 有多少个数准备多少个辅助空间
    int[] help = new int[R - L + 1];
    for (int d = 1; d &lt;= digit; d++) &#123; // 有多少位就进出几次
        // 10个空间
        // count[0] 当前位(d位)是0的数字有多少个
        // count[1] 当前位(d位)是(0和1)的数字有多少个
        // count[2] 当前位(d位)是(0、1和2)的数字有多少个
        // count[i] 当前位(d位)是(0~i)的数字有多少个
        int[] count = new int[radix]; // count[0..9]
        for (i = L; i &lt;= R; i++) &#123;
            // 103  1   3
            // 209  1   9
            j = getDigit(arr[i], d);
            count[j]++;
        &#125;
        for (i = 1; i &lt; radix; i++) &#123;
            count[i] = count[i] + count[i - 1];
        &#125;
        for (i = R; i >= L; i--) &#123;
            j = getDigit(arr[i], d);
            help[count[j] - 1] = arr[i];
            count[j]--;
        &#125;
        for (i = L, j = 0; i &lt;= R; i++, j++) &#123;
            arr[i] = help[j];
        &#125;
    &#125;
&#125;

public static int getDigit(int x, int d) &#123;
    return ((x / ((int) Math.pow(10, d - 1))) % 10);
&#125;
1）一般来讲，计数排序要求，样本是整数，且范围比较窄
2）一般来讲，基数排序要求，样本是10进制的正整数
一旦要求稍有升级，改写代价增加是显而易见的
排序算法的稳定性
稳定性是指同样大小的样本再排序之后不会改变相对次序
对基础类型来说，稳定性毫无意义
对非基础类型来说，稳定性有重要意义
有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的
排序算法总结




时间复杂度
额外空间复杂度
稳定性




选择排序
O(N^2)
O(1)
无


冒泡排序
O(N^2)
O(1)
有


插入排序
O(N^2)
O(1)
有


归并排序
O(N* logN)
O(N)
有


随机快排
O(N* logN)
O(logN)
无


堆排序
O(N* logN)
O(1)
无








计数排序
O(N)
O(M)
有


基数排序
O(N)
O(N)
有



1）不基于比较的排序，对样本数据有严格要求，不易改写
2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3）基于比较的排序，时间复杂度的极限是O(N∗logN)
4）时间复杂度O(N∗logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存 在的。
5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并
4 滑动窗口
滑动窗口更新结构
1 无重复数组的最长子串

给定一个字符串 找出里面没有重复的最长子串

// 1 使用窗口 因为不重复 可以用hashset来存储 结果集是char[] str
// 2 遍历数组 L 向右
// 2.1 R向右遍历:更新表
// 2.2 更新max、更新set:删除头
public static int lengthOfLongestSubstring(String s) &#123;
	if(s.length() == 0 || s ==  "")&#123;
		return 0;
	&#125;
	// 1
	HashSet&lt;Character> set = new HashSet&lt;Character>();
	char[] str = s.toCharArray();
	int ans = 0;
	int L = 0;
	int R = 0;
	// 2
	while(L &lt; str.length)&#123;
		// 2.1
		while(R &lt; str.length &amp;&amp; !set.contains(str[R]))&#123; // !!! 注意是不包含
			set.add(str[R]);
			R++;
		&#125;
		
		// 2.2
		ans = Math.max(ans, R - L );
		set.remove(str[L]);
		L++;
	&#125;
	return ans;		
	
&#125;

动态规划版
使用256数组进行存储 先都初始化为-1 下标是字符串值
public static int lengthOfLongestSubstring2(String s) &#123;
	if (s.length() == 0 || s == "") &#123;
		return 0;
	&#125;
	
	char[] str = s.toCharArray();
	int[] map = new int[256];
	for (int i = 0; i &lt; 256; i++) &#123;
		map[i] = -1;
	&#125;
	map[str[0]] = 0;
	int N = str.length;
	int ans = 1;
	int pre = 1;
	for (int i = 1; i &lt; N; i++) &#123;
		pre = Math.min(i - map[str[i]], pre + 1);
		ans = Math.max(ans, pre);
		map[str[i]] = i;	&#125;
	return ans;

&#125;
2 最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。

  // 1 使用map[256]来记录 t中需要的每种字符的数量;
	//all来记录所有字符剩下没找到的数量；start记录最小子串开头下标
	// 2 遍历字符集  L = 0 遍历 R 向右 
	// 2.1 右边界扩大 同时map相应-- 并且没有减到0的话all--
	// 2.2 当all还完之后 要将左边界缩小 
	// 2.2.1 map对应的str[L] 左边界有可能有重复值 对应map小于0 要缩到不能缩的地方
	// 2.2.2 更新minLen 和开头start 
	// 2.2.3 左边界L++、map对应++、 all++	
public static String minLength2(String s1, String s2) &#123;
		if (s1 == null || s2 == null || s1.length() &lt; s2.length()) &#123;
			return "";
		&#125;
		char[] str1 = s1.toCharArray();
		char[] str2 = s2.toCharArray();
		// 1
		int[] map = new int[256]; // map[37] = 4  37  4次
		for (int i = 0; i != str2.length; i++) &#123;
			map[str2[i]]++;
		&#125;
		int all = str2.length;
		
		int L = 0;
		int R = 0;// [L,R)  -> [0,0)
		int minLen = Integer.MAX_VALUE;
		int start = 0;// 记录最小子串开头下标 
		// 2
		while (R != str1.length) &#123;
			// 2.1
			map[str1[R]]--;
			if (map[str1[R]] >= 0) &#123;
				all--;
			&#125;
			// 2.2
			if (all == 0) &#123; // 还完了 就是一个解
				// 2.2.1
				while (map[str1[L]] &lt; 0) &#123;// ！！！左边界有可能有重复值 对应的map就是小于0的 我们要避免 所以缩到没有重复的地方才开始记录minlen
					map[str1[L]]++;
         	L++;
				&#125;
				// 2.2.2
				if(minLen > R - L + 1)&#123; 
					minLen = R - L + 1;
					start = L;
				&#125;
				// 2.2.3
				all++;
				map[str1[L++]]++;
			&#125;
			R++;
		&#125;
		return minLen == Integer.MAX_VALUE ? "" : s1.substring(start, start + minLen);
	&#125;
就是all还完之前r++往右展开 all==0 就要l++ 往左边缩

3 滑动窗口的最大值

假设一个固定大小为W的窗口;依次划过arr 返回每一次滑出状况的最大值

定义一个队列来作为窗口，里面放的是下标
循环遍历数组： L R边界
\1) 当窗口不为空&amp;窗口结尾小于当前R 结尾弹出（window是单调递减）
\2) 添加arr[R]
\3) 当队首元素已经不再滑动窗口内，将其从队首移除
\4) 当窗口右边界right+1大于等于窗口大小k时窗口形成。此时，队首元素就是该窗口内的最大值。
if( arr == null || w &lt; 1 || arr.length == 0 )&#123;
        return null;
    &#125;

    // 1
    LinkedList&lt;Integer> window = new LinkedList&lt;>();
    int[] res = new int[arr.length - w + 1];

    // 2
    for(int R = 0; R &lt; arr.length; R++)&#123;
        // 1)
        while(!window.isEmpty() &amp;&amp; arr[window.peekLast()] &lt; arr[R])&#123;
            window.pollLast();
        &#125;
        // 2)
        window.addLast(R);
        int L = R - w + 1;
        // 3)
        if(window.peekFirst() &lt; L)&#123;
            window.pollFirst();
        &#125;
        // 4)
        if(R >= w - 1)&#123;
            res[L] = arr[window.peekFirst()];
        &#125;
    &#125;
    return res;
4 满足绝对值差达标的子数组数量

给定一个整型数组arr, 和一个整数num 某一个arr中的子数组sub 如果想达标必须满足 sub中最大值 - sub中国最小值 &lt;= num 返回arr中达标子数组的数量

public class SW_AllLessNumSubArray &#123;
	// 1 需要两个双端队列来存储max和min
	// 2 遍历数组每一个数都做一次L开头
	// 2.1 往右R直到当前窗口内子数组不达标
	// 2.1.1 滑动窗口比较弹出末尾添加当前值
	// 2.1.2 不达标要break
	// 2.2 到达了不达标的位置 就可以结束当前L开头的收集 并弹出开头
	// 2.2.1 更新res:对收集达标的数组个数 进行累加
	// 2.2.2 更新窗口:弹出L开头
	public static int allLessNumSubArray(int[] arr, int num) &#123;
		if (arr.length == 0 || arr == null) &#123;
			return 0;
		&#125;
		// 1 
		LinkedList&lt;Integer> qmin = new LinkedList&lt;>();
		LinkedList&lt;Integer> qmax = new LinkedList&lt;>();
		int L = 0;
		int R = 0;
		int res = 0;

		// 2 
		while (L &lt; arr.length) &#123;
			// 2.1
			while (R &lt; arr.length) &#123;
				// 2.1.1
				while (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) &#123;
					qmax.pollLast();
				&#125;
				qmax.addLast(R);
				while (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] >= arr[R]) &#123;
					qmin.pollLast();
				&#125;
				qmin.addLast(R);
				// 2.1.2
				if (arr[qmax.getFirst()] - arr[qmin.getFirst()] > num) &#123;
					break;
				&#125;
				R++;
			&#125;

			// 2.2
			// 2.2.1
			res += R - L;
			// 2.2.2
			if (qmax.peekFirst() == L) &#123;
				qmax.pollFirst();
			&#125;
			if (qmin.peekFirst() == L) &#123;
				qmin.pollFirst();
			&#125;
			L++;
		&#125;
		return res;
	&#125;
&#125;
5 二叉树
public class TreeNode&#123;
  private int val;
  private TreeNode left;
  private TreeNode right;
  public TreeNode(int val, int left, int right) &#123;
    this.val = val;
    this.left = left;
    this.right = right;
  &#125;
&#125;
1 二叉树先、中、后序遍历(DFS)
递归
public void process(TreeNode head)&#123;
  // 前
  process(head.left);
  // 中
  process(head.right);
  // 后
&#125;
非递归(压栈)

先： 先压右再压左 输出—》头左右

public void front(TreeNode head) &#123;
  if(head == null) &#123;
    return;
  &#125;
  Stack&lt;TreeNode> stack = new Stack&lt;>();
  stack.push(head);
  while(!stack.isEmpty()) &#123;
    TreeNode cur = stack.pop();
    // 打印 
    sysout();
    if(cur.right != null) &#123; // !!! 判空
      stack.push(cur.right);
    &#125;
    if(cur.left != null) &#123; // !!! 判空
      stack.push(cur.left);
    &#125;
  &#125;
  return;
&#125;

后：用两个栈 1）先压左再压右 同时答应弹出改为压入另一个栈 输出—》 头右左 2）最后输出的时候就是左右头  头左右

public void process(TreeNode head) &#123;
  if(head == null) &#123;return;&#125;
  Stack&lt;TreeNode> stack = new Stack&lt;>();
  Stack&lt;TreeNode> stack2 = new Stack&lt;>();
  while(!stack.isEmpty()) &#123;
    TreeNode cur = stack.pop();
    // 前序打印行为改成压栈
    stack2.push(cur.val);
    if(cur.left != null) &#123; // 左
      stack.push(cur.left);
    &#125;
    if(cur.right != null) &#123;// 右
      stack.push(cur.right);
    &#125;
  &#125;
  // 栈2 弹出打印
  while(!stack2.isEmpty()) &#123;
    TreeNode cur = stack.pop();
    // 打印
    sysout();
  &#125;
  return;
&#125;


中： 1）先将左边界压入栈 2）直到null，弹出并打印进入右树



public void process(TreeNode head) &#123;
  if(head != null) &#123;
    Stack&lt;TreeNode> stack = new Stack&lt;>();// ⚠️一开始不用塞head
    while(!stack.isEmpty() || head != null) &#123;
      if(head != null) &#123;
        stack.push(head);
        head = head.left;
      &#125; else&#123; // 空了 就弹出打印 进入右边
        head = stack.pop();
        sysout(head.val);
        head = head.right;
      &#125;
    &#125;
  &#125;
  return;
&#125;
二叉搜索树也可以用这个
2 二叉树的层序遍历(BFS）
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）
 
1) 打印每一层

给你二叉树的根节点root， 返回其节点值的层序遍历，就是逐层打印

1.先定义结果集res 和判空操作
2.定义队列容器，head放入队列中。
3.定义结果集元素list 即每一层。
public static List&lt;List&lt;Integer>> levelOrder(TreeNode head) &#123;
		// 1
		List&lt;List&lt;Integer>> res = new ArrayList&lt;>();
		if (head == null) &#123;
			return res;
		&#125;

		// 2
		Queue&lt;TreeNode> q = new LinkedList&lt;>();
		q.add(head);

		// 3
		while (!q.isEmpty()) &#123;
			int size = q.size();
			List&lt;Integer> list = new ArrayList&lt;>();
			for (int i = 0; i &lt; size; i++) &#123; // size !!!
				TreeNode cur = q.poll();
				list.add(cur.val);
				if (cur.left != null) &#123;
					q.add(cur.left);
				&#125;
				if (cur.right != null) &#123;
					q.add(cur.right);
				&#125;
			&#125;
			res.add(list);
		&#125;
		return res;
	&#125;
二叉树的锯齿形遍历

就是在层序遍历基础上 使用flag来判断打印的顺序 ⚠️list.add(0, root.val) 就是添加到开头

public List&lt;List&lt;Integer>> zigzagLevelOrder(TreeNode root) &#123;
     List&lt;List&lt;Integer>> res = new ArrayList&lt;List&lt;Integer>>();
     if(root == null)&#123;
         return res;
     &#125;
     Queue&lt;TreeNode> queue = new LinkedList&lt;TreeNode>();
     queue.add(root);
     boolean flag = true;
     while(! queue.isEmpty())&#123;
         List&lt;Integer> list = new ArrayList&lt;Integer>();
         int size = queue.size();
         for(int i = 0; i &lt; size; ++i)&#123;
             root =  queue.poll();
             if(flag)&#123;//通过flag判断打印顺序
                 list.add(root.val);
             &#125;else&#123;
                 list.add(0, root.val);// ！！！
             &#125;
             if(root.left != null)&#123;
                 queue.add(root.left);
             &#125;
             if(root.right != null)&#123;
                 queue.add(root.right);
             &#125;

         &#125;
         flag = !flag;//这里易错
         res.add(list);
     &#125;
     return res;
 &#125;
2）返回节点最多的那一层

需要curEnd记录是否当前到层的结尾 需要nextEnd记录下一层的最后节点
将上面层序遍历添加每层元素的过程改为记录层的curSize
当cur == curEnd 时 更新 ans (maxWidth

public static int maxWidth(TreeNode head) &#123;
  int ans = 0;
  if(head == null) &#123;
    return ans;
  &#125;
 int curSize = 0;
  
&#125;
3）二叉树的右视图

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。


需要curEnd记录是否当前到层的结尾 需要nextEnd记录下一层的最后节点
List&lt;Integer> res = new ArrayList&lt;>();
		if (head == null) &#123;
			return res;
		&#125;

		// 1
		TreeNode curEnd = head;
		TreeNode nextEnd = null;

		Queue&lt;TreeNode> q = new LinkedList&lt;>();
		q.add(head);

		while (!q.isEmpty()) &#123;
			TreeNode cur = q.poll();
			// 2 用nextEnd记录最后一个节点
			if (cur.left != null) &#123;
				q.add(cur.left);
				nextEnd = cur.left;
			&#125;
			if (cur.right != null) &#123;
				q.add(cur.right);
				nextEnd = cur.right;
			&#125;

			// 3 更新当前最后的节点
			if (cur == curEnd) &#123;
				res.add(cur.val);
				curEnd = nextEnd;
			&#125;
		&#125;
		return res;
4）最大宽度（左右节点的距离）

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。
每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。
避免不了要记录每一个节点的index 所以需要一个新的节点结构

newnode&#123;

​	treenode node;

​	int level;

​	int pos;

&#125;



在层序遍历基础上 队列添加的是一个新的节点结构来对每个节点的层数和position进行记录 不需要


每次队列进行一次poll循环都要检查 如果curlever != cur.level 说明到了下一层，将curlevel更新，用first抓住第一个的pos


更新max


public int widthOfBinaryTree(TreeNode root) &#123;
        Queue&lt;NewNode> q = new LinkedList&lt;>();
        q.add(new NewNode(root, 0, 0)); // ⚠️一开始添加的就是newnode

        int ans = 0; 
        int curlevel = 0; // 记录当前层
        int firstpos = 0; // 记录每层最前
        
        while(!q.isEmpty())&#123;
            NewNode cur = q.poll();
            if(cur.node.left != null)&#123;
                q.add(new NewNode(cur.node.left, cur.level + 1, cur.pos * 2)); // ⚠️结构不能搞错 参数不要穿错
            &#125;
            if(cur.node.right != null)&#123;
                q.add(new NewNode(cur.node.right, cur.level + 1 , cur.pos * 2 + 1)); // ⚠️
            &#125;
            
            if(curlevel != cur.level)&#123;
                curlevel = cur.level;
                firstpos = cur.pos;
            &#125;

            ans = Math.max(ans, cur.pos - firstpos + 1);            
        &#125;
        return ans;
    &#125;

    public class NewNode&#123;
        private TreeNode node;
        private int level;
        private int pos;
        public NewNode(TreeNode node, int level, int pos)&#123;
            this.node = node;
            this.level = level;
            this.pos = pos;
        &#125;
    &#125;
3 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

Info&#123;boolean findP, boolean findQ, treenode ans&#125;
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
       return process(root,p,q).ans;
   &#125;

public static class Info&#123;
	public boolean findP;// 是否包含p
	public boolean findQ;// 是否包含q
	public TreeNode ans;// 保存结果
	public Info(boolean findP, boolean findQ, TreeNode ans)&#123;
		this.findP = findP;
		this.findQ = findQ;
		this.ans = ans;
	&#125;
&#125;
private Info process(TreeNode root, TreeNode p, TreeNode q) &#123;
	
	if(root == null)&#123;
		return new Info(false, false, null);
	&#125;
	
	Info leftInfo = process(root.left, p, q);
	Info rightInfo = process(root.right, p, q);
	
   // 填充当前info
	boolean findP = leftInfo.findP || rightInfo.findP || (root == p);
	boolean findQ = leftInfo.findQ || rightInfo.findQ || (root == q);
	
	TreeNode ans = null;
	if(leftInfo.ans != null)&#123;// leftInfo.findP &amp;&amp; leftInfo.findQ
		ans = leftInfo.ans;
	&#125;else if(rightInfo.ans != null)&#123; // rightInfo.findP &amp;&amp; rightInfo.findQ
		ans = rightInfo.ans;
	&#125;else if(findP &amp;&amp; findQ)&#123;
		ans = root;
	&#125;
	return new Info(findP, findQ, ans);
&#125;
4 二叉树最大路径和

public int maxPathSum(TreeNode root) &#123;
       if(root == null)&#123;
           return 0;
       &#125;
       return process(root).maxSum;
   &#125;
   public static class Info&#123; // z
	public int maxGain;//如果连上父节点的贡献值
	public int maxSum ;
	public Info(int m1, int m2)&#123;
		maxGain = m1;
		maxSum = m2;
	&#125;
&#125;

public static Info process(TreeNode head)&#123;
	if(head == null)&#123;
		return new Info(0, Integer.MIN_VALUE); // ⚠️ maxsum返回minvalue
	&#125;
	Info leftInfo = process(head.left);
	Info rightInfo = process(head.right);
	
	int leftGain = Math.max(leftInfo.maxGain, 0); // ⚠️ >0
	int rightGain = Math.max(rightInfo.maxGain, 0);
	
	int maxGain = Math.max(leftGain,rightGain) + head.val;
	
	int maxSum = Math.max(
			Math.max(leftInfo.maxSum,rightInfo.maxSum),
			leftGain + rightGain + head.val);
	
	return new Info(maxGain, maxSum);
&#125;
5 对称二叉树

给你一个二叉树的根节点 root ， 检查它是否轴对称。

public boolean isSymmetric(TreeNode root) &#123;
      return isMirror(root, root); // 复制一个自己的树
      &#125;
  public static boolean isMirror(TreeNode h1, TreeNode h2) &#123;
      if(h1 == null &amp;&amp; h2 == null)&#123; //两个树都是空
          return true;
      &#125;
      if(h1 != null &amp;&amp; h2 != null)&#123;// 两个树都不是空 就返回：1.当前节点值要相等 2.左边和右边也是mirror
          return (h1.val == h2.val) &amp;&amp; isMirror(h1.left, h2.right) &amp;&amp; isMirror(h1.right, h2.left); // 
      &#125;
      return false; //一个是空一个不是空

  &#125;
6 从前序和中序序列构造二叉树

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

/**
	 * 利用二叉树前序 头左右 找到头 再利用中序左右头进行左右树分离
	 */
    public TreeNode buildTree(int[] pre, int[] in) &#123;
        if(pre == null || in == null || pre.length != in.length)&#123;
            return null;
        &#125;
        return f(pre, 0, pre.length- 1, in, 0, in.length - 1);
    &#125;

    private TreeNode f(int[] pre, int L1, int R1, int[] in, int L2, int R2)&#123;
        // 越界情况
        if(L1 > R1)&#123;
            return null;
        &#125;
      	// 利用前序找到头
        TreeNode head = new TreeNode(pre[L1]);
        if(L1 == R1)&#123;
            return head;
        &#125;

       //中序对应找到头的下标find
        int find = L2;
        while(in[find] != pre[L1])&#123;
            find++;
        &#125;
				// （find - L2)就是左树的长度
        head.left = f(pre, L1 + 1, L1 + (find - L2), in, L2, find - 1);
        head.right = f(pre,  L1 + (find - L2) + 1, R1, in, find + 1, R2);
        return head;
    &#125;
&#125;
	
7 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

/*
* 用中序遍历
*/
public static boolean isValidBST(TreeNode head)&#123;
		if(head != null)&#123;
			Stack&lt;TreeNode> stack = new Stack&lt;TreeNode>();
			double last = -Double.MAX_VALUE;// ⚠️
			while(!stack.isEmpty() || head != null)&#123;
				// 1 
				if(head != null)&#123;
					stack.push(head);
					head = head.left;
				&#125;else&#123;// 2
					head = stack.pop();
					if(head.val &lt;= last)&#123;
						return false;
					&#125;
					last = head.val;
					head = head.right;
				&#125;
			&#125;
		&#125;
		return true;
	&#125;
8 平衡二叉树
使用递归套路
INFO &#123;
	高度；
	是否是平衡二叉树；
&#125;
public boolean isBalanced(TreeNode root) &#123;
      return process(root).isBt;
  &#125;

  //需要的信息
  public static class Info&#123;
      private int height;
      private boolean isBt;
      public Info(int h, boolean ib)&#123;
          height = h;
          isBt = ib;
      &#125;
  &#125;
  //找信息的过程
  public static Info process(TreeNode head)&#123;
      if(head == null)&#123;
          return new Info(0, true);
      &#125;
      Info leftInfo = process(head.left);
      Info rightInfo = process(head.right);


      //解决当前的Info的方法（也就是所有递归都会用到的方法）
      int height = Math.max(leftInfo.height, rightInfo.height) + 1; // ⚠️ 
      boolean isBalanced = false;
      if(leftInfo.isBt &amp;&amp; rightInfo.isBt &amp;&amp; Math.abs(leftInfo.height - rightInfo.height) &lt;= 1)&#123;
          isBalanced = true;
      &#125;
      return new Info(height, isBalanced);
  &#125;
9 二叉树的序列化和反序列化

思路
序列化： 准备一个string的队列 然后按照先序顺序将结点转为String类型然后加入队列，左边和右边结点按照顺序递归执行该方法
反序列化： 将要转化为二叉树的队列传入，然后弹出结点为head（注意转换回为Int类型），head左边递归执行preb（prelist），右边递归执行preb（prelist）
错误
判断null值注意判断哈 特别是递归里面 就算是方法前面判断了 当时不代表递归以后不会再次出现，所以方法内还要再判断一次

/*
 * 二叉树的前中后序列化
 */
public class BT_09_preSerial &#123;
	
	/**
	 * 序列化 使用队列
	 * @param head
	 * @return
	 */
	public static Queue&lt;String> preSerial(TreeNode head)&#123;
		Queue&lt;String> ans = new LinkedList&lt;>();
		pre(head, ans);
		return ans;
	&#125;

	private static void pre(TreeNode head, Queue&lt;String> ans) &#123;
		
		if(head == null)&#123;
			ans.add(null);// 用来规定用什么来占位
		&#125;else&#123;
			ans.add(String.valueOf(head.val));
			pre(head.left, ans);
			pre(head.right, ans);
		&#125;
	&#125;
	
	
	/**
	 * 反序列化
	 * @param head
	 * @return
	 */
	public static TreeNode buildByPreQueue(Queue&lt;String> prelist)&#123;
		if(prelist == null || prelist.size() == 0)&#123;
			return null;
		&#125;
		return preb(prelist);
	&#125;

	private static TreeNode preb(Queue&lt;String> prelist) &#123;
		String value = prelist.poll();
		if(value == null)&#123;
			return null;
		&#125;
		TreeNode head = new TreeNode(Integer.valueOf(value));
		head.left = preb(prelist);
		head.right = preb(prelist);
		return head;
	&#125;

&#125;

10 二叉树的最大深度

给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，
3
/ 
9  20
/  
15   7
返回它的最大深度 3 。

class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        return findDepth(root).height;
    &#125;

    public static class Info&#123;
        public int height;
        public Info(int h)&#123;
            height = h;
        &#125;
    &#125;

    public static Info findDepth(TreeNode head)&#123;
        if(head == null)&#123;
            return new Info(0);
        &#125;

        Info leftInfo = findDepth(head.left);
        Info rightInfo = findDepth(head.right);

        int height = Math.max(leftInfo.height, rightInfo.height) + 1;
        return new Info(height);
    &#125;
&#125;
11 最大直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树
   1
  / \
 2   3
/ \     

4   5
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

/*
 * 二叉树最大直径
 */
public class BT_05_ZhiJing &#123;
	static int ans = 1;
	public int max(TreeNode head)&#123;
		
		return process(head) - 1;
	&#125;
	
	public static int process(TreeNode head)&#123;
		if(head == null)&#123;
			return 0;
		&#125;
		
		int lM = process(head.left);
		int rM = process(head.right);
		ans = Math.max(lM + rM + 1, ans);
		
		return Math.max(lM, rM) + 1;
	&#125;
	
	/**
	 * 递归套路
	 * @param root
	 * @return
	 */
	public int max2(TreeNode root) &#123;
        if(root == null)&#123;
            return 0;
        &#125;
        return process2(root).max;
    &#125;

	public static class Info&#123;
		public Integer height;
		public Integer max;
		public Info(Integer h, Integer m)&#123;
			height = h;
			max = m;
		&#125;
	&#125;
	private Info process2(TreeNode root) &#123;
		if(root == null)&#123;
			return new Info(0, 0);
		&#125;
		
		Info leftInfo = process2(root.left);
		Info rightInfo = process2(root.right);
	
		int height = Math.max(leftInfo.height, rightInfo.height) + 1;
		
		int max = Math.max(Math.max(leftInfo.max, rightInfo.max),
				leftInfo.height + rightInfo.height);
		
		return new Info(height, max);
	&#125;
&#125;
12 路径总和
/**
	 * 路径总和 Ⅰ
	 * @return 要求返回是否存在总和为target的从根到节点的路径
	 */
	public static boolean isSum;

	
	public boolean hasPathSum(TreeNode root, int targetSum) &#123;
		if (root == null) &#123;
			return false;
		&#125;
		isSum = false;
		process(root, 0, targetSum);
		return isSum;
	&#125;

	public void process(TreeNode head, int preSum, int sum) &#123;
		// 是叶子节点
		if (head.left == null &amp;&amp; head.right == null) &#123;
			if (preSum + head.val == sum) &#123;
				isSum = true;
			&#125;
			return;
		&#125;

		// 不是叶子节点
		preSum += head.val;
		if (head.left != null) &#123;
			process(head.left, preSum, sum);
		&#125;
		if (head.right != null) &#123;
			process(head.right, preSum, sum);
		&#125;

	&#125;

	/**
	 * 路径总和Ⅱ
	 * @return 要求返回所有满足target的路径
	 */
	// 1 
	// 2 注意现场要恢复，因为只有一个path来存路 如果没有清空，后面根本装不下
	public List&lt;List&lt;Integer>> pathSum(TreeNode root, int targetSum) &#123;
		List&lt;List&lt;Integer>> ans = new ArrayList&lt;>();
		if (root == null) &#123;
			return ans;
		&#125;

		List&lt;Integer> path = new ArrayList&lt;>();
		process(root, path, 0, targetSum, ans);
		return ans;
	&#125;

	public void process(TreeNode head, List&lt;Integer> path, int preSum, int sum,
			List&lt;List&lt;Integer>> ans) &#123;

		// 叶子节点
		if (head.left == null &amp;&amp; head.right == null) &#123;
			if (head.val + preSum == sum) &#123;
				path.add(head.val);
				ans.add(new ArrayList&lt;>(path));// 传递是引用不能直接传path
				path.remove(path.size() - 1);
			&#125;
		&#125;

		preSum += head.val;
		path.add(head.val);

		// 不是叶子节点
		if (head.left != null) &#123;
			process(head.left, path, preSum, sum, ans);
		&#125;

		if (head.right != null) &#123;
			process(head.right, path, preSum, sum, ans);
		&#125;

		// 恢复现场
		path.remove(path.size() - 1);

	&#125;

13 翻转二叉树

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

翻转二叉树

 // 有点像数组swap
    public TreeNode invertTree(TreeNode root) &#123;
        if(root == null) &#123;
            return null;
        &#125;
        TreeNode left = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(left);
        return root;

    &#125;
6 栈
1 有效括号

给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。


遍历所有左边的括号变成对应的右括号压入栈
遇到的右边的括号

如果stack是空的，则false
弹出栈顶比较不相等 false


最后stack 必须是空的才能满足

public boolean isValid(String s) &#123;
	 	char[] str = s.toCharArray();
        Stack&lt;Character> stack = new Stack&lt;>();
        for(int i = 0; i &lt; str.length; i++) &#123;
            if(str[i] == '(' || str[i] == '[' || str[i] == '&#123;') &#123;
                stack.push(str[i]);
            &#125; else&#123;
                if(stack.isEmpty()) &#123;
                    return false;
                &#125; 
                char cur = stack.pop();
                if((str[i] == ')' &amp;&amp; cur != '(') || (str[i] 
                == '&#125;' &amp;&amp; cur != '&#123;') || (str[i] == ']' &amp;&amp; cur != '[')) &#123;
                    return false;
                &#125;
            &#125;
        &#125;
        return stack.isEmpty();
&#125;
2 用栈实现队列
class MyQueue &#123;
		private Stack&lt;Integer> sPop;
    private Stack&lt;Integer> sPush;
    public MyQueue() &#123;
        sPop = new Stack&lt;Integer>();
        sPush = new Stack&lt;Integer>();
    &#125;
    
    public void push(int x) &#123;
        sPush.push(x);
    &#125;
    
    public int pop() &#123;
        if(sPop.isEmpty())&#123;
            while(!sPush.isEmpty())&#123;
                sPop.push(sPush.pop());
            &#125;
        &#125;
        return sPop.pop();
        
    &#125;
    
    public int peek() &#123;
        if(sPop.isEmpty())&#123;
            while(!sPush.isEmpty())&#123;
                sPop.push(sPush.pop());
            &#125;
        &#125;
        return sPop.peek();
    &#125;
    
    public boolean empty() &#123;
        if(sPop.isEmpty() &amp;&amp; sPush.isEmpty())&#123;
            return true;
        &#125; else&#123;
            return false;
        &#125;
    &#125;
&#125;
3 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。


public class MinStack &#123;
	public Stack&lt;Integer> data;
	public Stack&lt;Integer> min;
	
	public MinStack() &#123;
		this.data = new Stack&lt;Integer>();
		this.min = new Stack&lt;Integer>();
		
    &#125;
    
    public void push(int val) &#123;
    	if(this.min.isEmpty())&#123;
    		this.min.push(val);
    	&#125;else if(val &lt; this.getMin())&#123;
    		this.min.push(val);
    	&#125;else&#123;
    		this.min.push(this.getMin());
    	&#125;
    	this.data.push(val);
    	

    &#125;
    
    public void pop() &#123;
    	this.data.pop();
    	this.min.pop();
    &#125;
    
    public int top() &#123;
    	return this.data.peek();
    &#125;
    
    public int getMin() &#123;
    	return this.min.peek();
    &#125;
&#125;

4 两个队列实现栈
在push操作里进行改进就可以：
通过
class MyStack &#123;
           public Queue&lt;Integer> q1;
        public Queue&lt;Integer> q2;
        /** Initialize your data structure here. */
        public MyStack()&#123;
            q1 = new LinkedList&lt;Integer>();
            q2 = new LinkedList&lt;Integer>();
        &#125;


        /** Push element x onto stack. */
        public void push(int x) &#123;
            q2.offer(x);
            while(!q1.isEmpty())&#123;
                q2.offer(q1.poll());
            &#125;
            Queue&lt;Integer> tmp = q1;
            q1 = q2;
            q2 = tmp;
        &#125;

        /** Removes the element on top of the stack and returns that element. */
        public int pop() &#123;
            return q1.poll();
        &#125;

        /** Get the top element. */
        public int top() &#123;
            return q1.peek();

        &#125;

        /** Returns whether the stack is empty. */
        public boolean empty() &#123;
            return q1.isEmpty();
        &#125;
&#125;
用一个队列也可以
public void push(int x) &#123;
       int n = queue.size();
       queue.offer(x);
       for (int i = 0; i &lt; n; i++) &#123;
           queue.offer(queue.poll());
       &#125;
   &#125;
5 单调栈
为了解决给定的一个可能含有重复值的arr，i位置一定有以下信息
1）arr[i] 左边有离它最近比它小的（大）的数
2）arr[i] 右边有离它最近比它小的（大）的数
找到左边和右边离i最近比其小的下表对 res[n][2]
public class Code1_MonotonousStack &#123;
	public static int[][] getNearLessNoRepeat(int[] arr)&#123;
		int[][] res = new int[arr.length][2];
		Stack&lt;Integer> stack = new Stack&lt;>();
		
		for(int i = 0; i &lt; arr.length; i++)&#123;
			//新的数压栈 如果比栈底小 栈底弹出 并记录
			while(!stack.isEmpty() &amp;&amp; arr[stack.peek()] > arr[i])&#123;
				int popIndex = stack.pop();
				int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
				res[popIndex][0] = leftLessIndex;
				res[popIndex][1] = i;
			&#125;
			stack.push(i);
		&#125;
		while(!stack.isEmpty())&#123;
			int popIndex = stack.pop();
			int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
			res[popIndex][0] = leftLessIndex;
			res[popIndex][1] = -1;
			
		&#125;
		return res;
	&#125;
	
	
	//数组中有重复的情况
	public static int[][] getNearLess(int[] arr)&#123;
		int[][] res = new int[arr.length][2];
		
		// List&lt;Integer> -> 放的是位置，同样值的东西，位置压在一起
		// 代表值    底  ->  顶   小  -> 大
		Stack&lt;List&lt;Integer>> stack = new Stack&lt;>();
		
		for(int i = 0; i &lt; arr.length; i++)&#123;
			//新的数压栈 如果比栈底小 栈底弹出 并记录
			while(!stack.isEmpty() &amp;&amp; arr[stack.peek().get(0)] > arr[i])&#123;
				List&lt;Integer> popIndex = stack.pop();
				int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
				for(Integer popi : popIndex)&#123;
					res[popi][0] = leftLessIndex;
					res[popi][1] = i;
				&#125;
			&#125;
			//相等的比你小的 都要把存入栈的格式改为存储了位置的list数组
			if(!stack.isEmpty() &amp;&amp; arr[stack.peek().get(0)] == arr[i])&#123;
				stack.peek().add(Integer.valueOf(i));
				
			&#125;else&#123;
				List&lt;Integer> pushIndex = new ArrayList&lt;>();
				pushIndex.add(Integer.valueOf(i));
				stack.push(pushIndex);
			&#125;
			
		&#125;
		
		while(!stack.isEmpty())&#123;
			List&lt;Integer> popIndex = stack.pop();
			//取决于最晚加入的那个
			int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
			for(Integer popi : popIndex)&#123;
				res[popi][0] = leftLessIndex;
				res[popi][1] = -1;
			&#125;
		&#125;
		return res;
	&#125;

&#125;

正数数组arr中（sub的累加和*min）的最大值

给定一个只包含正数的数组arr，arr中任何一个子数组sub，一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
那么所有子数组中，这个值最大是多少？

直接找每个数两边最近比它小中间部分累加和（这部分该数一定最小）
1 建立前缀和数组sums[i](这样求累加和就可以[0~R] -[0~L-1])
2 和上面单调栈思路差不多
​	1）栈顶弹出[j]后更新max
​	2）再遍历栈里的元素 右边没有比它最小所以累加直接用sums[N-1]来减

7 递归
1 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案


public static List&lt;List&lt;Integer>> permute(int[] nums) &#123;
        List&lt;List&lt;Integer>> ans = new ArrayList&lt;>();
        List&lt;Integer> path = new ArrayList&lt;Integer>();//选择的路
        if(nums.length == 0 || nums == null)&#123;
        	return ans;
        &#125;
        for (int num : nums) &#123;
            path.add(num);
        &#125;
        process(path, 0, ans);
        return ans;
    &#125;
	
	//  DFS
	// 1 for是在树形结构里平行进行  - - ->
	// 2 先交换成为一种情况
	// 3 往下|递归将剩余部分的情况搞定
	//      |
	//      v
	// 4 恢复原来状态 因为平行的分支需要同样的状态
	public static void process(List&lt;Integer> path, int i, List&lt;List&lt;Integer>> ans)&#123;
		if(i == path.size())&#123;
			ans.add(new ArrayList&lt;Integer>(path));
		&#125;
		boolean[] vis = new boolean[256];
		
		// 1
		for(int j = i; j &lt; path.size(); j++)&#123;
			if(!vis[path.get(j) + 128])&#123; // 剪枝
				vis[path.get(j) + 128] = true;
				// 2
				Collections.swap(path, i, j);
				// 3
				process(path, i + 1, ans);
				// 4
				Collections.swap(path, i, j);
			&#125;
			
		&#125;
	&#125;

全排列2⃣️ 不重复
/*
 * 全排列
 * 将给定数组进行排列组合 
 */
public class Recursion回溯_Permutation &#123;
    public static List&lt;List&lt;Integer>> permute(int[] nums) &#123;
        List&lt;List&lt;Integer>> ans = new ArrayList&lt;>();
        List&lt;Integer> path = new ArrayList&lt;>();// 不同打印结果存储
        for(int num : nums)&#123;
            path.add(num);
        &#125;
        process(path, 0, ans);
        return ans;

    &#125;

    //  DFS
    // 1 for是在树形结构里平行进行  - - ->
    // 2 先交换成为一种情况
    // 3 往下|递归将剩余部分的情况搞定
    //      |
    //      v
    // 4 恢复原来状态 因为平行的分支需要同样的状态
    public static void process(List&lt;Integer> path, int i, List&lt;List&lt;Integer>> ans)&#123;
        if(i == path.size())&#123;
            ans.add(new ArrayList&lt;Integer>(path));
        &#125;
        boolean[] vis = new boolean[256];

        // 1
        for(int j = i; j &lt; path.size(); j++)&#123;
            if(!vis[path.get(j)]+128)&#123; // 剪枝 数组有负数要加上128
                vis[path.get(j)+128] = true;
                // 2
                Collections.swap(path, i, j);
                // 3
                process(path, i + 1, ans);
                // 4
                Collections.swap(path, i, j);
            &#125;

        &#125;
    &#125;

&#125;


2 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

利用一个原理是 当前面已经做了选择的左括号比右括号多的时候
就添加右括号 
需要剪枝 在往path里面添加括号的时候
进行条件剪枝
public List&lt;String> generateParenthesis(int n) &#123;
        char[] path = new char[n &lt;&lt; 1];
        List&lt;String> ans = new ArrayList&lt;>();
        process(path,0, n, 0, ans); // ⚠️传进去的参数！
        return ans;
    &#125;
// 剪枝 左边括号还有 和左边-右边》0
    public static void process(char[] path, int i,int leftRest, int leftMinusRight, List&lt;String> ans )&#123;
        if(i == path.length)&#123; // 到结尾
            ans.add(String.valueOf(path)); // 一种可能
        &#125; else &#123;
            if(leftRest > 0)&#123; // 左边的括号还有 将当前的位置设为左， 剩下的去递归
                path[i] = '(';
                process(path, i + 1, leftRest - 1, leftMinusRight + 1, ans);
            &#125;
            if(leftMinusRight > 0)&#123;// 左边的括号大于右边的括号
                path[i] = ')';
                process(path, i + 1, leftRest, leftMinusRight - 1, ans);
            &#125;
        &#125;
    &#125;
3 复原ip地址

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。
例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

 static final int COUNT = 4;
int[] segment; // segment[i]存储第i段
List&lt;String> ans = new ArrayList&lt;>();

public List&lt;String> restoreIpAddresses(String s) &#123;
	segment = new int[COUNT];
	dfs(s, 0, 0);// s 字符串 id 段数 segstart
	return ans;
&#125;

public void dfs(String s, int id, int segStart) &#123;
	// 1 已经递归到第四段
	if (id == COUNT) &#123;
		if (segStart == s.length()) &#123;// 并且 所有数字都完成
			StringBuffer str = new StringBuffer();
			for (int i = 0; i &lt; COUNT; i++) &#123;
				str.append(segment[i]);
				if (i != COUNT - 1) &#123;
					str.append('.');
				&#125;
			&#125;
			ans.add(str.toString());
		&#125;
		return; // 记得向上返回！！！

	&#125;
	// 2 四段没玩但是已经到结尾
	if (segStart == s.length()) &#123;
		return;
	&#125;

	// 3 有0的情况
	if (s.charAt(segStart) == '0') &#123; // 有零
		segment[id] = 0;
		dfs(s, id + 1, segStart + 1);
	&#125;

	// 4 一般情况
	int ans = 0;
	for (int segEnd = segStart; segEnd &lt; s.length(); segEnd++) &#123;
		ans = ans * 10 + (s.charAt(segEnd) - '0');
		if (ans > 0 &amp;&amp; ans &lt;= 0xFF) &#123;// ans属于[0, 255]
			segment[id] = ans;
			dfs(s, id + 1, segEnd + 1);
		&#125; else &#123;
			break;
		&#125;
	&#125;
&#125;
4 单词搜索
dfs+回溯
class Solution &#123;
    public boolean exist(char[][] board, String word) &#123;
        int h = board.length, w = board[0].length;
        boolean[][] visited = new boolean[h][w];
        for (int i = 0; i &lt; h; i++) &#123;
            for (int j = 0; j &lt; w; j++) &#123;
                boolean flag = check(board, visited, i, j, word, 0);
                if (flag) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;

    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) &#123;
        if (board[i][j] != s.charAt(k)) &#123;
            return false;
        &#125; else if (k == s.length() - 1) &#123;
            return true;
        &#125;
        visited[i][j] = true;
        int[][] directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;
        boolean result = false;
        for (int[] dir : directions) &#123;
            int newi = i + dir[0], newj = j + dir[1];
            if (newi >= 0 &amp;&amp; newi &lt; board.length &amp;&amp; newj >= 0 &amp;&amp; newj &lt; board[0].length) &#123;
                if (!visited[newi][newj]) &#123;
                    boolean flag = check(board, visited, newi, newj, s, k + 1);
                    if (flag) &#123;
                        result = true;
                        break;
                    &#125;
                &#125;
            &#125;
        &#125;
        visited[i][j] = false;
        return result;
    &#125;
&#125;

5 子集

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：
输入：nums = [0]
输出：[[],[0]]

public static List&lt;List&lt;Integer>> subsets(int[] nums)&#123;
		List&lt;List&lt;Integer>> res = new ArrayList&lt;>();
		List&lt;Integer> path = new ArrayList&lt;>();//用来存放之前决定
		if(nums.length == 0 || nums == null)&#123;
			return res;
		&#125;
		process2(nums, 0, res, path);
		return res;
		
	&#125;

	private static void process2(int[] nums, int i, List&lt;List&lt;Integer>> res, List&lt;Integer> path) &#123;
		if(i == nums.length)&#123;
			res.add(new ArrayList&lt;>(path));
			return;
		&#125;
		// 两种可能
		process2(nums, i + 1, res, path);
		List&lt;Integer> path2 = new ArrayList&lt;>(path);
		path2.add(nums[i]);
		process2(nums, i + 1, res, path2);
	&#125;
8 并查集
并查集
用来解决图的连通性和环的数量
结构（hash表）
public class Code01_UnionFind &#123;
	public static class Node&lt;V> &#123;
		V value;
		public Node(V v) &#123;
			value = v;
		&#125;
	&#125;
	
	/**
	 * 并查集 
	 */
	// 1 构造方法
	// 2 Node&lt;V> findFather(Node&lt;V> cur)
	// 3 boolean isSameSet(V a, V b)
	// 4 void union(V a, V b)
	// 5 int sets()
	public static class UnionFind&lt;V> &#123;
		public HashMap&lt;V, Node&lt;V>> nodes;// 点
		public HashMap&lt;Node&lt;V>, Node&lt;V>> parents;// 最高父亲
		public HashMap&lt;Node&lt;V>, Integer> sizeMap;// 所在集合大小
		
		public UnionFind(List&lt;V> values) &#123;
      //1 初始化参数
			nodes = new HashMap&lt;>();
			parents = new HashMap&lt;>();
			sizeMap = new HashMap&lt;>();
      //2 遍历：先new一个node 然后更新点集，更新父亲表（自己是自己爹），最后更新sizemap
			for (V cur : values) &#123;
				Node&lt;V> node = new Node&lt;>(cur);
				nodes.put(cur, node);
				parents.put(node, node);
				sizeMap.put(node, 1);
			&#125;
		&#125;
		
    // 找爹
		public Node&lt;V> findFather(Node&lt;V> cur) &#123; 
      //1 new 一个 栈
			Stack&lt;Node&lt;V>> path = new Stack&lt;>();
      //2 如果当前cur不是自己爹 ：1）压栈 2）cur更新为自己爹
			while (cur != parents.get(cur)) &#123;
				path.push(cur);
				cur = parents.get(cur);
			&#125;
      //3 如果栈不空 cur就是当前最爹 所以循环弹出 将cur设为他们爹
			while (!path.isEmpty()) &#123;
				parents.put(path.pop(), cur);
			&#125;
			return cur;
		&#125;
		
    // 返回两爹是否相等
		public boolean isSameSet(V a, V b) &#123;
			return findFather(nodes.get(a)) == findFather(nodes.get(b));
		&#125;
    
		// 并
		public void union(V a, V b) &#123;
			Node&lt;V> aHead = findFather(nodes.get(a));
			Node&lt;V> bHead = findFather(nodes.get(b));
			// 如果两爹不同
			if(aHead != bHead) &#123;
        // 1 抓住size大小
				int aSize = sizeMap.get(aHead);
				int bSize = sizeMap.get(bHead);
        
        // 2 小的那个接在大的下面（big是small的父
				Node&lt;V> small = aSize &lt; bSize ? aHead : bHead;
				Node&lt;V> big = small == aHead ? bHead : aHead;
				parents.put(small, big);
        
        // 3 更新大集的size 并转移小集的sizemap
				sizeMap.put(big, aSize + bSize);
				sizeMap.remove(small);
			&#125;
			
		&#125;
		
		public int sets() &#123;
			return sizeMap.size();
		&#125;
	&#125;
&#125;

1 岛屿数量

给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

public static int numIslands(char[][] board) &#123;
		int islands = 0;
		for (int i = 0; i &lt; board.length; i++) &#123;
			for (int j = 0; j &lt; board[0].length; j++) &#123;
				if (board[i][j] == '1') &#123;
					islands++;
					infect(board, i, j);
				&#125;
			&#125;
		&#125;
		return islands;
	&#125;

	// 从(i,j)这个位置出发，把所有练成一片的'1'字符，变成0
	// DFS
	public static void infect(char[][] board, int a, int b) &#123;
		if (i &lt; 0 || j &lt; 0 || i >= board.length || j >= board[0].length
				|| board[i][j] != '1') &#123;
			return;
		&#125;
		board[i][j] = 0;
		infect1(board, i, j - 1);
		infect1(board, i, j + 1);
		infect1(board, i + 1, j);
		infect1(board, i - 1, j);

		&#125;
	&#125;
	/*
	 * BFS
	 */
	public static void infect2(char[][] board, int a, int b) &#123;
		Queue&lt;int[]> list = new LinkedList&lt;>();
		list.add(new int[] &#123; a, b &#125;);
		while(!list.isEmpty()) &#123;
			int[] cur = list.poll();
			int i = cur[0];
			int j = cur[1];
			if (i >= 0 &amp;&amp; j >= 0 &amp;&amp; i &lt; board.length &amp;&amp; j &lt; board[0].length
					&amp;&amp; board[i][j] == '1') &#123;
				board[i][j] = 0;
				list.add(new int[] &#123; i - 1, j &#125;);
				list.add(new int[] &#123; i + 1, j &#125;);
				list.add(new int[] &#123; i, j - 1 &#125;);
				list.add(new int[] &#123; i, j + 1 &#125;);
			&#125;
    &#125;
	
使用并查集（面试）
为什么要并查集？ 如果有多台cpu 大岛变成小岛就会很容易
面试就讲一下怎么通过并查集来进行union ： 并查集就是可以将a, b所在的集合进行合并；需要每个岛的位置 所以需要一个index方法来返回每格子的位置就是行数乘以矩阵宽度再加上列数， 然后要进行union（） 具体过程就是先找到两个要合并的点的父亲，如果不相同就再调出两个所在集合的大小sizemap，然后将小的集合接在大的集合下面， 更新sizemap。 这里找父亲的操作可以用一个help数组倒序遍历来代替栈
/**
	 * 使用并查集
	 * @param board
	 * @return
	 */
	public static int numIslands2(char[][] board) &#123;
		int row = board.length;
		int col = board[0].length;
		UnionFind2 uf = new UnionFind2(board);
		// 把第一行第一列先处理 就不需要后面考虑边界
		for (int j = 1; j &lt; col; j++) &#123;
			if (board[0][j - 1] == '1' &amp;&amp; board[0][j] == '1') &#123;
				uf.union(0, j - 1, 0, j);
			&#125;
		&#125;
		for (int i = 1; i &lt; row; i++) &#123;
			if (board[i - 1][0] == '1' &amp;&amp; board[i][0] == '1') &#123;
				uf.union(i - 1, 0, i, 0);
			&#125;
		&#125;
		// 除了第一行第一列的部分
		for (int i = 1; i &lt; row; i++) &#123;
			for (int j = 1; j &lt; col; j++) &#123;
				if (board[i][j] == '1')  // 看上面和左边
					if (board[i][j - 1] == '1') &#123;
						uf.union(i, j - 1, i, j);
					&#125;
					if (board[i - 1][j] == '1') &#123;
						uf.union(i - 1, j, i, j);
					&#125;
				&#125;
			&#125;
		&#125;
		return uf.sets();
	&#125;
	
	public static class UnionFind2 &#123;
		private int[] parent;
		private int[] size;
		private int[] help;
		private int col;// 用来计算矩阵数r*col + c
		private int sets;

		public UnionFind2(char[][] board) &#123;
			col = board[0].length;
			sets = 0;
			int row = board.length;
			int len = row * col;
			parent = new int[len];
			size = new int[len];
			help = new int[len];
			for (int r = 0; r &lt; row; r++) &#123;
				for (int c = 0; c &lt; col; c++) &#123;
					if (board[r][c] == '1') &#123;
						int i = index(r, c);
						parent[i] = i;
						size[i] = 1;
						sets++;
					&#125;
				&#125;
			&#125;
		&#125;

		// (r,c) -> i
		private int index(int r, int c) &#123;
			return r * col + c;
		&#125;

		// 原始位置 -> 下标
		private int find(int i) &#123;
			int hi = 0;
			while (i != parent[i]) &#123;
				help[hi++] = i;
				i = parent[i];
			&#125;
			for (hi--; hi >= 0; hi--) &#123;
				parent[help[hi]] = i;
			&#125;
			return i;
		&#125;

		public void union(int r1, int c1, int r2, int c2) &#123;
			int i1 = index(r1, c1);
			int i2 = index(r2, c2);
			int f1 = find(i1);
			int f2 = find(i2);
			if (f1 != f2) &#123;
				if (size[f1] >= size[f2]) &#123;
					size[f1] += size[f2];
					parent[f2] = f1;
				&#125; else &#123;
					size[f2] += size[f1];
					parent[f1] = f2;
				&#125;
				sets--;
			&#125;
		&#125;

		public int sets() &#123;
			return sets;
		&#125;

	&#125;
2 省份数量（朋友圈）

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

public int findCircleNum(int[][] M) &#123;
        int N = M.length;
        UnionFind unionFind = new UnionFind(N);
        for(int i = 0; i &lt; N; i++) &#123;
            for(int j = i+1; j &lt; N; j++) &#123;
                if(M[i][j] == 1) &#123;
                    unionFind.union(i, j);
                &#125;
            &#125;
        &#125;

        return unionFind.sets();
    &#125;

    // 使用数组结构的并查集
    public static class UnionFind &#123;
        private int[] parents;
        private int[] size;
        private int[] help;
        private int sets;

        public UnionFind(int N) &#123;
            parents = new int[N];
            size = new int[N];
            help = new int[N];
            sets = N;

            for(int i = 0; i &lt; N; i++) &#123;
                parents[i] = i;
                size[i] = 1;
            &#125;
        &#125;

        // 1 定义一个指针
        // 2 while(i不是自己爹）&#123;
        // 2.1 压help栈（虚拟的
        // 2.2 i指向自己的爹    &#125;
        // 3 for遍历help：模拟栈弹出 &#123;所有人爹设为i&#125;
        // 4 返回i:此时i指向最爹
        public int findFather(int i) &#123;
            int hi = 0;
            while( i != parents[i]) &#123;
                help[hi++] = i;
                i = parents[i];
            &#125;
            for(hi--; hi >=0; hi--)&#123;
                parents[help[hi]] = i;
            &#125;
            return i;
        &#125;

        public void union(int i, int j) &#123;
            int iF = findFather(i);
            int jF = findFather(j);

            if(iF != jF) &#123;
                if(size[iF] &lt; size[jF]) &#123;
                    size[jF] += size[iF];
                    parents[iF] = jF;
                &#125;else &#123;
                    size[iF] += size[jF];
                    parents[jF] = iF;
                &#125;
                sets--;
            &#125;

        &#125;

        public int sets() &#123;
            return sets;
        &#125;

    &#125;


7 图
将矩阵转化为自己的结构(creatGraph)

new一个自己的graph
遍历矩阵每一行 for(matrix.length)

weight:matrix[i][0] from[i][1] to:[i][2]
判断是否contanskey(from和to) 分别放入点集
edge初始化 并赋值 (weight,fromNode,toNode)
更新出入度、直接点、直接边
边放入边集



1 图的bfs
public class Code01_BFS &#123;

	// 从node出发，进行宽度优先遍历
	public static void bfs(Node start) &#123;
		if (start == null) &#123;
			return;
		&#125;
		Queue&lt;Node> queue = new LinkedList&lt;>();
		HashSet&lt;Node> set = new HashSet&lt;>();
		queue.add(start);
		set.add(start);
		while (!queue.isEmpty()) &#123;
			Node cur = queue.poll();
			System.out.println(cur.value);
			for (Node next : cur.nexts) &#123;
				if (!set.contains(next)) &#123;
					set.add(next);
					queue.add(next);
				&#125;
			&#125;
		&#125;
	&#125;

&#125;

2 DFS
package all.Graph;

import java.util.HashSet;
import java.util.Stack;

public class Code02_DFS &#123;

	public static void dfs(Node node) &#123;
		if (node == null) &#123;
			return;
		&#125;
		Stack&lt;Node> stack = new Stack&lt;>();
		HashSet&lt;Node> set = new HashSet&lt;>();
		stack.add(node);
		set.add(node);
		System.out.println(node.value);
		while (!stack.isEmpty()) &#123;
			Node cur = stack.pop();
			for (Node next : cur.nexts) &#123;
				if (!set.contains(next)) &#123;
					stack.push(cur);
					stack.push(next);
					set.add(next);
					System.out.println(next.value);
					break;
				&#125;
			&#125;
		&#125;
	&#125;
&#125;

3 拓扑排序
/**
 * 拓扑排序 ： 有向无环图
 * 
 * @author chs
 *
 */
public class Code03_TopologySort &#123;

	// directed graph and no loop
	public static List&lt;Node> sortedTopology(Graph graph) &#123;
		// key 某个节点   value 剩余的入度
		HashMap&lt;Node, Integer> inMap = new HashMap&lt;>();
		// 只有剩余入度为0的点，才进入这个队列
		Queue&lt;Node> zeroInQueue = new LinkedList&lt;>();
		for (Node node : graph.nodes.values()) &#123;
			inMap.put(node, node.in);
			if (node.in == 0) &#123;
				zeroInQueue.add(node);
			&#125;
		&#125;
		List&lt;Node> result = new ArrayList&lt;>();
		while (!zeroInQueue.isEmpty()) &#123;
			Node cur = zeroInQueue.poll();
			result.add(cur);
			for (Node next : cur.nexts) &#123;
				inMap.put(next, inMap.get(next) - 1);
				if (inMap.get(next) == 0) &#123;
					zeroInQueue.add(next);
				&#125;
			&#125;
		&#125;
		return result;
	&#125;
&#125;

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
