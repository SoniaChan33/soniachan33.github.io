<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>算法高频题总结 | Sonia33's Blog</title><meta name="keywords" content="Java"><meta name="author" content="Sonia33"><meta name="copyright" content="Sonia33"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="算法高频题总结"><meta name="application-name" content="算法高频题总结"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="算法高频题总结"><meta property="og:url" content="https://soniachen.com/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/index.html"><meta property="og:site_name" content="Sonia33's Blog"><meta property="og:description" content="leetcode、面试大厂高频题"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="Sonia33"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="leetcode、面试大厂高频题"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://soniachen.com/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Sonia33","link":"链接: ","source":"来源: Sonia33's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Sonia33's Blog',
  title: '算法高频题总结',
  postAI: '',
  pageFillDescription: '高频题, 三数之和, 两数之和, 搜索旋转排序数组（面试）, 合并两个有序数组, 螺旋矩阵, 字符串相加, 二分查找, 在排序数组中找到元素第一个和最后一个位置, 字符串转化整数, 下一个排列, 合并区间, x的平方根, 缺失的正数, 用rand7()生成rand10(), 找到两个有序数组的中位数(⚠️)/两个有序数组第k小, 翻转字符串中的单词, 思路, 字符串相乘, 删除数组中的重复项, 去除重复字母, 单词搜索, 多数元素, 1 链表, 1 反转链表, 反转链表二, 2 LRU缓存机制, 1) 总的缓存结构 和方法调用, 构造方法, 1 get(), 2 put(), 2）MyCache, 构造方法, 1 V get(K key) 通过key返回value 需要将node放到尾部, 2  void set(K key V value) 更新与新增：放到尾部超出内存就删除最长时间没有操作的, 3 void removeMostUnusedCache() 删去最长时间没有操作的缓存 ；在两个结构里面都删除, 3) 双向链表结构, 1 addNode()  来新节点挂到尾巴上, 2 moveToTail()  （修改过的节点要保证node在表中）更新到尾部, 3 removeHead()  将头节点移走返回新的头节点, 3 K个一组翻转链表, 4 合并两个有序链表, 合并k个链表, 5 相交链表, 无环链表相交, 有环链表相交, 6 环形链表, 7 重排链表, 8 删除链表重复节点, 9 排序链表, 10 两数相加, 11 链表中倒数第k个节点, 12 删除链表倒数第k个节点, 13 回文链表, 14 删除排序链表中的重复元素, 15 复制带有随机指针的链表, 2 动态规划, 基础问题 背包问题, 1. 最大子数组和, 用贪心, 如果需要返回该子数组, 2. 买卖股票的最佳时机 maxProfit, (1) 从头至尾买一次一股 返回最大利润, (2) 买一股但是可以买无限次, 3. 最长回文子串, (1) 动态规划O(N^2), (2) Manacher!, Manacher算法核心, 最长回文子序列, 4. 最长递增子序列, DP版  O(n^2), 二分查找+贪心  O(nlogn), 5. 接雨水, 6. 最长上升子序列, 7. 爬楼梯, 递归 笔试, 矩阵快速幂 o(logn), 8. 编辑距离(dp3), DP 样本对应模型：往往用最后的位置来判断可能性, 9. 最长公共子序列(dp3), 10 最小路径和, 扩展, 不同路径, 11  最长公共子数组(最长重复子数组), 12 零钱兑换问题 lt完全背包gt(dp4) 难, 1 返回需要最少的硬币个数, 动态规划, 2 返回凑齐的所有方法数, 暴力递归的尝试, 记忆化搜索, 动态规划, 3 最终代码, 零钱兑换1, 零钱兑换2, 13 最长有效括号, 14 打家劫舍, 打家劫舍Ⅱ, 15 矩阵的递增路径, 16 机器人walk, 17 纸牌博弈, 3 排序, -快速排序-, 1.0 partition, 2.0 荷兰国旗, 随机快排, 递归版本, lt随机快排的时间复杂度分析gt, !!! ==找到数组中的第k个最大元素==, 改写, BFPRT(面试聊), -堆排序-, -归并排序-, 递归版本, 非递归版本, 优化后的最终版本, 复杂度, -前缀树-, 例子, 前缀树的实现方式, -（桶排序）不基于比较的-, 计数排序和基数排序, 题目3 , 题目4 , 排序算法的稳定性, 排序算法总结, 4 滑动窗口, 1 无重复数组的最长子串, 动态规划版, 2 最小覆盖子串, , 3 滑动窗口的最大值, 4 满足绝对值差达标的子数组数量, 5 二叉树, 1 二叉树先、中、后序遍历(DFS), 递归, 非递归(压栈), 2 二叉树的层序遍历(BFS）, 1) 打印每一层, 二叉树的锯齿形遍历, 2）返回节点最多的那一层, 3）二叉树的右视图, 4）最大宽度（左右节点的距离）, 3 二叉树的最近公共祖先, 4 二叉树最大路径和, 5 对称二叉树, 6 从前序和中序序列构造二叉树, 7 验证二叉搜索树, 8 平衡二叉树, 9 二叉树的序列化和反序列化, 10 二叉树的最大深度, 11 最大直径, 12 路径总和, 13 翻转二叉树, 6 栈, 1 有效括号, 2 用栈实现队列, 3 最小栈, 4 两个队列实现栈, 5 单调栈, 找到左边和右边离i最近比其小的下表对 res[n][2], 正数数组arr中（sub的累加和*min）的最大值, 7 递归, 1 全排列, 全排列2⃣️ 不重复, 2 括号生成, 3 复原ip地址, 4 单词搜索, 5 子集, 8 并查集, 并查集, 结构（hash表）, 1 岛屿数量, 使用并查集（面试）, 2 省份数量（朋友圈）, 7 图, 将矩阵转化为自己的结构(creatGraph), 1 图的bfs, 2 DFS, 3 拓扑排序高频题三数之和两数之和为基础给你一个包含个整数的数组判断中是否存在三个元素使得请你找出所有和为且不重复的三元组注意答案中不可以包含重复的三元组先将数组排序从后往前遍历最后一个数找对应的二元组二元组保证不重复找出前面部分满足条件的二元组遍历将添加在后面三元组最后一个数是之前二元组这个范围上有多少个不同二元组相加全返回两个指针两数相加大于目标值就右缩小于就左缩等于就添加在结果集里面先加左再加右两数之和给定一个整数数组和一个整数目标值请你在该数组中找出和为目标值的那两个整数并返回它们的数组下标使用结构遍历一遍如果查询到里面有与解就返回和的最后如果没有找到就返回搜索旋转排序数组面试使用二分查找整数数组按升序排列数组中的值互不相同原本是有序数组旋转过而且左部分长度不知道以某一个下标为轴旋转例如在下标处经旋转后可能变为题目需要在里面找到思路是最差的情况不知道断点只要三个数不全部一样就可以进行二分左中右相等不能二分左中一直相等左中直到重合都相等回到循环开始重新来或者是到不相等地方继续左中右不都相等代表可以二分左边一定有序左边一定有断点右边有序合并两个有序数组给你两个有序数组和另有两个整数和分别表示和中的元素数目进行合并注意最终合并后数组不应由函数返回而是存储在数组中的初始长度为其中前个元素表示应合并的元素后个元素为应忽略的长度为相等的时候先拷贝长数组的尽可能让空间早释放都被填完就把剩下的填进螺旋矩阵给你一个行列的矩阵请按照顺时针螺旋顺序返回矩阵中的所有元素易错点一注意和别写反了上层从左到右行不变列变右层从上到下行变列不变易错点二注意针对行列不相等时下面两个循环要满足条件下层从右向左行不变列变左层从下到上行变列不变易错点三此处只需要不能字符串相加给定两个字符串形式的非负整数和计算它们的和并同样以字符串形式返回你不能使用任何內建的用于处理大整数的库比如也不能直接将输入的字符串转换为整数形式计算完以后的答案需要翻转过来二分查找没有相等在排序数组中找到元素第一个和最后一个位置在排序数组中查找元素的第一个和最后一个位置借助二分找到数组中比它小的最右的数如果该位置右边说明数组没有这个数如果是那么左边界找到右边界就是找到比小的最右的数利用二分一个指针存放结果小于就去右边找大于就去左边找字符串转化整数注意有很多特殊情况需要删除无用的前导空格检查下一个字符为正还是负只读一开始是数字的部分超出范围的数字返回边界主函数除去空格和后面非数字的部分前后都要判空判断该部分是否是有效数字转为负数形式转回不会溢出负数范围大些标志正负是最负的情况用了负数就只用可以装下如果用整数转最小就没法装是否有符号标志第一个不是零的位置标志数字部分后面的非数字部分的开头返回截取的带符号整数部分判断带符号整数部分是否有效开头在部分没有判断只要开头不是数字和符号都返回无效只有符号也无效夹杂着非数字字符也无效除去空格和后面不是数字的部分判断这部分是不是有效数字转为负数形式为了防止溢出标志正负不要搞反了后面会有的操作需要先判断会不会溢出转为负数在乘十之前判断是否会溢出是最负情况也就是本来是最大的返回边界是否有符号不能用标志第一个不是零的位置找到数字部分后面的非数组部分开头倒着遍历返回截取的带符号的整数部分判断是否是有效的数字如果开头不是数组只有符号也无效夹杂着非数字字符无效下一个排列给你一个整数数组找出的字典序中的下一个排列例如的下一个排列是类似地的下一个排列是而的下一个排列是因为不存在一个字典序更大的排列必须原地修改只允许使用额外常数空间倒着找升序对从倒着找比大的数将数组以后的反转因为有两种情况说明本身就是字典序最大直接翻转是降序需要翻转合并区间以数组表示若干个区间的集合其中单个区间为请你合并所有重叠的区间并返回一个不重叠的区间数组该数组需恰好覆盖输入中的所有区间和记录上一个区间的边界然后复用数组来存储最后复制数组部分先按照区间的左边界来排序然后复用数组来存储最后复制数组部分如果当前左边界大于说明没有覆盖可以更新部分的和然后更新为当前的左右边界如果当前左边界小于或者等于说明两个区间可以覆盖先将更新为这两个区间的最大右区间最后还有一次处的更新的平方根二分查找给你一个非负整数计算并返回的算术平方根由于返回类型是整数结果只保留整数部分小数部分将被舍去注意不允许使用任何内置指数函数和算符例如或者使用二分就更新和到右边就更新注意数据类型时主要是为了两个整型相乘不会溢出一定非负输入可以保证因为两个整数相乘可能会溢出扩展求出小数点后位其实思路与一样只是换成类型并且需要转换数格式缺失的正数给你一个未排序的整数数组请你找出没有出现的最小的正整数时间复杂度除了打标记以外我们还可以使用置换的方法将给定的数组恢复成下面的形式如果数组中包含那么恢复后数组的第个元素为在恢复后数组应当有的形式但其中有若干个位置上的数是错误的每一个错误的位置就代表了一个缺失的正数以题目中的示例二为例恢复后的数组应当为我们就可以知道缺失的数为交换的条件且和本来应该在的位置的值不相等用生成用一个不等概率返回和的函数怎么加工一个函数和等概率返回找到两个有序数组的中位数两个有序数组第小这里就主要处理两个为空一个为空全不为空的三个情况原型奇数偶数最后跳出循环都只剩一个数处理长度不同返回的情况翻转字符串中的单词给你一个字符串逐个翻转字符串中的所有单词单词是由非空格字符组成的字符串中使用至少一个空格将字符串中的单词分隔开请你返回一个翻转中单词顺序并用单个空格相连的字符串说明输入字符串可以在前面后面或者单词间包含多余的空格翻转后单词间应当仅用一个空格分隔翻转后的字符串中不应包含额外的空格示例输入输出示例输入输出解释输入字符串可以在前面或者后面包含多余的空格但是翻转后的字符不能包括思路去除多余的空白去掉字符串开头的空白字符去掉字符串末尾的空白字符将字符串间多余的空白字符去除翻转字符串翻转每一个单词遍历使用和来抓单词翻转单词更新去找下一个单词去除多余的空白翻转字符串翻转每一个单词去掉字符串开头的空白字符去掉字符串末尾的空白字符将字符串间多余的空白字符去除翻转任意字符遍历使用和来抓单词翻转单词更新去找下一个单词字符串相乘给定两个以字符串形式表示的非负整数和返回和的乘积它们的乘积也表示为字符串形式注意不能使用任何内置的库或直接将输入转换为整数示例输入输出示例输入输出删除数组中的重复项任何删除重复的都可以用快慢指针删除有序数组中的重复项任何删除重复的都可以用快慢指针去除重复字母贪心单调栈给你一个字符串请你去除字符串中重复的字母使得每个字母只出现一次需保证返回结果的字典序最小要求不能打乱其他字符的相对位置示例输入输出示例输入输出单词搜索给定一个的二维矩阵表示一个图像请你将图像顺时针旋转度你必须在原地旋转图像这意味着你需要直接修改输入的二维矩阵请不要使用另一个矩阵来旋转图像多数元素给定一个大小为的数组找到其中的多数元素多数元素是指在数组中出现次数大于的元素你可以假设数组是非空的并且给定的数组总是存在多数元素是一个超级水王问题遍历使用和来一次删除两个不同的数到最后不为则说明可能有水王是当前的再遍历一次找如果说明就是水王链表反转链表返回的是反转链表二就是反转链表中间一截第步从虚拟头节点走步来到节点的前一个节点第步从再走步来到节点第步切断出一个子链表截取链表先标记再切断第步同反转链表反转链表反转链表的子区间第步接回到原来的链表中需要一个虚拟头先找到反转部分的前面从再走步来到节点切断这部分的链表反转区间内的链表接回去接回去的时候已经是反过来了缓存机制请你设计并实现一个满足最近最少使用缓存约束的数据结构实现类以正整数作为容量初始化缓存如果关键字存在于缓存中则返回关键字的值否则返回如果关键字已经存在则变更其数据值如果不存在则向缓存中插入该组如果插入操作导致关键字数量超过则应该逐出最久未使用的关键字函数和必须以的平均时间复杂度运行总的缓存结构和方法调用构造方法构造方法通过返回需要将放到尾部更新与新增放到尾部超出内存就删除最长时间没有操作的删去最长时间没有操作的缓存在两个结构里面都删除双向链表结构基于机制的双向链表结构构造方法将头尾置为空来新节点挂到尾巴上修改过的节点要保证在表中更新到尾部将头节点移走返回新的头节点个一组翻转链表先将第一组凑齐并且反转再记录上一组的结尾节点循环当结尾更新更新注意判空反转变头上一组结尾连接到现在的开头更新注意判空反转往后移三个指针进行反转反转后是结尾要连接到注意要移动指针合并两个有序链表先抓小头抓大头比较谁小的就指向谁并且后移抓大头抓小头合并个链表给你一个链表数组每个链表都已经按升序排列请你将所有链表合并到一个升序链表中返回合并后的链表对数器定义一个对数器的小根堆将每一条的放在堆中抓出将该条后面一个节点放入堆指针重复弹出连接结果表再见弹出的下一个放入堆中相交链表需要分有环和无环两种情况如何辨别有无环环形链表无环链表相交给你两个单链表的头节点和请你找出并返回两个单链表相交的起始节点如果两个链表不存在相交节点返回需要两个指针先用记录两个链表长度大小以便分清楚谁长谁短长度差记得取绝对值长的走步到和短的一样长的起点两个指针一起走到相等的地方就是交点返回指向长的头指向短头将两个链表长度差取绝对值将指向长链表的指针往下移动到达和短链表指针与相交点相同距离的位置两个指针向下相遇点便是相交点有环链表相交有环的链表比较复杂有三种情况两个入环节点相同即相交在入环前两个相交在环内相交有两个相交点两个不相交方法与两个无环链表方法一样只不过把看作结尾往后移动如果在遇到自己之前遇到了就是情况环形链表返回入环节点没有环就返回先将从头节点快慢指针开始往后如果两个指针相遇那一定有环期间如果快指针到可以直接判断无环如果要找到入环节点就将指针指向不动然后让两个指针都只移动一步最后一定会在入环处相遇重排链表给定一个单链表的头节点单链表表示为请将其重新排列后变为不能只是单纯的改变节点内部的值而是需要实际的进行节点交换找到原表的中点快慢指针从开走返回慢指针将右半端反转反转链表反转链表将左右端合并判空分离返回的是合并过程就是使用两个指针来标志两个的下一个删除链表重复节点设置虚拟节点往后遍历条件的下一个和下下个都是空如果当前两个节点值相等就将当前的值保存在循环第一个节点后面的节点是否有重复的指向不等于该值的节点不相等就直接当前节点下一个和下下个不为空两个节点相等遍历第一个节点后面的节点是否有重复的有就直接讲指针指向下下个两个节点不相等指针后移排序链表就是给链表排序遍历一遍链表的长度是每次分组节点数一直乘二就是将五个参数处理返回方便利用左组从哪到哪右组从哪到哪左右去整体的头整体的尾返回五个参数左边结尾断开记录右边结尾的并断开结尾断开两数相加给你两个非空的链表表示两个非负的整数它们每位数字都是按照逆序的方式存储的并且每个节点只能存储一位数字请你将两个数相加并以相同形式返回一个表示和的链表你可以假设除了数字之外这两个数都不会以开头两个链表分长短分为三个阶段长短都还有节点短没有节点长有节点长也走到没节点一直在抓住最后一个节点一直在抓住最后一个节点到链表中倒数第个节点输入一个链表输出该链表中倒数第个节点为了符合大多数人的习惯本题从开始计数即链表的尾节点是倒数第个节点例如一个链表有个节点从头节点开始它们的值依次是这个链表的倒数第个节点是值为的节点删除链表倒数第个节点用两个指针截出长度两个指针一直往后直到到结尾在目标的前面一位直接将指针指向下下位使用虚拟节点以防删除的是头节点回文链表需要和然后判断对称然后再恢复回去现在就走到了中间偶数是上中将后半部分后面部分已经翻转现在对比两部分是否对称比较把后半部分又恢复原样删除排序链表中的重复元素给定一个已排序的链表的头删除所有重复的元素使每个元素只出现一次返回已排序的链表删除重复元素留下一个直接快慢指针复制带有随机指针的链表深度复制带有的链表最优解人工构造关系每一个节点后面加一个克隆节点遍历关系同时复制遍历分离同时复制使用一一对应关系遍历第一遍一一对应遍历第二遍复制关系动态规划具体步骤可以参考零钱兑换返回凑齐的所有方法数基础问题背包问题传入货物的重量和价值不能超过背包容量返回最大价值暴力递归加上没加动态规划版最大子数组和用贪心只需要一个反复更新记录以为底的最大累加和然后存最大的用两个变量存如果需要返回该子数组买卖股票的最佳时机从头至尾买一次一股返回最大利润遍历一遍标记最大利润更新就是找到最低点和最高点买一股但是可以买无限次遍历累加所有的爬坡一股随便买相当于在每次爬坡前后买卖将所有爬坡累加就行最长回文子串动态规划自己改动态规划边填边抓最长和该最长开始节点按对角线遍历最外循环不是的坐标代表了每个循环行是不变的是横坐标面试讲一讲假设字符串长度为想返回最长回文子串的长度时间复杂度算法核心理解回文半径数组理解所有中心的回文最右边界和取得时的中心点理解的结构以及根据回文长度进行的状况划分每一种情况划分都可以加速求解回文半径的过程最长回文子串就是我知道可以进行最长回文子序列子序列就是三种情况和和对角线遍历最长递增子序列版二分查找贪心维护一个数组存储代表长度下子序列的最后下标递增子序列的长度数组的下标设当前已求出的最长上升子序列的长度为初始时为从前往后遍历数组在遍历到时如果则否则在数组中二分查找找到第一个比小的数并更新代码存储第长度下子序列的最后下标数组的下标递增子序列的长度二分查找的下标在里面二分查找的数因为如果没有比他小的说明都比他大就更新的是抓住当前小于的数的后面一位后面会更新更新接雨水左右两个指针左右两个变量存储左右最大的值每次更新左右任意一边靠着或者的指针的雨水大小相当于是把每一下标积的水累加相当于是从左右两边来进行更新哪边的最大就比较那一边的与大小累加并且更新最大值最后返回累加和最长上升子序列设当前已求出的最长上升子序列的长度为初始时为从前往后遍历数组在遍历到时如果则直接加入到数组末尾并更新否则在数组中二分查找找到第一个比小的数并更新这道题要用二分查找和贪心暴力递归不用了老子存储第长度下子序列的最后下标数组的下标递增子序列的长度二分查找的下标在里面二分查找的数因为如果没有比他小的说明都比他大就更新的是抓住当前小于的数的后面一位后面会更新更新爬楼梯递归笔试状态转移方程可以看出就是斐波拉契数列用三个常量所以空间复杂度为矩阵快速幂如果是斐波拉契数列就要从返回的就是快速幂方法就是将指数循环每次循环内矩阵平方然后指数右移一位初始化为单位一次方先乘一次方注意是不等于的列的行主要就是注意快速幂里面要先进行一次方的判断编辑距离样本对应模型往往用最后的位置来判断可能性给两个单词返回第一个单词转换为第二个单词最少的操作数有增删改三种操作扩展可以增加分别代表增删改的代价根据最后一个位置有四种可能处理边界其中有字符串是空的情况全是增加操作普通情况从最后位置比较该如何处理最后一个位置修改或者保留注意最后一个位置删除最后一个位置增加因为有为的情况所以总的就是所以循环范围需要是并且下标对应下标减一最长公共子序列填边界的时候先将填了防止越界填完第一行和第一列按每行没列填不看当前的情况比较和或者和将这个位置的情况纳入比较和最小路径和的网格从左下角走到右下角怎么走路径最短开始填表注意别写反了扩展记录路径也可以开一个字典应该知道了每个上一个来源坐标最后用一个死循环输出所有当时候退出然后最后进行一个死循环就可以将循环打出来了不同路径的网格从左下角走到右下角有多少种走法方法数最长公共子数组最长重复子数组注意的还是边界应为需要最开始的状态来依赖所以要不选择外围加一圈要不就是内围循环从开始零钱兑换问题完全背包难关于背包问题吃透背包所有问题从左向右的尝试模型给你一个整数数组表示不同面额的硬币以及一个整数表示总金额返回需要最少的硬币个数计算并返回可以凑成总金额所需的最少硬币个数每个硬币都可以说使用无限次动态规划下边最小值相当于左边与下边进行比较无解情况返回返回凑齐的所有方法数返回硬币或者货币可以凑齐钱的所有方法数暴力递归的尝试所有的面值每一个面值都可以任意选择张数组成正好这么多钱方法数多少没钱了说明是有重复解的所以可以进一步进行记忆化搜索记忆化搜索就是用一个结构存储结果后面就不会重复解如果该题没有枚举行为那么傻缓存的方法和严格表结构动态规划的方法就是一样的严格的表结构就是在记忆化搜索的基础上进一步梳理了依赖关系从简单位置算出复杂位置严格规定好了计算顺序有枚举行为需要搞出严格的表结构进行继续优化动态规划第一版有枚举行为和上面记忆化搜索的方法是等效的第二版将枚举行为的规律找出来利用严格的表结构最终代码零钱兑换最小值判断无解情况返回一维难理解零钱兑换一维不是很好理解怕写错最长有效括号给你一个只包含和的字符串找出最长有效格式正确且连续括号子串的长度思路是子串类型看以结尾如果当前是就找可以和他配对的最前左括号下标前一个已经配好对的长度如果是左括号注意防止越界更新在前打家劫舍你是一个专业的小偷计划偷窃沿街的房屋每间房内都藏有一定的现金影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统如果两间相邻的房屋在同一晚上被小偷闯入系统会自动报警给定一个代表每个房屋存放金额的非负整数数组计算你不触动警报装置的情况下一夜之内能够偷窃到的最高金额链接注意要将先填从开始打家劫舍这个地方所有的房屋都围成一圈这意味着第一个房屋和最后一个房屋是紧挨着的是滚动数组可以分成两个数组来判断和矩阵的递增路径给定一个整数矩阵找出其中最长递增路径的长度对于每个单元格你可以往上下左右四个方向移动你不能在对角线方向上移动或移动到边界外即不允许环绕存了数就不用再算了上下左右四个方向机器人机器人在长度的数组中位置在要走步到有多少种方法暴力递归尝试每次走一步位置更新当剩下步到了返回没到返回两个边界条件返回递归结果直接使用矩阵来替代递归的过程纸牌博弈纸牌博弈问题两个会预判的人从左右选卡片返回胜利的人的分数在范围先拿纸牌被聪明人先拿获得的分数拿走一张或者后聪明人成了后拿的人在两种决策中选最优在范围后拿纸牌被聪明人后拿获得的分数对方拿走一张或者后聪明人成了先拿的人对方也是聪明人会留下最差的情况先处理在初始化就是不用管按着对角线来一步步求排序快速排序以为界分为三个部分每次可以找到一个位置的数荷兰国旗在上以为界将数组分为三个部分每次可以找到中间等等于那部分的数情况情况交换和的右边然后情况交换和左边不用随机快排在荷兰国旗基础上将数组的进行随机交换然后递归将数组所有部分都排完最终期望求出来的复杂度就是随机交换递归版本迭代自己压栈把任务做了然后再放出来最开始做一次递归里做的然后在迭代过程中再做递归里做的定义任务压栈开始是从随机交换分界随机交换和分界随机快排的时间复杂度分析通过分析知道划分值越靠近中间性能越好越靠近两边性能越差随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件把每一种情况都列出来会有每种情况下的时间复杂度但概率都是那么所有情况都考虑时间复杂度就是这种概率模型下的长期期望时间复杂度额外空间复杂度都是这么来的找到数组中的第个最大元素是大还是小改写快速排序时间复杂度原先数组不能改变复制一个新数组随机选一个数来分区分区返回两个边界如果分区中间部分包含就找到了没有就根据与边界大小比较大小去其中一部分去找原来的数组不好更改小的话就分区返回两个边界分区中间等于部分包含就是找到了没有找到就到另外两个部分继续找注意这里的因为是使用来分区所以边界注意对比快排用来分区快排还需要交换和返回的右边界是快排是面试聊俗称中位数之中位数算法依靠一种精心设计的选取方法该算法从理论上保证了最坏情形下的线性时间复杂度打败了平均线性最坏复杂度的传统算法算法改进部分就是将快排中随机选数的过程改为五个一组分组组中排好序找出每一段的中位数组成找到的中位数返回五个数一组每个小组内部排序找到中位数领出来组成中找到中位数反调改进部分随机部分改成一个方法五个数一组每个小组内部排序找到中位数领出来组成中找到中位数反调堆排序从下至上让整个数组变为大根堆并将堆顶与结尾交换再去重新调整遍历调整直到从下到上将整个数组变为大根堆结构先找到左孩子如果有孩子将最大的找到并与根比较谁大放在上面归并排序整体是递归左边排好序右边排好序让整体有序让其整体有序的过程里用了排外序方法利用公式来求解时间复杂度当然可以用非递归实现递归版本递归方法实现范围上变成有序的要么越界了要么越界了非递归版本流程就在于折腾步长这个概念步长开始步长的变化一定是的某次方最后一组凑不齐左组就不管了右组有多少算多少步长一旦超过总长度说明搞完了停止就行了注意最后一组左组可能越界从右往左合并就不用考虑越界问题了此处不用等号的原因如果个数最后一个调整是步长为的时候的调整前个数做左组后一个数做右组而是向下取整的所以在等于的时候就停止的话最后一个步长是不会有最后一个步长为的时候导致你出错了优化后的最终版本非递归方法实现当前有序的左组长度一组是倍的左组当前组凑不齐只有左边肯定有序预防越界风险有可能最后一组右组数目不够下一次左组防止溢出复杂度一共执行次数一次的复杂度总的复杂度前缀树单个字符串中字符从前到后的加到一棵多叉树上字符放在路上节点上有专属的数据项常见的是和值所有样本都这样添加如果没有路就新建如有路就复用沿途节点的值增加每个字符串结束时来到的节点值增加可以完成前缀相关的查询例子设计一种结构用户可以添加某个字符串可以重复添加每次算个查询某个字符串在结构中还有几个删掉某个字符串可以重复删除每次算个查询有多少个字符串是以做前缀的前缀树的实现方式经过几次作为几次后面的数组一条最长就所以这个方式不适合很多类型的节点头节点构造方法先抓住头节点从左向右遍历字符则新建节点最后查找出现了几次内存泄漏问题可以解决的先是否存在遍历经过要把且当时将置空后面的节点自动会清除有几个是以作为前缀的字符和步骤差不多最后的是桶排序不基于比较的桶排序思想下的排序计数排序基数排序桶排序思想下的排序都是不基于比较的排序时间复杂度为额外空间负载度应用范围有限需要样本的数据状况满足桶的划分计数排序和基数排序题目计数排序计数排序要求样本是整数且范围比较窄题目基数排序代码一般来讲基数排序要求样本是进制的正整数排序有多少个数准备多少个辅助空间有多少位就进出几次个空间当前位位是的数字有多少个当前位位是和的数字有多少个当前位位是和的数字有多少个当前位位是的数字有多少个一般来讲计数排序要求样本是整数且范围比较窄一般来讲基数排序要求样本是进制的正整数一旦要求稍有升级改写代价增加是显而易见的排序算法的稳定性稳定性是指同样大小的样本再排序之后不会改变相对次序对基础类型来说稳定性毫无意义对非基础类型来说稳定性有重要意义有些排序算法可以实现成稳定的而有些排序算法无论如何都实现不成稳定的排序算法总结时间复杂度额外空间复杂度稳定性选择排序无冒泡排序有插入排序有归并排序有随机快排无堆排序无计数排序有基数排序有不基于比较的排序对样本数据有严格要求不易改写基于比较的排序只要规定好两个样本怎么比大小就可以直接复用基于比较的排序时间复杂度的极限是时间复杂度额外空间复杂度低于且稳定的基于比较的排序是不存在的为了绝对的速度选快排为了省空间选堆排为了稳定性选归并滑动窗口滑动窗口更新结构无重复数组的最长子串给定一个字符串找出里面没有重复的最长子串使用窗口因为不重复可以用来存储结果集是遍历数组向右向右遍历更新表更新更新删除头注意是不包含动态规划版使用数组进行存储先都初始化为下标是字符串值最小覆盖子串给你一个字符串一个字符串返回中涵盖所有字符的最小子串如果中不存在涵盖所有字符的子串则返回空字符串使用来记录中需要的每种字符的数量来记录所有字符剩下没找到的数量记录最小子串开头下标遍历字符集遍历向右右边界扩大同时相应并且没有减到的话当还完之后要将左边界缩小对应的左边界有可能有重复值对应小于要缩到不能缩的地方更新和开头左边界对应次记录最小子串开头下标还完了就是一个解左边界有可能有重复值对应的就是小于的我们要避免所以缩到没有重复的地方才开始记录就是还完之前往右展开就要往左边缩滑动窗口的最大值假设一个固定大小为的窗口依次划过返回每一次滑出状况的最大值定义一个队列来作为窗口里面放的是下标循环遍历数组边界当窗口不为空窗口结尾小于当前结尾弹出是单调递减添加当队首元素已经不再滑动窗口内将其从队首移除当窗口右边界大于等于窗口大小时窗口形成此时队首元素就是该窗口内的最大值满足绝对值差达标的子数组数量给定一个整型数组和一个整数某一个中的子数组如果想达标必须满足中最大值中国最小值返回中达标子数组的数量需要两个双端队列来存储和遍历数组每一个数都做一次开头往右直到当前窗口内子数组不达标滑动窗口比较弹出末尾添加当前值不达标要到达了不达标的位置就可以结束当前开头的收集并弹出开头更新对收集达标的数组个数进行累加更新窗口弹出开头二叉树二叉树先中后序遍历递归前中后非递归压栈先先压右再压左输出头左右打印判空判空后用两个栈先压左再压右同时答应弹出改为压入另一个栈输出头右左最后输出的时候就是左右头头左右前序打印行为改成压栈左右栈弹出打印打印中先将左边界压入栈直到弹出并打印进入右树一开始不用塞空了就弹出打印进入右边二叉搜索树也可以用这个二叉树的层序遍历给你一个二叉树请你返回其按层序遍历得到的节点值即逐层地从左到右访问所有节点打印每一层给你二叉树的根节点返回其节点值的层序遍历就是逐层打印先定义结果集和判空操作定义队列容器放入队列中定义结果集元素即每一层二叉树的锯齿形遍历就是在层序遍历基础上使用来判断打印的顺序就是添加到开头通过判断打印顺序这里易错返回节点最多的那一层需要记录是否当前到层的结尾需要记录下一层的最后节点将上面层序遍历添加每层元素的过程改为记录层的当时更新二叉树的右视图给定一个二叉树的根节点想象自己站在它的右侧按照从顶部到底部的顺序返回从右侧所能看到的节点值需要记录是否当前到层的结尾需要记录下一层的最后节点用记录最后一个节点更新当前最后的节点最大宽度左右节点的距离给定一个二叉树编写一个函数来获取这个树的最大宽度树的宽度是所有层中的最大宽度这个二叉树与满二叉树结构相同但一些节点为空每一层的宽度被定义为两个端点该层最左和最右的非空节点两端点间的节点也计入长度之间的长度避免不了要记录每一个节点的所以需要一个新的节点结构在层序遍历基础上队列添加的是一个新的节点结构来对每个节点的层数和进行记录不需要每次队列进行一次循环都要检查如果说明到了下一层将更新用抓住第一个的更新一开始添加的就是记录当前层记录每层最前结构不能搞错参数不要穿错二叉树的最近公共祖先给定一个二叉树找到该树中两个指定节点的最近公共祖先百度百科中最近公共祖先的定义为对于有根树的两个节点最近公共祖先表示为一个节点满足是的祖先且的深度尽可能大一个节点也可以是它自己的祖先是否包含是否包含保存结果填充当前二叉树最大路径和如果连上父节点的贡献值返回对称二叉树给你一个二叉树的根节点检查它是否轴对称复制一个自己的树两个树都是空两个树都不是空就返回当前节点值要相等左边和右边也是一个是空一个不是空从前序和中序序列构造二叉树给定两个整数数组和其中是二叉树的先序遍历是同一棵树的中序遍历请构造二叉树并返回其根节点利用二叉树前序头左右找到头再利用中序左右头进行左右树分离越界情况利用前序找到头中序对应找到头的下标就是左树的长度验证二叉搜索树给你一个二叉树的根节点判断其是否是一个有效的二叉搜索树有效二叉搜索树定义如下节点的左子树只包含小于当前节点的数节点的右子树只包含大于当前节点的数所有左子树和右子树自身必须也是二叉搜索树用中序遍历平衡二叉树使用递归套路高度是否是平衡二叉树需要的信息找信息的过程解决当前的的方法也就是所有递归都会用到的方法二叉树的序列化和反序列化思路序列化准备一个的队列然后按照先序顺序将结点转为类型然后加入队列左边和右边结点按照顺序递归执行该方法反序列化将要转化为二叉树的队列传入然后弹出结点为注意转换回为类型左边递归执行右边递归执行错误判断值注意判断哈特别是递归里面就算是方法前面判断了当时不代表递归以后不会再次出现所以方法内还要再判断一次二叉树的前中后序列化序列化使用队列用来规定用什么来占位反序列化二叉树的最大深度给定一个二叉树找出其最大深度二叉树的深度为根节点到最远叶子节点的最长路径上的节点数说明叶子节点是指没有子节点的节点示例给定二叉树返回它的最大深度最大直径给定一棵二叉树你需要计算它的直径长度一棵二叉树的直径长度是任意两个结点路径长度中的最大值这条路径可能穿过也可能不穿过根结点示例给定二叉树返回它的长度是路径或者二叉树最大直径递归套路路径总和路径总和要求返回是否存在总和为的从根到节点的路径是叶子节点不是叶子节点路径总和要求返回所有满足的路径注意现场要恢复因为只有一个来存路如果没有清空后面根本装不下叶子节点传递是引用不能直接传不是叶子节点恢复现场翻转二叉树给你一棵二叉树的根节点翻转这棵二叉树并返回其根节点翻转二叉树有点像数组栈有效括号给定一个只包括的字符串判断字符串是否有效遍历所有左边的括号变成对应的右括号压入栈遇到的右边的括号如果是空的则弹出栈顶比较不相等最后必须是空的才能满足用栈实现队列最小栈设计一个支持操作并能在常数时间内检索到最小元素的栈将元素推入栈中删除栈顶的元素获取栈顶元素检索栈中的最小元素两个队列实现栈在操作里进行改进就可以通过用一个队列也可以单调栈为了解决给定的一个可能含有重复值的位置一定有以下信息左边有离它最近比它小的大的数右边有离它最近比它小的大的数找到左边和右边离最近比其小的下表对新的数压栈如果比栈底小栈底弹出并记录数组中有重复的情况放的是位置同样值的东西位置压在一起代表值底顶小大新的数压栈如果比栈底小栈底弹出并记录相等的比你小的都要把存入栈的格式改为存储了位置的数组取决于最晚加入的那个正数数组中的累加和的最大值给定一个只包含正数的数组中任何一个子数组一定都可以算出累加和中的最小值是什么那么所有子数组中这个值最大是多少直接找每个数两边最近比它小中间部分累加和这部分该数一定最小建立前缀和数组这样求累加和就可以和上面单调栈思路差不多栈顶弹出后更新再遍历栈里的元素右边没有比它最小所以累加直接用来减递归全排列给定一个不含重复数字的数组返回其所有可能的全排列你可以按任意顺序返回答案选择的路是在树形结构里平行进行先交换成为一种情况往下递归将剩余部分的情况搞定恢复原来状态因为平行的分支需要同样的状态剪枝全排列不重复全排列将给定数组进行排列组合回溯不同打印结果存储是在树形结构里平行进行先交换成为一种情况往下递归将剩余部分的情况搞定恢复原来状态因为平行的分支需要同样的状态剪枝数组有负数要加上括号生成数字代表生成括号的对数请你设计一个函数用于能够生成所有可能的并且有效的括号组合利用一个原理是当前面已经做了选择的左括号比右括号多的时候就添加右括号需要剪枝在往里面添加括号的时候进行条件剪枝传进去的参数剪枝左边括号还有和左边右边到结尾一种可能左边的括号还有将当前的位置设为左剩下的去递归左边的括号大于右边的括号复原地址有效地址正好由四个整数每个整数位于到之间组成且不能含有前导整数之间用分隔例如和是有效地址但是和是无效地址给定一个只包含数字的字符串用以表示一个地址返回所有可能的有效地址这些地址可以通过在中插入来形成你不能重新排序或删除中的任何数字你可以按任何顺序返回答案存储第段字符串段数已经递归到第四段并且所有数字都完成记得向上返回四段没玩但是已经到结尾有的情况有零一般情况属于单词搜索回溯子集给你一个整数数组数组中的元素互不相同返回该数组所有可能的子集幂集解集不能包含重复的子集你可以按任意顺序返回解集示例输入输出示例输入输出用来存放之前决定两种可能并查集并查集用来解决图的连通性和环的数量结构表并查集构造方法点最高父亲所在集合大小初始化参数遍历先一个然后更新点集更新父亲表自己是自己爹最后更新找爹一个栈如果当前不是自己爹压栈更新为自己爹如果栈不空就是当前最爹所以循环弹出将设为他们爹返回两爹是否相等并如果两爹不同抓住大小小的那个接在大的下面是的父更新大集的并转移小集的岛屿数量给你一个由陆地和水组成的的二维网格请你计算网格中岛屿的数量岛屿总是被水包围并且每座岛屿只能由水平方向和或竖直方向上相邻的陆地连接形成此外你可以假设该网格的四条边均被水包围从这个位置出发把所有练成一片的字符变成使用并查集面试为什么要并查集如果有多台大岛变成小岛就会很容易面试就讲一下怎么通过并查集来进行并查集就是可以将所在的集合进行合并需要每个岛的位置所以需要一个方法来返回每格子的位置就是行数乘以矩阵宽度再加上列数然后要进行具体过程就是先找到两个要合并的点的父亲如果不相同就再调出两个所在集合的大小然后将小的集合接在大的集合下面更新这里找父亲的操作可以用一个数组倒序遍历来代替栈使用并查集把第一行第一列先处理就不需要后面考虑边界除了第一行第一列的部分看上面和左边用来计算矩阵数原始位置下标省份数量朋友圈有个城市其中一些彼此相连另一些没有相连如果城市与城市直接相连且城市与城市直接相连那么城市与城市间接相连省份是一组直接或间接相连的城市组内不含其他没有相连的城市使用数组结构的并查集定义一个指针不是自己爹压栈虚拟的指向自己的爹遍历模拟栈弹出所有人爹设为返回此时指向最爹图将矩阵转化为自己的结构一个自己的遍历矩阵每一行判断是否和分别放入点集初始化并赋值更新出入度直接点直接边边放入边集图的从出发进行宽度优先遍历拓扑排序拓扑排序有向无环图某个节点剩余的入度只有剩余入度为的点才进入这个队列',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-18 09:21:09',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Sonia33's Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BlockChain/" style="font-size: 1.05rem;">BlockChain<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>1</sup></a><a href="/tags/DataBase/" style="font-size: 1.05rem;">DataBase<sup>2</sup></a><a href="/tags/FastDFS/" style="font-size: 1.05rem;">FastDFS<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/IO/" style="font-size: 1.05rem;">IO<sup>1</sup></a><a href="/tags/JDBC/" style="font-size: 1.05rem;">JDBC<sup>1</sup></a><a href="/tags/JQuery/" style="font-size: 1.05rem;">JQuery<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>2</sup></a><a href="/tags/NoSQL/" style="font-size: 1.05rem;">NoSQL<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 1.05rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redis/" style="font-size: 1.05rem;">Redis<sup>1</sup></a><a href="/tags/Zookeeper/" style="font-size: 1.05rem;">Zookeeper<sup>1</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>1</sup></a><a href="/tags/macOS/" style="font-size: 1.05rem;">macOS<sup>2</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.05rem;">分布式<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">并发编程<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">测试<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>1</sup></a><a href="/tags/%E8%B8%A9%E9%9B%B7/" style="font-size: 1.05rem;">踩雷<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/05/"><span class="card-archive-list-date">五月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">三月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/09/"><span class="card-archive-list-date">九月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/08/"><span class="card-archive-list-date">八月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/07/"><span class="card-archive-list-date">七月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/06/"><span class="card-archive-list-date">六月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url">算法</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a></span></div></div><h1 class="post-title" itemprop="name headline">算法高频题总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-02-23T02:24:18.000Z" title="发表于 2022-02-23 10:24:18">2022-02-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2022-05-18T01:21:09.607Z" title="更新于 2022-05-18 09:21:09">2022-05-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://soniachen.com/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/"><header><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url">算法</a><a href="/tags/Java/" tabindex="-1" itemprop="url">Java</a><h1 id="CrawlerTitle" itemprop="name headline">算法高频题总结</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Sonia33</span><time itemprop="dateCreated datePublished" datetime="2022-02-23T02:24:18.000Z" title="发表于 2022-02-23 10:24:18">2022-02-23</time><time itemprop="dateCreated datePublished" datetime="2022-05-18T01:21:09.607Z" title="更新于 2022-05-18 09:21:09">2022-05-18</time></header><h1>高频题</h1>
<h2 id="三数之和">三数之和</h2>
<p><a href="##%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C##">两数之和</a>为基础</p>
<blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 先将数组排序</span></span><br><span class="line">  <span class="comment">// 2 从后往前遍历最后一个数 找对应的二元组：二元组 + arr[i] = 0</span></span><br><span class="line">  <span class="comment">// 2.1 保证不重复</span></span><br><span class="line">  <span class="comment">// 2.2 找出前面部分满足条件的二元组</span></span><br><span class="line">  <span class="comment">// 2.3 遍历将arr[i]添加在后面</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      <span class="comment">// 1</span></span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123; <span class="comment">// 三元组最后一个数，是arr[i]   之前....二元组 + arr[i]</span></span><br><span class="line">          <span class="comment">// 2.1</span></span><br><span class="line">          <span class="keyword">if</span> (i == N - <span class="number">1</span> || nums[i] != nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">              <span class="comment">// 2.2</span></span><br><span class="line">              List&lt;List&lt;Integer&gt;&gt; nexts = twoSum(nums, i - <span class="number">1</span>, -nums[i]);</span><br><span class="line">              <span class="comment">// 2.3</span></span><br><span class="line">              <span class="keyword">for</span> (List&lt;Integer&gt; cur : nexts) &#123;</span><br><span class="line">                  cur.add(nums[i]);</span><br><span class="line">                  ans.add(cur);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// nums[0...end]这个范围上，有多少个不同二元组，相加==target，全返回</span></span><br><span class="line">  <span class="comment">// &#123;-1,5&#125;     K = 4</span></span><br><span class="line">  <span class="comment">// &#123;1, 3&#125;</span></span><br><span class="line">  <span class="comment">// 1 两个指针</span></span><br><span class="line">  <span class="comment">// 2 两数相加大于目标值就右缩;小于就左缩;等于就添加在结果集里面（先加左再加右）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> end, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> end;</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nums[L] + nums[R] &gt; target) &#123;</span><br><span class="line">              R--;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[L] + nums[R] &lt; target) &#123;</span><br><span class="line">              L++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[L] + nums[R] == target</span></span><br><span class="line">              <span class="keyword">if</span> (L == <span class="number">0</span> || nums[L - <span class="number">1</span>] != nums[L]) &#123;</span><br><span class="line">                  List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                  cur.add(nums[L]);</span><br><span class="line">                  cur.add(nums[R]);</span><br><span class="line">                  ans.add(cur);</span><br><span class="line">              &#125;</span><br><span class="line">              L++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="两数之和">两数之和</h2>
<blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
</blockquote>
<p>1 使用hashmap 结构 map.put(nums[i], i)</p>
<p>2 遍历一遍 如果查询到map里面有与解 就返回i和mapget的value</p>
<p>3 最后如果没有找到就返回new int[0]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索旋转排序数组（面试）">搜索旋转排序数组（面试）</h2>
<p><strong>使用二分查找</strong></p>
<blockquote>
<p>整数数组nums按升序排列，数组中的值互不相同。</p>
<p>arr，原本是有序数组，旋转过，而且左部分长度不知道.(以某一个下标为轴旋转 例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。)</p>
<p>题目需要在arr里面找到target</p>
</blockquote>
<p><strong>思路</strong>：</p>
<ol>
<li><code>L = M = R</code> 是最差的情况 不知道断点</li>
<li><code>L != M == R</code>/ <code>L == M != R</code>/ <code>L != M != R</code> 只要三个数不全部一样就可以进行<strong>二分</strong></li>
</ol>
<img src="算法高频题总结/image-20220508120620575.png" alt="image-20220508120620575" style="zoom: 33%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">		<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> N - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> (L + R) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (nums[M] == target) &#123;</span><br><span class="line">				<span class="keyword">return</span> M;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// nums[M] != target</span></span><br><span class="line">			<span class="comment">// 1 左 中 右 相等 -- 》不能二分</span></span><br><span class="line">			<span class="keyword">if</span> (nums[L] == nums[M] &amp;&amp; nums[M] == nums[R]) &#123;</span><br><span class="line">				<span class="comment">// 左中一直相等 L ++</span></span><br><span class="line">				<span class="keyword">while</span> (L != M &amp;&amp; nums[L] == nums[M]) &#123;</span><br><span class="line">					L++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 1.1 左中直到重合都相等</span></span><br><span class="line">				<span class="keyword">if</span> (L == M) &#123;</span><br><span class="line">					L = M + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">continue</span>;<span class="comment">// 回到循环开始重新来</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 1.2 或者是 到不相等地方 继续2</span></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 2 左中右不都相等 --&gt; 代表可以二分</span></span><br><span class="line">			<span class="keyword">if</span> (nums[L] != nums[M]) &#123; <span class="comment">// 2.1 [L] != [M] ?= [R]</span></span><br><span class="line">				<span class="keyword">if</span> (nums[L] &lt; nums[M]) &#123;<span class="comment">// 2.1.1 L &lt; M 左边一定有序</span></span><br><span class="line">					<span class="keyword">if</span> (nums[L] &lt;= target &amp;&amp; target &lt; nums[M]) &#123;</span><br><span class="line">						R = M - <span class="number">1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						L = M + <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.1.2 L &gt; M 左边一定有断点 右边有序</span></span><br><span class="line">					<span class="keyword">if</span> (nums[M] &lt; target &amp;&amp; target &lt;= nums[R]) &#123;</span><br><span class="line">						L = M + <span class="number">1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						R = M - <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">// 2.2 [L] ?= [M] != [R]</span></span><br><span class="line">				<span class="keyword">if</span> (nums[M] &lt; nums[R]) &#123;<span class="comment">// 2.2.1 M &lt; R</span></span><br><span class="line">					<span class="keyword">if</span> (nums[M] &lt; target &amp;&amp; target &lt;= nums[R]) &#123;</span><br><span class="line">						L = M + <span class="number">1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						R = M - <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.1.2 M &gt; R</span></span><br><span class="line">					<span class="keyword">if</span> (nums[L] &lt;= target &amp;&amp; target &lt; nums[M]) &#123;</span><br><span class="line">						R = M - <span class="number">1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						L = M + <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并两个有序数组">合并两个有序数组</h2>
<blockquote>
<p>给你两个有序数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的<code>元素数目</code>。进行合并。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">       <span class="keyword">while</span>(m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123; <span class="comment">// 相等的时候先拷贝长数组的  尽可能让空间早释放</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[m - <span class="number">1</span>] &gt;= nums2[n -<span class="number">1</span>])&#123;</span><br><span class="line">                nums1[--index] = nums1[--m];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[--index] = nums2[--n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;<span class="comment">// m都被填完 就把nums2剩下的n填进nums1</span></span><br><span class="line">            nums1[--index] = nums2[--n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="螺旋矩阵">螺旋矩阵</h2>
<blockquote>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
</blockquote>
<img src="算法高频题总结/image-20220508120715738.png" alt="image-20220508120715738" style="zoom:50%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">	List&lt;Integer&gt; order = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> order;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 易错点一：注意right和bottom别写反了。</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">		<span class="comment">// 上层：从左到右，行不变，列变。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">			order.add(matrix[top][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 右层：从上到下，行变，列不变。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">			order.add(matrix[i][right]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 易错点二：注意针对行列不相等时，下面两个循环要满足right &gt; left &amp;&amp; bottom &gt; top条件 ⚠️</span></span><br><span class="line">		<span class="keyword">if</span> (right &gt; left &amp;&amp; bottom &gt; top) &#123;</span><br><span class="line">			<span class="comment">// 下层：从右向左，行不变，列变。</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">				order.add(matrix[bottom][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 左层：从下到上，行变，列不变。</span></span><br><span class="line">			<span class="comment">// 易错点三：此处只需要 i&gt;top, i不能=top</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">				order.add(matrix[i][left]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		left++;</span><br><span class="line">		top++;</span><br><span class="line">		right--;</span><br><span class="line">		bottom--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串相加">字符串相加</h2>
<blockquote>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings2</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">	<span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x + y + add;</span><br><span class="line">		ans.append(result % <span class="number">10</span>);</span><br><span class="line">		add = result / <span class="number">10</span>;</span><br><span class="line">		i--;</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">	ans.reverse();</span><br><span class="line">	<span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找">二分查找</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R)&#123; <span class="comment">// ⚠️ 没有相等</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid])&#123;</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (nums[L] == target) ? L : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="在排序数组中找到元素第一个和最后一个位置">在排序数组中找到元素第一个和最后一个位置</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在排序数组中查找元素的第一个和最后一个位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fre_044_FindFirstAndLastPositionOfElementInSortedArray</span> &#123;</span><br><span class="line">	<span class="comment">// 借助二分 《找到数组中比它小的最右的数 (lessMostRight</span></span><br><span class="line">	<span class="comment">// 如果该位置右边!=target说明数组没有这个数</span></span><br><span class="line">	<span class="comment">// 如果是 那么左边界找到 右边界就是《找到比ta+1小的最右的数》 (lessMostRight</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> lessMostRight(nums, target) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (L == nums.length || nums[L] != target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; L, lessMostRight(nums, target + <span class="number">1</span>) &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 利用二分 </span></span><br><span class="line">	<span class="comment">// 1 一个指针 M</span></span><br><span class="line">	<span class="comment">// 2 ans存放结果</span></span><br><span class="line">	<span class="comment">// 3 arr[M] 小于就去右边找 大于就去左边找</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lessMostRight</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 1</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 2 </span></span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 3</span></span><br><span class="line">		<span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">			M = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (arr[M] &lt; num) &#123;</span><br><span class="line">				ans = M;</span><br><span class="line">				L = M + <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				R = M - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串转化整数">字符串转化整数</h2>
<p>注意有很多特殊情况</p>
<blockquote>
<p>1.需要删除无用的前导空格</p>
<p>2.检查下一个字符为正还是负</p>
<p>3.只读一开始是数字的部分</p>
<img src="算法高频题总结/image-20220212174954825.png" alt="image-20220212174954825" style="zoom:50%;" />
<img src="算法高频题总结/image-20220212174938284.png" alt="image-20220212174938284" style="zoom:50%;" />
<p>4.超出范围的数字返回边界</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 主函数myAtoi():</span><br><span class="line">     1 除去空格和后面非数字的部分( 前后都要判空)【removeHeadZero()】</span><br><span class="line">     2 判断该部分是否是有效数字【isValid()】</span><br><span class="line">     3 转为负数形式（转回不会溢出，负数范围大些） posi(标志正负)</span><br><span class="line">     4 res是最负的情况 (用了负数就只用可以装下，如果用整数转，最小就没法装)</span><br><span class="line">2. removeHeadZero():</span><br><span class="line">     1 是否有符号</span><br><span class="line">     2 s标志第一个不是零的位置</span><br><span class="line">     3 e标志数字部分后面的非数字部分的开头</span><br><span class="line">     4 返回截取的带符号整数部分</span><br><span class="line">3. isVaild():    判断带符号整数部分是否有效</span><br><span class="line">     1 开头在remove部分没有判断，只要开头不是数字和符号都返回无效</span><br><span class="line">     2 只有符号也无效</span><br><span class="line">     3 夹杂着非数字字符也无效</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fre_072_StringToInteger</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 1 除去空格和后面不是数字的部分</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.equals(<span class="string">&quot;&quot;</span>))&#123;<span class="comment">// ⚠️</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = removeHeadZero(s.trim());</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 判断这部分是不是有效数字</span></span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(!isValid(str))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 转为负数形式 为了防止溢出 posi(标志正负) ⚠️不要搞反了</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">posi</span> <span class="operator">=</span> str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 后面会有*10的操作 需要先判断会不会溢出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minq</span> <span class="operator">=</span> Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minp</span> <span class="operator">=</span> Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> || str[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">            cur = <span class="string">&#x27;0&#x27;</span> - str[i]; <span class="comment">// 转为负数</span></span><br><span class="line">            <span class="comment">// 在乘十之前判断是否会溢出</span></span><br><span class="line">            <span class="keyword">if</span>(res &lt; minq || (res == minq &amp;&amp; cur &lt; minp))&#123;</span><br><span class="line">                	<span class="keyword">return</span> posi ? Integer.MAX_VALUE : Integer.MIN_VALUE; </span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + cur;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 res是最负情况（也就是本来是最大的+1）</span></span><br><span class="line">        <span class="keyword">if</span>(posi &amp;&amp; (res == Integer.MIN_VALUE))&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE; <span class="comment">// 返回边界</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> posi ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeHeadZero</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">// 1 是否有符号</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r</span> <span class="operator">=</span> (s.startsWith(<span class="string">&quot;+&quot;</span>) || s.startsWith(<span class="string">&quot;-&quot;</span>)); <span class="comment">// ⚠️ 不能用charat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 标志第一个不是零的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> r ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; start&lt; s.length(); start++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 找到数字部分后面的非数组部分开头 倒着遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= (r ? <span class="number">1</span> : <span class="number">0</span>); i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>  || s.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                e = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回截取的带符号的整数部分</span></span><br><span class="line">        <span class="keyword">return</span> (r ? String.valueOf(s.charAt(<span class="number">0</span>)): <span class="string">&quot;&quot;</span>) + s.substring(start, e == -<span class="number">1</span> ? s.length() : e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是有效的数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">        <span class="comment">// 1 如果开头不是数组</span></span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; str[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; (str[<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span> || str[<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 只有符号也无效</span></span><br><span class="line">        <span class="keyword">if</span>((str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> || str[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &amp;&amp; str.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 夹杂着非数字字符 无效</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt;<span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下一个排列">下一个排列</h2>
<blockquote>
<p>给你一个整数数组 nums ，找出 nums 的字典序中的下一个排列。</p>
<p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">       <span class="comment">// 1 倒着找升序对 [ i , i+ 1]</span></span><br><span class="line">       <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">           i--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2 从end -&gt; i+1 倒着找比i大的数</span></span><br><span class="line">       <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(nums[i] &gt;= nums[j])&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           swap(nums, i, j);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3 将数组i+1以后的反转</span></span><br><span class="line">       <span class="comment">// 因为有两种情况：1） i&lt; 0 说明本身就是字典序最大，直接翻转 2）[i+1, end]是降序需要翻转</span></span><br><span class="line">       reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span>  nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">           swap(nums, left, right);</span><br><span class="line">           left++;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">       nums[i] = nums[j];</span><br><span class="line">       nums[j] = tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并区间">合并区间</h2>
<blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
</blockquote>
<ol>
<li>s 和 e 记录上一个区间的边界</li>
<li>然后复用interval数组来存储，最后复制数组size部分</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 先按照区间的左边界来排序</span></span><br><span class="line">		Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">		<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];<span class="comment">// </span></span><br><span class="line">		<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 然后复用interval数组来存储，最后复制数组size部分</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; e) &#123;<span class="comment">// 如果当前左边界大于e 说明没有覆盖 </span></span><br><span class="line">				intervals[size][<span class="number">0</span>] = s;<span class="comment">// 可以更新size部分的s和e 然后size++</span></span><br><span class="line">				intervals[size++][<span class="number">1</span>] = e;</span><br><span class="line">				s = intervals[i][<span class="number">0</span>];</span><br><span class="line">				e = intervals[i][<span class="number">1</span>];<span class="comment">// s e 更新为当前的左右边界</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				e = Math.max(e, intervals[i][<span class="number">1</span>]); <span class="comment">// 如果当前左边界小于或者等于 说明两个区间可以覆盖 先将e更新为这两个区间的最大右区间</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		intervals[size][<span class="number">0</span>] = s; <span class="comment">// 最后还有一次size处的更新</span></span><br><span class="line">		intervals[size++][<span class="number">1</span>] = e;</span><br><span class="line">		<span class="keyword">return</span> Arrays.copyOf(intervals, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="x的平方根">x的平方根</h2>
<p>==二分查找==</p>
<blockquote>
<p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 使用 二分 &lt;=就更新ans和L 到右边就更新R</span><br><span class="line">2. 注意数据类型时long主要是为了两个整型相乘不会溢出</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x一定非负，输入可以保证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// x &gt;= 3</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">R</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">long</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">            M = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 因为两个整数相乘可能会溢出</span></span><br><span class="line">            <span class="keyword">if</span> (M * M &lt;= x) &#123;</span><br><span class="line">                ans = M;</span><br><span class="line">                L = M + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                R = M - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>扩展：求出小数点后k位 其实思路与一样 只是换成double类型并且需要转换数格式</p>
<h2 id="缺失的正数">缺失的正数</h2>
<blockquote>
<p>给你一个未排序的整数数组，请你找出没有出现的最小的正整数 时间复杂度o(n)</p>
</blockquote>
<p>除了打标记以外，我们还可以使用置换的方法，将给定的数组「恢复」成下面的形式：</p>
<pre><code>如果数组中包含 x∈[1,N]x \in [1, N]x∈[1,N]，那么恢复后，数组的第 x−1x - 1x−1 个元素为 xxx。
</code></pre>
<p>在恢复后，数组应当有 [1, 2, …, N] 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以题目中的示例二 [3, 4, -1, 1] 为例，恢复后的数组应当为 [1, -1, 3, 4]，我们就可以知道缺失的数为 2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123; </span><br><span class="line">              <span class="comment">// ⚠️交换的条件---nums[i]∈[1,N] 且 nums[i]和本来应该在的位置的值nums[nums[i]-1]不相等</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="用rand7-生成rand10">用rand7()生成rand10()</h2>
<blockquote>
<p>用一个不等概率返回0和1的函数, 怎么加工一个函数0和1等概率返回</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">int</span> ans= <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">           ans = f2();</span><br><span class="line">       &#125;<span class="keyword">while</span>(ans &gt;<span class="number">9</span>);</span><br><span class="line">       <span class="keyword">return</span> ans + <span class="number">1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">int</span> ans= <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">           ans = rand7();</span><br><span class="line">       &#125;<span class="keyword">while</span>(ans == <span class="number">4</span>);</span><br><span class="line">       <span class="keyword">return</span> ans &lt; <span class="number">4</span>? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0000~1111 0~15</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (f() &lt;&lt; <span class="number">3</span>) + (f() &lt;&lt; <span class="number">2</span>) + (f() &lt;&lt; <span class="number">1</span> )+ f();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="找到两个有序数组的中位数-⚠️-两个有序数组第k小">找到两个有序数组的中位数(⚠️)/两个有序数组第k小</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">//这里就主要处理 两个为空 一个为空 全不为空的三个情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums1.length + nums2.length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">e</span> <span class="operator">=</span> (size &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length == <span class="number">0</span> &amp;&amp; nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!e)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[size/ <span class="number">2</span>];                   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">double</span>)(nums2[ size / <span class="number">2</span>- <span class="number">1</span>] + nums2[size / <span class="number">2</span> ])/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums2.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!e)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[size/ <span class="number">2</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">double</span>)(nums1[size / <span class="number">2</span> - <span class="number">1</span>] + nums1[size / <span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!e)&#123;</span><br><span class="line">                <span class="keyword">return</span> findKthNum(nums1, nums2, size / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">double</span>)(findKthNum(nums1, nums2, size/<span class="number">2</span>)+findKthNum(nums1, nums2, size/<span class="number">2</span> +<span class="number">1</span>))/<span class="number">2D</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getUpMedian</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span> s1,<span class="type">int</span> e1,<span class="type">int</span>[] arr2, <span class="type">int</span> s2, <span class="type">int</span> e2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s1 &lt; e1)&#123;</span><br><span class="line">            <span class="comment">//mid</span></span><br><span class="line">            mid1 = (e1 + s1) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            mid2 = (e2 + s2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr1[mid1] == arr2[mid2] ) <span class="keyword">return</span> arr1[mid1];</span><br><span class="line">            <span class="comment">//奇数</span></span><br><span class="line">            <span class="keyword">if</span>(((e1 - s1 + <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[mid1] &lt; arr2[mid2])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr1[mid1] &gt;= arr2[mid2 - <span class="number">1</span>]) <span class="keyword">return</span> arr1[mid1];</span><br><span class="line">                    s1 = mid1 + <span class="number">1</span>;</span><br><span class="line">                    e2 = mid2 - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr2[mid2] &gt;= arr1[mid1 - <span class="number">1</span>]) <span class="keyword">return</span> arr2[mid2];</span><br><span class="line">                    s2 = mid2 + <span class="number">1</span>;</span><br><span class="line">                    e1 = mid1 - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//偶数</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[mid1] &gt; arr2[mid2])&#123;</span><br><span class="line">                    e1 = mid1;</span><br><span class="line">                    s2 = mid2 + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    e2 = mid2;</span><br><span class="line">                    s1 = mid1 + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后跳出循环 都只剩一个数</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(arr1[s1], arr2[s2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理长度不同 返回Kth的情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKthNum</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] longs = arr1.length &gt;= arr2.length ? arr1 : arr2;</span><br><span class="line">        <span class="type">int</span>[] shorts = arr1.length &lt; arr2.length ? arr1 : arr2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> longs.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> shorts.length;</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= s)&#123;</span><br><span class="line">            <span class="keyword">return</span> getUpMedian(longs, <span class="number">0</span>, k - <span class="number">1</span>, shorts, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(longs[k - s - <span class="number">1</span>] &gt;= shorts[s - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> longs[k - s -<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shorts[k - l - <span class="number">1</span>] &gt;= longs[l - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> shorts[k - l - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> getUpMedian(longs, k - s, l - <span class="number">1</span>, shorts, k - l, s - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span>(longs[k - s - <span class="number">1</span>] &gt;= shorts[s - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> longs[k - s - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getUpMedian(longs, k - s, k - <span class="number">1</span>,shorts, <span class="number">0</span> ,s - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="翻转字符串中的单词">翻转字符串中的单词</h2>
<blockquote>
<p>给你一个字符串 s ，逐个翻转字符串中的所有 单词 。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。</p>
<p>说明：</p>
<p>输入字符串 s 可以在前面、后面或者单词间包含多余的空格。<br>
翻转后单词间应当仅用一个空格分隔。<br>
翻转后的字符串中不应包含额外的空格。</p>
<p>示例 1：</p>
<p>输入：s = “the sky is blue”<br>
输出：“blue is sky the”</p>
<p>示例 2：</p>
<p>输入：s = &quot;  hello world  &quot;<br>
输出：“world hello”<br>
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。</p>
</blockquote>
<h3 id="思路">思路:</h3>
<ol>
<li><strong>去除多余的空白：</strong><br>
<strong>(1去掉字符串开头的空白字符</strong><br>
<strong>(2去掉字符串末尾的空白字符</strong><br>
<strong>(3将字符串间多余的空白字符去除</strong></li>
<li><strong>翻转字符串：</strong></li>
<li><strong>翻转每一个单词：</strong><br>
<strong>(1 遍历sb 使用start 和 end来抓单词</strong><br>
<strong>(2 翻转单词</strong><br>
<strong>(3 更新start，去找下一个单词</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 去除多余的空白</span></span><br><span class="line">    <span class="comment">// 2 翻转字符串</span></span><br><span class="line">    <span class="comment">// 3 翻转每一个单词</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> trimSpaces(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 去掉字符串开头的空白字符</span></span><br><span class="line">    <span class="comment">// 2 去掉字符串末尾的空白字符</span></span><br><span class="line">    <span class="comment">// 3 将字符串间多余的空白字符去除</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">trimSpaces</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 1 </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转任意字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 遍历sb 使用start 和 end来抓单词</span></span><br><span class="line">        <span class="comment">// 2 翻转单词</span></span><br><span class="line">        <span class="comment">// 3 更新start，去找下一个单词</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串相乘">字符串相乘</h2>
<blockquote>
<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<p>示例 1:</p>
<p>输入: num1 = “2”, num2 = “3”<br>
输出: “6”</p>
<p>示例 2:</p>
<p>输入: num1 = “123”, num2 = “456”<br>
输出: “56088”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length(), n = num2.length();</span><br><span class="line">        <span class="type">int</span>[] ansArr = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ansArr[i + j + <span class="number">1</span>] += x * y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m + n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ansArr[i - <span class="number">1</span>] += ansArr[i] /<span class="number">10</span>;</span><br><span class="line">            ansArr[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ansArr[<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; m + n) &#123;</span><br><span class="line">            ans.append(ansArr[index]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除数组中的重复项">删除数组中的重复项</h2>
<p>任何删除重复的都可以用快慢指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除有序数组中的重复项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chs</span></span><br><span class="line"><span class="comment"> * 任何删除重复的都可以用快慢指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fre_017_RemoveDuplicatesFromSortedArray</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums.length;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">done</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] != nums[done]) &#123;</span><br><span class="line">				nums[++done] = nums[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> done + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="去除重复字母">去除重复字母</h2>
<p>贪心➕单调栈？</p>
<blockquote>
<p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>示例 1：</p>
<p>输入：s = “bcabc”<br>
输出：“abc”</p>
<p>示例 2：</p>
<p>输入：s = “cbacdcbc”<br>
输出：“acdb”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           num[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (!vis[ch - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">               <span class="keyword">while</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; sb.charAt(sb.length() - <span class="number">1</span>) &gt; ch) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (num[sb.charAt(sb.length() - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       vis[sb.charAt(sb.length() - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">                       sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               vis[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">               sb.append(ch);</span><br><span class="line">           &#125;</span><br><span class="line">           num[ch - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="单词搜索">单词搜索</h2>
<blockquote>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<img src="算法高频题总结/image-20220228230315689.png" alt="image-20220228230315689" style="zoom:33%;" />
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a &lt; c) &#123;</span><br><span class="line">            rotateEdge(matrix, a++, b++, c--, d--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotateEdge</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; d - b; i++) &#123;</span><br><span class="line">            tmp = m[a][b + i];</span><br><span class="line">            m[a][b + i] = m[c - i][b];</span><br><span class="line">            m[c - i][b] = m[c][d - i];</span><br><span class="line">            m[c][d - i] = m[a + i][d];</span><br><span class="line">            m[a + i][d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="多数元素">多数元素</h2>
<blockquote>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>是一个超级水王问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1遍历 使用 candidate和HP 来一次删除两个不同的数</span><br><span class="line">2到最后 HP 不为0 则说明可能有水王 是当前的candidate</span><br><span class="line">3再遍历一次找candi 如果 HP&gt; n/2 说明就是水王 </span><br></pre></td></tr></table></figure>
<img src="算法高频题总结/image-20220228231911847.png" alt="image-20220228231911847" style="zoom:50%;" />
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">candi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">HP</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(HP == <span class="number">0</span>) &#123;</span><br><span class="line">                candi = nums[i];</span><br><span class="line">                HP++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[i] != candi) &#123;</span><br><span class="line">                HP--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                HP++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(HP == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HP = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == candi) &#123;</span><br><span class="line">                HP++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(HP &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> candi;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>1 链表</h1>
<h2 id="1-反转链表">1 反转链表</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">      <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">          cur.next = pre;</span><br><span class="line">          pre = cur;</span><br><span class="line">          cur = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pre;<span class="comment">// ！返回的是pre</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表二">反转链表二</h3>
<blockquote>
<p>就是反转链表中间一截</p>
</blockquote>
<p>// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</p>
<p>// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</p>
<p>// 第 3 步：切断出一个子链表（截取链表）先标记再切断</p>
<p>// 第 4 步：[同反转链表](##1 反转链表##)，反转链表的子区间</p>
<p>// 第 5 步：接回到原来的链表中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//1 需要一个虚拟头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 先找到反转部分的left前面pre</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 从pre再走right - left + 1步 来到right节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rNode</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>;i++) &#123;</span><br><span class="line">            rNode = rNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 切断这部分的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> rNode.next;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        rNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4 反转区间内的链表</span></span><br><span class="line">        reverseLinkedList(lNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5 接回去</span></span><br><span class="line">        pre.next = rNode;<span class="comment">// ⚠️接回去的时候已经是反过来了</span></span><br><span class="line">        lNode.next = end;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-LRU缓存机制">2 LRU缓存机制</h2>
<blockquote>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>
实现 LRUCache 类：</p>
<p>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</p>
<p>函数 get 和 put 必0须以 O(1) 的平均时间复杂度运行。</p>
</blockquote>
<img src="算法高频题总结/image-20220508120449144.png" alt="image-20220508120449144" style="zoom:50%;" />			
<h4 id="1-总的缓存结构-和方法调用">1) 总的缓存结构 和方法调用</h4>
<h5 id="构造方法">构造方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MyCache&lt;Integer, Integer&gt; cache;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fre_278_LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">		cache = <span class="keyword">new</span> <span class="title class_">MyCache</span>&lt;&gt;(capacity);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h5 id="1-get">1 get()</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">ans</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">		<span class="keyword">return</span> ans == <span class="literal">null</span> ? -<span class="number">1</span> : ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-put">2 put()</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">		cache.set(key, value);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）MyCache">2）MyCache</h4>
<h5 id="构造方法-2"><strong>构造方法</strong></h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;K, Node&lt;K, V&gt;&gt; keyNodeMap;</span><br><span class="line">	<span class="keyword">private</span> NodeDoubleLinkedList&lt;K, V&gt; nodeList;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyCache</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">		keyNodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K, Node&lt;K, V&gt;&gt;();</span><br><span class="line">		nodeList = <span class="keyword">new</span> <span class="title class_">NodeDoubleLinkedList</span>&lt;K, V&gt;();</span><br><span class="line">		capacity = cap;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-V-get-K-key-通过key返回value-需要将node放到尾部">1 V get(K key) 通过key返回value 需要将node放到尾部</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">			Node&lt;K, V&gt; res = keyNodeMap.get(key);</span><br><span class="line">			nodeList.moveNodeToTail(res);</span><br><span class="line">			<span class="keyword">return</span> res.value;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-void-set-K-key-V-value-更新与新增：放到尾部，超出内存就删除最长时间没有操作的">2  void set(K key, V value) 更新与新增：放到尾部，超出内存就删除最长时间没有操作的</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">			Node&lt;K, V&gt; node = keyNodeMap.get(key);</span><br><span class="line">			node.value = value;</span><br><span class="line">			nodeList.moveNodeToTail(node);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K, V&gt;(key, value);</span><br><span class="line">			keyNodeMap.put(key, newNode);</span><br><span class="line">			nodeList.addNode(newNode);</span><br><span class="line">			<span class="keyword">if</span> (keyNodeMap.size() == capacity + <span class="number">1</span>) &#123;</span><br><span class="line">				removeMostUnusedCache();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-void-removeMostUnusedCache-删去最长时间没有操作的缓存-；在两个结构里面都删除">3 void removeMostUnusedCache() 删去最长时间没有操作的缓存 ；在两个结构里面都删除</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeMostUnusedCache</span><span class="params">()</span> &#123;</span><br><span class="line">			Node&lt;K, V&gt; removeNode = nodeList.removeHead();</span><br><span class="line">			keyNodeMap.remove(removeNode.key);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-双向链表结构">3) 双向链表结构</h4>
<p><strong>基于LRU机制的双向链表结构</strong><br>
private Node&lt;K, V&gt; head;<br>
private Node&lt;K, V&gt; tail;</p>
<p><strong>构造方法</strong>：将头尾置为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public NodeDoubleLinkedList()&#123;</span><br><span class="line">	head = null;</span><br><span class="line">	tail = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-addNode-来新节点，挂到尾巴上">1 addNode() : 来新节点，挂到尾巴上</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node&lt;K, V&gt; newNode)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(newNode == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(head ==  <span class="literal">null</span>) &#123;</span><br><span class="line">				head = newNode;</span><br><span class="line">				tail = newNode;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tail.next = newNode;</span><br><span class="line">				newNode.last = tail;</span><br><span class="line">				tail = newNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-moveToTail-（修改过的节点，要保证node在表中）更新到尾部">2 moveToTail() : （修改过的节点，要保证node在表中）更新到尾部</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveNodeToTail</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">		 </span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-removeHead-将头节点移走，返回新的头节点">3 removeHead() : 将头节点移走，返回新的头节点</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NodeDoubleLinkedList</span>&lt;K, V&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Node&lt;K, V&gt; <span class="title function_">removeHead</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node&lt;K, V&gt; res = head;</span><br><span class="line">		<span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">			head = <span class="literal">null</span>;</span><br><span class="line">			tail = <span class="literal">null</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			head = res.next;</span><br><span class="line">			res.next = <span class="literal">null</span>;</span><br><span class="line">			head.last = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-K个一组翻转链表">3 K个一组翻转链表</h2>
<p>1 先将第一组k凑齐 并且反转<br>
2 再记录上一组的结尾节点<br>
3 循环（当结尾.next != null)</p>
<p>(1)更新start   (2)更新end <strong>注意判空！！</strong></p>
<p>（3） 反转 ：end 变头</p>
<p>(4） 上一组结尾连接到现在的开头end (5)更新lastEnd</p>
<img src="算法高频题总结/image-20220107164908659.png" alt="image-20220107164908659" style="zoom:33%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       <span class="comment">// 1</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> getKEnd(start, k);</span><br><span class="line">       <span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       head = end;</span><br><span class="line">       reverse(start, end);</span><br><span class="line">       <span class="comment">// 2</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">lastEnd</span> <span class="operator">=</span> start;</span><br><span class="line">       <span class="comment">// 3</span></span><br><span class="line">       <span class="keyword">while</span> (lastEnd.next != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 1)</span></span><br><span class="line">           start = lastEnd.next;</span><br><span class="line">           <span class="comment">// 2)</span></span><br><span class="line">           end = getKEnd(start, k);</span><br><span class="line">           <span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;<span class="comment">// ⚠️(注意判空！！！)</span></span><br><span class="line">               <span class="keyword">return</span> head;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 3)</span></span><br><span class="line">           reverse(start, end);</span><br><span class="line">           <span class="comment">// 4)</span></span><br><span class="line">           lastEnd.next = end;</span><br><span class="line">           <span class="comment">// 5)</span></span><br><span class="line">           lastEnd = start;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ListNode <span class="title function_">getKEnd</span><span class="params">(ListNode start, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (--k != <span class="number">0</span> &amp;&amp; start != <span class="literal">null</span>) &#123;</span><br><span class="line">           start = start.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> start;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 反转 </span></span><br><span class="line">   <span class="comment">// 1 end 往后移</span></span><br><span class="line">   <span class="comment">// 2 三个指针进行反转</span></span><br><span class="line">   <span class="comment">// 3 start反转后是结尾要连接到end</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode start, ListNode end)</span> &#123;</span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">       end = end.next;<span class="comment">//⚠️(注意要移动end指针)</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> start;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       start.next = end;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-合并两个有序链表">4 合并两个有序链表</h2>
<ol>
<li>先抓小头head</li>
<li>cur2抓大头 cur1 = head.next pre = head</li>
<li>比较 c1 c2 谁小pre的next就指向谁 并且cur pre 后移</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span> || l2 ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抓大头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> l1.val &lt;= l2.val ? l1 : l2;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//抓小头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> head == l1 ? l2 : l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt;= cur2.val)&#123;</span><br><span class="line">                pre.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = cur1 != <span class="literal">null</span> ? cur1 :cur2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并k个链表">合并k个链表</h3>
<blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<img src="算法高频题总结/image-20220216171223838.png" alt="image-20220216171223838" style="zoom:50%; float:left;"/>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LianBiao_MergeMoreList</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对数器 ⚠️</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNodeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;ListNode&gt; &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(ListNode arg0, ListNode arg1)</span> &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> arg0.val - arg1.val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (lists == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1 定义一个对数器的小根堆</span></span><br><span class="line">		PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">ListNodeComparator</span>());</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">		<span class="comment">// 2 将每一条的head放在堆中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (lists[i] != <span class="literal">null</span>) &#123;<span class="comment">// !!! </span></span><br><span class="line">				heap.add(lists[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">if</span>(heap.isEmpty())&#123; <span class="comment">// ⚠️</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 3 抓出head 将该条后面一个节点放入堆</span></span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">		<span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;<span class="comment">// !!!</span></span><br><span class="line">			heap.add(head.next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;<span class="comment">// 指针</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4 重复弹出连接结果表 再见弹出的下一个放入堆中</span></span><br><span class="line">		<span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">			<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">			pre.next = cur;</span><br><span class="line">			pre = cur;</span><br><span class="line">			<span class="keyword">if</span> (cur.next != <span class="literal">null</span>) &#123;<span class="comment">// !!!</span></span><br><span class="line">				heap.add(cur.next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-相交链表">5 相交链表</h2>
<p>需要分有环和无环两种情况 [如何辨别有无环](##6 环形链表##)</p>
<h3 id="无环链表相交">无环链表相交</h3>
<img src="算法高频题总结/image-20220206111837413.png" alt="image-20220206111837413" style="zoom:50%;" />
<blockquote>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
</blockquote>
<ol>
<li>需要两个指针；</li>
<li>先用n记录两个链表长度大小以便分清楚谁长谁短，n长度差记得取绝对值；</li>
<li>长的走n步到和短的一样长的起点；</li>
<li>两个指针一起走到相等的地方 就是交点 返回；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getNoLoop</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">	  <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)&#123;</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA;</span><br><span class="line">	  <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> headB;</span><br><span class="line">	  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">while</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">		  n++;</span><br><span class="line">		  cur1 = cur1.next;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">while</span>(cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">		  n--;</span><br><span class="line">		  cur2 = cur2.next;</span><br><span class="line">	  &#125;</span><br><span class="line">	   <span class="keyword">if</span>(cur1 != cur2)&#123;</span><br><span class="line">		  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  cur1 = n &gt; <span class="number">0</span> ? headA : headB;<span class="comment">//cur1指向长的头</span></span><br><span class="line">	  cur2 = (cur1 == headA) ? headB : headA;<span class="comment">//cur2指向短头</span></span><br><span class="line">	  <span class="comment">//将两个链表长度差取绝对值</span></span><br><span class="line">	  n = Math.abs(n);</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//将指向长链表的指针cur1往下移动n,到达和短链表cur2指针与相交点相同距离的位置</span></span><br><span class="line">	  <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">		  n--;</span><br><span class="line">		  cur1 = cur1.next;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">//两个指针向下 相遇点便是相交点</span></span><br><span class="line">	  <span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">		  cur1 = cur1.next;</span><br><span class="line">		  cur2 = cur2.next;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> cur1;</span><br><span class="line">         </span><br><span class="line">  &#125;	</span><br></pre></td></tr></table></figure>
<h3 id="有环链表相交">有环链表相交</h3>
<p>有环的链表比较复杂 有三种情况</p>
<p>1 两个入环节点相同 即相交在入环前 (loop1 =loop2)</p>
<p>2 两个相交在环内相交 有两个相交点</p>
<p>3 两个不相交</p>
<img src="算法高频题总结/image-20220207095236631.png" alt="image-20220207095236631" style="zoom:50%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">bothLoop</span><span class="params">(ListNode headA,ListNode loop1,ListNode headB, ListNode loop2)</span>&#123;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(loop1 == loop2)&#123;<span class="comment">//2 </span></span><br><span class="line">			<span class="comment">//方法与两个无环链表方法一样只不过把loop1/2看作结尾</span></span><br><span class="line">			cur1 = headA;</span><br><span class="line">			cur2 = headB;</span><br><span class="line">			<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">				  n++;</span><br><span class="line">				  cur1 = cur1.next;</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="keyword">while</span>(cur2 != loop2)&#123;</span><br><span class="line">				  n--;</span><br><span class="line">				  cur2 = cur2.next;</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="keyword">if</span>(cur1 != cur2)&#123;</span><br><span class="line">				  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			  cur1 = n &gt; <span class="number">0</span> ? headA : headB;</span><br><span class="line">			  cur2 = (cur1 == headA) ? headB : headA;</span><br><span class="line">			  n = Math.abs(n);</span><br><span class="line">			  <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">				  n--;</span><br><span class="line">				  cur1 = cur1.next;</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">				  cur1 = cur1.next;</span><br><span class="line">				  cur2 = cur2.next;</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="keyword">return</span> cur1;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//loop1往后移动 如果在遇到自己之前遇到了loop2就是情况3</span></span><br><span class="line">			cur1 = loop1.next;</span><br><span class="line">			<span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">				<span class="keyword">if</span>(cur1 == loop2)&#123;</span><br><span class="line">					<span class="keyword">return</span> loop1;<span class="comment">//3</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//1</span></span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-环形链表">6 环形链表</h2>
<blockquote>
<p>返回入环节点，没有环就返回null；</p>
</blockquote>
<p>1.先将从头节点快慢指针开始往后，如果两个指针相遇那一定有环，期间如果快指针到null，可以直接判断无环。</p>
<p>2.如果要找到入环节点，就将fast指针指向head，slow不动，然后让两个指针都只移动一步，最后一定会在入环处相遇。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next ==  <span class="literal">null</span> || fast.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-重排链表">7 重排链表</h2>
<blockquote>
<p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln</p>
<p>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</p>
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</blockquote>
<ol>
<li>找到原表的中点
<ol>
<li>快慢指针从head开走</li>
<li>fast.next == null || fast.next.next = null 返回慢指针</li>
</ol>
</li>
<li>将右半端反转：[反转链表](##1 反转链表##)</li>
<li>将左右端合并</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">		 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123; <span class="comment">// ⚠️判空</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next =<span class="literal">null</span>; <span class="comment">// ⚠️分离</span></span><br><span class="line">        l2 = reverse(l2);</span><br><span class="line">        mergeList(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// ⚠️返回的是pre</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并过程就是使用两个指针来标志两个的下一个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        ListNode l1_next;</span><br><span class="line">        ListNode l2_next;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            l1_next = l1.next;</span><br><span class="line">            l2_next = l2.next;</span><br><span class="line"></span><br><span class="line">            l1.next = l2;</span><br><span class="line">            l1 = l1_next;</span><br><span class="line"></span><br><span class="line">            l2.next = l1;</span><br><span class="line">            l2 = l2_next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-删除链表重复节点">8 删除链表重复节点</h2>
<p>设置虚拟节点</p>
<p>往后遍历  （条件：cur的下一个和下下个都是空）<br>
2.1如果当前两个节点值相等就将当前cur.next的值保存在x;</p>
<p>​	循环（第一个节点后面的节点是否有重复的）cur.next指向不等于该x值的节点<br>
​    2.2 不相等就直接next</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">		 <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123; <span class="comment">// 当前节点下一个和下下个不为空</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123; <span class="comment">// 两个节点相等</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur.next.val; </span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == x)&#123; <span class="comment">// 遍历第一个节点后面的节点是否有重复的 </span></span><br><span class="line">                    cur.next = cur.next.next;<span class="comment">// 有就直接讲指针指向下下个</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 两个节点不相等 指针后移</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-排序链表">9 排序链表</h2>
<blockquote>
<p>就是给链表排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">		<span class="comment">// 1 遍历一遍链表的长度</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">			N++;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2 len是每次分组节点数 一直乘二</span></span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">teamFirst</span> <span class="operator">=</span> head;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; len &lt; N; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (teamFirst != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 3 F就是将五个参数处理返回方便利用</span></span><br><span class="line">				<span class="comment">// 左组从哪到哪   ls le</span></span><br><span class="line">				<span class="comment">// 右组从哪到哪   rs re</span></span><br><span class="line">				<span class="comment">// 左 右  next</span></span><br><span class="line">				ListNode[] f1 = f(teamFirst, len);</span><br><span class="line">				<span class="comment">// ls...le  rs...re -&gt; merge去</span></span><br><span class="line">				<span class="comment">// 整体的头、整体的尾</span></span><br><span class="line">				ListNode[] f2 = merge(f1[<span class="number">0</span>], f1[<span class="number">1</span>], f1[<span class="number">2</span>], f1[<span class="number">3</span>]);</span><br><span class="line">				<span class="keyword">if</span> (h == teamFirst) &#123;</span><br><span class="line">					h = f2[<span class="number">0</span>];</span><br><span class="line">					pre = f2[<span class="number">1</span>];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					pre.next = f2[<span class="number">0</span>];</span><br><span class="line">					pre = f2[<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				teamFirst = f1[<span class="number">4</span>];<span class="comment">// next</span></span><br><span class="line">			&#125;</span><br><span class="line">			teamFirst = h;</span><br><span class="line">			pre = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ListNode[] f(ListNode teamFirst, <span class="type">int</span> len) &#123;</span><br><span class="line">		<span class="comment">// 返回五个参数</span></span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">ls</span> <span class="operator">=</span> teamFirst;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">le</span> <span class="operator">=</span> teamFirst;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">re</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">pass</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (teamFirst != <span class="literal">null</span>) &#123;</span><br><span class="line">			pass++;</span><br><span class="line">			<span class="keyword">if</span> (pass &lt;= len) &#123;</span><br><span class="line">				le = teamFirst;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pass == len + <span class="number">1</span>) &#123;</span><br><span class="line">				rs = teamFirst;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pass &gt; len) &#123;</span><br><span class="line">				re = teamFirst;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pass == (len &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			teamFirst = teamFirst.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 左边结尾断开</span></span><br><span class="line">		le.next = <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">// 记录右边结尾的next并断开结尾断开 </span></span><br><span class="line">		<span class="keyword">if</span> (re != <span class="literal">null</span>) &#123;</span><br><span class="line">			next = re.next;</span><br><span class="line">			re.next = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>[] &#123; ls, le, rs, re, next &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ListNode[] merge(ListNode ls, ListNode le, ListNode rs, ListNode re) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rs == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>[] &#123; ls, le &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">while</span> (ls != le.next &amp;&amp; rs != re.next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ls.val &lt;= rs.val) &#123;</span><br><span class="line">				cur = ls;</span><br><span class="line">				ls = ls.next;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				cur = rs;</span><br><span class="line">				rs = rs.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;</span><br><span class="line">				head = cur;</span><br><span class="line">				pre = cur;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pre.next = cur;</span><br><span class="line">				pre = cur;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ls != le.next) &#123;</span><br><span class="line">			<span class="keyword">while</span> (ls != le.next) &#123;</span><br><span class="line">				pre.next = ls;</span><br><span class="line">				pre = ls;</span><br><span class="line">				tail = ls;</span><br><span class="line">				ls = ls.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (rs != re.next) &#123;</span><br><span class="line">				pre.next = rs;</span><br><span class="line">				pre = rs;</span><br><span class="line">				tail = rs;</span><br><span class="line">				rs = rs.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>[] &#123; head, tail &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-两数相加">10 两数相加</h2>
<blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">		<span class="comment">//两个链表分长短</span></span><br><span class="line">		<span class="comment">//分为三个阶段 ：1 长短都还有节点 2 短没有节点 长有节点 3 长也走到没节点</span></span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">l</span> <span class="operator">=</span> listLength(l1) &gt; listLength(l2) ? l1 : l2;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> (l == l1) ? l2 : l1;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">curl</span> <span class="operator">=</span> l;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">curs</span> <span class="operator">=</span> s;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> curl;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1 </span></span><br><span class="line">		<span class="keyword">while</span>(curs != <span class="literal">null</span>)&#123;</span><br><span class="line">			curNum = curs.val + curl.val + carry;</span><br><span class="line">			carry = curNum / <span class="number">10</span>;</span><br><span class="line">			curl.val = curNum % <span class="number">10</span>;</span><br><span class="line">			last = curl;<span class="comment">//last一直在抓住最后一个节点</span></span><br><span class="line">			curl = curl.next;</span><br><span class="line">			curs = curs.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2 </span></span><br><span class="line">		<span class="keyword">while</span>(curl != <span class="literal">null</span>)&#123;</span><br><span class="line">			curNum =  curl.val + carry;</span><br><span class="line">			carry = curNum / <span class="number">10</span>;</span><br><span class="line">			curl.val = curNum % <span class="number">10</span>;</span><br><span class="line">			last = curl;<span class="comment">//last一直在抓住最后一个节点</span></span><br><span class="line">			curl = curl.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3 到</span></span><br><span class="line">		<span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">			last.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">listLength</span><span class="params">(ListNode l)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(l != <span class="literal">null</span>)&#123;</span><br><span class="line">			length++;</span><br><span class="line">			l = l.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-链表中倒数第k个节点">11 链表中倒数第k个节点</h2>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fre_070_removeNthFromEnd</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(k - <span class="number">1</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-删除链表倒数第k个节点">12 删除链表倒数第k个节点</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">  			<span class="comment">// 1 用两个指针截出n+1长度</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">for</span>(;n&gt;<span class="number">0</span>;n--)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">  			<span class="comment">// 2 两个指针一直往后直到fast到结尾</span></span><br><span class="line">       <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">           fast = fast.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">  			<span class="comment">// 3 slow在目标的前面一位 直接将next指针指向下下位 </span></span><br><span class="line">       slow.next = slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;<span class="comment">// 使用虚拟节点以防删除的是头节点</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-回文链表">13 回文链表</h2>
<p>需要convert 和 然后判断对称 然后再convert恢复回去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 现在slow就走到了中间（偶数是上中）</span></span><br><span class="line">        <span class="comment">// 2 将后半部分convert</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//pre</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            l3 = l2.next;</span><br><span class="line">            l2.next = l1;</span><br><span class="line">            l1 = l2;</span><br><span class="line">            l2 = l3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 后面部分已经翻转 现在对比两部分是否对称</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        l2 = head;</span><br><span class="line">        l3 = l1;</span><br><span class="line">        <span class="keyword">while</span>(l3 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l2.val != l3.val)&#123; <span class="comment">// ⚠️比较val</span></span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            l3 = l3.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 把后半部分又恢复原样</span></span><br><span class="line">        l2 = <span class="literal">null</span>;<span class="comment">// pre</span></span><br><span class="line">        l3 = <span class="literal">null</span>;<span class="comment">// next</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            l3 = l1.next;</span><br><span class="line">            l1.next = l2;</span><br><span class="line">            l2 = l1;</span><br><span class="line">            l1 = l3;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-删除排序链表中的重复元素">14 删除排序链表中的重复元素</h2>
<blockquote>
<p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
</blockquote>
<p>删除重复元素 留下一个<br>
直接快慢指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>( right != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> right.next;</span><br><span class="line">           <span class="keyword">if</span>(left.val == right.val) &#123;</span><br><span class="line">               left.next = next;</span><br><span class="line">               right.next = <span class="literal">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">               left =  right;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           right = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="15-复制带有随机指针的链表">15 复制带有随机指针的链表</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度复制带有rand的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiaoBiao_copyListWithRandom</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">		<span class="keyword">public</span> Node next;</span><br><span class="line">		<span class="keyword">public</span> Node rand;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">			value = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 最优解：人工构造关系</span></span><br><span class="line"><span class="comment">	 * 1 每一个节点后面加一个克隆节点</span></span><br><span class="line"><span class="comment">	 * 2 遍历关系 （同时复制rand</span></span><br><span class="line"><span class="comment">	 * 3 遍历分离（同时复制next</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">copyListWithRandom</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    	<span class="comment">// 1</span></span><br><span class="line">    	<span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">    		next = cur.next;</span><br><span class="line">    		cur.next = <span class="keyword">new</span> <span class="title class_">Node</span>(cur.value);</span><br><span class="line">    		cur.next.next = next;</span><br><span class="line">    		cur = next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	cur = head;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">curCopy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    	<span class="comment">// 2</span></span><br><span class="line">    	<span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">    		next = cur.next.next;</span><br><span class="line">    		curCopy = cur.next;</span><br><span class="line">    		curCopy.rand = cur.rand != <span class="literal">null</span> ? cur.rand.next : <span class="literal">null</span>;</span><br><span class="line">    		cur = next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	cur = head;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">res</span> <span class="operator">=</span> head.next;</span><br><span class="line">    	<span class="comment">// 3</span></span><br><span class="line">    	<span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">    		next = cur.next.next;</span><br><span class="line">    		curCopy = cur.next;</span><br><span class="line">    		curCopy.next = cur.next != <span class="literal">null</span> ? cur.next.next : <span class="literal">null</span>;</span><br><span class="line">    		cur = next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用hashMap一一对应关系</span></span><br><span class="line"><span class="comment">     * 1 遍历第一遍一一对应</span></span><br><span class="line"><span class="comment">     * 2 遍历第二遍复制关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">copyListWithRandom2</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">		HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">		<span class="comment">// 1 </span></span><br><span class="line">		<span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">			map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.value));</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		cur = head;</span><br><span class="line">		<span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">			map.get(cur).next = map.get(cur.next);</span><br><span class="line">			map.get(cur).rand = map.get(cur.rand);</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> map.get(head);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>2 动态规划</h1>
<p>具体步骤 可以参考[零钱兑换](###2 返回凑齐的所有方法数)</p>
<h2 id="基础问题-背包问题">基础问题 背包问题</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入货物的重量和价值 不能超过bag背包容量，返回最大价值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP2_knapsack</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 暴力递归</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> process(w, v, <span class="number">0</span>, bag);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == w.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 加上i</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(w, v, i + <span class="number">1</span>, rest - w[i]);</span><br><span class="line">		<span class="comment">// 没加</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process(w, v, i + <span class="number">1</span>, rest);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p1 != -<span class="number">1</span>) &#123;</span><br><span class="line">			p1 += v[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 动态规划版</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> w.length;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bag; j ++)&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(j - w[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">					ans = dp[i + <span class="number">1</span>][j - w[i]] + v[i];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					ans = dp[i + <span class="number">1</span>][j];</span><br><span class="line">				&#125;</span><br><span class="line">				dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], ans);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h2 id="1-最大子数组和">1. 最大子数组和</h2>
<h3 id="用贪心">用贪心</h3>
<p>只需要一个pre反复更新记录以i为底的最大累加和，然后max存最大的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用两个变量存</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray4</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">			pre = Math.max(pre + nums[i], nums[i]);</span><br><span class="line">			max = Math.max(pre, max);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如果需要返回该子数组">如果需要返回该子数组</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>], l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		l = i;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[i] += max(<span class="number">0</span>, nums[i - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; nums[i]) &#123;</span><br><span class="line">		r = i;</span><br><span class="line">		res = nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-买卖股票的最佳时机-maxProfit">2. 买卖股票的最佳时机 maxProfit</h2>
<h3 id="1-从头至尾买一次一股-返回最大利润">(1) 从头至尾买一次一股 返回最大利润:</h3>
<p>遍历一遍 min标记， max最大利润更新 就是找到最低点和最高点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> prices[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minprice</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxprofit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-买一股但是可以买无限次">(2) 买一股但是可以买无限次</h3>
<p>遍历累加所有的爬坡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一股随便买</span></span><br><span class="line">	<span class="comment">// 相当于在每次爬坡前后买卖 将所有爬坡累加就行</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit2</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">			ans += prices[i] - prices[i - <span class="number">1</span>] &gt;= <span class="number">0</span> ? prices[i] - prices[i - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-最长回文子串">3. 最长回文子串</h2>
<h3 id="1-动态规划O-N-2">(1) 动态规划O(N^2)</h3>
<img src="算法高频题总结/image-20220114215749989.png" alt="image-20220114215749989" style="zoom: 33%;" />
<img src="算法高频题总结/image-20220114215821577.png" alt="image-20220114215821577" style="zoom: 33%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自己改动态规划</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">longestPalindrome33</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line">       <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[N][N];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">           dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//边填dp 边抓最长和该最长开始节点</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//按对角线遍历 </span></span><br><span class="line">      <span class="comment">// 最外循环不是dp的坐标</span></span><br><span class="line">      <span class="comment">// i代表了n - len 每个循环行是不变的 </span></span><br><span class="line">      <span class="comment">// j是横坐标L</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>; L &lt; i; L++)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + N - i;</span><br><span class="line">               <span class="keyword">if</span>(str[L] == str[R])&#123;</span><br><span class="line">                   <span class="keyword">if</span>(R - L &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                       dp[L][R] = <span class="literal">true</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       dp[L][R] = dp[L + <span class="number">1</span>][R - <span class="number">1</span>];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(dp[L][R] &amp;&amp; R - L + <span class="number">1</span> &gt; max)&#123;</span><br><span class="line">                   max = R - L + <span class="number">1</span>;</span><br><span class="line">                   index = L;	</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s.substring(index, index + max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Manacher">(2) Manacher!</h3>
<p>面试讲一讲</p>
<p>假设字符串str长度为N，想返回最长回文子串的长度</p>
<p>时间复杂度O(N)</p>
<h4 id="Manacher算法核心">Manacher算法核心</h4>
<p>1）理解回文半径数组<br>
2）理解所有中心的回文最右边界R，和取得R时的中心点C<br>
3）理解 L…(i’)…C…(i)…R 的结构，以及根据i’回文长度进行的状况划分<br>
4）每一种情况划分，都可以加速求解i回文半径的过程</p>
<p>最长回文子串就是我知道可以进行。</p>
<h3 id="最长回文子序列">最长回文子序列</h3>
<p>子序列就是三种情况 L+1 ~R 和 L ~ R-1 和 L +1 ~ R - 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line">       <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">           dp[i][i] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//对角线遍历</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>; L &lt; i; L++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + N - i;</span><br><span class="line">           dp[L][R] = Math.max(dp[L + <span class="number">1</span>][R],dp[L][R - <span class="number">1</span>]);</span><br><span class="line">           <span class="keyword">if</span>(str[L] == str[R])&#123;</span><br><span class="line">             dp[L][R] = Math.max(dp[L + <span class="number">1</span>][R - <span class="number">1</span>] + <span class="number">2</span>, dp[L][R]);</span><br><span class="line">           &#125;</span><br><span class="line">				&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h2 id="4-最长递增子序列">4. 最长递增子序列</h2>
<h3 id="DP版-O-n-2">DP版  O(n^2)</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123; </span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">maxans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">          dp[i] = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                  dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          maxans = Math.max(maxans, dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找-贪心-O-nlogn">二分查找+贪心  O(nlogn)</h3>
<p>维护一个end数组存储</p>
<ol>
<li>
<p>end[i] 代表  i+1 长度下子序列的最后下标</p>
</li>
<li>
<p>len = 递增子序列的长 度 - 1（end数组的下标 ）</p>
</li>
</ol>
<p>设当前已求出的最长上升子序列的长度为 len（初始时为1），从前往后遍历数组nums，在遍历到 nums[i] 时：</p>
<ul>
<li>如果 nums[i] &gt;[len] ，则[++len] = nums[i]；</li>
<li>否则，在end数组中[0 ~ len-1]二分查找，找到第一个比 nums[i] 小的数 end[k] ，并更新 end[k+1]=nums[i]。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// end[i]存储 第i+1长度下子序列的最后下标</span></span><br><span class="line">	<span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">	end[<span class="number">0</span>] = nums[<span class="number">0</span>];<span class="comment">//!!!</span></span><br><span class="line">	<span class="comment">// end数组的下标 = 递增子序列的长度 - 1</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 二分查找的下标</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span> (nums[i] &gt; end[len]) &#123;</span><br><span class="line">			end[++len] = nums[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 在end里面二分查找 &lt; num[i] 的数</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//因为如果没有比他小的 说明都比他大 就更新的是end[0]</span></span><br><span class="line">			<span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (R + L) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(end[mid] &lt; nums[i])&#123;</span><br><span class="line">					pos = mid + <span class="number">1</span>;<span class="comment">//抓住当前小于numi的数的后面一位 后面会更新</span></span><br><span class="line">					L = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					R = mid - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			end[pos] = nums[i];<span class="comment">//更新</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-接雨水">5. 接雨水</h2>
<ul>
<li>左右两个指针 left right</li>
<li>左右两个变量存储左右最大的值</li>
<li>每次更新左右任意一边靠着lmax或者rmax的指针的雨水大小</li>
<li>相当于是把每一下标积的水累加。</li>
</ul>
<p>相当于是从左右两边来进行更新 哪边的max最大就比较那一边的L/R与max大小 累加并且更新最大值</p>
<p>最后返回累加和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> arr[arr.length - <span class="number">1</span>];z</span><br><span class="line">	<span class="title function_">while</span><span class="params">(L &lt;= R)</span> &#123; <span class="comment">// ！！！！ &lt;=</span></span><br><span class="line">		<span class="keyword">if</span>(leftMax &lt;= rightMax) &#123;</span><br><span class="line">			ans += Math.max(<span class="number">0</span>, leftMax - arr[L]);</span><br><span class="line">			leftMax = Math.max(leftMax, arr[L++]);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			ans += Math.max(<span class="number">0</span>, rightMax - arr[R]);</span><br><span class="line">			rightMax = Math.max(rightMax, arr[R--]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-最长上升子序列">6. 最长上升子序列</h2>
<p>设当前已求出的最长上升子序列的长度为 len（初始时为1），从前往后遍历数组nums，在遍历到 nums[i] 时：</p>
<ul>
<li>如果 nums[i] d[len] ，则直接加入到 ddd 数组末尾，并更新 len= len+1；</li>
<li>否则，在 d数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k+1]=nums[i].</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这道题要用 二分查找和贪心</span></span><br><span class="line"><span class="comment">	 * 暴力递归XXX不用了老子 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// end[i]存储 第i+1长度下子序列的最后下标</span></span><br><span class="line">		<span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">		end[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// end数组的下标 = 递增子序列的长度 - 1</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 二分查找的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="keyword">if</span> (nums[i] &gt; end[len]) &#123;</span><br><span class="line">				end[++len] = nums[i];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">// 在end里面二分查找 &lt; num[i] 的数</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">				<span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//因为如果没有比他小的 说明都比他大 就更新的是end[0]</span></span><br><span class="line">				<span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (R + L) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(end[mid] &lt; nums[i])&#123;</span><br><span class="line">						pos = mid + <span class="number">1</span>;<span class="comment">//抓住当前小于numi的数的后面一位 后面会更新</span></span><br><span class="line">						L = mid + <span class="number">1</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						R = mid - <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				end[pos] = nums[i];<span class="comment">//更新</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-爬楼梯">7. 爬楼梯</h2>
<h3 id="递归-笔试">递归 笔试</h3>
<p><strong>状态转移方程</strong> f(n) = f(n - 1) + f(n - 2); ----&gt; 可以看出就是斐波拉契数列</p>
<p>用三个常量所以空间复杂度为O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;+</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="矩阵快速幂-o-logn">矩阵快速幂 o(logn)</h3>
<img src="算法高频题总结/image-20220124114518863.png" alt="image-20220124114518863" style="zoom: 33%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code4_ClimbStairs</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// [ 1 ,1 ]</span></span><br><span class="line">		<span class="comment">// [ 1, 0 ]</span></span><br><span class="line">		<span class="type">int</span>[][] base = &#123; &#123; <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">		<span class="type">int</span>[][] res = matrixPower(base, n);</span><br><span class="line">		<span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]; </span><br><span class="line">    <span class="comment">// 如果是斐波拉契数列 就要从1 1 2 3 5 </span></span><br><span class="line">    <span class="comment">// 返回的就是res[0][0]+res[0][1]</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  快速幂 方法就是将指数循环 每次循环内矩阵平方 然后指数右移一位</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] matrixPower(<span class="type">int</span>[][] m, <span class="type">int</span> p) &#123;</span><br><span class="line">    <span class="comment">// res初始化为单位1</span></span><br><span class="line">		<span class="type">int</span>[][] res = &#123;&#123;<span class="number">1</span>, <span class="number">0</span> &#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// m ---&gt; 一次方</span></span><br><span class="line">		<span class="type">int</span>[][] tmp = m;</span><br><span class="line">		<span class="keyword">for</span> (; p != <span class="number">0</span>; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((p &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123; <span class="comment">// ！！！先乘一次方 注意是不等于0 </span></span><br><span class="line">				res = muliMatrix(res, tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			tmp = muliMatrix(tmp, tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] muliMatrix(<span class="type">int</span>[][] m1, <span class="type">int</span>[][] m2) &#123;</span><br><span class="line">		<span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m1.length][m2[<span class="number">0</span>].length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m1.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m2[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; m2.length; k++) &#123;</span><br><span class="line">					res[i][j] += m1[i][k] * m2[k][j]; <span class="comment">// k = m1的列 = m2的行</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是注意快速幂里面要先进行 一次方的判断</p>
<h2 id="8-编辑距离-dp3">8. 编辑距离(dp3)</h2>
<h3 id="DP-样本对应模型：往往用最后的位置来判断可能性">DP 样本对应模型：往往用最后的位置来判断可能性</h3>
<p>给两个单词，返回第一个单词转换为第二个单词最少的操作数， 有增删改三种操作</p>
<p>（扩展：可以增加a d c分别代表增删改的代价）</p>
<p>根据最后一个位置有四种可能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP3_EditDistance</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">      	<span class="keyword">if</span>(word1 == <span class="literal">null</span> || word2 == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">char</span>[] str1 = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str1.length; </span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> str2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>][M+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 1 处理边界：其中有字符串是空的情况 全是增加操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 普通情况 从最后位置比较word1该如何处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">                <span class="comment">// 2.1 最后一个位置修改或者保留</span></span><br><span class="line">                <span class="keyword">if</span>(str1[i- <span class="number">1</span>] == str2[j - <span class="number">1</span>]) &#123;<span class="comment">// ！！！ 注意</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.2 最后一个位置删除</span></span><br><span class="line">                dp[i][j] = Math.min(dp[i- <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">                <span class="comment">// 2.3 最后一个位置增加 </span></span><br><span class="line">                dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ 因为有为0的情况 所以总的就是[0, N] 所以循环范围需要是[0,N]  并且<strong>str下标</strong> 对应 <strong>dp下标</strong>减一</p>
<img src="算法高频题总结/image-20220124222730796.png" alt="image-20220124222730796" style="zoom:33%;" />
<h2 id="9-最长公共子序列-dp3">9. 最长公共子序列(dp3)</h2>
<img src="算法高频题总结/image-20220125165947341.png" alt="image-20220125165947341" style="zoom:50%;" />
<p>⚠️填边界的时候先将<code>dp[0][0]</code>填了 防止 i - 1 越界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(text1 == <span class="literal">null</span> || text2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[str1.length][str2.length];</span><br><span class="line">        <span class="comment">// 1 填完第一行和第一列</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// !!!</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str2.length; i++) &#123;</span><br><span class="line">           dp[<span class="number">0</span>][i] = str1[<span class="number">0</span>] == str2[i] ? <span class="number">1</span> : dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] = str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 按每行没列填</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; str2.length; j++) &#123;</span><br><span class="line">              <span class="comment">// 1 不看当前的情况 比较[i - 1]和[j ]或者[ i]和[j - 1]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>];</span><br><span class="line">              <span class="comment">// 2 将这个位置的情况纳入 比较 [i]和 [j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                dp[i][j] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[str1.length - <span class="number">1</span>][str2.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-最小路径和">10 最小路径和</h2>
<blockquote>
<p>m ✖️n 的网格 从左下角走到右下角 怎么走路径最短</p>
</blockquote>
<p>⚠️[1, 1] 开始填表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum2</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123; <span class="comment">// !!! 注意别写反了</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="扩展">扩展</h4>
<p>记录路径也可以开一个字典，应该知道了每个 [i,j] 上一个来源坐标 last， path[(i,j)] = (lasti,lastj)，最后用一个死循环输出所有path，当 (i,j) == (0,0 ) 时候退出 然后最后进行一个死循环 就可以将循环打出来了</p>
<h3 id="不同路径">不同路径</h3>
<blockquote>
<p>m ✖️n 的网格 从左下角走到右下角 有多少种走法 （方法数）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]+ dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-最长公共子数组-最长重复子数组">11  最长公共子数组(最长重复子数组)</h2>
<blockquote>
<p>注意的还是<strong>边界</strong>； 应为需要最开始的状态来依赖 所以要不选择dp外围加一圈 要不就是dp内围循环从1开始</p>
</blockquote>
<img src="算法高频题总结/image-20220125205333273.png" alt="image-20220125205333273" style="zoom: 33%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span>[] B)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length, m = B.length;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				dp[i][j] = A[i] == B[j] ? dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">				ans = Math.max(ans, dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length+<span class="number">1</span>][nums2.length+<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length;i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">               dp[i][j] = nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//！！！</span></span><br><span class="line">               ans = Math.max(dp[i][j], ans);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-零钱兑换问题-完全背包-dp4-难">12 零钱兑换问题 &lt;完全背包&gt;(dp4) 难</h2>
<p>关于背包问题 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-sq9n/">吃透背包所有问题</a></p>
<p><strong>从左向右的尝试模型</strong></p>
<blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
</blockquote>
<h3 id="1-返回需要最少的硬币个数">1 返回需要最少的硬币个数</h3>
<blockquote>
<p>计算并返回可以凑成总金额所需的 <strong>最少</strong>硬币个数 。</p>
<p>每个硬币都可以说使用无限次。</p>
</blockquote>
<h4 id="动态规划">动态规划</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">		dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">			dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">				dp[index][rest] = dp[index + <span class="number">1</span>][rest];<span class="comment">// 下边</span></span><br><span class="line">				<span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span> </span><br><span class="line">						&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">          <span class="comment">// 最小值 相当于（ 左边+1）与（下边 ）进行比较</span></span><br><span class="line">					dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][aim] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[<span class="number">0</span>][aim];<span class="comment">// 无解情况返回-1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-返回凑齐的所有方法数">2 返回凑齐的所有方法数</h3>
<blockquote>
<p>返回硬币或者货币可以凑齐钱的所有方法数</p>
</blockquote>
<h4 id="暴力递归的尝试">暴力递归的尝试</h4>
<img src="算法高频题总结/image-20220126121822867.png" alt="image-20220126121822867" style="zoom:50%;float:left;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinsWay</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 没钱了</span></span><br><span class="line">			<span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123; </span><br><span class="line">			ways += process(arr, index + <span class="number">1</span>, rest - (zhang * arr[index]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ways;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="算法高频题总结/image-20220126122746347.png" alt="image-20220126122746347" style="zoom: 50%;float:left" />
<p><strong>说明是有重复解的</strong>,所以可以进一步进行记忆化搜索</p>
<h4 id="记忆化搜索">记忆化搜索</h4>
<p>就是用一个结构存储f(i, rest)结果 后面就不会重复解</p>
<img src="算法高频题总结/image-20220126124736980.png" alt="image-20220126124736980" style="zoom:50%; float: left;" />
<p>如果该题没有枚举行为那么傻缓存的方法和严格表结构（动态规划）的方法就是一样的。</p>
<p><strong>严格的表结构</strong>： 就是在记忆化搜索的基础上，进一步梳理了依赖关系，从简单位置算出复杂位置，严格规定好了计算顺序</p>
<p>有枚举行为：需要搞出严格的表结构进行继续优化。</p>
<h4 id="动态规划-2">动态规划</h4>
<p>第一版dp:有枚举行为，和上面记忆化搜索的方法是等效的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">		dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">					ways += dp[index + <span class="number">1</span>][rest - (zhang * arr[index])];</span><br><span class="line">				&#125;</span><br><span class="line">				dp[index][rest] = ways;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>第二版：将枚举行为的规律找出来，利用<strong>严格的表结构</strong></p>
<img src="算法高频题总结/image-20220126140549709.png" alt="image-20220126140549709" style="zoom:50%;float:left" />
<img src="算法高频题总结/image-20220126141740242.png" alt="image-20220126141740242" style="zoom:50%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (coins == <span class="literal">null</span> || coins.length == <span class="number">0</span> || amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> coins.length;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">		dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= amount; rest++) &#123;</span><br><span class="line">				dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">				<span class="keyword">if</span> (rest - coins[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					dp[index][rest] += dp[index][rest - coins[index]];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][amount];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h3 id="3-最终代码">3 最终代码</h3>
<h4 id="零钱兑换1">零钱兑换1</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">		dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">			dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">				dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">				<span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span> </span><br><span class="line">						&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">          <span class="comment">// 最小值判断</span></span><br><span class="line">					dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][aim] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[<span class="number">0</span>][aim];<span class="comment">// 无解情况返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 一维 难理解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换2">零钱兑换2</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (coins == <span class="literal">null</span> || coins.length == <span class="number">0</span> || amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> coins.length;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line">		dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= amount; rest++) &#123;</span><br><span class="line">				dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">				<span class="keyword">if</span> (rest - coins[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					dp[index][rest] += dp[index][rest - coins[index]];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][amount];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 一维 不是很好理解怕写错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-最长有效括号">13 最长有效括号</h2>
<blockquote>
<p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">    是子串类型，看以i结尾</span><br><span class="line">1 如果当前是‘）’ 就找可以和他配对的最前左括号pre下标</span><br><span class="line">   pre = i - dp[i - 1] - 1; </span><br><span class="line">           （dp[i - 1] 前一个已经配好对的长度 </span><br><span class="line">2 如果pre是左括号(注意pre&gt;= 0 防止越界) </span><br><span class="line">     更新dp[i] == 2 + dp [i - 1]+ (pre &gt; 0? dp [pre - 1] : 0);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.length()== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str= s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>( str[i] == <span class="string">&#x27;)&#x27;</span>) &#123; </span><br><span class="line">                <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> i - dp[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( pre &gt;= <span class="number">0</span> &amp;&amp; str[pre] == <span class="string">&#x27;(&#x27;</span> ) &#123; <span class="comment">// !! pre &gt;= 0在前 pre </span></span><br><span class="line">                    dp[i] = <span class="number">2</span> + dp[i - <span class="number">1</span>] + (pre &gt; <span class="number">0</span>? dp[pre - <span class="number">1</span>] : <span class="number">0</span>);  <span class="comment">//!!! pre -1 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(dp[i], max);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-打家劫舍">14 打家劫舍</h2>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123; <span class="comment">// ！！！ </span></span><br><span class="line">           <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">       <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">       dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">       dp[<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>], nums[<span class="number">1</span>]); <span class="comment">// ！！!注意要将[0][1] 先填 i从2开始</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> nums[i];</span><br><span class="line">           <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i - <span class="number">1</span>];</span><br><span class="line">           <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> nums[i] + dp[i - <span class="number">2</span>];</span><br><span class="line">           dp[i] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="打家劫舍Ⅱ">打家劫舍Ⅱ</h2>
<blockquote>
<p>这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。</p>
</blockquote>
<p>是滚动数组，可以分成两个数组来判断[0]-[N-2] 和 [1]-[N-1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> dp[i - <span class="number">2</span>] + nums[i];</span><br><span class="line">            dp[i] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> dp[nums.length - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> dp[i - <span class="number">2</span>] + nums[i];</span><br><span class="line">            dp[i] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(ans1, ans2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="15-矩阵的递增路径">15 矩阵的递增路径</h2>
<blockquote>
<p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<img src="算法高频题总结/image-20220228231209380.png" alt="image-20220228231209380" style="zoom:33%;" />
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestIncreasingPath</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">	<span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">	<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][M];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">			ans = Math.max(ans, process1(matrix, i, j, dp));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span>[][] m, <span class="type">int</span> i, <span class="type">int</span> j,<span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;<span class="comment">//存了数就不用再算了</span></span><br><span class="line">		<span class="keyword">return</span> dp[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 上下左右四个方向</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> i &gt; <span class="number">0</span> &amp;&amp; m[i][j] &lt; m[i - <span class="number">1</span>][j] ? process1(m, i - <span class="number">1</span>, j, dp) : <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> i &lt; (m.length - <span class="number">1</span>) &amp;&amp; m[i][j] &lt; m[i + <span class="number">1</span>][j] ? process1(m,</span><br><span class="line">			i + <span class="number">1</span>, j, dp) : <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j &gt; <span class="number">0</span> &amp;&amp; m[i][j] &lt; m[i][j - <span class="number">1</span>] ? process1(m, i, j - <span class="number">1</span>,dp) : <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> j &lt; (m[<span class="number">0</span>].length - <span class="number">1</span>) &amp;&amp; m[i][j] &lt; m[i][j + <span class="number">1</span>] ? process1(</span><br><span class="line">			m, i, j + <span class="number">1</span>, dp) : <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Math.max(Math.max(up, down), Math.max(left, right)) + <span class="number">1</span>;</span><br><span class="line">	dp[i][j] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-机器人walk">16 机器人walk</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 机器人在n长度的数组中，位置在M，要走k步到p，有多少种方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP_RobortWalk</span> &#123;</span><br><span class="line">	<span class="comment">/* 1</span></span><br><span class="line"><span class="comment">	 * 暴力递归尝试</span></span><br><span class="line"><span class="comment">	 * 每次走一步： 1. rest - 1 ；2. 位置cur更新</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">way1</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> K, <span class="type">int</span> P)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (N &lt; <span class="number">2</span> || M &lt; <span class="number">1</span> || M &gt; N || P &lt; <span class="number">1</span> || P &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> process1(N, M, K, P);</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1 当剩下0步 ：到了aim 返回1;没到 返回0</span></span><br><span class="line">	<span class="comment">// 2 两个边界条件</span></span><br><span class="line">	<span class="comment">// 3 返回递归结果</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim)</span>&#123;</span><br><span class="line">		<span class="comment">// 1 </span></span><br><span class="line">		<span class="keyword">if</span>(rest == <span class="number">0</span> )&#123;<span class="comment">// base case</span></span><br><span class="line">			<span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">if</span>(cur == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> process1(n, <span class="number">2</span>, rest - <span class="number">1</span>, aim);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur == n)&#123;</span><br><span class="line">			<span class="keyword">return</span> process1(n, n - <span class="number">1</span>, rest - <span class="number">1</span>, aim);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3</span></span><br><span class="line">		<span class="keyword">return</span> process1(n, cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim) +  process1(n, cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * DP:直接使用矩阵来替代递归的过程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">way3</span><span class="params">(<span class="type">int</span> N,<span class="type">int</span> M, <span class="type">int</span> K, <span class="type">int</span> P)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (N &lt; <span class="number">2</span> || M &lt; <span class="number">1</span> || M &gt; N || P &lt; <span class="number">1</span> || P &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 1</span></span><br><span class="line">		dp[P][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//base case </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= K; rest++) &#123;</span><br><span class="line">			<span class="comment">// 2</span></span><br><span class="line">			dp[<span class="number">1</span>][rest] = dp[<span class="number">2</span>][rest - <span class="number">1</span>];</span><br><span class="line">			dp[N][rest] = dp[N - <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">			<span class="comment">// 3</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">2</span>; cur &lt; N; cur++) &#123;</span><br><span class="line">				dp[cur][rest] = dp[cur - <span class="number">1</span>][rest - <span class="number">1</span>] + dp[cur + <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[M][K];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(way1(<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(way3(<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="17-纸牌博弈">17 纸牌博弈</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 纸牌博弈问题</span></span><br><span class="line"><span class="comment"> * 两个会预判的人 从左右选卡片 返回胜利的人的分数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP1_TwoSmartManPeekCard</span> &#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win1</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="literal">null</span>||arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>), s(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// f() 在i~j范围 先拿</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">//纸牌被聪明人先拿，获得的分数</span></span><br><span class="line">        <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿走一张（i或者j）后，聪明人成了后拿的人，在两种决策中选最优</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(arr[i]+s(arr,i+<span class="number">1</span>,j),arr[j]+s(arr,i,j-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g() 在i~j范围 后拿</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">s</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">//纸牌被聪明人后拿，获得的分数</span></span><br><span class="line">        <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对方拿走一张（i或者j）后，聪明人成了先拿的人，对方也是聪明人，会留下最差的情况</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(f(arr,i+<span class="number">1</span>,j),f(arr,i,j-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * DP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win2</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">		<span class="type">int</span>[][] fmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">		<span class="type">int</span>[][] gmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//先处理L == R （gmap在初始化就是0，不用管</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N - <span class="number">1</span>; i++)&#123;</span><br><span class="line">			fmap[i][i] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//按着对角线来一步步求！！！</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> <span class="number">1</span>; startCol &lt; N; startCol++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> startCol;</span><br><span class="line">			<span class="keyword">while</span> (R &lt; N) &#123;</span><br><span class="line">				fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="number">1</span>][R], arr[R] + gmap[L][R - <span class="number">1</span>]);</span><br><span class="line">				gmap[L][R] = Math.min(fmap[L + <span class="number">1</span>][R], fmap[L][R - <span class="number">1</span>]);</span><br><span class="line">				L++;</span><br><span class="line">				R++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Math.max(fmap[<span class="number">0</span>][N - <span class="number">1</span>], gmap[<span class="number">0</span>][N-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>3 排序</h1>
<h2 id="快速排序">-快速排序-</h2>
<h4 id="1-0-partition">1.0 partition</h4>
<blockquote>
<p>partition 以arr[R] 为界分为 &lt;=arr[R]   arr[R]    &gt;arr[R] 三个部分</p>
<p>每次可以找到一个位置的数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lessEqual</span> <span class="operator">=</span> L - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> L;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] &lt;= arr[R]) &#123;</span><br><span class="line">            swap(arr, index, ++lessEqual);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, ++lessEqual, R);</span><br><span class="line">    <span class="keyword">return</span> lessEqual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> partition(arr, L, R);</span><br><span class="line">    process1(arr, L, M - <span class="number">1</span>);</span><br><span class="line">    process1(arr, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-0-荷兰国旗">2.0 荷兰国旗</h4>
<blockquote>
<p>在[l, r]上以arr[R]为界 将数组分为&lt; = &gt; 三个部分</p>
<p>每次可以找到中间等等于那部分的数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] netherlandsFlag(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R) &#123;</span><br><span class="line">  <span class="keyword">if</span>(L &gt; R) &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;&#125;</span><br><span class="line">  <span class="keyword">if</span>(L == R) &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L, R&#125;;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> L - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> L;</span><br><span class="line">  <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> R;</span><br><span class="line"> 	<span class="keyword">while</span>(index &lt; more) &#123; <span class="comment">// !!! index &lt; more</span></span><br><span class="line">    <span class="keyword">if</span>(arr[index] == arr[R]) &#123;<span class="comment">// 1 == 情况 index++</span></span><br><span class="line">      index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[index] &lt; arr[R]) &#123; <span class="comment">// 2 &lt; 情况 交换index和less的右边 然后index++</span></span><br><span class="line">      swap(arr, index, ++less);</span><br><span class="line">      index++;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123; <span class="comment">// 3 &gt; 情况 交换index和more左边  不用index++！</span></span><br><span class="line">      swap(arr, index, --more);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, R, more);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;	less+<span class="number">1</span>, more&#125;; <span class="comment">// ！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="随机快排">随机快排</h5>
<blockquote>
<p>在荷兰国旗基础上 将数组的arr[R]进行随机交换 然后递归将数组所有部分都排完</p>
<p>最终期望求出来的复杂度就是O(logN*N)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">proces</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(L &gt; R) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="comment">// 随机交换</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> L + Math.random() * (R - L + <span class="number">1</span>);</span><br><span class="line">  swap(arr, R, random);</span><br><span class="line">  <span class="type">int</span>[] area = netherlandsFlag(arr, L, R);</span><br><span class="line">  process(arr, L, area[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">  process(arr, area[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="递归版本">递归版本</h5>
<blockquote>
<p>迭代，自己压栈，把任务做了然后再放出来</p>
<p>最开始做一次递归里做的 然后在迭代过程中再做递归里做的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Op</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> L;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> R;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Op</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    L = left;</span><br><span class="line">    R = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压栈：开始是从[0,N - 1]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(...) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">  <span class="comment">// 随机交换 分界</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * N);</span><br><span class="line">  swap(arr, N - <span class="number">1</span>, random);</span><br><span class="line">  <span class="type">int</span>[] area = netherlandsFlag(arr, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  Stack&lt;Op&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  stack.push(<span class="keyword">new</span> <span class="title class_">Op</span>(<span class="number">0</span>, area[<span class="number">0</span>]-<span class="number">1</span>));</span><br><span class="line">  stack.push(<span class="keyword">new</span> <span class="title class_">Op</span>(area[<span class="number">1</span>]+<span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">    <span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="keyword">if</span>(op.L &lt; op.R) &#123;</span><br><span class="line">      <span class="comment">// 随机交换和分界</span></span><br><span class="line">      random = op.L + (<span class="type">int</span>)(Math.random() * (op.R - op.L + <span class="number">1</span>));</span><br><span class="line">      swap(arr, op.R, random);</span><br><span class="line">      area = netherlandsFlag(arr, op.L, op.R);</span><br><span class="line">      </span><br><span class="line">      stack.push(<span class="keyword">new</span> <span class="title class_">Op</span>(op.L, area[<span class="number">0</span>]-<span class="number">1</span>));</span><br><span class="line">  		stack.push(<span class="keyword">new</span> <span class="title class_">Op</span>(area[<span class="number">1</span>]+<span class="number">1</span>, op.R));</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="随机快排的时间复杂度分析">&lt;随机快排的时间复杂度分析&gt;</h4>
<p>1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差<br>
2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件<br>
3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N<br>
4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</p>
<p><em><em>时间复杂度O(N</em> logN)，额外空间复杂度O(logN)都是这么来的。</em>*</p>
<h3 id="找到数组中的第k个最大元素">!!! ==找到数组中的第k个最大元素==</h3>
<p>⚠️是k大还是k小</p>
<h4 id="改写快速排序">改写<a href="###-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-">快速排序</a></h4>
<p><strong>时间复杂度O(N)</strong></p>
<p>1 原先数组不能改变 复制一个新数组<br>
2 随机选一个数来分区<br>
3 分区: 返回两个边界 partition<br>
4 如果分区中间=部分包含k 就找到了<br>
没有就根据k与边界大小比较大小去其中一部分去找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       <span class="comment">// 1 原来的数组不好更改</span></span><br><span class="line">       <span class="type">int</span>[] arr = copyArray(array);</span><br><span class="line">       <span class="keyword">return</span> process2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, arr.length - k);<span class="comment">// k 小的话就 k - 1</span></span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="comment">// 2 partition分区返回两个边界 分区中间等于部分包含k 就是找到了</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(L == R) &#123;</span><br><span class="line">           <span class="keyword">return</span> arr[L];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> L + (<span class="type">int</span>)(Math.random() * (R - L + <span class="number">1</span>));</span><br><span class="line">       <span class="type">int</span>[] area = partition(arr, L, R, arr[random]);</span><br><span class="line">       </span><br><span class="line">     	</span><br><span class="line">       <span class="keyword">if</span>(index &gt;= area[<span class="number">0</span>] &amp;&amp; index &lt;= area[<span class="number">1</span>]) &#123;</span><br><span class="line">           <span class="keyword">return</span> arr[index];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; area[<span class="number">0</span>]) &#123;<span class="comment">// 没有找到就到另外两个部分继续找</span></span><br><span class="line">           <span class="keyword">return</span> process2(arr, L, area[<span class="number">0</span>] - <span class="number">1</span>, index);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> process2(arr, area[<span class="number">1</span>] + <span class="number">1</span>, R, index);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的partition</p>
<blockquote>
<p>因为是使用num来分区 所以边界注意⚠️对比快排用arr[R]来分区</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> L , <span class="type">int</span> R, <span class="type">int</span> num) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> L - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> R + <span class="number">1</span>; <span class="comment">//！！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> L;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[index] &lt; num) &#123;</span><br><span class="line">            swap(arr, index, ++less);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[index] &gt; num) &#123;</span><br><span class="line">            swap(arr, index, --more);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 快排还需要交换more和R</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;less + <span class="number">1</span>, more - <span class="number">1</span>&#125;; <span class="comment">//！！！ 返回的右边界是more - 1 快排是more</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="BFPRT-面试聊">BFPRT(面试聊)</h4>
<p><strong>俗称&quot;中位数之中位数算法&quot;。依靠一种精心设计的 pivot 选取方法，该算法从理论上保证了最坏情形下的线性时间复杂度，打败了平均线性、最坏 O(n^2) 复杂度的传统算法</strong></p>
<blockquote>
<p>bfprt算法</p>
<ul>
<li>
<p>改进部分就是将快排中随机选数的过程改为五个一组 分组组中排好序</p>
</li>
<li>
<p>找出每一段的中位数 组成m[]</p>
</li>
<li>
<p>找到m的中位数返回</p>
</li>
<li>
<p>medianOfMedian():<br>
// 1 arr[L…R] 五个数一组<br>
// 2 每个小组内部排序，找到中位数领出来，组成m<br>
// 3 m[]中，找到中位数 反调bfprt</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改进部分：随机部分改成一个方法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> medianOfMedian(arr, L ,R);</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] range = partition(arr, L, R, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &gt;= range[<span class="number">0</span>] &amp;&amp; index &lt;= range[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; range[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> process(arr, L , range[<span class="number">0</span>] - <span class="number">1</span>, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(arr, range[<span class="number">1</span>] + <span class="number">1</span>, R, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 arr[L...R] 五个数一组 </span></span><br><span class="line"><span class="comment">// 2 每个小组内部排序，找到中位数领出来，组成m </span></span><br><span class="line"><span class="comment">// 3 m[]中，找到中位数 反调bfprt</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">medianOfMedian</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> size % <span class="number">5</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] m = <span class="keyword">new</span> <span class="title class_">int</span>[size/<span class="number">5</span> + offset];</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> L + i * <span class="number">5</span>;</span><br><span class="line">        m[i] = sortAndMedian(arr, first, Math.min(R, first + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> process(m, <span class="number">0</span>, m.length - <span class="number">1</span>, m.length / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sortAndMedian</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="comment">// SORT</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L + <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= L &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MEDIAN</span></span><br><span class="line">    <span class="keyword">return</span> arr[(L + R) / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">-堆排序-</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 从下至上让整个数组变为大根堆 并将堆顶(max)与结尾交换 再去重新调整</span></span><br><span class="line"><span class="comment">     * 2 遍历调整 直到heapSize = 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">while</span>(heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">            swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下到上将整个数组变为大根堆结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="comment">//先找到左孩子 如果有孩子 将最大的找到并与根比较 谁大放在上面</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            largest = arr[largest] &gt; arr[i] ? largest : i;</span><br><span class="line">            <span class="keyword">if</span>(largest == i)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, largest, i);</span><br><span class="line">            i = largest;</span><br><span class="line">            left = <span class="number">432</span> * i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> largest, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="归并排序">-归并排序-</h2>
<hr>
<p>1）整体是递归，左边排好序+右边排好序+merge让整体有序<br>
2）让其整体有序的过程里用了排外序方法<br>
3）利用master公式来求解时间复杂度<br>
4）当然可以用非递归实现</p>
<hr>
<h3 id="递归版本-2">递归版本</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L...R]范围上，变成有序的</span></span><br><span class="line"><span class="comment">// L...R    N    T(N) = 2*T(N/2) + O(N)  -&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    process(arr, L, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> M, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归版本">非递归版本</h3>
<p>流程就在于折腾  步长 这个概念<br>
步长 = 1 开始, 步长的变化一定是2的某次方<br>
最后一组: 凑不齐左组就不管了, 右组有多少算多少<br>
步长一旦超过总长度, 说明搞完了, 停止就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort3</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (step &lt; N) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( N - L &gt;= step) &#123;</span><br><span class="line">                M = L + step - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                M = N - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (M == N -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (N -<span class="number">1</span> - M &gt;= step) &#123;</span><br><span class="line">                R = M + step;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                R = N - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            merge(arr, L, M, R);</span><br><span class="line">            <span class="keyword">if</span> (R == N - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L = R + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        step &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意最后一组左组: L + step - 1 可能越界</p>
<p>从右往左合并就不用考虑越界问题了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (step &gt; N / 2) &#123;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处不用等号的原因:<br>
如果17个数, 最后一个调整是步长为16的时候的调整:<br>
前16个数做左组, 后一个数做右组<br>
而 N/2 是向下取整的, 17/2 =8 , 所以 mergeSize &gt;= N / 2,<br>
在等于的时候就停止的话, 最后一个步长是8, 不会有最后一个步长为16的时候, 导致你出错了</p>
<h3 id="优化后的最终版本">优化后的最终版本</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归方法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mergeSize</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// 当前有序的，左组长度</span></span><br><span class="line">    <span class="comment">// 一组是2倍的mergeSize</span></span><br><span class="line">    <span class="keyword">while</span> (mergeSize &lt; N) &#123; <span class="comment">// log N</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0.... </span></span><br><span class="line">        <span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">            <span class="comment">// L...M  左组（mergeSize）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> L + mergeSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (M &gt;= N) &#123; <span class="comment">// 当前组凑不齐,只有左边, 肯定有序</span></span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">// 预防越界风险</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  L...M   M+1...R(mergeSize)</span></span><br><span class="line">            <span class="comment">// 有可能最后一组右组数目不够</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> Math.min(M + mergeSize, N - <span class="number">1</span>);</span><br><span class="line">            merge(arr, L, M, R);</span><br><span class="line">            L = R + <span class="number">1</span>; <span class="comment">// 下一次左组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止溢出, INT_MAX</span></span><br><span class="line">        <span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度">复杂度</h4>
<p>一共执行次数  $log_2N$, merge 一次的复杂度 O(N)<br>
总的复杂度: $O(N*logN)$</p>
<h2 id="前缀树">-前缀树-</h2>
<p>1）单个字符串中，字符从前到后的加到一棵多叉树上<br>
2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）<br>
3）所有样本都这样添加，如果没有路就新建，如有路就复用<br>
4）沿途节点的pass值增加1，每个字符串结束时来-到的节点end值增加1</p>
<p>可以完成前缀相关的查询</p>
<h3 id="例子">例子</h3>
<p>设计一种结构。用户可以：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）void insert(String str)            添加某个字符串，可以重复添加，每次算1个</span><br><span class="line">2）int search(String str)             查询某个字符串在结构中还有几个</span><br><span class="line">3) void delete(String str)           删掉某个字符串，可以重复删除，每次算1个</span><br><span class="line">4）int prefixNumber(String str)       查询有多少个字符串，是以str做前缀的</span><br></pre></td></tr></table></figure>
<h3 id="前缀树的实现方式">前缀树的实现方式</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> pass;<span class="comment">// 经过几次</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> end;<span class="comment">// 作为end几次</span></span><br><span class="line">        <span class="keyword">public</span> Node[] nexts; <span class="comment">// 后面的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            nexts = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];<span class="comment">// 一条最长就26 所以这个方式不适合很多类型的节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Trie1</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node root;<span class="comment">// 头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie1</span><span class="params">()</span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * insert()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1 先抓住头节点  pass ++ </span></span><br><span class="line">        <span class="comment">// 2 从左向右遍历字符，next[path]== null则新建节点 pass++</span></span><br><span class="line">        <span class="comment">// 3 最后end++</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(word == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] str = word.toCharArray();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            node.pass++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">                path = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.nexts[path] == <span class="literal">null</span>)&#123;</span><br><span class="line">                    node.nexts[path] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[path];</span><br><span class="line">                node.pass++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * search():查找word出现了几次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(word ==  <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] str = word.toCharArray();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">                path = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.nexts[path] == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[path];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * delete() 内存泄漏问题jvm可以解决的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1 先search是否存在</span></span><br><span class="line">        <span class="comment">// 2 遍历经过要把pass-- 且当pass==0时将next[path]置空，后面的节点JVM自动会清除</span></span><br><span class="line">        <span class="comment">// 3 end --</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.search(word) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">char</span>[] str = word.toCharArray();</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">                node.pass--;</span><br><span class="line">                <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">                    path = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(--node.nexts[path].pass == <span class="number">0</span>)&#123;</span><br><span class="line">                        node.nexts[path] = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.nexts[path];</span><br><span class="line">                &#125;</span><br><span class="line">                node.end--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * prefixNode:有几个是以pre作为前缀的字符</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//和search步骤差不多 最后return的是pass</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prefixNode</span><span class="params">(String pre)</span>&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span>[] str = pre.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length;i++)&#123;</span><br><span class="line">                path = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.nexts[path] == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[path];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.pass;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="（桶排序）不基于比较的">-（桶排序）不基于比较的-</h2>
<p>桶排序思想下的排序：计数排序 &amp; 基数排序</p>
<p>1)桶排序思想下的排序都是不基于比较的排序</p>
<p>2)时间复杂度为O(N)，额外空间负载度O(M)</p>
<p>3)应用范围有限，需要样本的数据状况满足桶的划分</p>
<h3 id="计数排序和基数排序">计数排序和基数排序</h3>
<h4 id="题目3-计数排序">题目3: <a href="app://obsidian.md/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a></h4>
<p>计数排序要求，样本是整数，且范围比较窄</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only for 0~200 value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[i++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题目4-基数排序代码">题目4: <a href="app://obsidian.md/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81">基数排序代码</a></h4>
<p>一般来讲，基数排序要求，样本是10进制的正整数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only for no-negative value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    radixSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, maxbits(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxbits</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[l..r]排序  ,  digit</span></span><br><span class="line"><span class="comment">// l..r    3 56 17 100    3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> digit)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有多少个数准备多少个辅助空间</span></span><br><span class="line">    <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>; d &lt;= digit; d++) &#123; <span class="comment">// 有多少位就进出几次</span></span><br><span class="line">        <span class="comment">// 10个空间</span></span><br><span class="line">        <span class="comment">// count[0] 当前位(d位)是0的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[radix]; <span class="comment">// count[0..9]</span></span><br><span class="line">        <span class="keyword">for</span> (i = L; i &lt;= R; i++) &#123;</span><br><span class="line">            <span class="comment">// 103  1   3</span></span><br><span class="line">            <span class="comment">// 209  1   9</span></span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            count[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; radix; i++) &#123;</span><br><span class="line">            count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = R; i &gt;= L; i--) &#123;</span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            help[count[j] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++) &#123;</span><br><span class="line">            arr[i] = help[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDigit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((x / ((<span class="type">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>))) % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1）一般来讲，计数排序要求，样本是整数，且范围比较窄</strong></p>
<p><strong>2）一般来讲，基数排序要求，样本是10进制的正整数</strong></p>
<p><strong>一旦要求稍有升级，改写代价增加是显而易见的</strong></p>
<h2 id="排序算法的稳定性">排序算法的稳定性</h2>
<p>稳定性是指同样大小的样本再排序之后不会改变相对次序</p>
<p>对基础类型来说，稳定性毫无意义</p>
<p>对非基础类型来说，稳定性有重要意义</p>
<p>有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的</p>
<h2 id="排序算法总结">排序算法总结</h2>
<table>
<thead>
<tr>
<th></th>
<th>时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>无</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>有</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(N^2)</td>
<td>O(1)</td>
<td>有</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(N* logN)</td>
<td>O(N)</td>
<td>有</td>
</tr>
<tr>
<td>随机快排</td>
<td>O(N* logN)</td>
<td>O(logN)</td>
<td>无</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(N* logN)</td>
<td>O(1)</td>
<td>无</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>计数排序</td>
<td>O(N)</td>
<td>O(M)</td>
<td>有</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(N)</td>
<td>O(N)</td>
<td>有</td>
</tr>
</tbody>
</table>
<p>1）不基于比较的排序，对样本数据有严格要求，不易改写<br>
2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用<br>
3）基于比较的排序，时间复杂度的极限是O(N∗logN)<br>
4）时间复杂度O(N∗logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存 在的。<br>
5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并</p>
<h1>4 滑动窗口</h1>
<p>滑动窗口更新结构</p>
<h2 id="1-无重复数组的最长子串">1 无重复数组的最长子串</h2>
<blockquote>
<p>给定一个字符串 找出里面没有重复的最长子串</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 使用窗口 因为不重复 可以用hashset来存储 结果集是char[] str</span></span><br><span class="line"><span class="comment">// 2 遍历数组 L 向右</span></span><br><span class="line"><span class="comment">// 2.1 R向右遍历:更新表</span></span><br><span class="line"><span class="comment">// 2.2 更新max、更新set:删除头</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(s.length() == <span class="number">0</span> || s ==  <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">	HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">	<span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">while</span>(L &lt; str.length)&#123;</span><br><span class="line">		<span class="comment">// 2.1</span></span><br><span class="line">		<span class="keyword">while</span>(R &lt; str.length &amp;&amp; !set.contains(str[R]))&#123; <span class="comment">// !!! 注意是不包含</span></span><br><span class="line">			set.add(str[R]);</span><br><span class="line">			R++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2.2</span></span><br><span class="line">		ans = Math.max(ans, R - L );</span><br><span class="line">		set.remove(str[L]);</span><br><span class="line">		L++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态规划版">动态规划版</h3>
<p>使用256数组进行存储 先都初始化为-1 下标是字符串值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (s.length() == <span class="number">0</span> || s == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">	<span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">		map[i] = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	map[str[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">		pre = Math.min(i - map[str[i]], pre + <span class="number">1</span>);</span><br><span class="line">		ans = Math.max(ans, pre);</span><br><span class="line">		map[str[i]] = i;	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-最小覆盖子串">2 最小覆盖子串</h2>
<blockquote>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1 使用map[256]来记录 t中需要的每种字符的数量;</span></span><br><span class="line">	<span class="comment">//all来记录所有字符剩下没找到的数量；start记录最小子串开头下标</span></span><br><span class="line">	<span class="comment">// 2 遍历字符集  L = 0 遍历 R 向右 </span></span><br><span class="line">	<span class="comment">// 2.1 右边界扩大 同时map相应-- 并且没有减到0的话all--</span></span><br><span class="line">	<span class="comment">// 2.2 当all还完之后 要将左边界缩小 </span></span><br><span class="line">	<span class="comment">// 2.2.1 map对应的str[L] 左边界有可能有重复值 对应map小于0 要缩到不能缩的地方</span></span><br><span class="line">	<span class="comment">// 2.2.2 更新minLen 和开头start </span></span><br><span class="line">	<span class="comment">// 2.2.3 左边界L++、map对应++、 all++	</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minLength2</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s1.length() &lt; s2.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">		<span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">		<span class="comment">// 1</span></span><br><span class="line">		<span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>]; <span class="comment">// map[37] = 4  37  4次</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i != str2.length; i++) &#123;</span><br><span class="line">			map[str2[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> str2.length;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// [L,R)  -&gt; [0,0)</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">		<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 记录最小子串开头下标 </span></span><br><span class="line">		<span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">while</span> (R != str1.length) &#123;</span><br><span class="line">			<span class="comment">// 2.1</span></span><br><span class="line">			map[str1[R]]--;</span><br><span class="line">			<span class="keyword">if</span> (map[str1[R]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				all--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 2.2</span></span><br><span class="line">			<span class="keyword">if</span> (all == <span class="number">0</span>) &#123; <span class="comment">// 还完了 就是一个解</span></span><br><span class="line">				<span class="comment">// 2.2.1</span></span><br><span class="line">				<span class="keyword">while</span> (map[str1[L]] &lt; <span class="number">0</span>) &#123;<span class="comment">// ！！！左边界有可能有重复值 对应的map就是小于0的 我们要避免 所以缩到没有重复的地方才开始记录minlen</span></span><br><span class="line">					map[str1[L]]++;</span><br><span class="line">         	L++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 2.2.2</span></span><br><span class="line">				<span class="keyword">if</span>(minLen &gt; R - L + <span class="number">1</span>)&#123; </span><br><span class="line">					minLen = R - L + <span class="number">1</span>;</span><br><span class="line">					start = L;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 2.2.3</span></span><br><span class="line">				all++;</span><br><span class="line">				map[str1[L++]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			R++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s1.substring(start, start + minLen);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>就是all还完之前r++往右展开 all==0 就要l++ 往左边缩</strong></p>
<h2 id=""></h2>
<h2 id="3-滑动窗口的最大值">3 滑动窗口的最大值</h2>
<blockquote>
<p>假设一个固定大小为W的窗口;依次划过arr 返回每一次滑出状况的最大值</p>
</blockquote>
<p>定义一个队列来作为窗口，里面放的是下标</p>
<p>循环遍历数组： L R边界</p>
<p>\1) 当窗口不为空&amp;窗口结尾小于当前R 结尾弹出（window是单调递减）<br>
\2) 添加arr[R]<br>
\3) 当队首元素已经不再滑动窗口内，将其从队首移除<br>
\4) 当窗口右边界right+1大于等于窗口大小k时窗口形成。此时，队首元素就是该窗口内的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( arr == <span class="literal">null</span> || w &lt; <span class="number">1</span> || arr.length == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    LinkedList&lt;Integer&gt; window = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">0</span>; R &lt; arr.length; R++)&#123;</span><br><span class="line">        <span class="comment">// 1)</span></span><br><span class="line">        <span class="keyword">while</span>(!window.isEmpty() &amp;&amp; arr[window.peekLast()] &lt; arr[R])&#123;</span><br><span class="line">            window.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2)</span></span><br><span class="line">        window.addLast(R);</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> R - w + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 3)</span></span><br><span class="line">        <span class="keyword">if</span>(window.peekFirst() &lt; L)&#123;</span><br><span class="line">            window.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4)</span></span><br><span class="line">        <span class="keyword">if</span>(R &gt;= w - <span class="number">1</span>)&#123;</span><br><span class="line">            res[L] = arr[window.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h2 id="4-满足绝对值差达标的子数组数量">4 满足绝对值差达标的子数组数量</h2>
<blockquote>
<p>给定一个整型数组arr, 和一个整数num 某一个arr中的子数组sub 如果想达标必须满足 sub中最大值 - sub中国最小值 &lt;= num 返回arr中达标子数组的数量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SW_AllLessNumSubArray</span> &#123;</span><br><span class="line">	<span class="comment">// 1 需要两个双端队列来存储max和min</span></span><br><span class="line">	<span class="comment">// 2 遍历数组每一个数都做一次L开头</span></span><br><span class="line">	<span class="comment">// 2.1 往右R直到当前窗口内子数组不达标</span></span><br><span class="line">	<span class="comment">// 2.1.1 滑动窗口比较弹出末尾添加当前值</span></span><br><span class="line">	<span class="comment">// 2.1.2 不达标要break</span></span><br><span class="line">	<span class="comment">// 2.2 到达了不达标的位置 就可以结束当前L开头的收集 并弹出开头</span></span><br><span class="line">	<span class="comment">// 2.2.1 更新res:对收集达标的数组个数 进行累加</span></span><br><span class="line">	<span class="comment">// 2.2.2 更新窗口:弹出L开头</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">allLessNumSubArray</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr.length == <span class="number">0</span> || arr == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1 </span></span><br><span class="line">		LinkedList&lt;Integer&gt; qmin = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2 </span></span><br><span class="line">		<span class="keyword">while</span> (L &lt; arr.length) &#123;</span><br><span class="line">			<span class="comment">// 2.1</span></span><br><span class="line">			<span class="keyword">while</span> (R &lt; arr.length) &#123;</span><br><span class="line">				<span class="comment">// 2.1.1</span></span><br><span class="line">				<span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) &#123;</span><br><span class="line">					qmax.pollLast();</span><br><span class="line">				&#125;</span><br><span class="line">				qmax.addLast(R);</span><br><span class="line">				<span class="keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) &#123;</span><br><span class="line">					qmin.pollLast();</span><br><span class="line">				&#125;</span><br><span class="line">				qmin.addLast(R);</span><br><span class="line">				<span class="comment">// 2.1.2</span></span><br><span class="line">				<span class="keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; num) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				R++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2.2</span></span><br><span class="line">			<span class="comment">// 2.2.1</span></span><br><span class="line">			res += R - L;</span><br><span class="line">			<span class="comment">// 2.2.2</span></span><br><span class="line">			<span class="keyword">if</span> (qmax.peekFirst() == L) &#123;</span><br><span class="line">				qmax.pollFirst();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (qmin.peekFirst() == L) &#123;</span><br><span class="line">				qmin.pollFirst();</span><br><span class="line">			&#125;</span><br><span class="line">			L++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>5 二叉树</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> val;</span><br><span class="line">  <span class="keyword">private</span> TreeNode left;</span><br><span class="line">  <span class="keyword">private</span> TreeNode right;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-二叉树先、中、后序遍历-DFS">1 二叉树先、中、后序遍历(DFS)</h2>
<h3 id="递归">递归</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">  <span class="comment">// 前</span></span><br><span class="line">  process(head.left);</span><br><span class="line">  <span class="comment">// 中</span></span><br><span class="line">  process(head.right);</span><br><span class="line">  <span class="comment">// 后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归-压栈">非递归(压栈)</h3>
<ul>
<li>先： 先压右再压左 输出—》头左右</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">front</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  stack.push(head);</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="comment">// 打印 </span></span><br><span class="line">    sysout();</span><br><span class="line">    <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123; <span class="comment">// !!! 判空</span></span><br><span class="line">      stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123; <span class="comment">// !!! 判空</span></span><br><span class="line">      stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后：用两个栈 1）先压左再压右 同时答应弹出改为压入另一个栈 输出—》 头右左 2）最后输出的时候就是左右头  头左右</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="comment">// 前序打印行为改成压栈</span></span><br><span class="line">    stack2.push(cur.val);</span><br><span class="line">    <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123; <span class="comment">// 左</span></span><br><span class="line">      stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;<span class="comment">// 右</span></span><br><span class="line">      stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 栈2 弹出打印</span></span><br><span class="line">  <span class="keyword">while</span>(!stack2.isEmpty()) &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    sysout();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>中： 1）先将左边界压入栈 2）直到null，弹出并打印进入右树</p>
<img src="算法高频题总结/image-20220222171852618.png" alt="image-20220222171852618" style="zoom:50%;" />
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">// ⚠️一开始不用塞head</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || head != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(head);</span><br><span class="line">        head = head.left;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123; <span class="comment">// 空了 就弹出打印 进入右边</span></span><br><span class="line">        head = stack.pop();</span><br><span class="line">        sysout(head.val);</span><br><span class="line">        head = head.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉搜索树也可以用这个</p>
<h2 id="2-二叉树的层序遍历-BFS）">2 二叉树的层序遍历(BFS）</h2>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）</p>
 <img src="算法高频题总结/25617_oW1zq2BOkhrT7ERQ.png" alt="image" style="zoom:50%;" />
<h3 id="1-打印每一层">1) 打印每一层</h3>
<blockquote>
<p>给你二叉树的根节点root， 返回其节点值的层序遍历，就是逐层打印</p>
</blockquote>
<p>1.先定义结果集res 和判空操作</p>
<p>2.定义<strong>队列容器</strong>，head放入队列中。</p>
<p>3.定义结果集元素list 即每一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">		<span class="comment">// 1</span></span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2</span></span><br><span class="line">		Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		q.add(head);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3</span></span><br><span class="line">		<span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">			List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">// size !!!</span></span><br><span class="line">				<span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">				list.add(cur.val);</span><br><span class="line">				<span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">					q.add(cur.left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">					q.add(cur.right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			res.add(list);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的锯齿形遍历">二叉树的锯齿形遍历</h4>
<blockquote>
<p>就是在层序遍历基础上 使用flag来判断打印的顺序 ⚠️list.add(0, root.val) 就是添加到开头</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">     List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">     Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">     queue.add(root);</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">         List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">         <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">             root =  queue.poll();</span><br><span class="line">             <span class="keyword">if</span>(flag)&#123;<span class="comment">//通过flag判断打印顺序</span></span><br><span class="line">                 list.add(root.val);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 list.add(<span class="number">0</span>, root.val);<span class="comment">// ！！！</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                 queue.add(root.left);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                 queue.add(root.right);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         flag = !flag;<span class="comment">//这里易错</span></span><br><span class="line">         res.add(list);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）返回节点最多的那一层">2）返回节点最多的那一层</h3>
<ol>
<li>需要curEnd记录是否当前到层的结尾 需要nextEnd记录下一层的最后节点</li>
<li>将上面层序遍历添加每层元素的过程改为记录层的curSize</li>
<li>当cur == curEnd 时 更新 ans (maxWidth</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxWidth</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="type">int</span> <span class="variable">curSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3）二叉树的右视图">3）二叉树的右视图</h3>
<blockquote>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
</blockquote>
<img src="算法高频题总结/image-20220209205752144.png" alt="image-20220209205752144" style="zoom:50%;" />
<p>需要curEnd记录是否当前到层的结尾 需要nextEnd记录下一层的最后节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1</span></span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">curEnd</span> <span class="operator">=</span> head;</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">nextEnd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		q.add(head);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">			<span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">			<span class="comment">// 2 用nextEnd记录最后一个节点</span></span><br><span class="line">			<span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">				q.add(cur.left);</span><br><span class="line">				nextEnd = cur.left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">				q.add(cur.right);</span><br><span class="line">				nextEnd = cur.right;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3 更新当前最后的节点</span></span><br><span class="line">			<span class="keyword">if</span> (cur == curEnd) &#123;</span><br><span class="line">				res.add(cur.val);</span><br><span class="line">				curEnd = nextEnd;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h3 id="4）最大宽度（左右节点的距离）">4）最大宽度（左右节点的距离）</h3>
<blockquote>
<p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">避免不了要记录每一个节点的index 所以需要一个新的节点结构</span><br><span class="line"></span><br><span class="line">newnode&#123;</span><br><span class="line"></span><br><span class="line">​	treenode node;</span><br><span class="line"></span><br><span class="line">​	int level;</span><br><span class="line"></span><br><span class="line">​	int pos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>
<p><strong>在层序遍历基础上 队列添加的是一个新的节点结构来对每个节点的层数和position进行记录</strong> <strong>不需要</strong></p>
</li>
<li>
<p><strong>每次队列进行一次poll循环都要检查 如果curlever != cur.level 说明到了下一层，将curlevel更新，用first抓住第一个的pos</strong></p>
</li>
<li>
<p><strong>更新max</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;NewNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(<span class="keyword">new</span> <span class="title class_">NewNode</span>(root, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// ⚠️一开始添加的就是newnode</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">curlevel</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前层</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstpos</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录每层最前</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">NewNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">NewNode</span>(cur.node.left, cur.level + <span class="number">1</span>, cur.pos * <span class="number">2</span>)); <span class="comment">// ⚠️结构不能搞错 参数不要穿错</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">NewNode</span>(cur.node.right, cur.level + <span class="number">1</span> , cur.pos * <span class="number">2</span> + <span class="number">1</span>)); <span class="comment">// ⚠️</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curlevel != cur.level)&#123;</span><br><span class="line">                curlevel = cur.level;</span><br><span class="line">                firstpos = cur.pos;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, cur.pos - firstpos + <span class="number">1</span>);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewNode</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TreeNode node;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> pos;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">NewNode</span><span class="params">(TreeNode node, <span class="type">int</span> level, <span class="type">int</span> pos)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.level = level;</span><br><span class="line">            <span class="built_in">this</span>.pos = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-二叉树的最近公共祖先">3 二叉树的最近公共祖先</h2>
<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p><code>Info&#123;boolean findP, boolean findQ, treenode ans&#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> process(root,p,q).ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> findP;<span class="comment">// 是否包含p</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> findQ;<span class="comment">// 是否包含q</span></span><br><span class="line">	<span class="keyword">public</span> TreeNode ans;<span class="comment">// 保存结果</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">boolean</span> findP, <span class="type">boolean</span> findQ, TreeNode ans)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.findP = findP;</span><br><span class="line">		<span class="built_in">this</span>.findQ = findQ;</span><br><span class="line">		<span class="built_in">this</span>.ans = ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Info <span class="title function_">process</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">Info</span> <span class="variable">leftInfo</span> <span class="operator">=</span> process(root.left, p, q);</span><br><span class="line">	<span class="type">Info</span> <span class="variable">rightInfo</span> <span class="operator">=</span> process(root.right, p, q);</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 填充当前info</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">findP</span> <span class="operator">=</span> leftInfo.findP || rightInfo.findP || (root == p);</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">findQ</span> <span class="operator">=</span> leftInfo.findQ || rightInfo.findQ || (root == q);</span><br><span class="line">	</span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(leftInfo.ans != <span class="literal">null</span>)&#123;<span class="comment">// leftInfo.findP &amp;&amp; leftInfo.findQ</span></span><br><span class="line">		ans = leftInfo.ans;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(rightInfo.ans != <span class="literal">null</span>)&#123; <span class="comment">// rightInfo.findP &amp;&amp; rightInfo.findQ</span></span><br><span class="line">		ans = rightInfo.ans;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(findP &amp;&amp; findQ)&#123;</span><br><span class="line">		ans = root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(findP, findQ, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-二叉树最大路径和">4 二叉树最大路径和</h2>
<img src="算法高频题总结/image-20220211103231018.png" alt="image-20220211103231018" style="zoom: 67%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> process(root).maxSum;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123; <span class="comment">// z</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> maxGain;<span class="comment">//如果连上父节点的贡献值</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> maxSum ;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> m1, <span class="type">int</span> m2)</span>&#123;</span><br><span class="line">		maxGain = m1;</span><br><span class="line">		maxSum = m2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title function_">process</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, Integer.MIN_VALUE); <span class="comment">// ⚠️ maxsum返回minvalue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Info</span> <span class="variable">leftInfo</span> <span class="operator">=</span> process(head.left);</span><br><span class="line">	<span class="type">Info</span> <span class="variable">rightInfo</span> <span class="operator">=</span> process(head.right);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(leftInfo.maxGain, <span class="number">0</span>); <span class="comment">// ⚠️ &gt;0</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(rightInfo.maxGain, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">maxGain</span> <span class="operator">=</span> Math.max(leftGain,rightGain) + head.val;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Math.max(</span><br><span class="line">			Math.max(leftInfo.maxSum,rightInfo.maxSum),</span><br><span class="line">			leftGain + rightGain + head.val);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(maxGain, maxSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-对称二叉树">5 对称二叉树</h2>
<blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> isMirror(root, root); <span class="comment">// 复制一个自己的树</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode h1, TreeNode h2)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(h1 == <span class="literal">null</span> &amp;&amp; h2 == <span class="literal">null</span>)&#123; <span class="comment">//两个树都是空</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(h1 != <span class="literal">null</span> &amp;&amp; h2 != <span class="literal">null</span>)&#123;<span class="comment">// 两个树都不是空 就返回：1.当前节点值要相等 2.左边和右边也是mirror</span></span><br><span class="line">          <span class="keyword">return</span> (h1.val == h2.val) &amp;&amp; isMirror(h1.left, h2.right) &amp;&amp; isMirror(h1.right, h2.left); <span class="comment">// </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//一个是空一个不是空</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-从前序和中序序列构造二叉树">6 从前序和中序序列构造二叉树</h2>
<blockquote>
<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 利用二叉树前序 头左右 找到头 再利用中序左右头进行左右树分离</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span> || in == <span class="literal">null</span> || pre.length != in.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(pre, <span class="number">0</span>, pre.length- <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span>[] in, <span class="type">int</span> L2, <span class="type">int</span> R2)</span>&#123;</span><br><span class="line">        <span class="comment">// 越界情况</span></span><br><span class="line">        <span class="keyword">if</span>(L1 &gt; R1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 利用前序找到头</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[L1]);</span><br><span class="line">        <span class="keyword">if</span>(L1 == R1)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//中序对应找到头的下标find</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> L2;</span><br><span class="line">        <span class="keyword">while</span>(in[find] != pre[L1])&#123;</span><br><span class="line">            find++;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// （find - L2)就是左树的长度</span></span><br><span class="line">        head.left = f(pre, L1 + <span class="number">1</span>, L1 + (find - L2), in, L2, find - <span class="number">1</span>);</span><br><span class="line">        head.right = f(pre,  L1 + (find - L2) + <span class="number">1</span>, R1, in, find + <span class="number">1</span>, R2);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h2 id="7-验证二叉搜索树">7 验证二叉搜索树</h2>
<blockquote>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>
节点的右子树只包含 大于 当前节点的数。<br>
所有左子树和右子树自身必须也是二叉搜索树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 用中序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">			Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">			<span class="type">double</span> <span class="variable">last</span> <span class="operator">=</span> -Double.MAX_VALUE;<span class="comment">// ⚠️</span></span><br><span class="line">			<span class="keyword">while</span>(!stack.isEmpty() || head != <span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="comment">// 1 </span></span><br><span class="line">				<span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">					stack.push(head);</span><br><span class="line">					head = head.left;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;<span class="comment">// 2</span></span><br><span class="line">					head = stack.pop();</span><br><span class="line">					<span class="keyword">if</span>(head.val &lt;= last)&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					last = head.val;</span><br><span class="line">					head = head.right;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-平衡二叉树">8 平衡二叉树</h2>
<p><strong>使用递归套路</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO &#123;</span><br><span class="line">	高度；</span><br><span class="line">	是否是平衡二叉树；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> process(root).isBt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要的信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> isBt;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> h, <span class="type">boolean</span> ib)</span>&#123;</span><br><span class="line">          height = h;</span><br><span class="line">          isBt = ib;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//找信息的过程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title function_">process</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Info</span> <span class="variable">leftInfo</span> <span class="operator">=</span> process(head.left);</span><br><span class="line">      <span class="type">Info</span> <span class="variable">rightInfo</span> <span class="operator">=</span> process(head.right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//解决当前的Info的方法（也就是所有递归都会用到的方法）</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>; <span class="comment">// ⚠️ </span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isBalanced</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(leftInfo.isBt &amp;&amp; rightInfo.isBt &amp;&amp; Math.abs(leftInfo.height - rightInfo.height) &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">          isBalanced = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(height, isBalanced);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-二叉树的序列化和反序列化">9 二叉树的序列化和反序列化</h2>
<blockquote>
<p>思路</p>
<p>序列化： 准备一个string的队列 然后按照先序顺序将结点转为String类型然后加入队列，左边和右边结点按照顺序递归执行该方法</p>
<p>反序列化： 将要转化为二叉树的队列传入，然后弹出结点为head（注意转换回为Int类型），head左边递归执行preb（prelist），右边递归执行preb（prelist）</p>
<p>错误</p>
<p>判断null值注意判断哈 特别是递归里面 就算是方法前面判断了 当时不代表递归以后不会再次出现，所以方法内还要再判断一次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树的前中后序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BT_09_preSerial</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 序列化 使用队列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title function_">preSerial</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">		Queue&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		pre(head, ans);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pre</span><span class="params">(TreeNode head, Queue&lt;String&gt; ans)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">			ans.add(<span class="literal">null</span>);<span class="comment">// 用来规定用什么来占位</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ans.add(String.valueOf(head.val));</span><br><span class="line">			pre(head.left, ans);</span><br><span class="line">			pre(head.right, ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 反序列化</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildByPreQueue</span><span class="params">(Queue&lt;String&gt; prelist)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(prelist == <span class="literal">null</span> || prelist.size() == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> preb(prelist);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">preb</span><span class="params">(Queue&lt;String&gt; prelist)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> prelist.poll();</span><br><span class="line">		<span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.valueOf(value));</span><br><span class="line">		head.left = preb(prelist);</span><br><span class="line">		head.right = preb(prelist);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-二叉树的最大深度">10 二叉树的最大深度</h2>
<blockquote>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，</p>
<p>3</p>
<p>/ <br>
9  20<br>
/  <br>
15   7</p>
<p>返回它的最大深度 3 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findDepth(root).height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> height;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> h)</span>&#123;</span><br><span class="line">            height = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title function_">findDepth</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Info</span> <span class="variable">leftInfo</span> <span class="operator">=</span> findDepth(head.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">rightInfo</span> <span class="operator">=</span> findDepth(head.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-最大直径">11 最大直径</h2>
<blockquote>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>示例 :<br>
给定二叉树</p>
<pre><code>   1
  / \
 2   3
/ \     
</code></pre>
<p>4   5</p>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二叉树最大直径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BT_05_ZhiJing</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> process(head) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">lM</span> <span class="operator">=</span> process(head.left);</span><br><span class="line">		<span class="type">int</span> <span class="variable">rM</span> <span class="operator">=</span> process(head.right);</span><br><span class="line">		ans = Math.max(lM + rM + <span class="number">1</span>, ans);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Math.max(lM, rM) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归套路</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process2(root).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> Integer height;</span><br><span class="line">		<span class="keyword">public</span> Integer max;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(Integer h, Integer m)</span>&#123;</span><br><span class="line">			height = h;</span><br><span class="line">			max = m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> Info <span class="title function_">process2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Info</span> <span class="variable">leftInfo</span> <span class="operator">=</span> process2(root.left);</span><br><span class="line">		<span class="type">Info</span> <span class="variable">rightInfo</span> <span class="operator">=</span> process2(root.right);</span><br><span class="line">	</span><br><span class="line">		<span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(Math.max(leftInfo.max, rightInfo.max),</span><br><span class="line">				leftInfo.height + rightInfo.height);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(height, max);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-路径总和">12 路径总和</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 路径总和 Ⅰ</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 要求返回是否存在总和为target的从根到节点的路径</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> isSum;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		isSum = <span class="literal">false</span>;</span><br><span class="line">		process(root, <span class="number">0</span>, targetSum);</span><br><span class="line">		<span class="keyword">return</span> isSum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(TreeNode head, <span class="type">int</span> preSum, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">		<span class="comment">// 是叶子节点</span></span><br><span class="line">		<span class="keyword">if</span> (head.left == <span class="literal">null</span> &amp;&amp; head.right == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (preSum + head.val == sum) &#123;</span><br><span class="line">				isSum = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不是叶子节点</span></span><br><span class="line">		preSum += head.val;</span><br><span class="line">		<span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			process(head.left, preSum, sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			process(head.right, preSum, sum);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 路径总和Ⅱ</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 要求返回所有满足target的路径</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 1 </span></span><br><span class="line">	<span class="comment">// 2 注意现场要恢复，因为只有一个path来存路 如果没有清空，后面根本装不下</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		process(root, path, <span class="number">0</span>, targetSum, ans);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(TreeNode head, List&lt;Integer&gt; path, <span class="type">int</span> preSum, <span class="type">int</span> sum,</span></span><br><span class="line"><span class="params">			List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 叶子节点</span></span><br><span class="line">		<span class="keyword">if</span> (head.left == <span class="literal">null</span> &amp;&amp; head.right == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (head.val + preSum == sum) &#123;</span><br><span class="line">				path.add(head.val);</span><br><span class="line">				ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));<span class="comment">// 传递是引用不能直接传path</span></span><br><span class="line">				path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		preSum += head.val;</span><br><span class="line">		path.add(head.val);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不是叶子节点</span></span><br><span class="line">		<span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			process(head.left, path, preSum, sum, ans);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			process(head.right, path, preSum, sum, ans);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 恢复现场</span></span><br><span class="line">		path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="13-翻转二叉树">13 翻转二叉树</h2>
<blockquote>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">翻转二叉树</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 有点像数组swap</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1>6 栈</h1>
<h2 id="1-有效括号">1 有效括号</h2>
<blockquote>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
</blockquote>
<ol>
<li>遍历所有左边的括号变成对应的右括号压入栈</li>
<li>遇到的右边的括号
<ol>
<li>如果stack是空的，则false</li>
<li>弹出栈顶比较不相等 false</li>
</ol>
</li>
<li>最后stack 必须是空的才能满足</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	 	<span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(str[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span>((str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;(&#x27;</span>) || (str[i] </span><br><span class="line">                == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;&#123;&#x27;</span>) || (str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;[&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-用栈实现队列">2 用栈实现队列</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> Stack&lt;Integer&gt; sPop;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; sPush;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        sPop = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        sPush = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        sPush.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sPop.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!sPush.isEmpty())&#123;</span><br><span class="line">                sPop.push(sPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sPop.pop();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sPop.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!sPush.isEmpty())&#123;</span><br><span class="line">                sPop.push(sPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sPop.isEmpty() &amp;&amp; sPush.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-最小栈">3 最小栈</h2>
<blockquote>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>
<li><code>pop()</code> —— 删除栈顶的元素。</li>
<li><code>top()</code> —— 获取栈顶元素。</li>
<li><code>getMin()</code> —— 检索栈中的最小元素。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Stack&lt;Integer&gt; data;</span><br><span class="line">	<span class="keyword">public</span> Stack&lt;Integer&gt; min;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.data = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">		<span class="built_in">this</span>.min = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(<span class="built_in">this</span>.min.isEmpty())&#123;</span><br><span class="line">    		<span class="built_in">this</span>.min.push(val);</span><br><span class="line">    	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &lt; <span class="built_in">this</span>.getMin())&#123;</span><br><span class="line">    		<span class="built_in">this</span>.min.push(val);</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="built_in">this</span>.min.push(<span class="built_in">this</span>.getMin());</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">this</span>.data.push(val);</span><br><span class="line">    	</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.data.pop();</span><br><span class="line">    	<span class="built_in">this</span>.min.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.data.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-两个队列实现栈">4 两个队列实现栈</h2>
<p>在push操作里进行改进就可以：<br>
通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">           <span class="keyword">public</span> Queue&lt;Integer&gt; q1;</span><br><span class="line">        <span class="keyword">public</span> Queue&lt;Integer&gt; q2;</span><br><span class="line">        <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span>&#123;</span><br><span class="line">            q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">            q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            q2.offer(x);</span><br><span class="line">            <span class="keyword">while</span>(!q1.isEmpty())&#123;</span><br><span class="line">                q2.offer(q1.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            Queue&lt;Integer&gt; tmp = q1;</span><br><span class="line">            q1 = q2;</span><br><span class="line">            q2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q1.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Get the top element. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q1.peek();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一个队列也可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">       queue.offer(x);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           queue.offer(queue.poll());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-单调栈">5 单调栈</h2>
<p>为了解决给定的一个可能含有重复值的arr，i位置一定有以下信息</p>
<p>1）arr[i] 左边有离它最近比它小的（大）的数</p>
<p>2）arr[i] 右边有离它最近比它小的（大）的数</p>
<h3 id="找到左边和右边离i最近比其小的下表对-res-n-2">找到左边和右边离i最近比其小的下表对 <code>res[n][2]</code></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code1_MonotonousStack</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] getNearLessNoRepeat(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">		<span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">		Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			<span class="comment">//新的数压栈 如果比栈底小 栈底弹出 并记录</span></span><br><span class="line">			<span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i])&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">popIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">				<span class="type">int</span> <span class="variable">leftLessIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">				res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">				res[popIndex][<span class="number">1</span>] = i;</span><br><span class="line">			&#125;</span><br><span class="line">			stack.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">popIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">			<span class="type">int</span> <span class="variable">leftLessIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">			res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">			res[popIndex][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//数组中有重复的情况</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] getNearLess(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">		<span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// List&lt;Integer&gt; -&gt; 放的是位置，同样值的东西，位置压在一起</span></span><br><span class="line">		<span class="comment">// 代表值    底  -&gt;  顶   小  -&gt; 大</span></span><br><span class="line">		Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			<span class="comment">//新的数压栈 如果比栈底小 栈底弹出 并记录</span></span><br><span class="line">			<span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="number">0</span>)] &gt; arr[i])&#123;</span><br><span class="line">				List&lt;Integer&gt; popIndex = stack.pop();</span><br><span class="line">				<span class="type">int</span> <span class="variable">leftLessIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">for</span>(Integer popi : popIndex)&#123;</span><br><span class="line">					res[popi][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">					res[popi][<span class="number">1</span>] = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//相等的比你小的 都要把存入栈的格式改为存储了位置的list数组</span></span><br><span class="line">			<span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="number">0</span>)] == arr[i])&#123;</span><br><span class="line">				stack.peek().add(Integer.valueOf(i));</span><br><span class="line">				</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				List&lt;Integer&gt; pushIndex = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">				pushIndex.add(Integer.valueOf(i));</span><br><span class="line">				stack.push(pushIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">			List&lt;Integer&gt; popIndex = stack.pop();</span><br><span class="line">			<span class="comment">//取决于最晚加入的那个</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">leftLessIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(Integer popi : popIndex)&#123;</span><br><span class="line">				res[popi][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">				res[popi][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="正数数组arr中（sub的累加和-min）的最大值">正数数组arr中（sub的累加和*min）的最大值</h3>
<blockquote>
<p>给定一个只包含正数的数组arr，arr中任何一个子数组sub，一定都可以算出(sub累加和 )* (sub中的最小值)是什么，<br>
那么所有子数组中，这个值最大是多少？</p>
</blockquote>
<p>直接找每个数两边最近比它小中间部分累加和（这部分该数一定最小）</p>
<p>1 建立前缀和数组<code>sums[i]</code>(这样求累加和就可以[0~R] -[0~L-1])</p>
<p>2 和上面单调栈思路差不多</p>
<p>​	1）栈顶弹出<code>[j]</code>后更新max</p>
<p>​	2）再遍历栈里的元素 右边没有比它最小所以累加直接用<code>sums[N-1]</code>来减</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1>7 递归</h1>
<h2 id="1-全排列">1 全排列</h2>
<blockquote>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案</p>
</blockquote>
<img src="算法高频题总结/image-20220210103904616.png" alt="image-20220210103904616" style="zoom:50%;" />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();<span class="comment">//选择的路</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)&#123;</span><br><span class="line">        	<span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            path.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        process(path, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//  DFS</span></span><br><span class="line">	<span class="comment">// 1 for是在树形结构里平行进行  - - -&gt;</span></span><br><span class="line">	<span class="comment">// 2 先交换成为一种情况</span></span><br><span class="line">	<span class="comment">// 3 往下|递归将剩余部分的情况搞定</span></span><br><span class="line">	<span class="comment">//      |</span></span><br><span class="line">	<span class="comment">//      v</span></span><br><span class="line">	<span class="comment">// 4 恢复原来状态 因为平行的分支需要同样的状态</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;Integer&gt; path, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == path.size())&#123;</span><br><span class="line">			ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(path));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; path.size(); j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[path.get(j) + <span class="number">128</span>])&#123; <span class="comment">// 剪枝</span></span><br><span class="line">				vis[path.get(j) + <span class="number">128</span>] = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">// 2</span></span><br><span class="line">				Collections.swap(path, i, j);</span><br><span class="line">				<span class="comment">// 3</span></span><br><span class="line">				process(path, i + <span class="number">1</span>, ans);</span><br><span class="line">				<span class="comment">// 4</span></span><br><span class="line">				Collections.swap(path, i, j);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="全排列2⃣️-不重复">全排列2⃣️ 不重复</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全排列</span></span><br><span class="line"><span class="comment"> * 将给定数组进行排列组合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span>回溯_Permutation &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 不同打印结果存储</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            path.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        process(path, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  DFS</span></span><br><span class="line">    <span class="comment">// 1 for是在树形结构里平行进行  - - -&gt;</span></span><br><span class="line">    <span class="comment">// 2 先交换成为一种情况</span></span><br><span class="line">    <span class="comment">// 3 往下|递归将剩余部分的情况搞定</span></span><br><span class="line">    <span class="comment">//      |</span></span><br><span class="line">    <span class="comment">//      v</span></span><br><span class="line">    <span class="comment">// 4 恢复原来状态 因为平行的分支需要同样的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;Integer&gt; path, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == path.size())&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; path.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[path.get(j)]+<span class="number">128</span>)&#123; <span class="comment">// 剪枝 数组有负数要加上128</span></span><br><span class="line">                vis[path.get(j)+<span class="number">128</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 2</span></span><br><span class="line">                Collections.swap(path, i, j);</span><br><span class="line">                <span class="comment">// 3</span></span><br><span class="line">                process(path, i + <span class="number">1</span>, ans);</span><br><span class="line">                <span class="comment">// 4</span></span><br><span class="line">                Collections.swap(path, i, j);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-括号生成">2 括号生成</h2>
<blockquote>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">利用一个原理是 当前面已经做了选择的左括号比右括号多的时候</span><br><span class="line">就添加右括号 </span><br><span class="line">需要剪枝 在往path里面添加括号的时候</span><br><span class="line">进行条件剪枝</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] path = <span class="keyword">new</span> <span class="title class_">char</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        process(path,<span class="number">0</span>, n, <span class="number">0</span>, ans); <span class="comment">// ⚠️传进去的参数！</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 剪枝 左边括号还有 和左边-右边》0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] path, <span class="type">int</span> i,<span class="type">int</span> leftRest, <span class="type">int</span> leftMinusRight, List&lt;String&gt; ans )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == path.length)&#123; <span class="comment">// 到结尾</span></span><br><span class="line">            ans.add(String.valueOf(path)); <span class="comment">// 一种可能</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(leftRest &gt; <span class="number">0</span>)&#123; <span class="comment">// 左边的括号还有 将当前的位置设为左， 剩下的去递归</span></span><br><span class="line">                path[i] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                process(path, i + <span class="number">1</span>, leftRest - <span class="number">1</span>, leftMinusRight + <span class="number">1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftMinusRight &gt; <span class="number">0</span>)&#123;<span class="comment">// 左边的括号大于右边的括号</span></span><br><span class="line">                path[i] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                process(path, i + <span class="number">1</span>, leftRest, leftMinusRight - <span class="number">1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-复原ip地址">3 复原ip地址</h2>
<blockquote>
<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。</p>
<p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span>[] segment; <span class="comment">// segment[i]存储第i段</span></span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">	segment = <span class="keyword">new</span> <span class="title class_">int</span>[COUNT];</span><br><span class="line">	dfs(s, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// s 字符串 id 段数 segstart</span></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> id, <span class="type">int</span> segStart)</span> &#123;</span><br><span class="line">	<span class="comment">// 1 已经递归到第四段</span></span><br><span class="line">	<span class="keyword">if</span> (id == COUNT) &#123;</span><br><span class="line">		<span class="keyword">if</span> (segStart == s.length()) &#123;<span class="comment">// 并且 所有数字都完成</span></span><br><span class="line">			<span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">				str.append(segment[i]);</span><br><span class="line">				<span class="keyword">if</span> (i != COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">					str.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.add(str.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 记得向上返回！！！</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2 四段没玩但是已经到结尾</span></span><br><span class="line">	<span class="keyword">if</span> (segStart == s.length()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3 有0的情况</span></span><br><span class="line">	<span class="keyword">if</span> (s.charAt(segStart) == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 有零</span></span><br><span class="line">		segment[id] = <span class="number">0</span>;</span><br><span class="line">		dfs(s, id + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4 一般情况</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">segEnd</span> <span class="operator">=</span> segStart; segEnd &lt; s.length(); segEnd++) &#123;</span><br><span class="line">		ans = ans * <span class="number">10</span> + (s.charAt(segEnd) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ans &gt; <span class="number">0</span> &amp;&amp; ans &lt;= <span class="number">0xFF</span>) &#123;<span class="comment">// ans属于[0, 255]</span></span><br><span class="line">			segment[id] = ans;</span><br><span class="line">			dfs(s, id + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-单词搜索">4 单词搜索</h2>
<p>dfs+回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> board.length, w = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[h][w];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, i, j, word, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">boolean</span>[][] visited, <span class="type">int</span> i, <span class="type">int</span> j, String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newi</span> <span class="operator">=</span> i + dir[<span class="number">0</span>], newj = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newi &gt;= <span class="number">0</span> &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= <span class="number">0</span> &amp;&amp; newj &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[newi][newj]) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> check(board, visited, newi, newj, s, k + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        result = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-子集">5 子集</h2>
<blockquote>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]<br>
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
<p>示例 2：</p>
<p>输入：nums = [0]<br>
输出：[[],[0]]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//用来存放之前决定</span></span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		process2(nums, <span class="number">0</span>, res, path);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == nums.length)&#123;</span><br><span class="line">			res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 两种可能</span></span><br><span class="line">		process2(nums, i + <span class="number">1</span>, res, path);</span><br><span class="line">		List&lt;Integer&gt; path2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path);</span><br><span class="line">		path2.add(nums[i]);</span><br><span class="line">		process2(nums, i + <span class="number">1</span>, res, path2);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1>8 并查集</h1>
<h2 id="并查集">并查集</h2>
<p>用来解决图的连通性和环的数量</p>
<h2 id="结构（hash表）">结构（hash表）</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_UnionFind</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;V&gt; &#123;</span><br><span class="line">		V value;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(V v)</span> &#123;</span><br><span class="line">			value = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 并查集 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 1 构造方法</span></span><br><span class="line">	<span class="comment">// 2 Node&lt;V&gt; findFather(Node&lt;V&gt; cur)</span></span><br><span class="line">	<span class="comment">// 3 boolean isSameSet(V a, V b)</span></span><br><span class="line">	<span class="comment">// 4 void union(V a, V b)</span></span><br><span class="line">	<span class="comment">// 5 int sets()</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span>&lt;V&gt; &#123;</span><br><span class="line">		<span class="keyword">public</span> HashMap&lt;V, Node&lt;V&gt;&gt; nodes;<span class="comment">// 点</span></span><br><span class="line">		<span class="keyword">public</span> HashMap&lt;Node&lt;V&gt;, Node&lt;V&gt;&gt; parents;<span class="comment">// 最高父亲</span></span><br><span class="line">		<span class="keyword">public</span> HashMap&lt;Node&lt;V&gt;, Integer&gt; sizeMap;<span class="comment">// 所在集合大小</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(List&lt;V&gt; values)</span> &#123;</span><br><span class="line">      <span class="comment">//1 初始化参数</span></span><br><span class="line">			nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			parents = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			sizeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">//2 遍历：先new一个node 然后更新点集，更新父亲表（自己是自己爹），最后更新sizemap</span></span><br><span class="line">			<span class="keyword">for</span> (V cur : values) &#123;</span><br><span class="line">				Node&lt;V&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(cur);</span><br><span class="line">				nodes.put(cur, node);</span><br><span class="line">				parents.put(node, node);</span><br><span class="line">				sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 找爹</span></span><br><span class="line">		<span class="keyword">public</span> Node&lt;V&gt; <span class="title function_">findFather</span><span class="params">(Node&lt;V&gt; cur)</span> &#123; </span><br><span class="line">      <span class="comment">//1 new 一个 栈</span></span><br><span class="line">			Stack&lt;Node&lt;V&gt;&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">//2 如果当前cur不是自己爹 ：1）压栈 2）cur更新为自己爹</span></span><br><span class="line">			<span class="keyword">while</span> (cur != parents.get(cur)) &#123;</span><br><span class="line">				path.push(cur);</span><br><span class="line">				cur = parents.get(cur);</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">//3 如果栈不空 cur就是当前最爹 所以循环弹出 将cur设为他们爹</span></span><br><span class="line">			<span class="keyword">while</span> (!path.isEmpty()) &#123;</span><br><span class="line">				parents.put(path.pop(), cur);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> cur;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 返回两爹是否相等</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(V a, V b)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> findFather(nodes.get(a)) == findFather(nodes.get(b));</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 并</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(V a, V b)</span> &#123;</span><br><span class="line">			Node&lt;V&gt; aHead = findFather(nodes.get(a));</span><br><span class="line">			Node&lt;V&gt; bHead = findFather(nodes.get(b));</span><br><span class="line">			<span class="comment">// 如果两爹不同</span></span><br><span class="line">			<span class="keyword">if</span>(aHead != bHead) &#123;</span><br><span class="line">        <span class="comment">// 1 抓住size大小</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">aSize</span> <span class="operator">=</span> sizeMap.get(aHead);</span><br><span class="line">				<span class="type">int</span> <span class="variable">bSize</span> <span class="operator">=</span> sizeMap.get(bHead);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 小的那个接在大的下面（big是small的父</span></span><br><span class="line">				Node&lt;V&gt; small = aSize &lt; bSize ? aHead : bHead;</span><br><span class="line">				Node&lt;V&gt; big = small == aHead ? bHead : aHead;</span><br><span class="line">				parents.put(small, big);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 更新大集的size 并转移小集的sizemap</span></span><br><span class="line">				sizeMap.put(big, aSize + bSize);</span><br><span class="line">				sizeMap.remove(small);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sets</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> sizeMap.size();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-岛屿数量">1 岛屿数量</h2>
<blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">					islands++;</span><br><span class="line">					infect(board, i, j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> islands;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从(i,j)这个位置出发，把所有练成一片的&#x27;1&#x27;字符，变成0</span></span><br><span class="line">	<span class="comment">// DFS</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">infect</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length</span><br><span class="line">				|| board[i][j] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		board[i][j] = <span class="number">0</span>;</span><br><span class="line">		infect1(board, i, j - <span class="number">1</span>);</span><br><span class="line">		infect1(board, i, j + <span class="number">1</span>);</span><br><span class="line">		infect1(board, i + <span class="number">1</span>, j);</span><br><span class="line">		infect1(board, i - <span class="number">1</span>, j);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * BFS</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">infect2</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		Queue&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; a, b &#125;);</span><br><span class="line">		<span class="keyword">while</span>(!list.isEmpty()) &#123;</span><br><span class="line">			<span class="type">int</span>[] cur = list.poll();</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.length &amp;&amp; j &lt; board[<span class="number">0</span>].length</span><br><span class="line">					&amp;&amp; board[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				board[i][j] = <span class="number">0</span>;</span><br><span class="line">				list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i - <span class="number">1</span>, j &#125;);</span><br><span class="line">				list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i + <span class="number">1</span>, j &#125;);</span><br><span class="line">				list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j - <span class="number">1</span> &#125;);</span><br><span class="line">				list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j + <span class="number">1</span> &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h3 id="使用并查集（面试）">使用并查集（面试）</h3>
<p>为什么要并查集？ 如果有多台cpu 大岛变成小岛就会很容易</p>
<p><strong>面试就讲一下怎么通过并查集来进行union ： 并查集就是可以将a, b所在的集合进行合并；需要每个岛的位置 所以需要一个index方法来返回每格子的位置就是行数乘以矩阵宽度再加上列数， 然后要进行union（） 具体过程就是先找到两个要合并的点的父亲，如果不相同就再调出两个所在集合的大小sizemap，然后将小的集合接在大的集合下面， 更新sizemap。 这里找父亲的操作可以用一个help数组倒序遍历来代替栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用并查集</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> board</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numIslands2</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> board.length;</span><br><span class="line">		<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">		<span class="type">UnionFind2</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind2</span>(board);</span><br><span class="line">		<span class="comment">// 把第一行第一列先处理 就不需要后面考虑边界</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[<span class="number">0</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; board[<span class="number">0</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				uf.union(<span class="number">0</span>, j - <span class="number">1</span>, <span class="number">0</span>, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; board[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				uf.union(i - <span class="number">1</span>, <span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 除了第一行第一列的部分</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;1&#x27;</span>)  <span class="comment">// 看上面和左边</span></span><br><span class="line">					<span class="keyword">if</span> (board[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">						uf.union(i, j - <span class="number">1</span>, i, j);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (board[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">						uf.union(i - <span class="number">1</span>, j, i, j);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> uf.sets();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnionFind2</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] help;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> col;<span class="comment">// 用来计算矩阵数r*col + c</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> sets;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">UnionFind2</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">			col = board[<span class="number">0</span>].length;</span><br><span class="line">			sets = <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> board.length;</span><br><span class="line">			<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> row * col;</span><br><span class="line">			parent = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">			size = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">			help = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; row; r++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; col; c++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">						<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index(r, c);</span><br><span class="line">						parent[i] = i;</span><br><span class="line">						size[i] = <span class="number">1</span>;</span><br><span class="line">						sets++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (r,c) -&gt; i</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> r * col + c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 原始位置 -&gt; 下标</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (i != parent[i]) &#123;</span><br><span class="line">				help[hi++] = i;</span><br><span class="line">				i = parent[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (hi--; hi &gt;= <span class="number">0</span>; hi--) &#123;</span><br><span class="line">				parent[help[hi]] = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> r1, <span class="type">int</span> c1, <span class="type">int</span> r2, <span class="type">int</span> c2)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> index(r1, c1);</span><br><span class="line">			<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> index(r2, c2);</span><br><span class="line">			<span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> find(i1);</span><br><span class="line">			<span class="type">int</span> <span class="variable">f2</span> <span class="operator">=</span> find(i2);</span><br><span class="line">			<span class="keyword">if</span> (f1 != f2) &#123;</span><br><span class="line">				<span class="keyword">if</span> (size[f1] &gt;= size[f2]) &#123;</span><br><span class="line">					size[f1] += size[f2];</span><br><span class="line">					parent[f2] = f1;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					size[f2] += size[f1];</span><br><span class="line">					parent[f1] = f2;</span><br><span class="line">				&#125;</span><br><span class="line">				sets--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sets</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> sets;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-省份数量（朋友圈）">2 省份数量（朋友圈）</h2>
<blockquote>
<p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] M)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> M.length;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    unionFind.union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unionFind.sets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组结构的并查集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parents;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] help;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> sets;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">            parents = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">            size = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">            help = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">            sets = N;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                parents[i] = i;</span><br><span class="line">                size[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 定义一个指针</span></span><br><span class="line">        <span class="comment">// 2 while(i不是自己爹）&#123;</span></span><br><span class="line">        <span class="comment">// 2.1 压help栈（虚拟的</span></span><br><span class="line">        <span class="comment">// 2.2 i指向自己的爹    &#125;</span></span><br><span class="line">        <span class="comment">// 3 for遍历help：模拟栈弹出 &#123;所有人爹设为i&#125;</span></span><br><span class="line">        <span class="comment">// 4 返回i:此时i指向最爹</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findFather</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( i != parents[i]) &#123;</span><br><span class="line">                help[hi++] = i;</span><br><span class="line">                i = parents[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(hi--; hi &gt;=<span class="number">0</span>; hi--)&#123;</span><br><span class="line">                parents[help[hi]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">iF</span> <span class="operator">=</span> findFather(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">jF</span> <span class="operator">=</span> findFather(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(iF != jF) &#123;</span><br><span class="line">                <span class="keyword">if</span>(size[iF] &lt; size[jF]) &#123;</span><br><span class="line">                    size[jF] += size[iF];</span><br><span class="line">                    parents[iF] = jF;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    size[iF] += size[jF];</span><br><span class="line">                    parents[jF] = iF;</span><br><span class="line">                &#125;</span><br><span class="line">                sets--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sets</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sets;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>7 图</h1>
<h2 id="将矩阵转化为自己的结构-creatGraph">将矩阵转化为自己的结构(creatGraph)</h2>
<ol>
<li>new一个自己的graph</li>
<li>遍历矩阵每一行 for(matrix.length)
<ol>
<li>weight:<code>matrix[i][0]</code> from<code>[i][1]</code> to:<code>[i][2]</code></li>
<li>判断是否contanskey(from和to) 分别放入点集</li>
<li>edge初始化 并赋值 (weight,fromNode,toNode)</li>
<li>更新出入度、直接点、直接边</li>
<li>边放入边集</li>
</ol>
</li>
</ol>
<h2 id="1-图的bfs">1 图的bfs</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_BFS</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从node出发，进行宽度优先遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node start)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (start == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		queue.add(start);</span><br><span class="line">		set.add(start);</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">			System.out.println(cur.value);</span><br><span class="line">			<span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">					set.add(next);</span><br><span class="line">					queue.add(next);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-DFS">2 DFS</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> all.Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_DFS</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		stack.add(node);</span><br><span class="line">		set.add(node);</span><br><span class="line">		System.out.println(node.value);</span><br><span class="line">		<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">			<span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">					stack.push(cur);</span><br><span class="line">					stack.push(next);</span><br><span class="line">					set.add(next);</span><br><span class="line">					System.out.println(next.value);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-拓扑排序">3 拓扑排序</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拓扑排序 ： 有向无环图</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_TopologySort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// directed graph and no loop</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">sortedTopology</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">		<span class="comment">// key 某个节点   value 剩余的入度</span></span><br><span class="line">		HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// 只有剩余入度为0的点，才进入这个队列</span></span><br><span class="line">		Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">			inMap.put(node, node.in);</span><br><span class="line">			<span class="keyword">if</span> (node.in == <span class="number">0</span>) &#123;</span><br><span class="line">				zeroInQueue.add(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Node&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!zeroInQueue.isEmpty()) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> zeroInQueue.poll();</span><br><span class="line">			result.add(cur);</span><br><span class="line">			<span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">				inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">					zeroInQueue.add(next);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Sonia33</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://soniachen.com/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://soniachen.com/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/')">算法高频题总结</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://soniachen.com/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=算法高频题总结&amp;url=https://soniachen.com/2022/02/23/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://soniachen.com" target="_blank">Sonia33's Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/12/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="prev-cover" src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis面试题</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/10/%E7%BD%91%E7%BB%9CIO%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="next-cover" src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">网络IO面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2021/06/07/JDBC/" title="JDBC"><img class="cover" src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-06-07</div><div class="title">JDBC</div></div></a></div><div><a href="/2021/07/20/JavaEE/" title="JavaEE"><img class="cover" src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-07-20</div><div class="title">JavaEE</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">高频题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.1.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.2.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">搜索旋转排序数组（面试）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">合并两个有序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">1.5.</span> <span class="toc-text">螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.6.</span> <span class="toc-text">字符串相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E5%85%83%E7%B4%A0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.7.1.</span> <span class="toc-text">在排序数组中找到元素第一个和最后一个位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%95%B4%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">字符串转化整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">1.9.</span> <span class="toc-text">下一个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">1.10.</span> <span class="toc-text">合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-number">1.11.</span> <span class="toc-text">x的平方根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">缺失的正数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8rand7-%E7%94%9F%E6%88%90rand10"><span class="toc-number">1.13.</span> <span class="toc-text">用rand7()生成rand10()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-%E2%9A%A0%EF%B8%8F-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%AC%ACk%E5%B0%8F"><span class="toc-number">1.14.</span> <span class="toc-text">找到两个有序数组的中位数(⚠️)&#x2F;两个有序数组第k小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">1.15.</span> <span class="toc-text">翻转字符串中的单词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.15.1.</span> <span class="toc-text">思路:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="toc-number">1.16.</span> <span class="toc-text">字符串相乘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">1.17.</span> <span class="toc-text">删除数组中的重复项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D"><span class="toc-number">1.18.</span> <span class="toc-text">去除重复字母</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">1.19.</span> <span class="toc-text">单词搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">1.20.</span> <span class="toc-text">多数元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">1 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E4%BA%8C"><span class="toc-number">2.1.1.</span> <span class="toc-text">反转链表二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">2 LRU缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%80%BB%E7%9A%84%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84-%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">1) 总的缓存结构 和方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.0.1.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-get"><span class="toc-number">2.2.0.1.2.</span> <span class="toc-text">1 get()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-put"><span class="toc-number">2.2.0.1.3.</span> <span class="toc-text">2 put()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89MyCache"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">2）MyCache</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">2.2.0.2.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-V-get-K-key-%E9%80%9A%E8%BF%87key%E8%BF%94%E5%9B%9Evalue-%E9%9C%80%E8%A6%81%E5%B0%86node%E6%94%BE%E5%88%B0%E5%B0%BE%E9%83%A8"><span class="toc-number">2.2.0.2.2.</span> <span class="toc-text">1 V get(K key) 通过key返回value 需要将node放到尾部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-void-set-K-key-V-value-%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%96%B0%E5%A2%9E%EF%BC%9A%E6%94%BE%E5%88%B0%E5%B0%BE%E9%83%A8%EF%BC%8C%E8%B6%85%E5%87%BA%E5%86%85%E5%AD%98%E5%B0%B1%E5%88%A0%E9%99%A4%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%B2%A1%E6%9C%89%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="toc-number">2.2.0.2.3.</span> <span class="toc-text">2  void set(K key, V value) 更新与新增：放到尾部，超出内存就删除最长时间没有操作的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-void-removeMostUnusedCache-%E5%88%A0%E5%8E%BB%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%B2%A1%E6%9C%89%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BC%93%E5%AD%98-%EF%BC%9B%E5%9C%A8%E4%B8%A4%E4%B8%AA%E7%BB%93%E6%9E%84%E9%87%8C%E9%9D%A2%E9%83%BD%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.0.2.4.</span> <span class="toc-text">3 void removeMostUnusedCache() 删去最长时间没有操作的缓存 ；在两个结构里面都删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">3) 双向链表结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-addNode-%E6%9D%A5%E6%96%B0%E8%8A%82%E7%82%B9%EF%BC%8C%E6%8C%82%E5%88%B0%E5%B0%BE%E5%B7%B4%E4%B8%8A"><span class="toc-number">2.2.0.3.1.</span> <span class="toc-text">1 addNode() : 来新节点，挂到尾巴上</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-moveToTail-%EF%BC%88%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E8%A6%81%E4%BF%9D%E8%AF%81node%E5%9C%A8%E8%A1%A8%E4%B8%AD%EF%BC%89%E6%9B%B4%E6%96%B0%E5%88%B0%E5%B0%BE%E9%83%A8"><span class="toc-number">2.2.0.3.2.</span> <span class="toc-text">2 moveToTail() : （修改过的节点，要保证node在表中）更新到尾部</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-removeHead-%E5%B0%86%E5%A4%B4%E8%8A%82%E7%82%B9%E7%A7%BB%E8%B5%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E6%96%B0%E7%9A%84%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.0.3.3.</span> <span class="toc-text">3 removeHead() : 将头节点移走，返回新的头节点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3 K个一组翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4 合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">合并k个链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">5 相交链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">2.5.1.</span> <span class="toc-text">无环链表相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">2.5.2.</span> <span class="toc-text">有环链表相交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">6 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">2.7.</span> <span class="toc-text">7 重排链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="toc-number">2.8.</span> <span class="toc-text">8 删除链表重复节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.9.</span> <span class="toc-text">9 排序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.10.</span> <span class="toc-text">10 两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.11.</span> <span class="toc-text">11 链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.12.</span> <span class="toc-text">12 删除链表倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">2.13.</span> <span class="toc-text">13 回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">2.14.</span> <span class="toc-text">14 删除排序链表中的重复元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%A4%8D%E5%88%B6%E5%B8%A6%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">2.15.</span> <span class="toc-text">15 复制带有随机指针的链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">2 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">基础问题 背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">3.2.</span> <span class="toc-text">1. 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E8%B4%AA%E5%BF%83"><span class="toc-number">3.2.1.</span> <span class="toc-text">用贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E8%AF%A5%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">如果需要返回该子数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-maxProfit"><span class="toc-number">3.3.</span> <span class="toc-text">2. 买卖股票的最佳时机 maxProfit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%8E%E5%A4%B4%E8%87%B3%E5%B0%BE%E4%B9%B0%E4%B8%80%E6%AC%A1%E4%B8%80%E8%82%A1-%E8%BF%94%E5%9B%9E%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">3.3.1.</span> <span class="toc-text">(1) 从头至尾买一次一股 返回最大利润:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B9%B0%E4%B8%80%E8%82%A1%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%B9%B0%E6%97%A0%E9%99%90%E6%AC%A1"><span class="toc-number">3.3.2.</span> <span class="toc-text">(2) 买一股但是可以买无限次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">3.4.</span> <span class="toc-text">3. 最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92O-N-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">(1) 动态规划O(N^2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Manacher"><span class="toc-number">3.4.2.</span> <span class="toc-text">(2) Manacher!</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Manacher%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">Manacher算法核心</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.4.3.</span> <span class="toc-text">最长回文子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.5.</span> <span class="toc-text">4. 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DP%E7%89%88-O-n-2"><span class="toc-number">3.5.1.</span> <span class="toc-text">DP版  O(n^2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E8%B4%AA%E5%BF%83-O-nlogn"><span class="toc-number">3.5.2.</span> <span class="toc-text">二分查找+贪心  O(nlogn)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">3.6.</span> <span class="toc-text">5. 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.7.</span> <span class="toc-text">6. 最长上升子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">3.8.</span> <span class="toc-text">7. 爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92-%E7%AC%94%E8%AF%95"><span class="toc-number">3.8.1.</span> <span class="toc-text">递归 笔试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-o-logn"><span class="toc-number">3.8.2.</span> <span class="toc-text">矩阵快速幂 o(logn)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-dp3"><span class="toc-number">3.9.</span> <span class="toc-text">8. 编辑距离(dp3)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DP-%E6%A0%B7%E6%9C%AC%E5%AF%B9%E5%BA%94%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%BE%80%E5%BE%80%E7%94%A8%E6%9C%80%E5%90%8E%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%9D%A5%E5%88%A4%E6%96%AD%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="toc-number">3.9.1.</span> <span class="toc-text">DP 样本对应模型：往往用最后的位置来判断可能性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-dp3"><span class="toc-number">3.10.</span> <span class="toc-text">9. 最长公共子序列(dp3)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">3.11.</span> <span class="toc-text">10 最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">3.11.0.1.</span> <span class="toc-text">扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">3.11.1.</span> <span class="toc-text">不同路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E6%95%B0%E7%BB%84-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">3.12.</span> <span class="toc-text">11  最长公共子数组(最长重复子数组)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-dp4-%E9%9A%BE"><span class="toc-number">3.13.</span> <span class="toc-text">12 零钱兑换问题 &lt;完全背包&gt;(dp4) 难</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%94%E5%9B%9E%E9%9C%80%E8%A6%81%E6%9C%80%E5%B0%91%E7%9A%84%E7%A1%AC%E5%B8%81%E4%B8%AA%E6%95%B0"><span class="toc-number">3.13.1.</span> <span class="toc-text">1 返回需要最少的硬币个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.13.1.1.</span> <span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%94%E5%9B%9E%E5%87%91%E9%BD%90%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E6%95%B0"><span class="toc-number">3.13.2.</span> <span class="toc-text">2 返回凑齐的所有方法数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E7%9A%84%E5%B0%9D%E8%AF%95"><span class="toc-number">3.13.2.1.</span> <span class="toc-text">暴力递归的尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">3.13.2.2.</span> <span class="toc-text">记忆化搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-number">3.13.2.3.</span> <span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81"><span class="toc-number">3.13.3.</span> <span class="toc-text">3 最终代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A21"><span class="toc-number">3.13.3.1.</span> <span class="toc-text">零钱兑换1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A22"><span class="toc-number">3.13.3.2.</span> <span class="toc-text">零钱兑换2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">3.14.</span> <span class="toc-text">13 最长有效括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">3.15.</span> <span class="toc-text">14 打家劫舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A1"><span class="toc-number">3.16.</span> <span class="toc-text">打家劫舍Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">3.17.</span> <span class="toc-text">15 矩阵的递增路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%9C%BA%E5%99%A8%E4%BA%BAwalk"><span class="toc-number">3.18.</span> <span class="toc-text">16 机器人walk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%BA%B8%E7%89%8C%E5%8D%9A%E5%BC%88"><span class="toc-number">3.19.</span> <span class="toc-text">17 纸牌博弈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">3 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">-快速排序-</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-0-partition"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">1.0 partition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-0-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">2.0 荷兰国旗</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%BF%AB%E6%8E%92"><span class="toc-number">4.1.0.2.1.</span> <span class="toc-text">随机快排</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC"><span class="toc-number">4.1.0.2.2.</span> <span class="toc-text">递归版本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%BF%AB%E6%8E%92%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">&lt;随机快排的时间复杂度分析&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">4.1.1.</span> <span class="toc-text">!!! &#x3D;&#x3D;找到数组中的第k个最大元素&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%86%99%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">改写快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFPRT-%E9%9D%A2%E8%AF%95%E8%81%8A"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">BFPRT(面试聊)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">-堆排序-</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">-归并排序-</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">递归版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC"><span class="toc-number">4.3.2.</span> <span class="toc-text">非递归版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E7%89%88%E6%9C%AC"><span class="toc-number">4.3.3.</span> <span class="toc-text">优化后的最终版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">4.4.</span> <span class="toc-text">-前缀树-</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">4.4.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">前缀树的实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%89%E4%B8%8D%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84"><span class="toc-number">4.5.</span> <span class="toc-text">-（桶排序）不基于比较的-</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.5.1.</span> <span class="toc-text">计数排序和基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">题目3: 计数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">题目4: 基数排序代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">4.6.</span> <span class="toc-text">排序算法的稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">4.7.</span> <span class="toc-text">排序算法总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">4 滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">5.1.</span> <span class="toc-text">1 无重复数组的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%89%88"><span class="toc-number">5.1.1.</span> <span class="toc-text">动态规划版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">5.2.</span> <span class="toc-text">2 最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">5.4.</span> <span class="toc-text">3 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%BB%A1%E8%B6%B3%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%B7%AE%E8%BE%BE%E6%A0%87%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E9%87%8F"><span class="toc-number">5.5.</span> <span class="toc-text">4 满足绝对值差达标的子数组数量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">5 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-DFS"><span class="toc-number">6.1.</span> <span class="toc-text">1 二叉树先、中、后序遍历(DFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">6.1.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92-%E5%8E%8B%E6%A0%88"><span class="toc-number">6.1.2.</span> <span class="toc-text">非递归(压栈)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-BFS%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">2 二叉树的层序遍历(BFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%93%E5%8D%B0%E6%AF%8F%E4%B8%80%E5%B1%82"><span class="toc-number">6.2.1.</span> <span class="toc-text">1) 打印每一层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">二叉树的锯齿形遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%BF%94%E5%9B%9E%E8%8A%82%E7%82%B9%E6%9C%80%E5%A4%9A%E7%9A%84%E9%82%A3%E4%B8%80%E5%B1%82"><span class="toc-number">6.2.2.</span> <span class="toc-text">2）返回节点最多的那一层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">6.2.3.</span> <span class="toc-text">3）二叉树的右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%EF%BC%88%E5%B7%A6%E5%8F%B3%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%89"><span class="toc-number">6.2.4.</span> <span class="toc-text">4）最大宽度（左右节点的距离）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">6.3.</span> <span class="toc-text">3 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">6.4.</span> <span class="toc-text">4 二叉树最大路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.5.</span> <span class="toc-text">5 对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.6.</span> <span class="toc-text">6 从前序和中序序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.7.</span> <span class="toc-text">7 验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.8.</span> <span class="toc-text">8 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.9.</span> <span class="toc-text">9 二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">6.10.</span> <span class="toc-text">10 二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%9C%80%E5%A4%A7%E7%9B%B4%E5%BE%84"><span class="toc-number">6.11.</span> <span class="toc-text">11 最大直径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">6.12.</span> <span class="toc-text">12 路径总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.13.</span> <span class="toc-text">13 翻转二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">6 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">7.1.</span> <span class="toc-text">1 有效括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">7.2.</span> <span class="toc-text">2 用栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">7.3.</span> <span class="toc-text">3 最小栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">7.4.</span> <span class="toc-text">4 两个队列实现栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">7.5.</span> <span class="toc-text">5 单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%B7%A6%E8%BE%B9%E5%92%8C%E5%8F%B3%E8%BE%B9%E7%A6%BBi%E6%9C%80%E8%BF%91%E6%AF%94%E5%85%B6%E5%B0%8F%E7%9A%84%E4%B8%8B%E8%A1%A8%E5%AF%B9-res-n-2"><span class="toc-number">7.5.1.</span> <span class="toc-text">找到左边和右边离i最近比其小的下表对 res[n][2]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E6%95%B0%E6%95%B0%E7%BB%84arr%E4%B8%AD%EF%BC%88sub%E7%9A%84%E7%B4%AF%E5%8A%A0%E5%92%8C-min%EF%BC%89%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">7.5.2.</span> <span class="toc-text">正数数组arr中（sub的累加和*min）的最大值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">7 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">8.1.</span> <span class="toc-text">1 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%972%E2%83%A3%EF%B8%8F-%E4%B8%8D%E9%87%8D%E5%A4%8D"><span class="toc-number">8.1.1.</span> <span class="toc-text">全排列2⃣️ 不重复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">8.2.</span> <span class="toc-text">2 括号生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80"><span class="toc-number">8.3.</span> <span class="toc-text">3 复原ip地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">8.4.</span> <span class="toc-text">4 单词搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%90%E9%9B%86"><span class="toc-number">8.5.</span> <span class="toc-text">5 子集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">8 并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">9.1.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%EF%BC%88hash%E8%A1%A8%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">结构（hash表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">9.3.</span> <span class="toc-text">1 岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-number">9.3.1.</span> <span class="toc-text">使用并查集（面试）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F%EF%BC%88%E6%9C%8B%E5%8F%8B%E5%9C%88%EF%BC%89"><span class="toc-number">9.4.</span> <span class="toc-text">2 省份数量（朋友圈）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">7 图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E7%9F%A9%E9%98%B5%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%93%E6%9E%84-creatGraph"><span class="toc-number">10.1.</span> <span class="toc-text">将矩阵转化为自己的结构(creatGraph)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84bfs"><span class="toc-number">10.2.</span> <span class="toc-text">1 图的bfs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-DFS"><span class="toc-number">10.3.</span> <span class="toc-text">2 DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">10.4.</span> <span class="toc-text">3 拓扑排序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/17/WEB3%20Day1%20%E2%80%94%E2%80%94%20BlockChain%20Basic%201/" title="WEB3 Day1 —— BlockChain Basic 1">WEB3 Day1 —— BlockChain Basic 1</a><time datetime="2025-06-17T06:26:18.000Z" title="发表于 2025-06-17 14:26:18">2025-06-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AC%94%E8%AE%B0/" title="分布式笔记">分布式笔记</a><time datetime="2022-05-16T02:25:28.000Z" title="发表于 2022-05-16 10:25:28">2022-05-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/10/mysql8%E9%A1%B9%E7%9B%AE%E8%BF%9E%E6%8E%A5%E5%87%BA%E9%94%99-%E7%AB%AF%E5%8F%A3%E4%B8%BA0/" title="mysql8项目连接出错&amp;端口为0">mysql8项目连接出错&amp;端口为0</a><time datetime="2022-05-10T06:23:51.000Z" title="发表于 2022-05-10 14:23:51">2022-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/09/%E5%9B%9B%E6%9C%88%E9%9D%A2%E7%BB%8F/" title="四月面经">四月面经</a><time datetime="2022-05-09T02:01:20.000Z" title="发表于 2022-05-09 10:01:20">2022-05-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/06/Hexo-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/" title="Hexo + GitHub搭建个人博客">Hexo + GitHub搭建个人博客</a><time datetime="2022-05-06T02:24:55.000Z" title="发表于 2022-05-06 10:24:55">2022-05-06</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Sonia33" target="_blank">Sonia33</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">14</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BlockChain/" style="font-size: 0.88rem;">BlockChain<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>1</sup></a><a href="/tags/DataBase/" style="font-size: 0.88rem;">DataBase<sup>2</sup></a><a href="/tags/FastDFS/" style="font-size: 0.88rem;">FastDFS<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/IO/" style="font-size: 0.88rem;">IO<sup>1</sup></a><a href="/tags/JDBC/" style="font-size: 0.88rem;">JDBC<sup>1</sup></a><a href="/tags/JQuery/" style="font-size: 0.88rem;">JQuery<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>2</sup></a><a href="/tags/NoSQL/" style="font-size: 0.88rem;">NoSQL<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 0.88rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redis/" style="font-size: 0.88rem;">Redis<sup>1</sup></a><a href="/tags/Zookeeper/" style="font-size: 0.88rem;">Zookeeper<sup>1</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>1</sup></a><a href="/tags/macOS/" style="font-size: 0.88rem;">macOS<sup>2</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 0.88rem;">分布式<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">并发编程<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">测试<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>1</sup></a><a href="/tags/%E8%B8%A9%E9%9B%B7/" style="font-size: 0.88rem;">踩雷<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Sonia33 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>